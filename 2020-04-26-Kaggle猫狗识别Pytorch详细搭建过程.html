<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Kaggle猫狗识别Pytorch详细搭建过程 | BraveY</title><meta name="description" content="Kaggle猫狗识别Pytorch详细搭建过程"><meta name="keywords" content="Pytorch"><meta name="author" content="BraveY"><meta name="copyright" content="BraveY"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="hDujO4MQUB7U9ir-4VXM5PW4fDFSq0-7G-LBX-Lh86M"/><meta name="baidu-site-verification" content="8XIUcPkbzm"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Kaggle猫狗识别Pytorch详细搭建过程"><meta name="twitter:description" content="Kaggle猫狗识别Pytorch详细搭建过程"><meta name="twitter:image" content="https://images.pexels.com/photos/390051/surfer-wave-sunset-the-indian-ocean-390051.jpeg?auto=compress&amp;cs=tinysrgb&amp;dpr=1&amp;w=500"><meta property="og:type" content="article"><meta property="og:title" content="Kaggle猫狗识别Pytorch详细搭建过程"><meta property="og:url" content="https://bravey.github.io/2020-04-26-Kaggle%E7%8C%AB%E7%8B%97%E8%AF%86%E5%88%ABPytorch%E8%AF%A6%E7%BB%86%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B.html"><meta property="og:site_name" content="BraveY"><meta property="og:description" content="Kaggle猫狗识别Pytorch详细搭建过程"><meta property="og:image" content="https://images.pexels.com/photos/390051/surfer-wave-sunset-the-indian-ocean-390051.jpeg?auto=compress&amp;cs=tinysrgb&amp;dpr=1&amp;w=500"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://bravey.github.io/2020-04-26-Kaggle%E7%8C%AB%E7%8B%97%E8%AF%86%E5%88%ABPytorch%E8%AF%A6%E7%BB%86%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B.html"><link rel="next" title="leetcode 55 Jump Game" href="https://bravey.github.io/2020-04-25-leetcode-55-Jump-Game.html"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: {"text":"富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善","fontSize":"15px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: true,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar3.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">64</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">94</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">14</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#需求"><span class="toc-number">1.</span> <span class="toc-text">需求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#包的导入"><span class="toc-number">2.</span> <span class="toc-text">包的导入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据集的创建"><span class="toc-number">3.</span> <span class="toc-text">数据集的创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据集划分"><span class="toc-number">4.</span> <span class="toc-text">数据集划分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据加载"><span class="toc-number">5.</span> <span class="toc-text">数据加载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#resize后的图像查看"><span class="toc-number">5.1.</span> <span class="toc-text">resize后的图像查看</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#网络搭建"><span class="toc-number">6.</span> <span class="toc-text">网络搭建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#预训练模型"><span class="toc-number">6.1.</span> <span class="toc-text">预训练模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#损失函数和优化函数"><span class="toc-number">7.</span> <span class="toc-text">损失函数和优化函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#训练日志的打印"><span class="toc-number">8.</span> <span class="toc-text">训练日志的打印</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#准确率的计算"><span class="toc-number">9.</span> <span class="toc-text">准确率的计算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#tensorboard画图"><span class="toc-number">9.1.</span> <span class="toc-text">tensorboard画图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#迭代训练"><span class="toc-number">10.</span> <span class="toc-text">迭代训练</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#模型评估"><span class="toc-number">11.</span> <span class="toc-text">模型评估</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#输出测试集的预测结果"><span class="toc-number">12.</span> <span class="toc-text">输出测试集的预测结果</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#完整调用流程"><span class="toc-number">13.</span> <span class="toc-text">完整调用流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#训练过程"><span class="toc-number">13.1.</span> <span class="toc-text">训练过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#验证过程"><span class="toc-number">13.2.</span> <span class="toc-text">验证过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#输出测试集预测结果"><span class="toc-number">13.3.</span> <span class="toc-text">输出测试集预测结果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结果"><span class="toc-number">14.</span> <span class="toc-text">结果</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题"><span class="toc-number">15.</span> <span class="toc-text">问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">16.</span> <span class="toc-text">参考</span></a></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><div class="post-bg" id="nav" style="background-image: url(https://images.pexels.com/photos/390051/surfer-wave-sunset-the-indian-ocean-390051.jpeg?auto=compress&amp;cs=tinysrgb&amp;dpr=1&amp;w=500)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">BraveY</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">Kaggle猫狗识别Pytorch详细搭建过程</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-04-26 13:02:42"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-04-26</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-04-26 14:14:32"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-04-26</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">深度学习</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">4.5k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 18 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>评论数:</span><span class="disqus-comment-count comment-count"><a href="https://bravey.github.io/2020-04-26-Kaggle%E7%8C%AB%E7%8B%97%E8%AF%86%E5%88%ABPytorch%E8%AF%A6%E7%BB%86%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B.html#disqus_thread"></a></span></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><p><a href="https://github.com/BraveY/AI-with-code/tree/master/dog-vs-cat" target="_blank" rel="noopener">文章源码链接</a>，包括Notebook和对应的Pycharm项目。求个Star！！</p>
<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p><a href="https://www.kaggle.com/c/dogs-vs-cats-redux-kernels-edition?rvi=1" target="_blank" rel="noopener">Kaggle比赛链接</a> ,给出猫狗图片，然后预测图片中是狗的概率。</p>
<p>训练集有25,000张图片，测试集12,500 张图片。</p>
<p><img src="/" class="lazyload" data-src="https://res.cloudinary.com/bravey/image/upload/v1587879395/blog/deep-learning/CatAndDog.jpg"  alt=""></p>
<p>自己最开始构思大致框架的时候的一个思维导图：</p>
<p><img src="/" class="lazyload" data-src="https://res.cloudinary.com/bravey/image/upload/v1587879936/blog/deep-learning/CatAndDog_xmid.jpg"  alt=""></p>
<h2 id="包的导入"><a href="#包的导入" class="headerlink" title="包的导入"></a>包的导入</h2><p>需要注意的是将tqdm 改为tqdm.notebook，从而在notebook环境下获得更好的体验。因为导入tqdm的话，会发生进度条打印多次的情况，体验很不好</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os </span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd </span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms,models,utils</span><br><span class="line"><span class="keyword">from</span> tqdm.notebook <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="comment"># from tqdm import tqdm_notebook as tqdm</span></span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter </span><br><span class="line"><span class="comment"># from torchvision import datasets, transforms,utils</span></span><br></pre></td></tr></table></figure>
<p>相关文件路径配置，在pycharm项目中将相关路径的配置都统一放在config.py中来管理</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">train_path = <span class="string">'D:/AIdata/dog vs cat/train'</span></span><br><span class="line">test_path = <span class="string">'D:/AIdata/dog vs cat/test1'</span></span><br><span class="line">data_root = <span class="string">'D:/AIdata/dog vs cat/'</span></span><br><span class="line">csv_path = <span class="string">'./submission_valnet.csv'</span></span><br><span class="line">tensorboard_path=<span class="string">'C:/Users/BraveY/Documents/BraveY/AI-with-code/dog-vs-cat/tensortboard'</span></span><br><span class="line">model_save_path = <span class="string">'C:/Users/BraveY/Documents/BraveY/AI-with-code/dog-vs-cat/modelDict/dogs-vs-cats-notebook.pth'</span></span><br></pre></td></tr></table></figure>
<h2 id="数据集的创建"><a href="#数据集的创建" class="headerlink" title="数据集的创建"></a>数据集的创建</h2><p>因为Kaggle官方提供的是<a href="https://www.kaggle.com/c/dogs-vs-cats-redux-kernels-edition/data" target="_blank" rel="noopener">原始数据</a>，不像之前的手写数字数据集可以从pytorch中直接下载已经处理过的数据集，可以直接将数据放入模型进行训练。因此需要我们自己实现数据集的生成。</p>
<p>数据集生成的总体思路是继承torch.utils.data.Dataset这个类，自己实现<strong>getitem</strong>和<strong>len</strong>这两个私有方法来完成对我们自己数据的读取操作。其中<strong>getitem</strong>这个函数的主要功能是根据样本的索引，返回索引对应的一张图片的图像数据X与对应的标签Y，也就是返回一个对应的训练样本。<strong>len</strong>这个函数的功能比较简单直接返回数据集中样本的个数即可。</p>
<p>具体而言，<strong>getitem</strong>的实现思路比较简单，将索引idx转换为图片的路径，然后用PIL的Image包来读取图片数据，然后将数据用torchvision的transforms转换成tensor并且进行Resize来统一大小（给出的图片尺寸不一致）与归一化，这样一来就可以得到图像数据了。因为训练集中图片的文件名上面带有猫狗的标签，所以标签可以通过对图片文件名split后得到然后转成0,1编码。</p>
<p>在获取标签的时候，因为官方提供的测试数据集中并没有猫狗的标签，所以测试集的标签逻辑稍有不同。我的做法是使用一个train标志来进行区分，对于测试的数据，直接将测试样本的标签变成图片自带的id，这样方便后面输出提交的csv文件。因为测试样本不用计算loss，所以将标签置为id是没问题的。</p>
<p>为了实现将idx索引转换成图片路径，需要在<strong>init</strong>()函数中将所有的图片路径放在一个list中，这可以用os.listdir()来实现，然后就可以根据索引去获得路径了。</p>
<p>需要注意的是，之所以<strong>getitem</strong>()需要根据索引来返回样本，是因为训练数据并不是一次性将所有样本数据加载到内存中，这样太耗内存。而是只用加载对应batch中的一部分数据，所以通过索引来加载送入模型中的一批数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDataset</span><span class="params">(Dataset)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data_path:str, train=True, transform=None)</span>:</span></span><br><span class="line">        self.data_path = data_path</span><br><span class="line">        self.train_flag = train</span><br><span class="line">        <span class="keyword">if</span> transform <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.transform = transforms.Compose(</span><br><span class="line">            [</span><br><span class="line">                transforms.Resize(size = (<span class="number">224</span>,<span class="number">224</span>)),<span class="comment">#尺寸规范</span></span><br><span class="line">                transforms.ToTensor(),   <span class="comment">#转化为tensor</span></span><br><span class="line">                transforms.Normalize((<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>), (<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>)),</span><br><span class="line">            ])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.transform = transform</span><br><span class="line">        self.path_list = os.listdir(data_path)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, idx: int)</span>:</span></span><br><span class="line">        <span class="comment"># img to tensor and label to tensor</span></span><br><span class="line">        img_path = self.path_list[idx]</span><br><span class="line">        <span class="keyword">if</span> self.train_flag <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> img_path.split(<span class="string">'.'</span>)[<span class="number">0</span>] == <span class="string">'dog'</span> : </span><br><span class="line">                label = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                label = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            label = int(img_path.split(<span class="string">'.'</span>)[<span class="number">0</span>]) <span class="comment"># split 的是str类型要转换为int</span></span><br><span class="line">        label = torch.as_tensor(label, dtype=torch.int64) <span class="comment"># 必须使用long 类型数据，否则后面训练会报错 expect long</span></span><br><span class="line">        img_path = os.path.join(self.data_path, img_path)</span><br><span class="line">        img = Image.open(img_path)</span><br><span class="line">        img = self.transform(img)</span><br><span class="line">        <span class="keyword">return</span> img, label</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.path_list)</span><br></pre></td></tr></table></figure>
<p>测试一下，确保Dataset可以正常迭代</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">train_ds = MyDataset(train_path)</span><br><span class="line">test_ds = MyDataset(test_path,train=<span class="literal">False</span>)</span><br><span class="line"><span class="keyword">for</span> i, item <span class="keyword">in</span> enumerate(tqdm(train_ds)):</span><br><span class="line"><span class="comment">#     pass</span></span><br><span class="line">    print(item)</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<pre><code>(tensor([[[ 0.5922,  0.6078,  0.6392,  ...,  0.9216,  0.8902,  0.8745],
         [ 0.5922,  0.6078,  0.6392,  ...,  0.9216,  0.8980,  0.8824],
         [ 0.5922,  0.6078,  0.6392,  ...,  0.9216,  0.9059,  0.8902],
         ...,
         [ 0.2078,  0.2157,  0.2235,  ..., -0.9765, -0.9765, -0.9765],
         [ 0.2000,  0.2000,  0.2078,  ..., -0.9843, -0.9843, -0.9843],
         [ 0.1843,  0.1922,  0.2000,  ..., -0.9922, -0.9922, -0.9922]],

        [[ 0.2863,  0.3020,  0.3333,  ...,  0.6000,  0.5843,  0.5686],
         [ 0.2863,  0.3020,  0.3333,  ...,  0.6000,  0.5922,  0.5765],
         [ 0.2863,  0.3020,  0.3333,  ...,  0.6000,  0.6000,  0.5843],
         ...,
         [-0.0353, -0.0275, -0.0196,  ..., -0.9765, -0.9765, -0.9765],
         [-0.0431, -0.0431, -0.0353,  ..., -0.9843, -0.9843, -0.9843],
         [-0.0588, -0.0510, -0.0431,  ..., -0.9922, -0.9922, -0.9922]],

        [[-0.3176, -0.3020, -0.2706,  ..., -0.0588, -0.0431, -0.0510],
         [-0.3176, -0.3020, -0.2706,  ..., -0.0510, -0.0431, -0.0431],
         [-0.3176, -0.3020, -0.2706,  ..., -0.0431, -0.0275, -0.0353],
         ...,
         [-0.5608, -0.5529, -0.5451,  ..., -0.9922, -0.9922, -0.9922],
         [-0.5686, -0.5686, -0.5608,  ..., -1.0000, -1.0000, -1.0000],
         [-0.5843, -0.5765, -0.5686,  ..., -1.0000, -1.0000, -1.0000]]]), tensor(0))
</code></pre><h2 id="数据集划分"><a href="#数据集划分" class="headerlink" title="数据集划分"></a>数据集划分</h2><p>如前面所述，因为官方测试集没有标签，而且提交结果上去后只有一个log loos来作为分值，没有准确率的结果。所以为了得到准确率这个指标，需要新建个有标签的验证集来查看准确率。</p>
<p>实现思路是使用torch.utils.data.random_split(),来将官方提供训练数据集划分出一部分的验证集。我的比例是80%的训练集，20%的验证集</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">full_ds = train_ds</span><br><span class="line">train_size = int(<span class="number">0.8</span> * len(full_ds))</span><br><span class="line">validate_size = len(full_ds) - train_size</span><br><span class="line">new_train_ds, validate_ds = torch.utils.data.random_split(full_ds,[train_size, validate_size])<span class="comment">#数据集划分</span></span><br></pre></td></tr></table></figure>
<h2 id="数据加载"><a href="#数据加载" class="headerlink" title="数据加载"></a>数据加载</h2><p>我们制作的数据集并不能直接放入模型进行训练，还需要使用一个数据加载器，来加载数据集。使用torch.utils.data.DataLoader()来划分每个batch用来后面训练的时候向网络提供输入数据</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">train_loader = torch.utils.data.DataLoader(train_ds, batch_size=<span class="number">32</span>,</span><br><span class="line">                                            shuffle=<span class="literal">True</span>, pin_memory=<span class="literal">True</span>, num_workers=<span class="number">0</span>)</span><br><span class="line">test_loader = torch.utils.data.DataLoader(test_ds, batch_size=<span class="number">32</span>,</span><br><span class="line">                                            shuffle=<span class="literal">True</span>, pin_memory=<span class="literal">True</span>, num_workers=<span class="number">0</span>)</span><br><span class="line"><span class="comment">## numworkers设置不为0 会报错 Broken pipe Error 网上说是win10上的pytorch bug</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new_train_loader = torch.utils.data.DataLoader(train_ds, batch_size=<span class="number">32</span>,</span><br><span class="line">                                            shuffle=<span class="literal">True</span>, pin_memory=<span class="literal">True</span>, num_workers=<span class="number">0</span>)</span><br><span class="line">validate_loader = torch.utils.data.DataLoader(validate_ds, batch_size=<span class="number">32</span>,</span><br><span class="line">                                            shuffle=<span class="literal">True</span>, pin_memory=<span class="literal">True</span>, num_workers=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>加载过后数据形状从三维变成四维，多的维度是batch_size，这里是32个样本构成一个batch</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, item <span class="keyword">in</span> enumerate(train_loader):</span><br><span class="line"><span class="comment">#     pass</span></span><br><span class="line">    print(item[<span class="number">0</span>].shape)</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<pre><code>torch.Size([32, 3, 224, 224])
</code></pre><h3 id="resize后的图像查看"><a href="#resize后的图像查看" class="headerlink" title="resize后的图像查看"></a>resize后的图像查看</h3><p>前面提到过对数据进行了resize和正则化的处理，下面是对处理后的图像的可视化</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">img_PIL_Tensor = train_ds[<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">new_img_PIL = transforms.ToPILImage()(img_PIL_Tensor).convert(<span class="string">'RGB'</span>)</span><br><span class="line">plt.imshow(new_img_PIL)</span><br><span class="line">plt.show()</span><br><span class="line"><span class="comment"># print(new_img_PIL.show())</span></span><br></pre></td></tr></table></figure>
<p><img src="/" class="lazyload" data-src="https://res.cloudinary.com/bravey/image/upload/v1587879395/blog/deep-learning/output_16_0.png"  alt="png"></p>
<p>​<br>​    </p>
<h2 id="网络搭建"><a href="#网络搭建" class="headerlink" title="网络搭建"></a>网络搭建</h2><p>网络搭建的框架与之前的<a href="https://zhuanlan.zhihu.com/p/112829371" target="_blank" rel="noopener">手写数字识别</a>的框架一致，两个卷积层后3个全连接层。需要注意的是参数不能套用之前的参数了，因为之前的手写数字的图片很小，而且数据量不大所以尽管参数比较大，也能在我的机子上跑起来(MX150,2GB显存)。猫狗的数据量显然比之前的大，所以需要将参数变小些，才能跑起来。 我实验了下，如果不将网络参数降低的话，只调整batch_size没有用，依然会报显存不足。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCNN</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(MyCNN,self).__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">3</span>,<span class="number">8</span>,kernel_size=<span class="number">3</span>,stride=<span class="number">1</span>,padding=<span class="number">1</span>) <span class="comment"># 按照公式计算后经过卷积层不改变尺寸</span></span><br><span class="line">        self.pool = nn.MaxPool2d(<span class="number">2</span>,<span class="number">2</span>) <span class="comment"># 2*2的池化 池化后size 减半</span></span><br><span class="line">        self.conv2 = nn.Conv2d(<span class="number">8</span>,<span class="number">16</span>,kernel_size=<span class="number">3</span>,stride=<span class="number">1</span>,padding=<span class="number">1</span>)</span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">16</span>*<span class="number">56</span>*<span class="number">56</span>,<span class="number">256</span>)<span class="comment">#两个池化，所以是224/2/2=56</span></span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">256</span>,<span class="number">64</span>)</span><br><span class="line">        self.fc3 = nn.Linear(<span class="number">64</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment">#         self.dp = nn.Dropout(p=0.5)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,x)</span>:</span></span><br><span class="line"><span class="comment">#         print("input:", x)</span></span><br><span class="line">        x = self.pool(F.relu(self.conv1(x)))</span><br><span class="line"><span class="comment">#         print("first conv:", x)</span></span><br><span class="line">        x = self.pool(F.relu(self.conv2(x)))</span><br><span class="line"><span class="comment">#         print("second conv:", x)</span></span><br><span class="line">             </span><br><span class="line">        x = x.view(<span class="number">-1</span>, <span class="number">16</span> * <span class="number">56</span>* <span class="number">56</span>)<span class="comment">#将数据平整为一维的 </span></span><br><span class="line">        x = F.relu(self.fc1(x))</span><br><span class="line">        x = F.relu(self.fc2(x))  </span><br><span class="line">        x = self.fc3(x)  </span><br><span class="line"><span class="comment">#         x = F.log_softmax(x,dim=1) NLLLoss()才需要，交叉熵不需要</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>
<h3 id="预训练模型"><a href="#预训练模型" class="headerlink" title="预训练模型"></a>预训练模型</h3><p>除了自己手动DIY一个网络，也可以使用Pytorch已经提供的一些性能很好的模型比如VGG16，ResNet50等等，然后微调下网络结构，来得到符合自己的任务的网络架构。还可以直接下载这些模型在ImageNet上的预训练参数，然后在自己的数据集上进行训练。</p>
<p>我在这儿选择了ResNet50网络以及预训练好的权重进行了下实验，我在实验室的机器上面用P100跑的，因为自己的笔记本显卡太垃圾了只有2GB显存。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 直接设置为True的话下载权重太慢了</span></span><br><span class="line"><span class="comment">## 所以手动用浏览器下载好了之后再重新加载</span></span><br><span class="line">resnet50 = models.resnet50(pretrained=<span class="literal">False</span>)  </span><br><span class="line">model_path = <span class="string">'D:/AIdata/dog vs cat/resnet50-19c8e357.pth'</span></span><br><span class="line">resnet50.load_state_dict(torch.load(model_path))</span><br><span class="line">resnet50.fc = nn.Linear(<span class="number">2048</span>, <span class="number">2</span>) <span class="comment">#修改最后一层网络将输出调整为两维</span></span><br></pre></td></tr></table></figure>
<h2 id="损失函数和优化函数"><a href="#损失函数和优化函数" class="headerlink" title="损失函数和优化函数"></a>损失函数和优化函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net = MyCNN()</span><br><span class="line"><span class="comment"># net = resnet50</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line"><span class="comment"># criterion = nn.BCELoss()  #二分类交叉熵损失函数</span></span><br><span class="line"><span class="comment"># criterion = nn.BCEWithLogitsLoss() #二分类交叉熵损失函数 带log loss</span></span><br><span class="line"><span class="comment"># criterion = nn.MSELoss()</span></span><br><span class="line"></span><br><span class="line">optimizer = optim.SGD(net.parameters(), lr=<span class="number">0.001</span>, momentum=<span class="number">0.9</span>)</span><br><span class="line"><span class="comment">#也可以选择Adam优化方法</span></span><br><span class="line"><span class="comment"># optimizer = torch.optim.Adam(net.parameters(),lr=1e-2)</span></span><br></pre></td></tr></table></figure>
<h2 id="训练日志的打印"><a href="#训练日志的打印" class="headerlink" title="训练日志的打印"></a>训练日志的打印</h2><p>在之前的手写数字识别的准确率的计算和画图以日志的打印比较简单，在这更新为topk准确率以及使用tensorboard来画曲线。并且使用tqdm进度条来实时的打印日志。</p>
<p>专门建立一个类来保存和更新准确率的结果，使用类来让代码更加的规范化</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AvgrageMeter</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.reset()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reset</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.avg = <span class="number">0</span></span><br><span class="line">        self.sum = <span class="number">0</span></span><br><span class="line">        self.cnt = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self, val, n=<span class="number">1</span>)</span>:</span></span><br><span class="line">        self.sum += val * n</span><br><span class="line">        self.cnt += n</span><br><span class="line">        self.avg = self.sum / self.cnt</span><br></pre></td></tr></table></figure>
<h2 id="准确率的计算"><a href="#准确率的计算" class="headerlink" title="准确率的计算"></a>准确率的计算</h2><p>torch.topk(input, k, dim=None, largest=True, sorted=True, out=None) -&gt; (Tensor, LongTensor) 返回某一维度前k个的索引<br>input：一个tensor数据<br>k：指明是得到前k个数据以及其index<br>dim： 指定在哪个维度上排序， 默认是最后一个维度<br>largest：如果为True，按照大到小排序； 如果为False，按照小到大排序<br>sorted：返回的结果按照顺序返回<br>out：可缺省，不要</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## topk的准确率计算</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accuracy</span><span class="params">(output, label, topk=<span class="params">(<span class="number">1</span>,)</span>)</span>:</span></span><br><span class="line">    maxk = max(topk) </span><br><span class="line">    batch_size = label.size(<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取前K的索引</span></span><br><span class="line">    _, pred = output.topk(maxk, <span class="number">1</span>, <span class="literal">True</span>, <span class="literal">True</span>) <span class="comment">#使用topk来获得前k个的索引</span></span><br><span class="line">    pred = pred.t() <span class="comment"># 进行转置</span></span><br><span class="line">    <span class="comment"># eq按照对应元素进行比较 view(1,-1) 自动转换到行为1,的形状， expand_as(pred) 扩展到pred的shape</span></span><br><span class="line">    <span class="comment"># expand_as 执行按行复制来扩展，要保证列相等</span></span><br><span class="line">    correct = pred.eq(label.view(<span class="number">1</span>, <span class="number">-1</span>).expand_as(pred)) <span class="comment"># 与正确标签序列形成的矩阵相比，生成True/False矩阵</span></span><br><span class="line"><span class="comment">#     print(correct)</span></span><br><span class="line"></span><br><span class="line">    rtn = []</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> topk:</span><br><span class="line">        correct_k = correct[:k].view(<span class="number">-1</span>).float().sum(<span class="number">0</span>) <span class="comment"># 前k行的数据 然后平整到1维度，来计算true的总个数</span></span><br><span class="line">        rtn.append(correct_k.mul_(<span class="number">100.0</span> / batch_size)) <span class="comment"># mul_() ternsor 的乘法  正确的数目/总的数目 乘以100 变成百分比</span></span><br><span class="line">    <span class="keyword">return</span> rtn</span><br></pre></td></tr></table></figure>
<h3 id="tensorboard画图"><a href="#tensorboard画图" class="headerlink" title="tensorboard画图"></a>tensorboard画图</h3><p>详细的参数讲解参考：<a href="https://www.pytorchtutorial.com/pytorch-builtin-tensorboard/" target="_blank" rel="noopener">https://www.pytorchtutorial.com/pytorch-builtin-tensorboard/</a><br>在使用pip install安装tensorboard如果速度很慢经常断线的话可以换个国内的源：<br><code>pip config set global.index-url https://mirrors.ustc.edu.cn/pypi/web/simple</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter </span><br><span class="line">writer = SummaryWriter(<span class="string">'./tensortboard/'</span>)</span><br></pre></td></tr></table></figure>
<p>画图的结果是实时，还可以放大放小，曲线的平滑度设置等，比自己写的画图函数要方便很多：</p>
<p><img src="/" class="lazyload" data-src="https://res.cloudinary.com/bravey/image/upload/v1587879396/blog/deep-learning/tensorboard.jpg"  alt=""></p>
<h2 id="迭代训练"><a href="#迭代训练" class="headerlink" title="迭代训练"></a>迭代训练</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">( epoch, train_loader, device, model, criterion, optimizer,tensorboard_path)</span>:</span></span><br><span class="line">    model.train()</span><br><span class="line">    train_loss = <span class="number">0.0</span></span><br><span class="line">    top1 = AvgrageMeter()</span><br><span class="line">    train_loader = tqdm(train_loader)  <span class="comment">#转换成tqdm类型 以方便增加日志的输出</span></span><br><span class="line"></span><br><span class="line">    model = model.to(device)</span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> range(epoch):</span><br><span class="line">        running_loss = <span class="number">0.0</span></span><br><span class="line">        train_loader.set_description(<span class="string">'[%s%04d/%04d %s%f]'</span> % (<span class="string">'Epoch:'</span>, e + <span class="number">1</span>, epoch, <span class="string">'lr:'</span>, <span class="number">0.001</span>))</span><br><span class="line">        <span class="keyword">for</span> i, data <span class="keyword">in</span> enumerate(train_loader, <span class="number">0</span>):  <span class="comment"># 0是下标起始位置默认为0</span></span><br><span class="line">            inputs, labels = data[<span class="number">0</span>].to(device), data[<span class="number">1</span>].to(device)</span><br><span class="line">            <span class="comment"># 初始为0，清除上个batch的梯度信息</span></span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            outputs = model(inputs)</span><br><span class="line">            loss = criterion(outputs,labels)</span><br><span class="line">            loss.backward()</span><br><span class="line">            optimizer.step()</span><br><span class="line">            <span class="comment"># topk 准确率计算</span></span><br><span class="line">            prec1, prec2 = accuracy(outputs, labels, topk=(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">            n = inputs.size(<span class="number">0</span>)</span><br><span class="line">            top1.update(prec1.item(), n)</span><br><span class="line">            train_loss += loss.item()</span><br><span class="line">            postfix = &#123;<span class="string">'train_loss'</span>: <span class="string">'%.6f'</span> % (train_loss / (i + <span class="number">1</span>)), <span class="string">'train_acc'</span>: <span class="string">'%.6f'</span> % top1.avg&#125;</span><br><span class="line">            train_loader.set_postfix(log=postfix)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># ternsorboard 曲线绘制</span></span><br><span class="line">            writer = SummaryWriter(tensorboard_path)</span><br><span class="line">            writer.add_scalar(<span class="string">'Train/Loss'</span>, loss.item(), epoch)</span><br><span class="line">            writer.add_scalar(<span class="string">'Train/Accuracy'</span>, top1.avg, epoch)</span><br><span class="line">            writer.flush()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'Finished Training'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h2><p>准确率验证<br>在验证集上面的验证，求网络的的准确率指标</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">validate</span><span class="params">(validate_loader, device, model, criterion)</span>:</span></span><br><span class="line">    val_acc = <span class="number">0.0</span></span><br><span class="line">    model = model.to(device)</span><br><span class="line">    model.eval()</span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():  <span class="comment"># 进行评测的时候网络不更新梯度</span></span><br><span class="line">        val_top1 = AvgrageMeter()</span><br><span class="line">        validate_loader = tqdm(validate_loader)</span><br><span class="line">        validate_loss = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">for</span> i, data <span class="keyword">in</span> enumerate(validate_loader, <span class="number">0</span>):  <span class="comment"># 0是下标起始位置默认为0</span></span><br><span class="line">            inputs, labels = data[<span class="number">0</span>].to(device), data[<span class="number">1</span>].to(device)</span><br><span class="line">            <span class="comment">#         inputs,labels = data[0],data[1]</span></span><br><span class="line">            outputs = model(inputs)</span><br><span class="line">            loss = criterion(outputs, labels)</span><br><span class="line"></span><br><span class="line">            prec1, prec2 = accuracy(outputs, labels, topk=(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">            n = inputs.size(<span class="number">0</span>)</span><br><span class="line">            val_top1.update(prec1.item(), n)</span><br><span class="line">            validate_loss += loss.item()</span><br><span class="line">            postfix = &#123;<span class="string">'validate_loss'</span>: <span class="string">'%.6f'</span> % (validate_loss / (i + <span class="number">1</span>)), <span class="string">'validate_acc'</span>: <span class="string">'%.6f'</span> % val_top1.avg&#125;</span><br><span class="line">            validate_loader.set_postfix(log=postfix)</span><br><span class="line">        val_acc = val_top1.avg</span><br><span class="line">    <span class="keyword">return</span> val_acc</span><br></pre></td></tr></table></figure>
<h2 id="输出测试集的预测结果"><a href="#输出测试集的预测结果" class="headerlink" title="输出测试集的预测结果"></a>输出测试集的预测结果</h2><p>将测试集输入进网络，得到测试集的预测结果，并转换成csv文件，用来提交到Kaggle上进行评分。需要注意的是，因为官网要求给的是图片是狗的概率，需要将网络的输出转成概率值。</p>
<p>但实际上测试的时候网络的输出是一正一负的值，不是概率值。这是因为测试的时候没有计算loss ，而softmax这个过程是在计算交叉熵的时候自动计算的，所以在网络架构中最后一层全连接输出后没有softmax计算。因此需要我们手动增加上softmax的过程，这样经过softmax后就可以变成两个概率值了!将图片是狗的概率保存下来，并转成符合官方要求的提交格式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">submission</span><span class="params">(csv_path,test_loader, device, model)</span>:</span></span><br><span class="line">    result_list = []</span><br><span class="line">    model = model.to(device)</span><br><span class="line">    test_loader = tqdm(test_loader)</span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():  <span class="comment"># 进行评测的时候网络不更新梯度</span></span><br><span class="line">        <span class="keyword">for</span> i, data <span class="keyword">in</span> enumerate(test_loader, <span class="number">0</span>):</span><br><span class="line">            images, labels = data[<span class="number">0</span>].to(device), data[<span class="number">1</span>].to(device)</span><br><span class="line">            outputs = model(images)</span><br><span class="line">            softmax_func = nn.Softmax(dim=<span class="number">1</span>)  <span class="comment"># dim=1表示行的和为1</span></span><br><span class="line">            soft_output = softmax_func(outputs)</span><br><span class="line">            predicted = soft_output[:, <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(predicted)):</span><br><span class="line">                result_list.append(&#123;</span><br><span class="line">                    <span class="string">"id"</span>: labels[i].item(),</span><br><span class="line">                    <span class="string">"label"</span>: predicted[i].item()</span><br><span class="line">                &#125;)</span><br><span class="line">    <span class="comment"># 从list转成 dataframe 然后保存为csv文件</span></span><br><span class="line">    columns = result_list[<span class="number">0</span>].keys()</span><br><span class="line">    result_dict = &#123;col: [anno[col] <span class="keyword">for</span> anno <span class="keyword">in</span> result_list] <span class="keyword">for</span> col <span class="keyword">in</span> columns&#125;</span><br><span class="line">    result_df = pd.DataFrame(result_dict)</span><br><span class="line">    result_df = result_df.sort_values(<span class="string">"id"</span>)</span><br><span class="line">    result_df.to_csv(csv_path, index=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<h2 id="完整调用流程"><a href="#完整调用流程" class="headerlink" title="完整调用流程"></a>完整调用流程</h2><p> 损失函数和优化方法的确定</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">net = MyCNN()</span><br><span class="line">device = torch.device(<span class="string">"cuda:0"</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">"cpu"</span>)</span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line"><span class="comment"># criterion = nn.BCELoss()  #二分类交叉熵损失函数</span></span><br><span class="line"><span class="comment"># criterion = nn.BCEWithLogitsLoss() #二分类交叉熵损失函数 带log loss</span></span><br><span class="line"><span class="comment"># criterion = nn.MSELoss()</span></span><br><span class="line"></span><br><span class="line">optimizer = optim.SGD(net.parameters(), lr=<span class="number">0.001</span>, momentum=<span class="number">0.9</span>)</span><br><span class="line"><span class="comment">#也可以选择Adam优化方法</span></span><br><span class="line"><span class="comment"># optimizer = torch.optim.Adam(net.parameters(),lr=1e-2)</span></span><br></pre></td></tr></table></figure>
<h3 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a><strong>训练过程</strong></h3><p>需要传入epoch数目，训练数据加载器，设备，网络模型，损失函数，优化方法和tensorboard画图的路径等参数。<br>注意的是如果使用完整的官方训练数据集来训练网络后，用这个网络去在验证集上面验证是没有意义的，因为验证集的数据是从完整训练数据集上面划分出来，所以相当于在用训练数据验证性能。用划分过后的new_train_loader训练的网络在进行验证才有意义。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># train( 1, train_loader, device,net, criterion, optimizer,tensorboard_path) # 完整的训练数据集</span></span><br><span class="line">train( <span class="number">1</span>, new_train_loader, device,net, criterion, optimizer,tensorboard_path) <span class="comment"># 划分80%后的训练数据集</span></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<pre><code>Finished Training
</code></pre><p>在训练的时候会用tensorboard保存每个时刻的训练数据，需要新打开一个命令端口输入：<br><code>tensorboard --logdir=/path_to_log_dir/ --port 6006</code> 命令，然后通过在浏览器中输入网址<a href="http://localhost:6006/" target="_blank" rel="noopener">http://localhost:6006/</a> 来查看</p>
<p>模型的保存和加载</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">torch.save(net.state_dict(), model_save_path)</span><br><span class="line">val_net = MyCNN()</span><br><span class="line">val_net.load_state_dict(torch.load(<span class="string">'./dogs-vs-cats_12epoch_valnet.pth'</span>))</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<pre><code>&lt;All keys matched successfully&gt;
</code></pre><h3 id="验证过程"><a href="#验证过程" class="headerlink" title="验证过程"></a><strong>验证过程</strong></h3><p>输入的网络是上面训练过的网络，或者从模型权重保存路径加载的模型。输出模型在自己划分的验证集上面的准确率，结果是98.84%</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">validate(validate_loader,device,val_net,criterion)</span><br></pre></td></tr></table></figure>
<p>​    输出：</p>
<pre><code>98.92
</code></pre><h3 id="输出测试集预测结果"><a href="#输出测试集预测结果" class="headerlink" title="输出测试集预测结果"></a><strong>输出测试集预测结果</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">submission(<span class="string">'./test.csv'</span>,test_loader, device, val_net)</span><br></pre></td></tr></table></figure>
<p>最后在Kaggle上提交预测结果csv文件，得到打分。 需要先报名参赛这些操作，而且只有Dogs vs. Cats Redux: Kernels Edition这个才能够提交数据，最开始的那个6年前的提交通道已经关闭了。提交可以下载Kaggle的API在命令行提交，也可以直接在<a href="https://www.kaggle.com/c/dogs-vs-cats-redux-kernels-edition/submit" target="_blank" rel="noopener">提交链接</a>提交</p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>文章基于Notebook的过程，也构建了对应的<a href="https://github.com/BraveY/AI-with-code/tree/master/dog-vs-cat/pycharm-project/src" target="_blank" rel="noopener">Pycharm项目</a>，将整个过程分模块来编码,架构更清晰。</p>
<p>我总共训练了三个网络，其中MyCNN_net_1使用全部的训练数据，MyCNN_net_2使用划分过的训练数据，RestNet50是预训练的模型，使用完整训练数据训练。</p>
<p>Kaggle上的评分是根据log loss来计算的，分数越低代表模型性能越好。然后其他两个网络使用的完整训练数据集是包含验证集的，所以没有计算验证集的准确率。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>网络</th>
<th>epochs</th>
<th>训练数据</th>
<th>得分</th>
<th>验证集准确率</th>
</tr>
</thead>
<tbody>
<tr>
<td>ResNet50</td>
<td>3</td>
<td>完整训练数据集</td>
<td>0.06691</td>
<td>-</td>
</tr>
<tr>
<td>MyCNN_net_1</td>
<td>12</td>
<td>划分的80%训练数据集</td>
<td>0.73358</td>
<td>98.92</td>
</tr>
<tr>
<td>MyCNN_net_2</td>
<td>12</td>
<td>完整训练数据集</td>
<td>0.94158</td>
<td>-</td>
</tr>
</tbody>
</table>
</div>
<p>实验结果并不严谨，只进行了一次，所以存在一些随机性。</p>
<p>其中使用预训练的ResNet50的效果非常好，在猫狗数据集上训练微调的时候loss就很低了，所以只训练了3轮。</p>
<p><img src="/" class="lazyload" data-src="https://res.cloudinary.com/bravey/image/upload/v1587879398/blog/deep-learning/Resnet50.jpg"  alt=""></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>自己在搭建网络的时候遇到一个问题就是随便设置的一个网络结构的时候，发现交叉熵的loss会一直维持在0.69，不下降。暂时还没有搞懂问题出在哪儿，后面有时间了研究下，</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://bravey.github.io/2020-03-13-%E4%BD%BF%E7%94%A8Pytorch%E6%A1%86%E6%9E%B6%E7%9A%84CNN%E7%BD%91%E7%BB%9C%E5%AE%9E%E7%8E%B0%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%EF%BC%88MNIST%EF%BC%89%E8%AF%86%E5%88%AB.html">之前的手写数字识别</a></p>
<p><a href="https://www.pytorchtutorial.com/pytorch-builtin-tensorboard/" target="_blank" rel="noopener">tensorboard画图</a><br><a href="https://www.zhihu.com/question/38341743" target="_blank" rel="noopener">pip源的更新</a><br><a href="https://www.cnblogs.com/marsggbo/p/10496696.html" target="_blank" rel="noopener">数据集的划分</a><br><a href="https://github.com/ShunLu91/Single-Path-One-Shot-NAS" target="_blank" rel="noopener">topk的计算</a></p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">BraveY</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://bravey.github.io/2020-04-26-Kaggle%E7%8C%AB%E7%8B%97%E8%AF%86%E5%88%ABPytorch%E8%AF%A6%E7%BB%86%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B.html">https://bravey.github.io/2020-04-26-Kaggle%E7%8C%AB%E7%8B%97%E8%AF%86%E5%88%ABPytorch%E8%AF%A6%E7%BB%86%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://bravey.github.io" target="_blank">BraveY</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Pytorch/">Pytorch</a></div><div class="post_share"><div class="social-share" data-image="https://images.pexels.com/photos/390051/surfer-wave-sunset-the-indian-ocean-390051.jpeg?auto=compress&amp;cs=tinysrgb&amp;dpr=1&amp;w=500" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/2020-04-25-leetcode-55-Jump-Game.html"><img class="next_cover lazyload" data-src="https://images.pexels.com/photos/452780/pexels-photo-452780.jpeg?auto=compress&amp;cs=tinysrgb&amp;dpr=1&amp;w=500" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">leetcode 55 Jump Game</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019-12-20-LSTM与Prophet时间序列预测实验.html" title="LSTM与Prophet时间序列预测实验"><img class="relatedPosts_cover lazyload"data-src="https://images.pexels.com/photos/640809/pexels-photo-640809.jpeg?auto=compress&cs=tinysrgb&dpr=1&w=500"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-12-20</div><div class="relatedPosts_title">LSTM与Prophet时间序列预测实验</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div id="disqus_thread"></div><script>var disqus_config = function () {
  this.page.url = 'https://bravey.github.io/2020-04-26-Kaggle%E7%8C%AB%E7%8B%97%E8%AF%86%E5%88%ABPytorch%E8%AF%A6%E7%BB%86%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B.html';
  this.page.identifier = '2020-04-26-Kaggle猫狗识别Pytorch详细搭建过程.html';
  this.page.title = 'Kaggle猫狗识别Pytorch详细搭建过程';
};
(function() { 
  var d = document, s = d.createElement('script');
  s.src = 'https://bravey.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
})();
</script><script>function getDisqusCount() {
  var d = document, s = d.createElement('script');
  s.src = 'https://bravey.disqus.com/count.js';
  s.id = 'dsq-count-scr';
  (d.head || d.body).appendChild(s);
}

window.addEventListener('load', getDisqusCount, false);</script></div></article></main><footer id="footer" style="background-image: url(https://images.pexels.com/photos/390051/surfer-wave-sunset-the-indian-ocean-390051.jpeg?auto=compress&amp;cs=tinysrgb&amp;dpr=1&amp;w=500)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2020 By BraveY</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="/js/third-party/ClickShowText.js"></script><script src="/js/search/local-search.js"></script></body></html>
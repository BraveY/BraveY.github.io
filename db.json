{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/robots.txt","path":"robots.txt","modified":1,"renderable":0},{"_id":"themes/next-reloaded/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/images/favicon.png","path":"images/favicon.png","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/images/favicon16x16.png","path":"images/favicon16x16.png","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/js/bookmark.js","path":"js/bookmark.js","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/js/algolia-search.js","path":"js/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/js/local-search.js","path":"js/local-search.js","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/lib/anime.min.js","path":"lib/anime.min.js","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/js/next-boot.js","path":"js/next-boot.js","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/js/motion.js","path":"js/motion.js","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/lib/canvas-nest/README.md","path":"lib/canvas-nest/README.md","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/lib/canvas-nest/LICENSE","path":"lib/canvas-nest/LICENSE","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/lib/canvas-nest/canvas-nest-nomobile.min.js","path":"lib/canvas-nest/canvas-nest-nomobile.min.js","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/lib/canvas-nest - 副本/LICENSE","path":"lib/canvas-nest - 副本/LICENSE","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/lib/canvas-nest - 副本/canvas-nest.min.js","path":"lib/canvas-nest - 副本/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/lib/canvas-nest - 副本/canvas-nest-nomobile.min.js","path":"lib/canvas-nest - 副本/canvas-nest-nomobile.min.js","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/lib/canvas-nest - 副本/README.md","path":"lib/canvas-nest - 副本/README.md","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1}],"Cache":[{"_id":"themes/next-reloaded/.gitattributes","hash":"3e00e1fb043438cd820d94ee3dc9ffb6718996f3","modified":1573650247501},{"_id":"themes/next-reloaded/.gitignore","hash":"a1b7ccf59a9732e644b1b4d65b024c7e9dfe4a05","modified":1573719785640},{"_id":"source/robots.txt","hash":"bbfef6d0a1bee35d06457106003c6c0e399ea6e0","modified":1573221035771},{"_id":"source/google33ea6e69d32e20f7.html","hash":"422e223a4acc2bbb17b8fef05ec23e0df52a4860","modified":1574734363142},{"_id":"themes/next-reloaded/.eslintrc.json","hash":"d3c11de434171d55d70daadd3914bc33544b74b8","modified":1573650247500},{"_id":"themes/next-reloaded/_config.yml","hash":"d3f22eebfca4cac142f046a0e9aa21df87734817","modified":1581395066609},{"_id":"themes/next-reloaded/.editorconfig","hash":"731c650ddad6eb0fc7c3d4a91cad1698fe7ad311","modified":1573650247499},{"_id":"themes/next-reloaded/LICENSE.md","hash":"0a9c7399f102b4eb0a6950dd31264be421557c7d","modified":1573650247513},{"_id":"themes/next-reloaded/README.md","hash":"cea1e65e6e0309c2f7793b1889ecec05ef05725c","modified":1573650247513},{"_id":"themes/next-reloaded/gulpfile.js","hash":"c4cffe4df4ba406d9ab347bc52a0c8059c5050b1","modified":1573650247530},{"_id":"themes/next-reloaded/.travis.yml","hash":"379f31a140ce41e441442add6f673bf397d863ea","modified":1573650247512},{"_id":"themes/next-reloaded/.stylintrc","hash":"6259e2a0b65d46865ab89564b88fc67638668295","modified":1573650247511},{"_id":"themes/next-reloaded/package.json","hash":"c4b5e96ccfa6956348c57e15dfa6047935af807c","modified":1573650247585},{"_id":"themes/next-reloaded/crowdin.yml","hash":"4a53f5985e545c635cb56b2a57ed290cb8cf8942","modified":1573650247515},{"_id":"themes/next-reloaded/edited_config.yml","hash":"3fd31325ec4f940a4ebaa8144d0bab7d797c5a97","modified":1573654662648},{"_id":"source/categories/index.md","hash":"a9e619f11903bc0331f052475b269335d9a2a019","modified":1553578252809},{"_id":"source/_posts/2019-03-20-Redis设计与实现读书笔记.md","hash":"030a1f43ab91e616acac87d1c1cc37068d543a8c","modified":1573218920055},{"_id":"source/tags/index.md","hash":"079964de51a26ff63e1fadd50b5387b60c62633a","modified":1553578252810},{"_id":"source/_posts/2019-03-26-使用Travis-CI自动部署博客.md","hash":"35695761fee3f772393fd4a0b35146e832178cae","modified":1573733916776},{"_id":"source/_posts/2019-03-27-Redis-设计与实现读书笔记——第四章-字典.md","hash":"c15917eccc04cf255bc968dbfca555ae59b0dbde","modified":1573218822256},{"_id":"source/_posts/2019-03-29-Redis设计与实现读书笔记——第8章-对象.md","hash":"af253a9fe4ecf840e7674653afe6427950943e18","modified":1573218910743},{"_id":"source/_posts/2019-04-01-Docker-学习.md","hash":"2dc81661f9316e0c79873fd1b35757a41d1b4c6d","modified":1573218832912},{"_id":"source/_posts/2019-03-27-剑指offer-读书笔记——第2章.md","hash":"c705a14819ec2d4cce47ff4a9118c7a347bfa89b","modified":1573218874631},{"_id":"source/_posts/2019-04-03-gdb-调试.md","hash":"3fe85dc48474413e45425655ad619d48dfc2dd38","modified":1574913776772},{"_id":"source/_posts/2019-03-31-计算Linux系统的CPU利用率.md","hash":"5e87e9ec6249bb911aadcd57fd5b725b5c6d9d88","modified":1573218893661},{"_id":"source/_posts/2019-04-17-青蛙跳台阶问题.md","hash":"e6b6293250dc9dff35cf28d3cc021c641e634a98","modified":1574913559907},{"_id":"source/_posts/2019-04-10-Linux-shell脚本计算运行时间.md","hash":"92302d59156c6824dff74e39d1fe84dc9143b999","modified":1573218842619},{"_id":"source/_posts/2019-04-26-Redis-Makefile注解.md","hash":"475fd84b6efcb717d65c1a30be747b79c0f0d8d4","modified":1573218803742},{"_id":"source/_posts/2019-04-25-GCC的编译选项.md","hash":"fae7e7b1a9f53f6615859a5e18e8d5b6118f8268","modified":1573218811703},{"_id":"source/_posts/2019-08-24-shadowsocks的部署.md","hash":"d97b022b28129402c3800e65f905b7d88fc2dc77","modified":1581045632398},{"_id":"source/_posts/2019-09-19-数组中的第K大的数.md","hash":"e62393ac2d78a97ba21e63864b0ec611903abbfb","modified":1573444193617},{"_id":"source/_posts/2019-10-14-数组中的主要元素.md","hash":"3fffdd8d0b374586f8679cacae859534dd8c14bb","modified":1573663577188},{"_id":"source/_posts/2019-09-08-实模式寻址方式.md","hash":"f70903c082da1b25be563a714054ee2023db616d","modified":1573218738272},{"_id":"source/_posts/2019-10-07-逆序对的计数.md","hash":"f8569a7762a20d3b253f918458ed5bc6aa0c6c21","modified":1573663673243},{"_id":"source/_posts/2019-09-08-OJ输入输出.md","hash":"59ca713f69ea57e46a2b8962f349817ed8508256","modified":1573443285463},{"_id":"source/_posts/2019-11-07-Clementine教程.md","hash":"f68987ae6408e17a3872fbac00bc5dc77f32aef2","modified":1573473074326},{"_id":"source/_posts/2019-11-15-数据仓库.md","hash":"5869aeb38fcaf49ca5f4be170a81e14b11317eb8","modified":1573909219536},{"_id":"source/_posts/2019-10-31-内嵌汇编.md","hash":"b3e6e8729ecb78e172e84f43eeadf3da84f9df1b","modified":1576769928527},{"_id":"source/_posts/2019-11-17-分类与预测.md","hash":"0914deb63415870f574c9d4dd708ce4764a3a26f","modified":1574089044981},{"_id":"source/_posts/2019-11-19-聚类方法.md","hash":"1007701f2ed07b471623992d6e6f2c14b4d54d87","modified":1574157767887},{"_id":"source/_posts/2019-11-16-数据预处理.md","hash":"a858893b5b70c4f57e3d2e07a3864ca2e1219a24","modified":1574176903723},{"_id":"source/_posts/2019-11-19-推荐系统.md","hash":"575a51807b034ec12c054661d6bf2de3ba139f18","modified":1574157872466},{"_id":"source/_posts/2019-11-18-关联规则.md","hash":"3b5b01b38b175e6dcb5d8e7922b804a8c27b0b36","modified":1574158029703},{"_id":"source/_posts/2019-11-22-leetcode153-154-Find-Minimum-in-Rotated-Sorted-Array-III.md","hash":"2b0764e3375738a5adf1db8f0672446b88705c93","modified":1574912441687},{"_id":"source/_posts/2019-12-27-奇思妙想.md","hash":"8d6d22c3d290879f1cabb3bb3e5248d4dd317a49","modified":1580870297933},{"_id":"source/_posts/2019-11-29-leetcode-881-Boats-to-Save-People.md","hash":"b7212c56b2224e531c8b9d8bd7b2a42c70d40727","modified":1575016066912},{"_id":"source/_posts/2019-12-20-LSTM与Prophet时间序列预测实验.md","hash":"a187a486b90ed57e5e418700c4ef1fb4bd185ad2","modified":1576916593385},{"_id":"source/_posts/2019-12-08-线性判别函数.md","hash":"1a23d6992c5094bd0a636babd438b9793515b8f2","modified":1577451140495},{"_id":"source/_posts/2019-12-28-特征选择和特征提取.md","hash":"ca7aeb98163a996abf0b4f3df7acfc6f2636ea4a","modified":1577600029230},{"_id":"source/_posts/2020-01-06-leetcode-543-Diameter-of-Binary-Tree.md","hash":"032e46fa2b6088969997eaf62b3906ba99d2c666","modified":1581082243619},{"_id":"source/_posts/2020-01-29-leetcode-53-Maximum-Subarray.md","hash":"b47a6c25e7c90cc621d249d2bbc5affe994e4e9f","modified":1581084181482},{"_id":"source/_posts/2020-02-07-leetcode-300-Longest-Increasing-Subsequence.md","hash":"542ed9bdfe60ac0fd3f216ae1957bbbb08a1eaba","modified":1581261026907},{"_id":"source/_posts/2020-02-05-c++拾遗.md","hash":"9a0da8a75193c763839589c8e10cba3eb17a3909","modified":1580885398759},{"_id":"source/_posts/BigdataBench-deploy.md","hash":"3f0bee3ca87f917c4de9d6e722c45c6defc2f49e","modified":1573218712787},{"_id":"source/_posts/Linux 命令 学习.md","hash":"45a03144efd0f17a9c9fe3c041d4c41fdbcb3547","modified":1573218993020},{"_id":"themes/next-reloaded/reload_bak_config.yml","hash":"a952a57b271963b4f579f993d678e155b6de6f48","modified":1573650247514},{"_id":"source/_posts/ceph部署文档.md","hash":"e9e153c84949498e0f335e8e96dc20ee086c5d14","modified":1573218703727},{"_id":"source/_posts/apt-get install 失败.md","hash":"44e05ee8ec75520a53daae8c667b16d6963314db","modified":1573219014015},{"_id":"source/_posts/make学习.md","hash":"c6ffd8a913be89c042411ef126baa2e5a11250a3","modified":1573218793283},{"_id":"source/_posts/使用YCSB 评测redis性能.md","hash":"2706432c2446e6ce6bc87acb5cb3ba558bc87a44","modified":1573218964265},{"_id":"source/_posts/ping 问题.md","hash":"448ffea3ba1108ac8c9397e4a1d7c27113fddfc4","modified":1573218982252},{"_id":"source/_posts/图计算常用算法.md","hash":"0eac96edbcd9abc27b21f2fd7b05ad3bfb6b3b45","modified":1573218948042},{"_id":"source/_posts/tee命令解析.md","hash":"01039140d54bbd67b43b4b48679c42b019e4e271","modified":1573701341475},{"_id":"source/_posts/使用shell脚本遍历redis数据库中的所有kv对.md","hash":"2ca613aa393cd64b563ef5de291a61d7fb3c195d","modified":1573218939540},{"_id":"themes/next-reloaded/.github/CODE_OF_CONDUCT.md","hash":"778b7e052993ed59f21ed266ba7119ee2e5253fb","modified":1573650247501},{"_id":"themes/next-reloaded/.github/lock.yml","hash":"3ce3d0a26030a1cd52b273cc6a6d444d7c8d85c2","modified":1573650247508},{"_id":"themes/next-reloaded/.github/auto_assign.yml","hash":"9fe0dbe3f6edc59bf10ea25b14eba0e92e2c8f42","modified":1573650247506},{"_id":"themes/next-reloaded/.github/eslint-disable-bot.yml","hash":"e06053d417579ed967a94166deb6bda5ce41d805","modified":1573650247507},{"_id":"themes/next-reloaded/.github/config.yml","hash":"cbd06d0c40afa9fdf056765120e9085826b00d20","modified":1573650247507},{"_id":"themes/next-reloaded/.github/CONTRIBUTING.md","hash":"06b62d1b37ed1b48210fe27158e83b4dbc5ed23d","modified":1573650247502},{"_id":"themes/next-reloaded/.github/issue_label_bot.yaml","hash":"18eddb3ba5e94cac0642134581f86e26f568d388","modified":1573650247508},{"_id":"themes/next-reloaded/.github/PULL_REQUEST_TEMPLATE.md","hash":"15b0ac46f260743c925ab2eba3f081640a21cd3a","modified":1573650247506},{"_id":"themes/next-reloaded/.github/mergeable.yml","hash":"1c1cb77a62df1e3654b151c2da34b4a10d351170","modified":1573650247509},{"_id":"themes/next-reloaded/.github/stale.yml","hash":"b2b762645d3c3e373e0b2c861bf2ddf7f303c577","modified":1573650247510},{"_id":"themes/next-reloaded/docs/AUTHORS.md","hash":"cde7cc095ac31b421a573042cf61060f90d9ad0d","modified":1573650247517},{"_id":"themes/next-reloaded/docs/ALGOLIA-SEARCH.md","hash":"5ace79ff1859d985339fdf6d74b779f60c91a27a","modified":1573650247516},{"_id":"themes/next-reloaded/docs/AGPL3.md","hash":"f463f95b169d64983f59fa6f3e4b6760290a0e6b","modified":1573650247515},{"_id":"themes/next-reloaded/docs/DATA-FILES.md","hash":"062b36699c78676a25e3da95bb197841adb600ba","modified":1573650247517},{"_id":"themes/next-reloaded/docs/INSTALLATION.md","hash":"07ea00bee149a1bdc9073e903ee6b411e9f2f818","modified":1573650247518},{"_id":"themes/next-reloaded/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"356ada9837300bcdd1711321dabc309887e23730","modified":1573650247518},{"_id":"themes/next-reloaded/docs/MATH.md","hash":"6f6faf58f86b03b9344ef857ae34de97fc336590","modified":1573650247520},{"_id":"themes/next-reloaded/docs/LICENSE.txt","hash":"ae5ad07e4f4106bad55535dba042221539e6c7f9","modified":1573650247519},{"_id":"themes/next-reloaded/.github/release-drafter.yml","hash":"09c3352b2d643acdc6839601ceb38abc38ab97c5","modified":1573650247509},{"_id":"themes/next-reloaded/.github/support.yml","hash":"7ce2722d6904c31a086444c422dc49b6aa310651","modified":1573650247510},{"_id":"themes/next-reloaded/languages/en.yml","hash":"f6a8d95948762c978d2ed065c5f87d2061aa6fc1","modified":1573650247532},{"_id":"themes/next-reloaded/languages/de.yml","hash":"c94ff69db40c22de61ce6446cdc9108177379074","modified":1573650247531},{"_id":"themes/next-reloaded/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1573650247531},{"_id":"themes/next-reloaded/languages/fa.yml","hash":"856e19aec28767e1f91a8e805011f82c7601ec60","modified":1573650247533},{"_id":"themes/next-reloaded/docs/UPDATE-FROM-5.1.X.md","hash":"20e2223836233c812f268b4a7050762dd56cf2be","modified":1573650247520},{"_id":"themes/next-reloaded/languages/fr.yml","hash":"a9ac6ce36e97a06ad6ab3431eb652b8702b7a63e","modified":1573650247534},{"_id":"themes/next-reloaded/languages/es.yml","hash":"203084eace039610ac097e0e6ce6b5f4f8356217","modified":1573650247532},{"_id":"themes/next-reloaded/languages/ja.yml","hash":"8341ccdd1b2fbf11e9d80c1aacd37a969c57ca9c","modified":1573650247536},{"_id":"themes/next-reloaded/languages/it.yml","hash":"08b2db3eece91edd2759ca4b26de74b2992c7dae","modified":1573650247535},{"_id":"themes/next-reloaded/languages/id.yml","hash":"1c321f62378dc029f7b795ad2fcb0f80277de52f","modified":1573650247535},{"_id":"themes/next-reloaded/languages/ko.yml","hash":"4f3a4165ceaaada238316fe8bd2438f775abebfc","modified":1573650247537},{"_id":"themes/next-reloaded/languages/hu.yml","hash":"313894fd5615e37c1935a235f8f702df7852345a","modified":1573650247534},{"_id":"themes/next-reloaded/languages/pt.yml","hash":"7d3f040065b0a04a23d3be42ddfcafc95f79854e","modified":1573650247539},{"_id":"themes/next-reloaded/languages/nl.yml","hash":"387ea251057164f8dcd38553bac01a909cf11f0d","modified":1573650247538},{"_id":"themes/next-reloaded/languages/ru.yml","hash":"ca8f3c22fb10cf3e455890e0f1f2b29b8814a702","modified":1573650247539},{"_id":"themes/next-reloaded/languages/uk.yml","hash":"aa90a1b6f12f5bae1ff6386ea99c63db901179a8","modified":1573650247541},{"_id":"themes/next-reloaded/languages/pt-BR.yml","hash":"075140b21edd6cb0ec1e9b3e79e1339d1e1a17e4","modified":1573650247538},{"_id":"themes/next-reloaded/languages/tr.yml","hash":"c99f21a9cb86957618428e488ece24df063222f3","modified":1573650247540},{"_id":"themes/next-reloaded/languages/vi.yml","hash":"a5f60a2b3dc1b90b867e99dd3b108113a04f9ba5","modified":1573650247541},{"_id":"themes/next-reloaded/languages/zh-CN.yml","hash":"8c70af9442f12aa65e8737774ea032bb6420a715","modified":1573650247542},{"_id":"themes/next-reloaded/languages/zh-TW.yml","hash":"7402f4b899dbeead3641417bfaf5f46f3a3934a5","modified":1573650247543},{"_id":"themes/next-reloaded/layout/_layout.swig","hash":"6eb89a44dc5e958b41df8a673cc28f67bb56ccf3","modified":1573650247544},{"_id":"themes/next-reloaded/languages/zh-HK.yml","hash":"1c8b8ad49a15ea3491555a2ae1819b1ad405fab2","modified":1573650247542},{"_id":"themes/next-reloaded/layout/page.swig","hash":"8322d902a8d870e6d0b0bc25750141c51749bf8b","modified":1573650247584},{"_id":"themes/next-reloaded/layout/post.swig","hash":"d75078e7acd9ead60dee9bec05b2b4f60e121177","modified":1573650247584},{"_id":"themes/next-reloaded/layout/category.swig","hash":"9febc49ff6f476fd0261c75aecbc67cc24c11667","modified":1573650247583},{"_id":"themes/next-reloaded/layout/archive.swig","hash":"54a96d109374536b5f2ef1bb8b6f82825dc810c9","modified":1573650247582},{"_id":"themes/next-reloaded/scripts/renderer.js","hash":"e3658eea97b1183ee2e9f676231e53f7994741f6","modified":1573650247598},{"_id":"themes/next-reloaded/layout/index.swig","hash":"014202a6e316096f85f8c1489568d31212c5f1b2","modified":1573650247583},{"_id":"themes/next-reloaded/layout/tag.swig","hash":"eedd3a19aa5222184ea6ee628fa46dfa0654ece8","modified":1573650247585},{"_id":"source/_posts/Redis源码阅读——SDS/memset.png","hash":"728c1559807187a4badabbfa2ed7cee503648e16","modified":1553578252798},{"_id":"source/_posts/BigdataBench-deploy/runcc.png","hash":"92edff3c535d6744e38fd0b933a5474d768b5ecc","modified":1553578252794},{"_id":"source/_posts/Redis源码阅读——SDS/2019-03-22-Redis源码阅读——SDS.md","hash":"dd5b8de63ba9950621d9003289895f1dcc16ada3","modified":1573219044974},{"_id":"source/_posts/Redis源码阅读——SDS/sds.png","hash":"8ca71f0c564d44bbe5c792a3fc5bbb53b49f22c5","modified":1553578252799},{"_id":"themes/next-reloaded/.github/ISSUE_TEMPLATE/bug-report.md","hash":"6f669d3ac018915a130d72e483666d0d63560c94","modified":1573650247503},{"_id":"themes/next-reloaded/.github/ISSUE_TEMPLATE/question.md","hash":"5804fc485a683839b797003ce6402b907ed5791d","modified":1573650247505},{"_id":"themes/next-reloaded/.github/ISSUE_TEMPLATE/feature-request.md","hash":"dea66b33b57f18b3ab6d807741c7cf776366f6d2","modified":1573650247504},{"_id":"themes/next-reloaded/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"fcbe8e8d7ad39028936ba341f4154e4f9234d8b2","modified":1573650247525},{"_id":"themes/next-reloaded/.github/ISSUE_TEMPLATE/other.md","hash":"efe32a27eb47ff28dc2a3783a50dbde5a4627b9f","modified":1573650247504},{"_id":"themes/next-reloaded/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"7202fd76db39f8246a0f80aab68b720d89f48af1","modified":1573650247525},{"_id":"themes/next-reloaded/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"9916a1a0883d5807ddc0cc2607c878d1e1f5fa0a","modified":1573650247528},{"_id":"themes/next-reloaded/docs/zh-CN/README.md","hash":"8845e67bc594a5cdbfad617374faef34230841c6","modified":1573650247529},{"_id":"themes/next-reloaded/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"e93a800008567dd48b6f388982ec72db91bb913a","modified":1573650247530},{"_id":"themes/next-reloaded/docs/zh-CN/MATH.md","hash":"bfd10209878e6252467311f9544841751c465058","modified":1573650247529},{"_id":"themes/next-reloaded/docs/zh-CN/CONTRIBUTING.md","hash":"ff3a003820ccc63c06a6df2117d023959c7cf4ec","modified":1573650247526},{"_id":"themes/next-reloaded/docs/ru/DATA-FILES.md","hash":"6db9eb0e2393a391a5e17b62a43b264fce5ed018","modified":1573650247521},{"_id":"themes/next-reloaded/docs/zh-CN/DATA-FILES.md","hash":"a7de5ce2931290a67feebd149e41a9648de4bb83","modified":1573650247527},{"_id":"themes/next-reloaded/docs/zh-CN/INSTALLATION.md","hash":"716111dd36d276f463c707dfcc9937fea2a1cf7a","modified":1573650247527},{"_id":"themes/next-reloaded/docs/ru/UPDATE-FROM-5.1.X.md","hash":"510cfd27e37e3a611649a3d1a84cc52fd4da5936","modified":1573650247524},{"_id":"themes/next-reloaded/docs/ru/INSTALLATION.md","hash":"a9cfe5ac9ef727a8650b2b6584482751a26b1460","modified":1573650247522},{"_id":"themes/next-reloaded/docs/ru/README.md","hash":"7b5fa4461646677e4ab5cb271477795987ba1ab3","modified":1573650247523},{"_id":"themes/next-reloaded/layout/_macro/sidebar.swig","hash":"be603e35bea3431b133fcd4b9626993dcfb85c06","modified":1573650247545},{"_id":"themes/next-reloaded/layout/_macro/post-collapse.swig","hash":"db25de9ceaa1ec5650ff15cf4aee4399ed8f9c42","modified":1573650247544},{"_id":"themes/next-reloaded/layout/_macro/post.swig","hash":"cb456a03e794f04b081d03fe9e3ccc148cafaf22","modified":1573650247545},{"_id":"themes/next-reloaded/layout/_partials/widgets.swig","hash":"5392dcbb504266f0f61d5b8219914068ef9cdc25","modified":1573650247559},{"_id":"themes/next-reloaded/layout/_partials/pagination.swig","hash":"29ce76e36011da76c50d482396e2558f72525fe0","modified":1573650247553},{"_id":"themes/next-reloaded/layout/_partials/comments.swig","hash":"223bd7b04acb32ddbe813f21a75290e1461630fb","modified":1573650247546},{"_id":"themes/next-reloaded/layout/_scripts/index.swig","hash":"1822eaf55bbb4bec88871c324fc18ad95580ccb4","modified":1573650247560},{"_id":"themes/next-reloaded/layout/_scripts/noscript.swig","hash":"7b9e0f776a5be6c3f95bc7f394e1424ba02ba93b","modified":1573650247560},{"_id":"themes/next-reloaded/layout/_partials/footer.swig","hash":"ce3423a66ba62335a761ff213106e2b8bb906a69","modified":1573704098863},{"_id":"themes/next-reloaded/layout/_scripts/three.swig","hash":"6b092c6d882b2dfa5273e1b3f60b244cb7c29fcd","modified":1573650247564},{"_id":"themes/next-reloaded/layout/_scripts/vendors.swig","hash":"244ca2d74ee0d497c87572c6a26b43c62a952673","modified":1573650247565},{"_id":"themes/next-reloaded/scripts/events/index.js","hash":"37347490d7960955e65f0a172aaae6423e7eec48","modified":1573650247587},{"_id":"themes/next-reloaded/layout/_third-party/index.swig","hash":"c6b63cbc80938e6e09578b8c67e01adf13a9e3bd","modified":1573650247573},{"_id":"themes/next-reloaded/scripts/helpers/font.js","hash":"20317a314d2283e4f87c8c8d247422f33427ebbe","modified":1573650247597},{"_id":"themes/next-reloaded/layout/_scripts/pjax.swig","hash":"f1c4611c543eddf364dce68dd9825f3df958aab3","modified":1573650247561},{"_id":"themes/next-reloaded/scripts/helpers/engine.js","hash":"a2d2f19271ad1d347c05c3195b5d3f53d2eb8af4","modified":1573650247596},{"_id":"themes/next-reloaded/scripts/helpers/next-url.js","hash":"3340964985ada2ad6beb7ec8a3321eacbdc61980","modified":1573650247597},{"_id":"themes/next-reloaded/scripts/filters/default-injects.js","hash":"ad321db012cea520066deb0639335e9bc0dcc343","modified":1573650247594},{"_id":"themes/next-reloaded/scripts/filters/locals.js","hash":"71afa945066c24a46b6ac172c23415dd8bdedd4a","modified":1573650247595},{"_id":"themes/next-reloaded/scripts/filters/minify.js","hash":"21196a48cb127bf476ce598f25f24e8a53ef50c2","modified":1573650247595},{"_id":"themes/next-reloaded/scripts/filters/front-matter.js","hash":"305d03c1e45782988809298c3e3b3c5d5ee438aa","modified":1573650247594},{"_id":"themes/next-reloaded/scripts/filters/post.js","hash":"7c86c0fb9179e02e0e530c9b90483cd3db2a400d","modified":1573650247596},{"_id":"themes/next-reloaded/scripts/tags/button.js","hash":"39156bf735c1d1ebd0d418c411f14ff4f0acdd75","modified":1573650247598},{"_id":"themes/next-reloaded/scripts/tags/caniuse.js","hash":"6fbc5764dddca114667f1487120a9ed32519857b","modified":1573650247599},{"_id":"themes/next-reloaded/scripts/tags/label.js","hash":"fc83f4e1be2c34e81cb79938f4f99973eba1ea60","modified":1573650247600},{"_id":"themes/next-reloaded/scripts/tags/center-quote.js","hash":"4519ab8e6898f2ee90d05cde060375462b937a7d","modified":1573650247599},{"_id":"themes/next-reloaded/scripts/tags/mermaid.js","hash":"81134494ff0134c0dae1b3815caf6606fccd4e46","modified":1573650247601},{"_id":"themes/next-reloaded/scripts/tags/note.js","hash":"1fdf4f95810fdb983bfd5ad4c4f13fedd4ea2f8d","modified":1573650247601},{"_id":"themes/next-reloaded/scripts/tags/group-pictures.js","hash":"47de27db13f25ae124c7284ccdb026b1b297f65a","modified":1573650247600},{"_id":"themes/next-reloaded/scripts/tags/pdf.js","hash":"ab995f0fc60d60f637220e2651111b775b8a06de","modified":1573650247602},{"_id":"themes/next-reloaded/scripts/tags/tabs.js","hash":"72a5adbd8f300bee1d0c289367598ca06b2bed17","modified":1573650247602},{"_id":"themes/next-reloaded/scripts/tags/video.js","hash":"944293fec96e568d9b09bc1280d5dbc9ee1bbd17","modified":1573650247603},{"_id":"themes/next-reloaded/layout/_third-party/baidu-push.swig","hash":"bd9ba0bf60cc3008ee14339fa395ee6af188e879","modified":1573650247567},{"_id":"themes/next-reloaded/layout/_third-party/quicklink.swig","hash":"fef4bfec70cb877c23c7a6b096d35b1579d0e2b2","modified":1573650247575},{"_id":"themes/next-reloaded/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1573650247660},{"_id":"themes/next-reloaded/layout/_third-party/rating.swig","hash":"206644ff2c769226a58a9039eda9206302460626","modified":1573650247576},{"_id":"themes/next-reloaded/source/css/main.styl","hash":"ee7c731c03d724827d9324d08be701c9d2f04c60","modified":1573650247659},{"_id":"themes/next-reloaded/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1573650247659},{"_id":"themes/next-reloaded/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1573650247660},{"_id":"themes/next-reloaded/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1573650247661},{"_id":"themes/next-reloaded/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1573650247662},{"_id":"themes/next-reloaded/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1573650247661},{"_id":"themes/next-reloaded/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1573650247663},{"_id":"themes/next-reloaded/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1573650247663},{"_id":"themes/next-reloaded/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1573650247664},{"_id":"themes/next-reloaded/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1573650247662},{"_id":"themes/next-reloaded/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1573650247664},{"_id":"themes/next-reloaded/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1573650247665},{"_id":"themes/next-reloaded/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1573650247665},{"_id":"themes/next-reloaded/source/images/favicon.png","hash":"9ad0834cb90e0a8ff8ee739e51d8109aceb7cf68","modified":1573202476399},{"_id":"themes/next-reloaded/source/images/favicon16x16.png","hash":"a63a2e0b78898ee887f4cced3e2b9559dc0dcc3f","modified":1573660544398},{"_id":"themes/next-reloaded/source/js/bookmark.js","hash":"6531c706f34c38d8b44afebfac60cc35171d36f3","modified":1573650247668},{"_id":"themes/next-reloaded/source/js/algolia-search.js","hash":"f632ff7a404ac4fb04313bc554815406ebcb2a0b","modified":1573650247667},{"_id":"themes/next-reloaded/source/js/utils.js","hash":"ae7714d74d4029fbd9d9a86ae42885c20f42cae3","modified":1573650247672},{"_id":"themes/next-reloaded/source/js/local-search.js","hash":"7b0ac87fd6a3cc43d538fe6228429c97876173b6","modified":1573650247668},{"_id":"themes/next-reloaded/source/lib/anime.min.js","hash":"960be51132134acd65c2017cc8a5d69cb419a0cd","modified":1573650247673},{"_id":"themes/next-reloaded/source/js/next-boot.js","hash":"81454487703958e2ce06965fd3879c1d859b6f36","modified":1573650247669},{"_id":"themes/next-reloaded/source/js/motion.js","hash":"19a589098fd13993cb3d198a96f0ed45e1560a64","modified":1573650247669},{"_id":"themes/next-reloaded/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1573650247666},{"_id":"themes/next-reloaded/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1573650247666},{"_id":"themes/next-reloaded/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1573650247643},{"_id":"themes/next-reloaded/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1573650247644},{"_id":"themes/next-reloaded/layout/_partials/head/head.swig","hash":"b2f1000ff62d44e2120399036e69c63a278e3114","modified":1581394653069},{"_id":"themes/next-reloaded/layout/_partials/header/index.swig","hash":"94edc28022325ba21b4e23bb13e1fac337223adc","modified":1573650247549},{"_id":"themes/next-reloaded/layout/_partials/header/menu.swig","hash":"abef4951b8f0eb5fd11067b775b0144c613e8237","modified":1573650247550},{"_id":"themes/next-reloaded/layout/_partials/header/brand.swig","hash":"36d64a542b709490489c8c61269216f47241793a","modified":1573650247549},{"_id":"themes/next-reloaded/layout/_partials/header/menu-item.swig","hash":"2eb7c38ce833e9c5aa7967528af123c36971af5a","modified":1573650247550},{"_id":"themes/next-reloaded/layout/_partials/page/breadcrumb.swig","hash":"91c0addb33006619faa4c32e5d66874e25f1e9b3","modified":1573650247552},{"_id":"themes/next-reloaded/layout/_partials/head/head-unique.swig","hash":"8fc1611774b54a8afee1792c4d8ab2d9581a259b","modified":1573650247547},{"_id":"themes/next-reloaded/layout/_partials/header/sub-menu.swig","hash":"cdae167fbf8ef9904d52a2b76579bc8ca0c5458d","modified":1573650247551},{"_id":"themes/next-reloaded/layout/_partials/page/page-header.swig","hash":"b3b4ffcbda422d7fc21ee43fec7d2a5056b2f381","modified":1573650247552},{"_id":"themes/next-reloaded/layout/_partials/post/post-footer.swig","hash":"ce712c110b5ce8aacba7a86b0558ff89700675c9","modified":1573650247555},{"_id":"themes/next-reloaded/layout/_partials/post/post-copyright.swig","hash":"d3fa29e2d83f29357760e02f32fb5597db8aa780","modified":1573650247554},{"_id":"themes/next-reloaded/layout/_partials/sidebar/site-overview.swig","hash":"842beaadaa2800679667e91fe946f50bded44bc6","modified":1573650247558},{"_id":"themes/next-reloaded/layout/_partials/search/algolia-search.swig","hash":"f9017a2deb2f262912476e94822081bb10ee43af","modified":1573650247557},{"_id":"themes/next-reloaded/layout/_partials/post/post-related.swig","hash":"bc7b047a6246df07767373644b1637d91c3a88b1","modified":1573650247555},{"_id":"themes/next-reloaded/layout/_partials/search/localsearch.swig","hash":"98453ac4a520b2600181fc0331f0067125d0ed4f","modified":1573650247558},{"_id":"themes/next-reloaded/layout/_partials/post/post-reward.swig","hash":"c6d3b1a3fae969d9c03ee48207925fc71e0a63d9","modified":1573650247556},{"_id":"themes/next-reloaded/layout/_partials/search/index.swig","hash":"f1107c28661370e10e1940bff856f22f14f08518","modified":1573650247557},{"_id":"themes/next-reloaded/layout/_scripts/schemes/mist.swig","hash":"0b44f400ec00d2b5add5ee96c11d22465c432376","modified":1573650247563},{"_id":"themes/next-reloaded/layout/_scripts/schemes/gemini.swig","hash":"34495d408e8467555afee489500b8aad98c52079","modified":1573650247562},{"_id":"themes/next-reloaded/layout/_third-party/analytics/growingio.swig","hash":"91c2cb900c76224c5814eeb842d1d5f517f9bf05","modified":1573650247567},{"_id":"themes/next-reloaded/layout/_scripts/pages/schedule.swig","hash":"026087c0be7ec598eba9df2e877cfebf8850d651","modified":1573650247561},{"_id":"themes/next-reloaded/layout/_third-party/analytics/baidu-analytics.swig","hash":"84adaadd83ce447fa9da2cff19006334c9fcbff9","modified":1573650247566},{"_id":"themes/next-reloaded/layout/_scripts/schemes/pisces.swig","hash":"34495d408e8467555afee489500b8aad98c52079","modified":1573650247563},{"_id":"themes/next-reloaded/layout/_scripts/schemes/muse.swig","hash":"0b44f400ec00d2b5add5ee96c11d22465c432376","modified":1573650247563},{"_id":"themes/next-reloaded/layout/_third-party/chat/tidio.swig","hash":"fb94ee487d75e484e59b7fba96e989f699ff8a83","modified":1573650247569},{"_id":"themes/next-reloaded/layout/_third-party/analytics/google-analytics.swig","hash":"f2ef530c77798b19653b4fd3339cc6ae3b9f0afe","modified":1573650247566},{"_id":"themes/next-reloaded/layout/_third-party/analytics/index.swig","hash":"85b60e222712ca3b2c4dc2039de2dc36b8d82940","modified":1573650247567},{"_id":"themes/next-reloaded/layout/_third-party/comments/gitalk.swig","hash":"a4402ded51db062d293a53de40dcf206a16e684e","modified":1573650247571},{"_id":"themes/next-reloaded/layout/_third-party/chat/chatra.swig","hash":"e8aa0ba146b658ae3b73efc4ca63325886bbaa2d","modified":1573650247568},{"_id":"themes/next-reloaded/layout/_third-party/comments/livere.swig","hash":"ef38217a457749e528cf00c487b99cb963ccfbea","modified":1573650247572},{"_id":"themes/next-reloaded/layout/_third-party/comments/disqusjs.swig","hash":"c378efaef4052dbeda0c2356b2b90f2d26eeb83a","modified":1573650247571},{"_id":"themes/next-reloaded/layout/_third-party/comments/valine.swig","hash":"a748a1e25df83ab8f53e4c9bc3370139912c3877","modified":1573650247573},{"_id":"themes/next-reloaded/layout/_third-party/comments/disqus.swig","hash":"0f703d0cfca6149d4ada7af346ce4adbf257fd18","modified":1573650247570},{"_id":"themes/next-reloaded/layout/_third-party/math/katex.swig","hash":"276f523e414d4aa7f350a8f2fd3df8a3d8ea9656","modified":1573650247574},{"_id":"themes/next-reloaded/layout/_third-party/math/index.swig","hash":"59df21fcfe9d0ada8cee3188cb1075529c1c3eb8","modified":1573650247574},{"_id":"themes/next-reloaded/layout/_third-party/search/localsearch.swig","hash":"58296a5c1883f26464c2a5ccf734c19f5fbf395a","modified":1573650247577},{"_id":"themes/next-reloaded/layout/_third-party/search/algolia-search.swig","hash":"35fb1f6438111451ccfbb8ba4a6a8424259c0149","modified":1573650247576},{"_id":"themes/next-reloaded/layout/_third-party/comments/changyan.swig","hash":"a7a26afd3118e036621f802bad42c0cbcced9676","modified":1573650247569},{"_id":"themes/next-reloaded/layout/_third-party/search/swiftype.swig","hash":"aa6ab95b8b76611694613defb4bf25003d1b927f","modified":1573650247577},{"_id":"themes/next-reloaded/layout/_third-party/statistics/busuanzi-counter.swig","hash":"5b5618c2f6ad1d7971e6db257222fce89aa56565","modified":1573650247578},{"_id":"themes/next-reloaded/layout/_third-party/math/mathjax.swig","hash":"1a8bdd6fa16f609872c8f92b546e29a16031b1f5","modified":1573650247575},{"_id":"themes/next-reloaded/layout/_third-party/statistics/index.swig","hash":"ec3c1cd6ace7e6a01b490ac323a4e1ec1fa65fd1","modified":1573650247579},{"_id":"themes/next-reloaded/layout/_third-party/statistics/cnzz-analytics.swig","hash":"53a0760c75d5aaabb3ce8e8aa8e003510d59807f","modified":1573650247578},{"_id":"themes/next-reloaded/layout/_third-party/statistics/tencent-mta.swig","hash":"a2bfea40acc9e18d1cd73edc52df57278b746e81","modified":1573650247581},{"_id":"themes/next-reloaded/scripts/events/lib/injects-point.js","hash":"08496b71c9939718e7955704d219e44d7109247b","modified":1573650247589},{"_id":"themes/next-reloaded/scripts/events/lib/config.js","hash":"2ebf60495afccfef49eb35e28bc672f531a316b1","modified":1573650247588},{"_id":"themes/next-reloaded/scripts/events/lib/injects.js","hash":"8cd0203eb137eec05b28a11c6aa57e150fc3fa68","modified":1573650247589},{"_id":"themes/next-reloaded/layout/_third-party/statistics/tencent-analytics.swig","hash":"c7b55198361ffd96b921b37ca90f6adfccf0d391","modified":1573650247580},{"_id":"themes/next-reloaded/scripts/filters/comment/changyan.js","hash":"9a3a1ad60c51926e286d92063b19ec03b60d37b7","modified":1573650247590},{"_id":"themes/next-reloaded/scripts/filters/comment/default-config.js","hash":"0c3bea89d64bc12c1bbe6f208a83773c6fb5375a","modified":1573650247591},{"_id":"themes/next-reloaded/scripts/filters/comment/common.js","hash":"31a6c8fbdfa16112b0b099727437b9df7641d421","modified":1573650247591},{"_id":"themes/next-reloaded/scripts/filters/comment/disqus.js","hash":"2f5d1cdc9e1c3498c3d59da01bd89e3e45cd95d3","modified":1573650247591},{"_id":"themes/next-reloaded/layout/_third-party/statistics/firestore.swig","hash":"edeb02d4d56c11536eaed5a8b4705b717f357895","modified":1573650247579},{"_id":"themes/next-reloaded/scripts/filters/comment/disqusjs.js","hash":"f53cf433714bfef152d5e5463c748216c196e460","modified":1573650247592},{"_id":"themes/next-reloaded/scripts/filters/comment/gitalk.js","hash":"323a47df6ded894944a2647db44556d6163e67c4","modified":1573650247592},{"_id":"themes/next-reloaded/scripts/filters/comment/livere.js","hash":"76b2dc98b63180c2e082727fc71c4f576b3ff43d","modified":1573650247593},{"_id":"themes/next-reloaded/scripts/filters/comment/valine.js","hash":"5b7ecbaf1ea67aed4df38ba69a7bf5e67ec843c2","modified":1573650247593},{"_id":"themes/next-reloaded/layout/_third-party/statistics/lean-analytics.swig","hash":"6c007dd76f1cb8171681d7437ec1498ca1229466","modified":1573650247580},{"_id":"themes/next-reloaded/layout/_third-party/tags/pdf.swig","hash":"42e7beed8c7583e0c0612692eebfa5743cc4d006","modified":1573650247582},{"_id":"themes/next-reloaded/source/css/_mixins/Pisces.styl","hash":"1619130f81e091bb9ac43f93814f594dd1739255","modified":1573650247644},{"_id":"themes/next-reloaded/layout/_third-party/tags/mermaid.swig","hash":"db17f093ecf23e960a32af661c6b9a0651281a6b","modified":1573650247582},{"_id":"themes/next-reloaded/source/css/_mixins/Gemini.styl","hash":"b58ed9dabc5be0090647d9a0afc43359e1e0e14c","modified":1573650247643},{"_id":"themes/next-reloaded/source/css/_mixins/base.styl","hash":"a0e0628fc958dfe794e2c073301f7c2ba00e20f1","modified":1573650247645},{"_id":"themes/next-reloaded/source/css/_variables/Mist.styl","hash":"5832f04fab4e4224bca6dc31a3d94da034a20861","modified":1573650247656},{"_id":"themes/next-reloaded/source/css/_variables/Gemini.styl","hash":"f6517f04ee9c8d93d1667c5617116f03ce1942a2","modified":1573650247656},{"_id":"themes/next-reloaded/source/css/_variables/Muse.styl","hash":"1ff4303ad83f96b152be571d4df07969199d5930","modified":1573650247657},{"_id":"themes/next-reloaded/source/js/schemes/muse.js","hash":"a8aea6d062c2859b503ea1bb8b7c9ce364ed9100","modified":1573650247671},{"_id":"themes/next-reloaded/source/js/schemes/pisces.js","hash":"8138e7d3e98a59a8a23daa98deac4c0024838b09","modified":1573650247671},{"_id":"themes/next-reloaded/source/lib/font-awesome/.gitignore","hash":"03ddbf76c1dd1afb93eed0b670d2eee747472ef1","modified":1573650247674},{"_id":"themes/next-reloaded/source/lib/canvas-nest/README.md","hash":"6cb4993cbe75298f9b6a8738cb210f06489df840","modified":1573719520818},{"_id":"themes/next-reloaded/source/lib/font-awesome/.bower.json","hash":"b4aefc910578d76b267e86dfffdd5121c8db9aec","modified":1573650247674},{"_id":"themes/next-reloaded/source/lib/canvas-nest/LICENSE","hash":"336611e76f0638d3d8aeca6b1b97138d2a07523f","modified":1573719520817},{"_id":"themes/next-reloaded/source/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1573650247675},{"_id":"themes/next-reloaded/source/lib/canvas-nest/canvas-nest-nomobile.min.js","hash":"6b4437a9cd8aa04329cc6220a595acfe1fb9b598","modified":1573719520819},{"_id":"themes/next-reloaded/source/lib/font-awesome/bower.json","hash":"71e7183634dc1b9449f590f15ebd7201add22ca7","modified":1573650247676},{"_id":"themes/next-reloaded/source/css/_variables/Pisces.styl","hash":"0bccf86c88e4d27b41f75bf166e66480c7bf919c","modified":1573650247658},{"_id":"themes/next-reloaded/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1573719520820},{"_id":"themes/next-reloaded/source/lib/canvas-nest - 副本/LICENSE","hash":"336611e76f0638d3d8aeca6b1b97138d2a07523f","modified":1573719520817},{"_id":"themes/next-reloaded/source/lib/canvas-nest - 副本/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1573719520820},{"_id":"themes/next-reloaded/source/lib/canvas-nest - 副本/canvas-nest-nomobile.min.js","hash":"6b4437a9cd8aa04329cc6220a595acfe1fb9b598","modified":1573719520819},{"_id":"themes/next-reloaded/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1573650247683},{"_id":"themes/next-reloaded/source/lib/canvas-nest - 副本/README.md","hash":"6cb4993cbe75298f9b6a8738cb210f06489df840","modified":1573719520818},{"_id":"themes/next-reloaded/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1573650247684},{"_id":"themes/next-reloaded/source/lib/font-awesome/.npmignore","hash":"c31ff06a740955e44edd4403902e653ccabfd4db","modified":1573650247675},{"_id":"themes/next-reloaded/source/css/_variables/base.styl","hash":"fc48141e45c9c1275013cdd5d552e4867ae92810","modified":1573650247658},{"_id":"themes/next-reloaded/source/css/_common/components/back-to-top.styl","hash":"bf86c81c57db3ed8fbb67df44fc2c0a79cd6ffd6","modified":1573650247605},{"_id":"themes/next-reloaded/source/css/_common/components/rainbow.styl","hash":"fbcffb91e7f1ca3cde988353e36e4bf75770a8e8","modified":1573650247615},{"_id":"themes/next-reloaded/source/css/_common/components/components.styl","hash":"daf188e77bd9d9fcff74c5659e875ebdd2010f08","modified":1573650247606},{"_id":"themes/next-reloaded/source/css/_common/components/back-to-top-sidebar.styl","hash":"672866ede12bc2dd0835858f2697703fbc9dacb2","modified":1573650247605},{"_id":"themes/next-reloaded/source/css/_common/components/reading-progress.styl","hash":"4052c6c598a9dc443ffac171cc6cb31e981c5e5d","modified":1573650247615},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/buttons.styl","hash":"5c27faaaf5a201d1c41c08ad5bfe1757a894fd69","modified":1573650247632},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/base.styl","hash":"1efa25a0efc072a65735c3c7d19267ce958afbbe","modified":1573650247632},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/comments.styl","hash":"5772ee6cdc50a9e1a4425d79114d46065babe217","modified":1573650247633},{"_id":"themes/next-reloaded/source/css/_schemes/Gemini/index.styl","hash":"404ecb2e51eb85020eee2405372cc4c4946106ad","modified":1573650247645},{"_id":"themes/next-reloaded/source/css/_common/outline/mobile.styl","hash":"78406dfb644b0e516f697aead3ed5d545c5b8144","modified":1573650247625},{"_id":"themes/next-reloaded/source/css/_common/outline/outline.styl","hash":"ca1da6314c123f1bf0a95feefb073f08bb8c256a","modified":1573650247625},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/normalize.styl","hash":"6d740699fb6a7640647a8fd77c4ea4992d8d6437","modified":1573650247635},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/scaffolding.styl","hash":"43045d115f8fe95732c446aa45bf1c97609ff2a5","modified":1573650247637},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/toggles.styl","hash":"20e0e3e3eba384930c022e21511214d244b4c9e7","modified":1573650247642},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/pagination.styl","hash":"b619f39e18398422e0ac4999d8f042a5eaebe9cd","modified":1573650247636},{"_id":"themes/next-reloaded/source/css/_schemes/Muse/_header.styl","hash":"9a7d7502ce394ddeba1773f90bbe19016b0cf0f6","modified":1573650247649},{"_id":"themes/next-reloaded/source/css/_schemes/Muse/_menu.styl","hash":"3923dccd95e404c6c8d4578306551d40f230c62d","modified":1573650247650},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/tables.styl","hash":"77015610da04ec0214d14e65effd0d87f3ff9dec","modified":1573650247638},{"_id":"themes/next-reloaded/source/css/_schemes/Muse/_layout.styl","hash":"49c76bc723d3952abb613d9d68398ed7305da999","modified":1573650247649},{"_id":"themes/next-reloaded/source/css/_schemes/Muse/_sidebar.styl","hash":"4dc216cb9f1c12bf7720012fd24e126ef6a4eca7","modified":1573650247650},{"_id":"themes/next-reloaded/source/css/_schemes/Pisces/_header.styl","hash":"55a1e7deda42cb3318d1e19b904c9c91891659f3","modified":1573650247652},{"_id":"themes/next-reloaded/source/css/_schemes/Muse/index.styl","hash":"25c2a7930da14f023329df20f38df2728057fb4d","modified":1573650247651},{"_id":"themes/next-reloaded/source/css/_schemes/Muse/_sub-menu.styl","hash":"2d3e05015796a790abd9d68957a5c698c0c9f9b6","modified":1573650247650},{"_id":"themes/next-reloaded/source/css/_schemes/Pisces/_layout.styl","hash":"d7a59c099ba678e13e55163b6675776c7266aebe","modified":1573650247652},{"_id":"themes/next-reloaded/source/css/_schemes/Pisces/_menu.styl","hash":"0f4f40e93a0127feadb0bedbe3f8e069a288fae0","modified":1573650247653},{"_id":"themes/next-reloaded/source/css/_schemes/Pisces/index.styl","hash":"25c2a7930da14f023329df20f38df2728057fb4d","modified":1573650247655},{"_id":"themes/next-reloaded/source/css/_schemes/Pisces/_sub-menu.styl","hash":"111766f2494ae2b7d6f432c9eb3bda4793e47f9a","modified":1573650247654},{"_id":"themes/next-reloaded/source/css/_schemes/Pisces/_sidebar.styl","hash":"1ae5f3b48300457940102f2201fba7b8547ace4b","modified":1573650247654},{"_id":"themes/next-reloaded/source/css/_schemes/Mist/_header.styl","hash":"f03bde9f5804b14f6b297e22a4f0de9a25b38914","modified":1573650247646},{"_id":"themes/next-reloaded/source/css/_schemes/Mist/_layout.styl","hash":"5ae9f601b4c85afe33c5fe338b371b507d6f351c","modified":1573650247646},{"_id":"themes/next-reloaded/source/css/_schemes/Mist/index.styl","hash":"c5142739e01e9f25c8b32b2209af85c787bb2b42","modified":1573650247648},{"_id":"themes/next-reloaded/source/css/_schemes/Mist/_menu.styl","hash":"68f4854a327a51c2092c6d605ed195dfaf413823","modified":1573650247647},{"_id":"themes/next-reloaded/source/css/_schemes/Mist/_posts-expand.styl","hash":"7199707befa5469f2a3fb18ca49c2e0ff2c62ee0","modified":1573650247647},{"_id":"themes/next-reloaded/source/lib/canvas-nest/.github/stale.yml","hash":"dbd5e6bf89b76ad1f2b081578b239c7ae32755af","modified":1573719520817},{"_id":"themes/next-reloaded/source/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1573650247677},{"_id":"themes/next-reloaded/source/lib/font-awesome/css/font-awesome.css","hash":"3655f1fdf1e584c4d8e8d39026093ca306a5a341","modified":1573650247677},{"_id":"themes/next-reloaded/source/lib/font-awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1573650247678},{"_id":"themes/next-reloaded/source/lib/canvas-nest - 副本/.github/stale.yml","hash":"dbd5e6bf89b76ad1f2b081578b239c7ae32755af","modified":1573719520817},{"_id":"themes/next-reloaded/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1573650247681},{"_id":"themes/next-reloaded/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1573650247682},{"_id":"themes/next-reloaded/source/css/_common/components/pages/pages.styl","hash":"6cf78a379bb656cc0abb4ab80fcae60152ce41ad","modified":1573650247608},{"_id":"themes/next-reloaded/source/css/_common/components/pages/categories.styl","hash":"18edddb2ffb3f85a68e4367f81e06c461e07bc25","modified":1573650247607},{"_id":"themes/next-reloaded/source/css/_common/components/pages/breadcrumb.styl","hash":"236a039b0900f4267de566b46f62314ad967d30f","modified":1573650247607},{"_id":"themes/next-reloaded/source/css/_common/components/pages/tag-cloud.styl","hash":"a22c639cdf1073c9d060af62233125991ddf4dd5","modified":1573650247609},{"_id":"themes/next-reloaded/source/css/_common/components/pages/schedule.styl","hash":"686c780e6a483a2e494d9aab682803666ef63b3b","modified":1573650247608},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-eof.styl","hash":"724ca213d15ae27158c2cddf9c26d3dba3582283","modified":1573650247610},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-copyright.styl","hash":"37701d40233a587401bcfc5ede056d8d1a8ba006","modified":1573650247610},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-collapse.styl","hash":"49bebe05a149f9fffba8d7d004a617e8a6e5e660","modified":1573650247609},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-reward.styl","hash":"f0a5b3b7f9f18d37595eafb1809312d4b7965c58","modified":1573650247613},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-expand.styl","hash":"a5ef170128ab8bc9c0336d6d8d082a97f677563e","modified":1573650247611},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-gallery.styl","hash":"616b11ef7a87751b164ad6d55923833ea475c988","modified":1573650247611},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-header.styl","hash":"4af60e5cfc8161e93b27090400ff74b8e2f84eea","modified":1573650247612},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-rtl.styl","hash":"09dda2667628d1f91b2e37d8fc6df1413f961b64","modified":1573650247613},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-nav.styl","hash":"bb1cdbe39d9948474f80d0915ac9cf9cf63fbe7f","modified":1573650247612},{"_id":"themes/next-reloaded/source/css/_common/components/post/post.styl","hash":"c5ecffcb9b22308f2049a2ff46f8f57067148ba4","modified":1573650247614},{"_id":"themes/next-reloaded/source/css/_common/components/third-party/gitalk.styl","hash":"b87f4a06c0db893df4f756f24be182e1a4751f24","modified":1573650247616},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-tags.styl","hash":"5cc9e7394c927065c688cba5edd6e0a27587f1d8","modified":1573650247613},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-widgets.styl","hash":"b266d2ce5e2b117be01537889e839a69004dc0bb","modified":1573650247614},{"_id":"themes/next-reloaded/source/css/_common/components/third-party/math.styl","hash":"6880467b4f6d7b057fb8291aa10966429a0a3bff","modified":1573650247617},{"_id":"themes/next-reloaded/source/css/_common/components/third-party/third-party.styl","hash":"1f6b0d3ab227697ca115e57fd61122ea7950e19d","modified":1573650247618},{"_id":"themes/next-reloaded/source/css/_common/components/third-party/related-posts.styl","hash":"8ed7a9d5dfac592de703421b543978095129aa5b","modified":1573650247617},{"_id":"themes/next-reloaded/source/css/_common/outline/footer/footer.styl","hash":"d38a6b55ceea75016e73908ce9e223f9147e123c","modified":1573650247619},{"_id":"themes/next-reloaded/source/css/_common/outline/header/bookmark.styl","hash":"f7977cfacaca9db6fab4d154486ad57ec4b0fde9","modified":1573650247620},{"_id":"themes/next-reloaded/source/css/_common/components/third-party/search.styl","hash":"089e9e3ec17e68a7cfec5ae065e958eb40dbf71e","modified":1573650247618},{"_id":"themes/next-reloaded/source/css/_common/outline/header/headerband.styl","hash":"6d5f26646e2914474f295de8bf6dc327d4acd529","modified":1573650247623},{"_id":"themes/next-reloaded/source/css/_common/outline/header/github-banner.styl","hash":"0bd0f4a28b3362898f4d9061b307b12bd128f6b0","modified":1573650247621},{"_id":"themes/next-reloaded/source/css/_common/outline/header/header.styl","hash":"459a39c54e4a16db287f390160fc06a829d64160","modified":1573650247622},{"_id":"themes/next-reloaded/source/css/_common/outline/header/site-meta.styl","hash":"3e6287e2241eac9a4090b452cd270c37dc240ed2","modified":1573650247624},{"_id":"themes/next-reloaded/source/css/_common/outline/header/site-nav.styl","hash":"19677978a4b2b0712d20fee15e952a78e7ba6365","modified":1573650247624},{"_id":"themes/next-reloaded/source/css/_common/outline/header/menu.styl","hash":"de55bc28b9ecbc5fb66a177c2db735223e04e54c","modified":1573650247623},{"_id":"themes/next-reloaded/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"bfbb2b8dfceb79c5adcc31338f9cc8efdd3c1bc6","modified":1573650247627},{"_id":"themes/next-reloaded/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"49722d555a2edb18094bb2cb3d7336dd72051b93","modified":1573650247626},{"_id":"themes/next-reloaded/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"400c180753d3517a7332108d83ea7f2e7acbceca","modified":1573650247628},{"_id":"themes/next-reloaded/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"12f7eaf6b56624cbc411528562d6bb848ff97039","modified":1573650247628},{"_id":"themes/next-reloaded/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"00b2055f170e54267321d27118e0a7f07d10890b","modified":1573650247628},{"_id":"themes/next-reloaded/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"098b4bdf49c7300490f959386d5d1185a32543f6","modified":1573650247630},{"_id":"themes/next-reloaded/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"7406d2b31b9d329043160191c98232e5aeebbc2c","modified":1573650247629},{"_id":"themes/next-reloaded/source/css/_common/outline/sidebar/site-state.styl","hash":"a782cd5ceee062fdfb91a9732017d19672973784","modified":1573650247631},{"_id":"themes/next-reloaded/source/css/_common/outline/sidebar/sidebar.styl","hash":"f6f6306a3975c1544688b95a139af8d9262499b4","modified":1573650247630},{"_id":"themes/next-reloaded/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"a78eb9f212f405378bd38582742581d26a57fe7f","modified":1573650247630},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/highlight/diff.styl","hash":"83bd737f663a8461e66985af8ddbfc0a731fc939","modified":1573650247634},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/highlight/theme.styl","hash":"c911045b2ce9a66e38d9dd30c7ed078abbc10cbf","modified":1573650247635},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"0bf030b71cc75d7d2c0517c9f2ed61d1dba7722d","modified":1573650247633},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/highlight/highlight.styl","hash":"d7a4bb39b50be363afaf143be05e8bc1f409c86e","modified":1573650247634},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"8c318a485c56dbdcdb22fd00781484ecc151bf8a","modified":1573650247639},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"4727e2721029acc7f70ea6a0f2775d6aa289edaf","modified":1573650247639},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/tags/label.styl","hash":"77d4f332cf805aa7d294346c99e2d72afe2e82a4","modified":1573650247640},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/tags/tabs.styl","hash":"1bb94cf2d8d3dbb4e2cb1d617df0137046fe90fc","modified":1573650247641},{"_id":"themes/next-reloaded/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1573650247680},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/tags/pdf.styl","hash":"c9337e837f10c5f40c27a0c0a012f39dfadc7572","modified":1573650247641},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/tags/tags.styl","hash":"51d46fa3c7c6b691c61a2c2b0ac005c97cfbf72b","modified":1573650247642},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/tags/note.styl","hash":"4ef9d8d3e4a00d622f0dd22418a0848eed9dcc17","modified":1573650247640},{"_id":"public/baidusitemap.xml","hash":"d9611f6243d73a27965d8aabf190dd3bf785001a","modified":1581395469347},{"_id":"public/search.xml","hash":"2ebf71e63fd9ec7db41d1ae80140d4eb335705b0","modified":1581395469387},{"_id":"public/sitemap.xml","hash":"5449c2e896ae67f654b10b6fc1c4425644787aa5","modified":1581395469387},{"_id":"public/leancloud_counter_security_urls.json","hash":"7ed641ba56196648b1a65d136b9ba331d104255f","modified":1581395469388},{"_id":"public/google33ea6e69d32e20f7.html","hash":"f008e309f2197d39b64a9a95adbd8bd44f599003","modified":1581395469407},{"_id":"public/tags/index.html","hash":"2972b5463dbc51cedca68e7629a753a1a4e2bf06","modified":1581395469407},{"_id":"public/2020-02-05-c++拾遗.html","hash":"d902acaea8ace9f1bc5292bfd192e82ae2339f49","modified":1581395469407},{"_id":"public/2020-02-07-leetcode-300-Longest-Increasing-Subsequence.html","hash":"f35fb0ffb80f2b628d8c99961e9384620573b62b","modified":1581395469407},{"_id":"public/categories/index.html","hash":"b28b34be5ee70ba573612dfe4228990e67588499","modified":1581395469407},{"_id":"public/2020-01-29-leetcode-53-Maximum-Subarray.html","hash":"218fef6252ba7467596907947442508773908873","modified":1581395469408},{"_id":"public/2020-01-06-leetcode-543-Diameter-of-Binary-Tree.html","hash":"98dd906103b37611f0f0d7f8806be477e32f43f5","modified":1581395469408},{"_id":"public/2019-12-20-LSTM与Prophet时间序列预测实验.html","hash":"6e2063a049bdb72dcc2f28a38e34b1e9f26efe70","modified":1581395469408},{"_id":"public/2019-12-08-线性判别函数.html","hash":"d15defb125fd4aaa9dd8ac1dc8cec1c4a6bd41bb","modified":1581395469408},{"_id":"public/2019-12-28-特征选择和特征提取.html","hash":"9154847517e7a1ddf8675ebac59b8bf4f0fd5c3e","modified":1581395469408},{"_id":"public/2019-12-27-奇思妙想.html","hash":"c4cce940077f843f20ddadb4089c3d15247c14bc","modified":1581395469408},{"_id":"public/2019-11-29-leetcode-881-Boats-to-Save-People.html","hash":"42252b4d4b9a69fd539d78d7f2bf963b5de99a8b","modified":1581395469408},{"_id":"public/2019-11-22-leetcode153-154-Find-Minimum-in-Rotated-Sorted-Array-III.html","hash":"e1a4a8ff857a34154b5b9aab239d11f5e6664df8","modified":1581395469408},{"_id":"public/2019-11-19-推荐系统.html","hash":"36e994696a9fd3a41489a87b474102449914ffc4","modified":1581395469408},{"_id":"public/2019-11-19-聚类方法.html","hash":"edaa4e7f68fdfa24c1bef07e1899f775d602bbb2","modified":1581395469411},{"_id":"public/2019-11-18-关联规则.html","hash":"270ca55cc9678a1a9e482053fa9d12027eca9db5","modified":1581395469411},{"_id":"public/2019-11-17-分类与预测.html","hash":"4832d763c9f31a5db68fc91f078c3cfa63db5098","modified":1581395469411},{"_id":"public/2019-11-07-Clementine教程.html","hash":"cc78c9c98515f5b6c11def8a31ab567cfbe4b98f","modified":1581395469411},{"_id":"public/2019-11-16-数据预处理.html","hash":"15e3b9f1755957db2120bae02792beb97232fa57","modified":1581395469411},{"_id":"public/2019-11-15-数据仓库.html","hash":"c6c5eea92f338bdf9ba0f86dd011b4cf65c39f06","modified":1581395469411},{"_id":"public/2019-10-31-内嵌汇编.html","hash":"a735e2f80a7081a11c52d047558c5fe9dbcc667d","modified":1581395469411},{"_id":"public/2019-10-14-数组中的主要元素.html","hash":"4aa6842ed63eb253ff94bbe1225e2330387f4599","modified":1581395469411},{"_id":"public/2019-09-08-OJ输入输出.html","hash":"1c69cca8f7bc5ef56b5730d6eedfbc935f442391","modified":1581395469411},{"_id":"public/2019-10-07-逆序对的计数.html","hash":"9a0064e3d53ea2d42fc10b68f7ff654ba48db3a7","modified":1581395469411},{"_id":"public/2019-09-19-数组中的第K大的数.html","hash":"ef6ee23466353cdcca7f54784dda3de964cd24cc","modified":1581395469411},{"_id":"public/2019-09-08-实模式寻址方式.html","hash":"396385933ea2b3e07e7a9d6c448b970cab1bd7ab","modified":1581395469411},{"_id":"public/2019-08-24-shadowsocks的部署.html","hash":"023ee7ac4d7bdd5c7badd4b722245bb92e826f5a","modified":1581395469411},{"_id":"public/2019-04-26-Redis-Makefile注解.html","hash":"c4b36c937f5ae8cfd3c3a1c280f6062af885e62d","modified":1581395469411},{"_id":"public/2019-04-25-GCC的编译选项.html","hash":"3eefd4f904e8661d40aa9f2dbb388fab7b49b853","modified":1581395469412},{"_id":"public/2019-04-17-青蛙跳台阶问题.html","hash":"8ee2e1a35cd87bd0d169d484d8af306f338b9384","modified":1581395469412},{"_id":"public/2019-04-10-Linux-shell脚本计算运行时间.html","hash":"6ee87bb22d318f6521168755e70e7e7cee484d96","modified":1581395469412},{"_id":"public/2019-04-03-gdb-调试.html","hash":"f99aa635f136df91ab57891d99e98850796d712a","modified":1581395469412},{"_id":"public/2019-04-01-Docker-学习.html","hash":"03598879c983fcc766c5721e6ae6fe1d00737988","modified":1581395469412},{"_id":"public/2019-03-31-计算Linux系统的CPU利用率.html","hash":"eeefb32761627cd132cf5c74d4f8eb875707e7fe","modified":1581395469412},{"_id":"public/2019-03-29-Redis设计与实现读书笔记——第8章-对象.html","hash":"ae35ded59ebe9db18035655e460697fc3d0538f8","modified":1581395469412},{"_id":"public/2019-03-26-使用Travis-CI自动部署博客.html","hash":"a3d07e651dabb203a1c1b5cbfd280fa4aa38cec0","modified":1581395469412},{"_id":"public/2019-03-27-剑指offer-读书笔记——第2章.html","hash":"d191f81db7e1690a1c05fe657b39c400efadc106","modified":1581395469412},{"_id":"public/2019-03-27-Redis-设计与实现读书笔记——第四章-字典.html","hash":"ad178b70f62986b31f2798f6f6b4fdb27ab648da","modified":1581395469412},{"_id":"public/Redis源码阅读——SDS/2019-03-22-Redis源码阅读——SDS.html","hash":"60c6a8d31ab5456ee9e4686ac610a00fb6b03d80","modified":1581395469412},{"_id":"public/2019-03-20-Redis设计与实现读书笔记.html","hash":"225847695b1aeea2aa10e67a94f1664694ee0576","modified":1581395469412},{"_id":"public/使用shell脚本遍历redis数据库中的所有kv对.html","hash":"8dffe2a04617f6211d6007b5de4a235b000edfe3","modified":1581395469412},{"_id":"public/ping 问题.html","hash":"21928ccc57df757967231620240d7bf766063dc1","modified":1581395469412},{"_id":"public/使用YCSB 评测redis性能.html","hash":"4d6f6fc1a60cf35669b22c205fd65d5d96c2c530","modified":1581395469412},{"_id":"public/apt-get install 失败.html","hash":"fd155ac236eba040f80b98286671b25eda7d4ffa","modified":1581395469412},{"_id":"public/BigdataBench-deploy.html","hash":"3e35c8a88490ce823cd32e21774cbf081a17e043","modified":1581395469412},{"_id":"public/tee命令解析.html","hash":"8072052a503331fda3f14c078a462688459b8bae","modified":1581395469412},{"_id":"public/Linux 命令 学习.html","hash":"1ab96ba31ab4cf7c3a9fb9a10d2e5cc3982accb6","modified":1581395469413},{"_id":"public/make学习.html","hash":"90bf3f62442c1868000584cb2e216982fe6ff81c","modified":1581395469413},{"_id":"public/图计算常用算法.html","hash":"a879ad92e2d7c475c9adb4cd1ef21064caf9917e","modified":1581395469413},{"_id":"public/ceph部署文档.html","hash":"4d95876ca6aae68df6e8eca446dd6e39f7e9729e","modified":1581395469413},{"_id":"public/archives/index.html","hash":"8833d0076b76d858477f8085d3929045241787fe","modified":1581395469413},{"_id":"public/archives/page/2/index.html","hash":"8b051ef24a410c3e30457e132cef8508cefc4975","modified":1581395469413},{"_id":"public/archives/page/3/index.html","hash":"501a951d24d198ebb5d8a472e7ce30729046daeb","modified":1581395469413},{"_id":"public/archives/page/4/index.html","hash":"d80ee89b2daa8e4b1d78510d254773ef2dc49a18","modified":1581395469413},{"_id":"public/archives/page/5/index.html","hash":"6683413bc725ecfc192b38d3d3b68e826b211466","modified":1581395469413},{"_id":"public/archives/2018/index.html","hash":"f504ce3624650519c3d69eaa4d275e5156e2fbd8","modified":1581395469413},{"_id":"public/archives/2018/04/index.html","hash":"18c762afd09dfee43d88883a7a59075535558a05","modified":1581395469413},{"_id":"public/archives/2018/06/index.html","hash":"8f13181c47470f7646adacabbc73369346a0ae86","modified":1581395469413},{"_id":"public/archives/2018/07/index.html","hash":"c86b0a6d0ed922eecbeaaeff6515d131a70e08f4","modified":1581395469413},{"_id":"public/archives/2018/10/index.html","hash":"fca1eaebf6216cf4c93ec1ae33d7161f48c9e276","modified":1581395469413},{"_id":"public/archives/2019/index.html","hash":"71d645f065bd647314b48000b953ee11c64d5c12","modified":1581395469413},{"_id":"public/archives/2019/page/2/index.html","hash":"528ac9c666be506ad7a8162cf42c35006684fdea","modified":1581395469413},{"_id":"public/archives/2019/page/4/index.html","hash":"a0a3c681f3dc0763cbd3976d37b206db1fd92289","modified":1581395469413},{"_id":"public/archives/2019/page/3/index.html","hash":"1e637c1f8f0a692e6f0175e55376b3f2e60ebb8c","modified":1581395469413},{"_id":"public/archives/2019/04/index.html","hash":"16cd484f077f2ab5519a70a16e9490239ab18593","modified":1581395469413},{"_id":"public/archives/2019/03/page/2/index.html","hash":"560390eb2ceb88f667c31458015ef503525bdbe0","modified":1581395469414},{"_id":"public/archives/2019/03/index.html","hash":"7431b15ede2ae35950c06042ab6fdc47b2e8ed3f","modified":1581395469414},{"_id":"public/archives/2019/08/index.html","hash":"69e86ed149e07a194549c5c71b232ddca92fcecf","modified":1581395469414},{"_id":"public/archives/2019/09/index.html","hash":"50d1bc802458f9abac174f5c668fea56042199da","modified":1581395469414},{"_id":"public/archives/2019/10/index.html","hash":"6fbaa0b7a78b3713018dad358cd3ce77e34e810e","modified":1581395469414},{"_id":"public/archives/2019/11/index.html","hash":"5360e70cc228d1fbfa59c2ded45ae0141ece3ee7","modified":1581395469414},{"_id":"public/archives/2019/12/index.html","hash":"7fe4c10f1ec10fc345f11a231781f587e2d7bcce","modified":1581395469414},{"_id":"public/archives/2020/index.html","hash":"82b8182e7348ad6d4e60a1c9cd0b986977d35226","modified":1581395469414},{"_id":"public/archives/2020/01/index.html","hash":"9914ea35527830eb200f29ec53cf76fc61485dde","modified":1581395469414},{"_id":"public/archives/2020/02/index.html","hash":"1b9a825846a68519ee03e331ed561d114a61f754","modified":1581395469414},{"_id":"public/index.html","hash":"c98daac9659317120790bba10d018bf719cfbd6f","modified":1581395469414},{"_id":"public/page/2/index.html","hash":"432d36cd2cb670ae24c736c64f4b4c5818b0d6cf","modified":1581395469414},{"_id":"public/page/3/index.html","hash":"db5c399e25b08d29502371b74cc2f62202ccf964","modified":1581395469414},{"_id":"public/page/4/index.html","hash":"8bc5da025b70107294d271cf77782144d81aceda","modified":1581395469414},{"_id":"public/categories/读书笔记/index.html","hash":"c6fdd7fa5a3d58830339e53a5aaeb75ce5f131d5","modified":1581395469414},{"_id":"public/page/5/index.html","hash":"629518a289ecc203c35beb7bcb8dc19d219006b3","modified":1581395469414},{"_id":"public/categories/Hexo/index.html","hash":"359ccf74bd32d5642851c475d3fcf520bde9f867","modified":1581395469414},{"_id":"public/categories/Linux/index.html","hash":"87e6a9cd947bb0d9ef7d7a257f3293ace3b5d6e8","modified":1581395469414},{"_id":"public/categories/题解/index.html","hash":"d86cba64c8d80ffcd7fbf436844d85493563d5b6","modified":1581395469414},{"_id":"public/categories/源码阅读/index.html","hash":"57d70560690cb504128b9dd41f64c818078e24ef","modified":1581395469415},{"_id":"public/categories/deploy/index.html","hash":"453b81c00cfc5e5c4a464bad56abb9240681f604","modified":1581395469415},{"_id":"public/categories/数据挖掘/index.html","hash":"363d36add458025c3ce2dbb8ed3c64bed700bc6f","modified":1581395469415},{"_id":"public/categories/计算机基础/index.html","hash":"d416c143aa2d084f4172afce5131ea5c477788ec","modified":1581395469415},{"_id":"public/categories/其他/index.html","hash":"a36ba47a93a84d00c81f7a5ec6ff6379da919c14","modified":1581395469415},{"_id":"public/categories/编程语言/index.html","hash":"416031e278ed6e1d35f174a132fcc6106f2c8f77","modified":1581395469415},{"_id":"public/categories/深度学习/index.html","hash":"ec47e59b28eda063b689bae8ab565f2c930e80c3","modified":1581395469415},{"_id":"public/categories/algorithm/index.html","hash":"cae392b2df18ac30183e9a75b613858e0c9cd24e","modified":1581395469415},{"_id":"public/categories/机器学习/index.html","hash":"784dc34d29690a0c77949593abb1fa1eadda8f2d","modified":1581395469415},{"_id":"public/tags/源码阅读/index.html","hash":"26db6e9a4e752156e519059ed63e1ef71a8f2630","modified":1581395469415},{"_id":"public/tags/redis/index.html","hash":"00c59281c3f85aa0510457b68795a133c04439ad","modified":1581395469415},{"_id":"public/tags/Hexo/index.html","hash":"d63c7be9b64921ae532b70300316d104a713c5d3","modified":1581395469415},{"_id":"public/tags/Travis-CI/index.html","hash":"c89211b47a6cb982e065c7b94ba16d7d8a086880","modified":1581395469415},{"_id":"public/tags/docker/index.html","hash":"0cb3afd7e19bd7bd1b06de539c0a584d5210144e","modified":1581395469415},{"_id":"public/tags/dict/index.html","hash":"82f7f5075046fac94273f7a433330b7b57d7360a","modified":1581395469415},{"_id":"public/tags/容器/index.html","hash":"f9e302ca2ca738df92224fb41086cd23480b9ebb","modified":1581395469415},{"_id":"public/tags/工具/index.html","hash":"2e2f9a48a5ec8b1d67bb1df0184bfbd47bfa42ef","modified":1581395469415},{"_id":"public/tags/object/index.html","hash":"d5d69f24b2a61ec50d4243719eacf04789b7f116","modified":1581395469415},{"_id":"public/tags/gdb/index.html","hash":"45d574e87f1825cb9c0edc299410fa93e5432999","modified":1581395469415},{"_id":"public/tags/Linux/index.html","hash":"6343b932ae65314f1a211695734f42aeecc0e189","modified":1581395469415},{"_id":"public/tags/coding/index.html","hash":"cbb76e2de5c5db12d5ecc57ce302edd1c50b6366","modified":1581395469415},{"_id":"public/tags/shell/index.html","hash":"3edd4515cfa5ccc0a3c7da309c82e68578f33a82","modified":1581395469416},{"_id":"public/tags/c/index.html","hash":"540b250f907de0ea438af1b0819aa2b819f11f6a","modified":1581395469416},{"_id":"public/tags/牛客/index.html","hash":"15b087b4d0d2784b4ee907bf827aea7e9e982216","modified":1581395469416},{"_id":"public/tags/斐波拉契数列/index.html","hash":"3fb7de49afa5cc433ce63caa5345477e7c1d06ef","modified":1581395469416},{"_id":"public/tags/快排/index.html","hash":"fcfc4481e9673ed18423e251ec9b9e92b2a6a8d3","modified":1581395469416},{"_id":"public/tags/剑指offer/index.html","hash":"1bd8c80d8104bcb876db5d1e2240dc1ff96486c4","modified":1581395469416},{"_id":"public/tags/Makefile/index.html","hash":"59dc050074334575d2df2dd3fa24d65b504649d6","modified":1581395469416},{"_id":"public/tags/leetcode/index.html","hash":"ead0e46e1244a57c0620365cd78a2c6be2701b2d","modified":1581395469416},{"_id":"public/tags/gcc/index.html","hash":"205cade7be91c0f12f3c883b415ab46417c2a786","modified":1581395469416},{"_id":"public/tags/make/index.html","hash":"4d8dbc6235fcfa60632f58e15e0061ef2423743b","modified":1581395469416},{"_id":"public/tags/shadowsocks/index.html","hash":"d829a45886f0c3b01d13240f272fe1afba0f009c","modified":1581395469416},{"_id":"public/tags/ipv6/index.html","hash":"f4e73dbc2c277f46aa9dca6e062715f0b0238eff","modified":1581395469416},{"_id":"public/tags/分治/index.html","hash":"46de98379965082b1b515815a2f8a96ebb8355e3","modified":1581395469416},{"_id":"public/tags/哈希/index.html","hash":"fa4edf12f4376ddab08f5639d30e02eef4ccc35f","modified":1581395469416},{"_id":"public/tags/翻墙/index.html","hash":"030fb3048e522d9f068aa1546cd5c22a74ccd5a3","modified":1581395469416},{"_id":"public/tags/摩尔投票/index.html","hash":"b82d99e190b71d06ff3262f9972ddc2d8ea316ba","modified":1581395469416},{"_id":"public/tags/OJ/index.html","hash":"f682172b92090606d78391f9ef5a658debcc9c1c","modified":1581395469416},{"_id":"public/tags/编程/index.html","hash":"7fd8dae15764bd2534c66dafff92b2c09878882a","modified":1581395469416},{"_id":"public/tags/内存寻址/index.html","hash":"cf4d27a258e0a5b9dfb228758963334487bc818e","modified":1581395469416},{"_id":"public/tags/寄存器/index.html","hash":"8c63def9efffeb20a9514d0a55d8144a24c7a67e","modified":1581395469416},{"_id":"public/tags/归并排序/index.html","hash":"788d50e3c35bbd8ceaeec5e827180dbeca8dc589","modified":1581395469416},{"_id":"public/tags/BIOS/index.html","hash":"d1f404434e79bd4f834b4d6270fdfc8a58f23d71","modified":1581395469417},{"_id":"public/tags/Clementine/index.html","hash":"d20e9a1153399dc3fe815bc076d6941e7ebdf8cc","modified":1581395469417},{"_id":"public/tags/数据仓库/index.html","hash":"a777dc398b087e439a642e8968cc4e1891ce8b2f","modified":1581395469417},{"_id":"public/tags/课程/index.html","hash":"2af37fa372299b34047c5869b4edbfe9a1ad362b","modified":1581395469417},{"_id":"public/tags/OLAPS/index.html","hash":"5dab76536e57b1ba5c9ceffd75125c761bae8d37","modified":1581395469417},{"_id":"public/tags/分类/index.html","hash":"50d3ca159e55a938fe0ccaa076722dd8a9240b5f","modified":1581395469417},{"_id":"public/tags/国科大/index.html","hash":"63a2c912efa9a61be8b3d0d4cae4c3b2718567fe","modified":1581395469417},{"_id":"public/tags/贝叶斯/index.html","hash":"1972ef0d983abac3eb7c92f8dcc3f86c592bc057","modified":1581395469417},{"_id":"public/tags/神经网络/index.html","hash":"cfeb48add7c58b42c67b8bba4eb759f4523669f1","modified":1581395469417},{"_id":"public/tags/决策树/index.html","hash":"fe6736d6062e497e7cd2d69ae22fe3b0d40f9464","modified":1581395469417},{"_id":"public/tags/C语言/index.html","hash":"3e5153a43c0453635542979dcef27072b90a6392","modified":1581395469417},{"_id":"public/tags/汇编/index.html","hash":"28555fb1079d147ef987f8396aed9d671eacde3b","modified":1581395469417},{"_id":"public/tags/相关性分析/index.html","hash":"459bd61aea8555a589e26b3311b2611a7255855a","modified":1581395469417},{"_id":"public/tags/降维/index.html","hash":"e8515fe27e6cd994d96ce9d579dad4471fcffbd5","modified":1581395469417},{"_id":"public/tags/聚类/index.html","hash":"214a8c930a179ae217e4564c8e0b91c488631a3b","modified":1581395469417},{"_id":"public/tags/K-Means/index.html","hash":"544058ca80c707efc2473a34fcd55b13cbbc7a2e","modified":1581395469417},{"_id":"public/tags/余弦相似度/index.html","hash":"cf2df4ab26bf726678b18ef8dd7f10475b94b5d7","modified":1581395469417},{"_id":"public/tags/推荐/index.html","hash":"08ff676f81f675d88b31293821f14d0ff118b30d","modified":1581395469417},{"_id":"public/tags/数组/index.html","hash":"ae766578d8f906ec349671fc8711824573c34db4","modified":1581395469417},{"_id":"public/tags/最小值/index.html","hash":"2fff354c8d79c843218963097be288cb4a42f18c","modified":1581395469417},{"_id":"public/tags/二分查找/index.html","hash":"46cc45c522d991b23ab25abb282062b29447df60","modified":1581395469418},{"_id":"public/tags/贪心/index.html","hash":"89df6af7c48733e64bc553388f9565c8858506c8","modified":1581395469418},{"_id":"public/tags/关联规则/index.html","hash":"1fb5acb5db366956ccfe0c0c90e94bb27e55ba1a","modified":1581395469418},{"_id":"public/tags/Apriori/index.html","hash":"c5b3695b16a210c20f3ff274d362f11f9ea59b36","modified":1581395469418},{"_id":"public/tags/FP-Growth/index.html","hash":"2364f395d080c69f04f35de386b1f22aaeefbf11","modified":1581395469418},{"_id":"public/tags/数学/index.html","hash":"debff95dddf8c346602e0240cfb0322b744d22b1","modified":1581395469418},{"_id":"public/tags/点子/index.html","hash":"40956f2c2da4c2c5076b7fb26607557dd94a05e5","modified":1581395469418},{"_id":"public/tags/LSTM/index.html","hash":"5729dd40a5049b9672e4f8319023b5a9f5cb29bc","modified":1581395469418},{"_id":"public/tags/时间序列/index.html","hash":"971202bd6c69f2d05282a8ae882d0c118a0a600e","modified":1581395469418},{"_id":"public/tags/Pytorch/index.html","hash":"cfbf7f54445883b2948ae75686f39dc1792a23c9","modified":1581395469418},{"_id":"public/tags/Prophet/index.html","hash":"e38d4ca5c51ec6ea760ba01f15be78770ffefa7e","modified":1581395469418},{"_id":"public/tags/模式识别/index.html","hash":"8d0b5dc3d90daeeb41ac2bb6ff97e57c3d07a0a4","modified":1581395469418},{"_id":"public/tags/特征提取/index.html","hash":"37c34e00bc47208b97fa5b687e4bd49ffd853b92","modified":1581395469418},{"_id":"public/tags/距离矩阵/index.html","hash":"64a0777b86aac932e846930012d7572314db88dd","modified":1581395469418},{"_id":"public/tags/二叉树/index.html","hash":"758b4b4e317b1ed21705d801f93abe968805161f","modified":1581395469418},{"_id":"public/tags/指针/index.html","hash":"8a0cad44ba972bb178be062cb18a83ac5c4b4314","modified":1581395469418},{"_id":"public/tags/动态规划/index.html","hash":"650344885c141edee003fdaf63d5f07e75bdcd3c","modified":1581395469418},{"_id":"public/tags/command/index.html","hash":"e1cb3c28d8d46daa5f6ca1a8d63137f60e944c99","modified":1581395469418},{"_id":"public/tags/ceph/index.html","hash":"cbd9acfcf80a704587e67e23c37eab193766ce34","modified":1581395469418},{"_id":"public/tags/bigdatabench/index.html","hash":"215fc7d9bd4a942525476005510bdf9286a292f8","modified":1581395469418},{"_id":"public/tags/运维/index.html","hash":"52cc833a1c0f42ee3bd8abee3b04b3e685d80f5c","modified":1581395469418},{"_id":"public/tags/benchmark/index.html","hash":"4140ae53aabdba406f36d90239b3a49341bebca9","modified":1581395469419},{"_id":"public/tags/网络问题/index.html","hash":"45c537c83e4f847b6caa4fa2188eb8ceedff4a8d","modified":1581395469419},{"_id":"public/tags/graph/index.html","hash":"b758c0f78d4825f4cf6aa44f8b2fc6dc06f90000","modified":1581395469424},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1581395469424},{"_id":"public/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1581395469424},{"_id":"public/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1581395469424},{"_id":"public/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1581395469424},{"_id":"public/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1581395469424},{"_id":"public/robots.txt","hash":"bbfef6d0a1bee35d06457106003c6c0e399ea6e0","modified":1581395469424},{"_id":"public/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1581395469425},{"_id":"public/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1581395469425},{"_id":"public/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1581395469425},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1581395469425},{"_id":"public/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1581395469425},{"_id":"public/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1581395469425},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1581395469425},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1581395469425},{"_id":"public/images/favicon.png","hash":"9ad0834cb90e0a8ff8ee739e51d8109aceb7cf68","modified":1581395469425},{"_id":"public/images/favicon16x16.png","hash":"a63a2e0b78898ee887f4cced3e2b9559dc0dcc3f","modified":1581395469425},{"_id":"public/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1581395469425},{"_id":"public/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1581395469425},{"_id":"public/lib/canvas-nest/LICENSE","hash":"336611e76f0638d3d8aeca6b1b97138d2a07523f","modified":1581395469425},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1581395469425},{"_id":"public/lib/canvas-nest - 副本/LICENSE","hash":"336611e76f0638d3d8aeca6b1b97138d2a07523f","modified":1581395469425},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1581395469425},{"_id":"public/BigdataBench-deploy/runcc.png","hash":"92edff3c535d6744e38fd0b933a5474d768b5ecc","modified":1581395469425},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1581395469875},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1581395469877},{"_id":"public/js/bookmark.js","hash":"c9acb262acf0cf127497b570fa9479fb32f34547","modified":1581395469885},{"_id":"public/js/algolia-search.js","hash":"813afcc30feee11d59f297f2d5a96f98fbbd4743","modified":1581395469885},{"_id":"public/js/local-search.js","hash":"fda0f761ae20577f22c1528dde7ae059368fe9a8","modified":1581395469885},{"_id":"public/js/motion.js","hash":"9ac69597315b5b7b4c8900b7949d2a31387d6284","modified":1581395469885},{"_id":"public/js/utils.js","hash":"a2984bf0631756a904cd43f8e3a8f6fb15b9ceb5","modified":1581395469885},{"_id":"public/js/next-boot.js","hash":"f7045763e277e685c271bd4b4c37e531d699ac63","modified":1581395469886},{"_id":"public/js/schemes/pisces.js","hash":"dccbb1be3938050e13277251ab5d88c736edf396","modified":1581395469886},{"_id":"public/js/schemes/muse.js","hash":"792f4522a3b0b96584a041a4aca20fcded410079","modified":1581395469886},{"_id":"public/lib/canvas-nest/README.html","hash":"3f775753e74420ec8f5d090955140de882c24678","modified":1581395469886},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1581395469886},{"_id":"public/lib/canvas-nest/canvas-nest-nomobile.min.js","hash":"956eada198babd00f028e8908767cb158926c3f3","modified":1581395469886},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1581395469886},{"_id":"public/lib/canvas-nest - 副本/canvas-nest-nomobile.min.js","hash":"956eada198babd00f028e8908767cb158926c3f3","modified":1581395469886},{"_id":"public/lib/canvas-nest - 副本/README.html","hash":"3f775753e74420ec8f5d090955140de882c24678","modified":1581395469886},{"_id":"public/lib/canvas-nest - 副本/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1581395469886},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1581395469886},{"_id":"public/css/main.css","hash":"ea0deee8bbb0c8d2baa3e0981cb551ff97c859b5","modified":1581395469886},{"_id":"public/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1581395469886},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1581395469886},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1581395469886},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1581395469886},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1581395469887}],"Category":[{"name":"读书笔记","_id":"ck6he13y10005dstz9roogsys"},{"name":"Hexo","_id":"ck6he13y6000adstz1eqld0v6"},{"name":"Linux","_id":"ck6he13ya000fdstz0f6c8qa6"},{"name":"题解","_id":"ck6he13ym0010dstze7totaot"},{"name":"源码阅读","_id":"ck6he13yt001ddstz6dddezpl"},{"name":"deploy","_id":"ck6he13yx001ndstzxg13iafz"},{"name":"计算机基础","_id":"ck6he13z1001udstzna2omqt0"},{"name":"数据挖掘","_id":"ck6he13z40021dstzror3d68c"},{"name":"编程语言","_id":"ck6he13zd002ldstzdhvm8qwl"},{"name":"其他","_id":"ck6he13zo0037dstz3jkrhtk3"},{"name":"深度学习","_id":"ck6he13zs003edstzbe7f7k6r"},{"name":"机器学习","_id":"ck6he13zv003kdstzsl5hxz3g"},{"name":"algorithm","_id":"ck6he14040042dstzjdsv2jop"}],"Data":[],"Page":[{"_content":"google-site-verification: google33ea6e69d32e20f7.html","source":"google33ea6e69d32e20f7.html","raw":"google-site-verification: google33ea6e69d32e20f7.html","date":"2019-11-26T02:12:43.142Z","updated":"2019-11-26T02:12:43.142Z","path":"google33ea6e69d32e20f7.html","title":"","comments":1,"layout":"page","_id":"ck6he13u80000dstz4yjd45u0","content":"google-site-verification: google33ea6e69d32e20f7.html","site":{"data":{}},"length":52,"excerpt":"","more":"google-site-verification: google33ea6e69d32e20f7.html"},{"title":"categories","date":"2019-03-10T12:10:41.000Z","type":"categories","_content":"\n","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2019-03-10 20:10:41\ntype: \"categories\"\n---\n\n","updated":"2019-03-26T05:30:52.809Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ck6he13xs0001dstz6fk6u8n2","content":"","site":{"data":{}},"length":0,"excerpt":"","more":""},{"title":"tags","date":"2019-03-10T12:15:52.000Z","type":"tags","_content":"\n","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2019-03-10 20:15:52\ntype: \"tags\"\n---\n\n","updated":"2019-03-26T05:30:52.810Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ck6he13xx0003dstzwun0shm2","content":"","site":{"data":{}},"length":0,"excerpt":"","more":""}],"Post":[{"title":"Redis设计与实现读书笔记——第二章SDS","date":"2019-03-20T07:20:23.000Z","copyright":true,"_content":"\n# Redis设计与实现读书笔记——第二章 \n\n为了做Redis相关实验，在网上粗略看了Redis设计与实现的电子版，感觉收获很多，但是因为是旧版，所以买了第二版，重读第二次。\n\n<!--more-->\n\n## 第二章 简单动态字符串\n\n### 简介\n\n1. 字符串值的键值对在底层都是由SDS实现的。\n2. sds的功能：\n   1. 存储字符串值\n   2. 用作缓冲区\n      1. AOF模块缓冲区\n      2. 客户端状态的输入缓冲区\n\n### 2.1 SDS的定义\n\n文件：sds.h/sdshdr 结构体 \n\n书中的为3.0版本，4.0版本有较大改动。\n\nversion: redis-4.02 \n\n参考：https://www.cnblogs.com/chenpingzhao/p/7292182.html\n\nhttps://www.codesheep.cn/2018/08/09/Redis%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E5%86%85%E9%83%A8%E7%BC%96%E7%A0%81%E5%89%96%E6%9E%90/\n\n````c\ntypedef char *sds;  //注意，sds其实不是一个结构体类型，而是被typedef的char*\n\n/* Note: sdshdr5 is never used, we just access the flags byte directly.\n * However is here to document the layout of type 5 SDS strings. */\nstruct __attribute__ ((__packed__)) sdshdr5 {\n    unsigned char flags; /* 3 lsb of type, and 5 msb of string length */\n    char buf[];\n};\nstruct __attribute__ ((__packed__)) sdshdr8 {\n    uint8_t len; /* used */\n    uint8_t alloc; /* excluding the header and null terminator */\n    unsigned char flags; /* 3 lsb of type, 5 unused bits */\n    char buf[];\n};\nstruct __attribute__ ((__packed__)) sdshdr16 {\n    uint16_t len; /* used */\n    uint16_t alloc; /* excluding the header and null terminator */\n    unsigned char flags; /* 3 lsb of type, 5 unused bits */\n    char buf[];\n};\nstruct __attribute__ ((__packed__)) sdshdr32 {\n    uint32_t len; /* used */\n    uint32_t alloc; /* excluding the header and null terminator */\n    unsigned char flags; /* 3 lsb of type, 5 unused bits */\n    char buf[];\n};\nstruct __attribute__ ((__packed__)) sdshdr64 {\n    uint64_t len; /* used */\n    uint64_t alloc; /* excluding the header and null terminator */\n    unsigned char flags; /* 3 lsb of type, 5 unused bits */\n    char buf[];\n};\n\n````\n\n除了结构体字段对len和alloc的数据类型的不同(` unit8, unit16， unit32, unit64`)，  其字段含义相差无几。其中header记录`len, alloc, flags` 信息。不同的header的目的是节省内存。**header与buf数组在内存地址上前后相邻。**\n\n```\n+--------+-------------------------------+-----------+\n| Header | Binary safe C alike string... | Null term |\n+--------+-------------------------------+-----------+\n         |\n         `-> Pointer returned to the user.\n```\n\n```\nlen: 记录buf数组中已使用的字节数量 等于保存的字符串的长度 （不算结尾的\\0 标识符）\nalloc: 字符串最大的容量。（除开header和最后的null终止符） \nflags: 总是会占用一个字节 8bit，加上unsigned是因为flags都是非负数 ，其中的最低3个bit用来表示header的类型还有 5个bit没有使用。\nbuf: 字符数组，用于保存字符串。  柔性数组\n```\n\nbuf的大小=alloc+1；\n\nheader类型定义中，注意的地方：\n\n- 在各个header的定义中使用了__attribute__ ((packed))，是为了让**编译器以紧凑模式来分配内存**，取消字节对齐。\n\n  - 结构体的成员内存是'\"连续\"的，但是这个连续是以对齐的单位而言的。比如说A成员的内存是3个字节，假设对齐单位是4个字节，会给A成员多分配一个字节。A成员后面才又紧接B成员的内存。\n  - 如果没有这个属性，编译器可能会为struct的字段做优化对齐，在其中填充空字节。那样的话，就不能保证header和sds的数据部分紧紧前后相邻，也不能按照固定向低地址方向偏移1个字节的方式来获取flags字段了。\n\n- 在各个header的定义中最后有一个char buf[]。我们注意到这是一个没有指明长度的字符数组，这是C语言中定义字符数组的一种特殊写法，称为**柔性数组**（[flexible array member](https://en.wikipedia.org/wiki/Flexible_array_member)），只能定义在一个结构体的最后一个字段上。它在这里只是起到一个标记的作用，表示在flags字段后面就是一个字符数组，或者说，它指明了紧跟在flags字段后面的这个字符数组在结构体中的偏移位置。而程序在为header分配的内存的时候，它并不占用内存空间。如果计算sizeof(struct sdshdr16)的值，那么结果是5个字节，其中没有buf字段。\n\n- sdshdr5与其它几个header结构不同，它不包含alloc字段，而长度使用flags的高5位来存储。因此，它不能为字符串分配空余空间。如果字符串需要动态增长，那么它就必然要重新分配内存才行。所以说，这种类型的sds字符串更适合存储静态的短字符串（长度小于32）。 因为长度的范围是5个bit来存储的\n  $$\n  2^5-1 = 31\n  $$\n\n\n\n\nsds字符串的header，其实隐藏在真正的字符串数据的前面（低地址方向）。这样的一个定义，有如下几个好处\n\n- header和数据相邻，而不用分成两块内存空间来单独分配。这有利于减少内存碎片，提高存储效率（memory efficiency）。\n- 虽然header有多个类型，但sds可以用统一的char *来表达。且它与传统的C语言字符串保持类型兼容。如果一个sds里面存储的是可打印字符串，那么我们可以直接把它传给C函数，比如使用strcmp比较字符串大小，或者使用printf进行打印。\n### 2.2 SDS与C字符串的区别\n\nc语言使用N+1长度的字符数组来表示长度为N的字符串，因为需要增加一个`\\0` 字符终止\n\n#### 2.2.1  常数复杂度获取字符串长度\n\n因为c语言要知道字符串的长度只能遍历数组，所以复杂度为O(N)。 \n\n而获取sds的字符串长度，只需要返回len的值就可以了复杂度为O(1)。这样对一个非常长的字符串键反复执行STRLEN命令，也不会对系统性能造成任何影响。\n\n#### 2.2.2 杜绝缓冲区溢出\n\nC字符串不记录自身长度会带来易造成缓冲区溢出的问题。 比如使用strcat函数拼接两个字符串，被拼接的字符串要是没有提前分配空间，就会造成缓冲区溢出。（溢出的字节会导致这个字符串内存紧邻的其他字符串的内容被修改）\n\n而SDS的空间分配策略完全杜绝了发生缓冲区溢出的可能，SDS的API需要修改SDS时，会先检查空间alloc是否满足修改所需的要求。不满足的话会先将空间扩展至修改所需的大小，再执行修改。\n\n#### 2.2.3 减少修改字符串时带来的内存重分配次数\n\nC语言字符串用N+1个字节长的数组来保存N个字节的字符串，因为这个关联性所以每次每次增长或者缩短一个C字符串，都要对这个字符串进行一次内存重分配操作。\n\n- 执行增长操作 比如append，需要首先通过内存重分配来扩展底层数组的空间大小，否则产生缓冲区溢出\n- 执行所动操作比如截断操作trime，需要首先通过内存重分配来释放字符串不再使用的空间，否则造成内存泄漏。\n\n内存重分配涉及复杂的算法，并且可能需要执行系统调用，所以通常是一个比较耗时的操作。这对Redis经常用于速度要求严苛，数据被频繁修改的场合来说，是不可接受的。\n\n因此SDS通过未使用空间解除了字符串长度和底层数组长度之间的关联：buf的长度可以大于len的长度。 **（4.0版本的源码还未找到对应的函数，所以可能和书上说的有变化了）**\n\n1. 空间预分配 ——减少连续执行字符串增长操作所需的内存重分配次数。\n\n   - 用于优化字符串**增长**操作。\n\n     当需要对SDS的空间进行空间扩展时，不仅会对SDS分配修改所必需的空间，还会额外分配未使用空间。\n\n     当len < 1Mb时 alloc = 2*len; 当len >= 1 mb时 alloc= len +1Mb。\n\n   源码分析\n\n   ```c\n   /* Enlarge the free space at the end of the sds string so that the caller\n    * is sure that after calling this function can overwrite up to addlen\n    * bytes after the end of the string, plus one more byte for nul term.\n    *\n    * Note: this does not change the *length* of the sds string as returned\n    * by sdslen(), but only the free buffer space we have. */\n   sds sdsMakeRoomFor(sds s, size_t addlen) {\n       void *sh, *newsh;\n       size_t avail = sdsavail(s);\n       size_t len, newlen;\n       char type, oldtype = s[-1] & SDS_TYPE_MASK;\n       int hdrlen;\n   \n       /* Return ASAP if there is enough space left. */\n       if (avail >= addlen) return s;\n   \n       len = sdslen(s);\n       sh = (char*)s-sdsHdrSize(oldtype);\n       newlen = (len+addlen);  // 预分配\n       if (newlen < SDS_MAX_PREALLOC)\n           newlen *= 2;\n       else\n           newlen += SDS_MAX_PREALLOC;\n   \n       type = sdsReqType(newlen);\n   \n       /* Don't use type 5: the user is appending to the string and type 5 is\n        * not able to remember empty space, so sdsMakeRoomFor() must be called\n        * at every appending operation. */\n       if (type == SDS_TYPE_5) type = SDS_TYPE_8;\n   \n       hdrlen = sdsHdrSize(type);\n       if (oldtype==type) {\n           newsh = s_realloc(sh, hdrlen+newlen+1);\n           if (newsh == NULL) return NULL;\n           s = (char*)newsh+hdrlen;\n       } else {\n           /* Since the header size changes, need to move the string forward,\n            * and can't use realloc */\n           newsh = s_malloc(hdrlen+newlen+1);\n           if (newsh == NULL) return NULL;\n           memcpy((char*)newsh+hdrlen, s, len+1);\n           s_free(sh);\n           s = (char*)newsh+hdrlen;\n           s[-1] = type;\n           sdssetlen(s, len);\n       }\n       sdssetalloc(s, newlen);\n       return s;\n   }\n   ```\n\n   \n\n2. 惰性空间释放\n\n   - 用于优化SDS的字符串**缩短**操作\n\n     缩短SDS保存的字符串时，并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性，将这些字节的数量记录起来，并等待将来使用。\n\n#### 2.2.4 二进制安全\n\nC字符串中的字符必须符合某种编码（如ASCII），除了末尾字符串中间不能有`\\0` 这个空字符，否则最先被程序读取的空字符将被认为是结尾，导致C字符串只能保存文本数据，而不能保存图片、音频、视频、压缩文件这样的二进制数据。\n\n所谓二进制安全：以处理二进制的方式来处理SDS存放在buf数组里的数据，程序不会对其中的数据做任何限制、过滤、或者假设，数据在写入时是什么样的，被读取是就是什么样的。因为SDS使用len来判断字符串是否结束。\n\n所以buf是字节数组，而不是字符数组。\n\n#### 2.2.5 兼容部分C字符串函数\n\n因为遵循C字符串以`\\0`结尾的惯例，所以可以兼容`<string.h>/strcasecmp ` ,`<stdio.h>/printf` 这些函数。但是是否是书上的使用结构体指针还是博客说的可以直接使用sds来调用？还需验证。\n\n书：`printf(\"%s\", sds->buf)`  sds是指向结构体的指针。\n\n博客：https://blog.csdn.net/yangbodong22011/article/details/78419966   :`printf(%s, sds)`\n\n源码中是直接使用sds\n\n#### 2.2.6 总结\n\n|                C字符串                 |              SDS               |\n| :------------------------------------: | :----------------------------: |\n|       获取字符串长度复杂度为O(N)       |   获取字符串长度复杂度为O(1)   |\n|     API不安全，可能造成缓冲区溢出      |  API安全，不会造成缓冲区溢出   |\n| 修改字符串长度N次必然执行N次内存重分配 |     最多执行N次内存重分配      |\n|            只能保存文本数据            | 二进制安全文本与二进制数据皆可 |\n|     可使用`<string.h>`库中所有函数     |  部分使用`<string.h>`库中函数  |\n\n### 2.3 SDSAPI\n\n\n\n|               函数                |                    作用                    |\n| :-------------------------------: | :----------------------------------------: |\n|        sdslen(const sds s)        |          获取sds字符串长度 O（1）          |\n|  sdssetlen(sds s, size_t newlen)  |             设置sds字符串长度              |\n|   sdsinclen(sds s, size_t inc)    |             增加sds字符串长度              |\n|       sdsalloc(const sds s)       |             获取sds字符串容量              |\n| sdssetalloc(sds s, size_t newlen) |            设置sds字符串容量。             |\n|       sdsavail(const sds s)       |   获取sds字符串空余空间（即alloc - len）   |\n|       sdsHdrSize(char type)       |        根据header类型得到header大小        |\n|  sdsReqType(size_t string_size)   | 根据字符串数据长度计算所需要的header类型。 |\n\n#### sdsReqType函数源码分析\n\n```c\nstatic inline char sdsReqType(size_t string_size) {\n    if (string_size < 1<<5) // string_size < 2^5\n        return SDS_TYPE_5;\n    if (string_size < 1<<8)  //string_size < 2^8\n        return SDS_TYPE_8;\n    if (string_size < 1<<16)\t//string_size < 2^16\n        return SDS_TYPE_16;\n#if (LONG_MAX == LLONG_MAX)\n    if (string_size < 1ll<<32)  //string_size < 2^32\n        return SDS_TYPE_32;\n#endif\n    return SDS_TYPE_64; \n}\n```\n\n采用左移来计算对应多少位的范围，而不是用2^5 这样的乘法。**直接移位比使用幂来计算快很多**。\n\n`1<<5`   计算出来就是2^5 次方。1是int型，4byte32位。最低8bit位的二进制为：00000001 左移5位后变成了：00100000 对应的十进制既是32。\n\n计算n个bit位的最大值：(1<<n) -1\n\n但是需要注意位数不够的情况。因为1是int型，只有32个bit。所以在左移32个bit时，需要使用long long int型。用1ll来表示，此时1ll为64个bit。\n\n还得考虑机器是否为64位机器，在32位机器上LONG_MAX = 2147483647L，64位机器上LONG_MAX = 9223372036854775807L 。不论32位机器还是64位机器上 LLONG_MAX 都是9223372036854775807L 。所以当LONG_MAX == LLONG_MAX 说明字长为64bit。加上条件编译，说明在32位机器上不使用sdshdr32而直接跳到了sdshdr64，仅仅在64位机器上使用sdshdr32。原因是什么？还没想通\n\n#### 问题\n\n1. 为什么Redis需要自己实现字符串功能，而不直接使用c语言的传统字符串？\n   - 见第二节。\n2. 执行SET 与GET命令的过程。\n3. `char buf[]` 为什么没有指定大小？一个数组占用的内存大小\n   - 在各个header的定义中最后有一个char buf[]。我们注意到这是一个没有指明长度的字符数组，这是C语言中定义字符数组的一种特殊写法，称为柔性数组（[flexible array member](https://en.wikipedia.org/wiki/Flexible_array_member)），只能定义在一个结构体的最后一个字段上。它在这里只是起到一个标记的作用，表示在flags字段后面就是一个字符数组，或者说，它指明了紧跟在flags字段后面的这个字符数组在结构体中的偏移位置。而程序在为header分配的内存的时候，它并不占用内存空间。如果计算sizeof(struct sdshdr16)的值，那么结果是5个字节，其中没有buf字段。\n   - 数组内存大小为分配的的长度*数组类型的内存大小\n4. 为什么redis 在32位机器上不使用sdshdr32？ ","source":"_posts/2019-03-20-Redis设计与实现读书笔记.md","raw":"---\ntitle: Redis设计与实现读书笔记——第二章SDS\ndate: 2019-03-20 15:20:23\ncategories: 读书笔记\ntags:\n- redis\n- 源码阅读\ncopyright: true\n---\n\n# Redis设计与实现读书笔记——第二章 \n\n为了做Redis相关实验，在网上粗略看了Redis设计与实现的电子版，感觉收获很多，但是因为是旧版，所以买了第二版，重读第二次。\n\n<!--more-->\n\n## 第二章 简单动态字符串\n\n### 简介\n\n1. 字符串值的键值对在底层都是由SDS实现的。\n2. sds的功能：\n   1. 存储字符串值\n   2. 用作缓冲区\n      1. AOF模块缓冲区\n      2. 客户端状态的输入缓冲区\n\n### 2.1 SDS的定义\n\n文件：sds.h/sdshdr 结构体 \n\n书中的为3.0版本，4.0版本有较大改动。\n\nversion: redis-4.02 \n\n参考：https://www.cnblogs.com/chenpingzhao/p/7292182.html\n\nhttps://www.codesheep.cn/2018/08/09/Redis%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E5%86%85%E9%83%A8%E7%BC%96%E7%A0%81%E5%89%96%E6%9E%90/\n\n````c\ntypedef char *sds;  //注意，sds其实不是一个结构体类型，而是被typedef的char*\n\n/* Note: sdshdr5 is never used, we just access the flags byte directly.\n * However is here to document the layout of type 5 SDS strings. */\nstruct __attribute__ ((__packed__)) sdshdr5 {\n    unsigned char flags; /* 3 lsb of type, and 5 msb of string length */\n    char buf[];\n};\nstruct __attribute__ ((__packed__)) sdshdr8 {\n    uint8_t len; /* used */\n    uint8_t alloc; /* excluding the header and null terminator */\n    unsigned char flags; /* 3 lsb of type, 5 unused bits */\n    char buf[];\n};\nstruct __attribute__ ((__packed__)) sdshdr16 {\n    uint16_t len; /* used */\n    uint16_t alloc; /* excluding the header and null terminator */\n    unsigned char flags; /* 3 lsb of type, 5 unused bits */\n    char buf[];\n};\nstruct __attribute__ ((__packed__)) sdshdr32 {\n    uint32_t len; /* used */\n    uint32_t alloc; /* excluding the header and null terminator */\n    unsigned char flags; /* 3 lsb of type, 5 unused bits */\n    char buf[];\n};\nstruct __attribute__ ((__packed__)) sdshdr64 {\n    uint64_t len; /* used */\n    uint64_t alloc; /* excluding the header and null terminator */\n    unsigned char flags; /* 3 lsb of type, 5 unused bits */\n    char buf[];\n};\n\n````\n\n除了结构体字段对len和alloc的数据类型的不同(` unit8, unit16， unit32, unit64`)，  其字段含义相差无几。其中header记录`len, alloc, flags` 信息。不同的header的目的是节省内存。**header与buf数组在内存地址上前后相邻。**\n\n```\n+--------+-------------------------------+-----------+\n| Header | Binary safe C alike string... | Null term |\n+--------+-------------------------------+-----------+\n         |\n         `-> Pointer returned to the user.\n```\n\n```\nlen: 记录buf数组中已使用的字节数量 等于保存的字符串的长度 （不算结尾的\\0 标识符）\nalloc: 字符串最大的容量。（除开header和最后的null终止符） \nflags: 总是会占用一个字节 8bit，加上unsigned是因为flags都是非负数 ，其中的最低3个bit用来表示header的类型还有 5个bit没有使用。\nbuf: 字符数组，用于保存字符串。  柔性数组\n```\n\nbuf的大小=alloc+1；\n\nheader类型定义中，注意的地方：\n\n- 在各个header的定义中使用了__attribute__ ((packed))，是为了让**编译器以紧凑模式来分配内存**，取消字节对齐。\n\n  - 结构体的成员内存是'\"连续\"的，但是这个连续是以对齐的单位而言的。比如说A成员的内存是3个字节，假设对齐单位是4个字节，会给A成员多分配一个字节。A成员后面才又紧接B成员的内存。\n  - 如果没有这个属性，编译器可能会为struct的字段做优化对齐，在其中填充空字节。那样的话，就不能保证header和sds的数据部分紧紧前后相邻，也不能按照固定向低地址方向偏移1个字节的方式来获取flags字段了。\n\n- 在各个header的定义中最后有一个char buf[]。我们注意到这是一个没有指明长度的字符数组，这是C语言中定义字符数组的一种特殊写法，称为**柔性数组**（[flexible array member](https://en.wikipedia.org/wiki/Flexible_array_member)），只能定义在一个结构体的最后一个字段上。它在这里只是起到一个标记的作用，表示在flags字段后面就是一个字符数组，或者说，它指明了紧跟在flags字段后面的这个字符数组在结构体中的偏移位置。而程序在为header分配的内存的时候，它并不占用内存空间。如果计算sizeof(struct sdshdr16)的值，那么结果是5个字节，其中没有buf字段。\n\n- sdshdr5与其它几个header结构不同，它不包含alloc字段，而长度使用flags的高5位来存储。因此，它不能为字符串分配空余空间。如果字符串需要动态增长，那么它就必然要重新分配内存才行。所以说，这种类型的sds字符串更适合存储静态的短字符串（长度小于32）。 因为长度的范围是5个bit来存储的\n  $$\n  2^5-1 = 31\n  $$\n\n\n\n\nsds字符串的header，其实隐藏在真正的字符串数据的前面（低地址方向）。这样的一个定义，有如下几个好处\n\n- header和数据相邻，而不用分成两块内存空间来单独分配。这有利于减少内存碎片，提高存储效率（memory efficiency）。\n- 虽然header有多个类型，但sds可以用统一的char *来表达。且它与传统的C语言字符串保持类型兼容。如果一个sds里面存储的是可打印字符串，那么我们可以直接把它传给C函数，比如使用strcmp比较字符串大小，或者使用printf进行打印。\n### 2.2 SDS与C字符串的区别\n\nc语言使用N+1长度的字符数组来表示长度为N的字符串，因为需要增加一个`\\0` 字符终止\n\n#### 2.2.1  常数复杂度获取字符串长度\n\n因为c语言要知道字符串的长度只能遍历数组，所以复杂度为O(N)。 \n\n而获取sds的字符串长度，只需要返回len的值就可以了复杂度为O(1)。这样对一个非常长的字符串键反复执行STRLEN命令，也不会对系统性能造成任何影响。\n\n#### 2.2.2 杜绝缓冲区溢出\n\nC字符串不记录自身长度会带来易造成缓冲区溢出的问题。 比如使用strcat函数拼接两个字符串，被拼接的字符串要是没有提前分配空间，就会造成缓冲区溢出。（溢出的字节会导致这个字符串内存紧邻的其他字符串的内容被修改）\n\n而SDS的空间分配策略完全杜绝了发生缓冲区溢出的可能，SDS的API需要修改SDS时，会先检查空间alloc是否满足修改所需的要求。不满足的话会先将空间扩展至修改所需的大小，再执行修改。\n\n#### 2.2.3 减少修改字符串时带来的内存重分配次数\n\nC语言字符串用N+1个字节长的数组来保存N个字节的字符串，因为这个关联性所以每次每次增长或者缩短一个C字符串，都要对这个字符串进行一次内存重分配操作。\n\n- 执行增长操作 比如append，需要首先通过内存重分配来扩展底层数组的空间大小，否则产生缓冲区溢出\n- 执行所动操作比如截断操作trime，需要首先通过内存重分配来释放字符串不再使用的空间，否则造成内存泄漏。\n\n内存重分配涉及复杂的算法，并且可能需要执行系统调用，所以通常是一个比较耗时的操作。这对Redis经常用于速度要求严苛，数据被频繁修改的场合来说，是不可接受的。\n\n因此SDS通过未使用空间解除了字符串长度和底层数组长度之间的关联：buf的长度可以大于len的长度。 **（4.0版本的源码还未找到对应的函数，所以可能和书上说的有变化了）**\n\n1. 空间预分配 ——减少连续执行字符串增长操作所需的内存重分配次数。\n\n   - 用于优化字符串**增长**操作。\n\n     当需要对SDS的空间进行空间扩展时，不仅会对SDS分配修改所必需的空间，还会额外分配未使用空间。\n\n     当len < 1Mb时 alloc = 2*len; 当len >= 1 mb时 alloc= len +1Mb。\n\n   源码分析\n\n   ```c\n   /* Enlarge the free space at the end of the sds string so that the caller\n    * is sure that after calling this function can overwrite up to addlen\n    * bytes after the end of the string, plus one more byte for nul term.\n    *\n    * Note: this does not change the *length* of the sds string as returned\n    * by sdslen(), but only the free buffer space we have. */\n   sds sdsMakeRoomFor(sds s, size_t addlen) {\n       void *sh, *newsh;\n       size_t avail = sdsavail(s);\n       size_t len, newlen;\n       char type, oldtype = s[-1] & SDS_TYPE_MASK;\n       int hdrlen;\n   \n       /* Return ASAP if there is enough space left. */\n       if (avail >= addlen) return s;\n   \n       len = sdslen(s);\n       sh = (char*)s-sdsHdrSize(oldtype);\n       newlen = (len+addlen);  // 预分配\n       if (newlen < SDS_MAX_PREALLOC)\n           newlen *= 2;\n       else\n           newlen += SDS_MAX_PREALLOC;\n   \n       type = sdsReqType(newlen);\n   \n       /* Don't use type 5: the user is appending to the string and type 5 is\n        * not able to remember empty space, so sdsMakeRoomFor() must be called\n        * at every appending operation. */\n       if (type == SDS_TYPE_5) type = SDS_TYPE_8;\n   \n       hdrlen = sdsHdrSize(type);\n       if (oldtype==type) {\n           newsh = s_realloc(sh, hdrlen+newlen+1);\n           if (newsh == NULL) return NULL;\n           s = (char*)newsh+hdrlen;\n       } else {\n           /* Since the header size changes, need to move the string forward,\n            * and can't use realloc */\n           newsh = s_malloc(hdrlen+newlen+1);\n           if (newsh == NULL) return NULL;\n           memcpy((char*)newsh+hdrlen, s, len+1);\n           s_free(sh);\n           s = (char*)newsh+hdrlen;\n           s[-1] = type;\n           sdssetlen(s, len);\n       }\n       sdssetalloc(s, newlen);\n       return s;\n   }\n   ```\n\n   \n\n2. 惰性空间释放\n\n   - 用于优化SDS的字符串**缩短**操作\n\n     缩短SDS保存的字符串时，并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性，将这些字节的数量记录起来，并等待将来使用。\n\n#### 2.2.4 二进制安全\n\nC字符串中的字符必须符合某种编码（如ASCII），除了末尾字符串中间不能有`\\0` 这个空字符，否则最先被程序读取的空字符将被认为是结尾，导致C字符串只能保存文本数据，而不能保存图片、音频、视频、压缩文件这样的二进制数据。\n\n所谓二进制安全：以处理二进制的方式来处理SDS存放在buf数组里的数据，程序不会对其中的数据做任何限制、过滤、或者假设，数据在写入时是什么样的，被读取是就是什么样的。因为SDS使用len来判断字符串是否结束。\n\n所以buf是字节数组，而不是字符数组。\n\n#### 2.2.5 兼容部分C字符串函数\n\n因为遵循C字符串以`\\0`结尾的惯例，所以可以兼容`<string.h>/strcasecmp ` ,`<stdio.h>/printf` 这些函数。但是是否是书上的使用结构体指针还是博客说的可以直接使用sds来调用？还需验证。\n\n书：`printf(\"%s\", sds->buf)`  sds是指向结构体的指针。\n\n博客：https://blog.csdn.net/yangbodong22011/article/details/78419966   :`printf(%s, sds)`\n\n源码中是直接使用sds\n\n#### 2.2.6 总结\n\n|                C字符串                 |              SDS               |\n| :------------------------------------: | :----------------------------: |\n|       获取字符串长度复杂度为O(N)       |   获取字符串长度复杂度为O(1)   |\n|     API不安全，可能造成缓冲区溢出      |  API安全，不会造成缓冲区溢出   |\n| 修改字符串长度N次必然执行N次内存重分配 |     最多执行N次内存重分配      |\n|            只能保存文本数据            | 二进制安全文本与二进制数据皆可 |\n|     可使用`<string.h>`库中所有函数     |  部分使用`<string.h>`库中函数  |\n\n### 2.3 SDSAPI\n\n\n\n|               函数                |                    作用                    |\n| :-------------------------------: | :----------------------------------------: |\n|        sdslen(const sds s)        |          获取sds字符串长度 O（1）          |\n|  sdssetlen(sds s, size_t newlen)  |             设置sds字符串长度              |\n|   sdsinclen(sds s, size_t inc)    |             增加sds字符串长度              |\n|       sdsalloc(const sds s)       |             获取sds字符串容量              |\n| sdssetalloc(sds s, size_t newlen) |            设置sds字符串容量。             |\n|       sdsavail(const sds s)       |   获取sds字符串空余空间（即alloc - len）   |\n|       sdsHdrSize(char type)       |        根据header类型得到header大小        |\n|  sdsReqType(size_t string_size)   | 根据字符串数据长度计算所需要的header类型。 |\n\n#### sdsReqType函数源码分析\n\n```c\nstatic inline char sdsReqType(size_t string_size) {\n    if (string_size < 1<<5) // string_size < 2^5\n        return SDS_TYPE_5;\n    if (string_size < 1<<8)  //string_size < 2^8\n        return SDS_TYPE_8;\n    if (string_size < 1<<16)\t//string_size < 2^16\n        return SDS_TYPE_16;\n#if (LONG_MAX == LLONG_MAX)\n    if (string_size < 1ll<<32)  //string_size < 2^32\n        return SDS_TYPE_32;\n#endif\n    return SDS_TYPE_64; \n}\n```\n\n采用左移来计算对应多少位的范围，而不是用2^5 这样的乘法。**直接移位比使用幂来计算快很多**。\n\n`1<<5`   计算出来就是2^5 次方。1是int型，4byte32位。最低8bit位的二进制为：00000001 左移5位后变成了：00100000 对应的十进制既是32。\n\n计算n个bit位的最大值：(1<<n) -1\n\n但是需要注意位数不够的情况。因为1是int型，只有32个bit。所以在左移32个bit时，需要使用long long int型。用1ll来表示，此时1ll为64个bit。\n\n还得考虑机器是否为64位机器，在32位机器上LONG_MAX = 2147483647L，64位机器上LONG_MAX = 9223372036854775807L 。不论32位机器还是64位机器上 LLONG_MAX 都是9223372036854775807L 。所以当LONG_MAX == LLONG_MAX 说明字长为64bit。加上条件编译，说明在32位机器上不使用sdshdr32而直接跳到了sdshdr64，仅仅在64位机器上使用sdshdr32。原因是什么？还没想通\n\n#### 问题\n\n1. 为什么Redis需要自己实现字符串功能，而不直接使用c语言的传统字符串？\n   - 见第二节。\n2. 执行SET 与GET命令的过程。\n3. `char buf[]` 为什么没有指定大小？一个数组占用的内存大小\n   - 在各个header的定义中最后有一个char buf[]。我们注意到这是一个没有指明长度的字符数组，这是C语言中定义字符数组的一种特殊写法，称为柔性数组（[flexible array member](https://en.wikipedia.org/wiki/Flexible_array_member)），只能定义在一个结构体的最后一个字段上。它在这里只是起到一个标记的作用，表示在flags字段后面就是一个字符数组，或者说，它指明了紧跟在flags字段后面的这个字符数组在结构体中的偏移位置。而程序在为header分配的内存的时候，它并不占用内存空间。如果计算sizeof(struct sdshdr16)的值，那么结果是5个字节，其中没有buf字段。\n   - 数组内存大小为分配的的长度*数组类型的内存大小\n4. 为什么redis 在32位机器上不使用sdshdr32？ ","slug":"2019-03-20-Redis设计与实现读书笔记","published":1,"updated":"2019-11-08T13:15:20.055Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6he13xt0002dstz97wnh59g","content":"<h1 id=\"Redis设计与实现读书笔记——第二章\"><a href=\"#Redis设计与实现读书笔记——第二章\" class=\"headerlink\" title=\"Redis设计与实现读书笔记——第二章\"></a>Redis设计与实现读书笔记——第二章</h1><p>为了做Redis相关实验，在网上粗略看了Redis设计与实现的电子版，感觉收获很多，但是因为是旧版，所以买了第二版，重读第二次。</p>\n<a id=\"more\"></a>\n<h2 id=\"第二章-简单动态字符串\"><a href=\"#第二章-简单动态字符串\" class=\"headerlink\" title=\"第二章 简单动态字符串\"></a>第二章 简单动态字符串</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><ol>\n<li>字符串值的键值对在底层都是由SDS实现的。</li>\n<li>sds的功能：<ol>\n<li>存储字符串值</li>\n<li>用作缓冲区<ol>\n<li>AOF模块缓冲区</li>\n<li>客户端状态的输入缓冲区</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"2-1-SDS的定义\"><a href=\"#2-1-SDS的定义\" class=\"headerlink\" title=\"2.1 SDS的定义\"></a>2.1 SDS的定义</h3><p>文件：sds.h/sdshdr 结构体 </p>\n<p>书中的为3.0版本，4.0版本有较大改动。</p>\n<p>version: redis-4.02 </p>\n<p>参考：<a href=\"https://www.cnblogs.com/chenpingzhao/p/7292182.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/chenpingzhao/p/7292182.html</a></p>\n<p><a href=\"https://www.codesheep.cn/2018/08/09/Redis%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E5%86%85%E9%83%A8%E7%BC%96%E7%A0%81%E5%89%96%E6%9E%90/\" target=\"_blank\" rel=\"noopener\">https://www.codesheep.cn/2018/08/09/Redis%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E5%86%85%E9%83%A8%E7%BC%96%E7%A0%81%E5%89%96%E6%9E%90/</a></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">char</span> *sds;  <span class=\"comment\">//注意，sds其实不是一个结构体类型，而是被typedef的char*</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Note: sdshdr5 is never used, we just access the flags byte directly.</span></span><br><span class=\"line\"><span class=\"comment\"> * However is here to document the layout of type 5 SDS strings. */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> __<span class=\"title\">attribute__</span> ((__<span class=\"title\">packed__</span>)) <span class=\"title\">sdshdr5</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> flags; <span class=\"comment\">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> __<span class=\"title\">attribute__</span> ((__<span class=\"title\">packed__</span>)) <span class=\"title\">sdshdr8</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">uint8_t</span> len; <span class=\"comment\">/* used */</span></span><br><span class=\"line\">    <span class=\"keyword\">uint8_t</span> alloc; <span class=\"comment\">/* excluding the header and null terminator */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> flags; <span class=\"comment\">/* 3 lsb of type, 5 unused bits */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> __<span class=\"title\">attribute__</span> ((__<span class=\"title\">packed__</span>)) <span class=\"title\">sdshdr16</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">uint16_t</span> len; <span class=\"comment\">/* used */</span></span><br><span class=\"line\">    <span class=\"keyword\">uint16_t</span> alloc; <span class=\"comment\">/* excluding the header and null terminator */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> flags; <span class=\"comment\">/* 3 lsb of type, 5 unused bits */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> __<span class=\"title\">attribute__</span> ((__<span class=\"title\">packed__</span>)) <span class=\"title\">sdshdr32</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> len; <span class=\"comment\">/* used */</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> alloc; <span class=\"comment\">/* excluding the header and null terminator */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> flags; <span class=\"comment\">/* 3 lsb of type, 5 unused bits */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> __<span class=\"title\">attribute__</span> ((__<span class=\"title\">packed__</span>)) <span class=\"title\">sdshdr64</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">uint64_t</span> len; <span class=\"comment\">/* used */</span></span><br><span class=\"line\">    <span class=\"keyword\">uint64_t</span> alloc; <span class=\"comment\">/* excluding the header and null terminator */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> flags; <span class=\"comment\">/* 3 lsb of type, 5 unused bits */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>除了结构体字段对len和alloc的数据类型的不同(<code>unit8, unit16， unit32, unit64</code>)，  其字段含义相差无几。其中header记录<code>len, alloc, flags</code> 信息。不同的header的目的是节省内存。<strong>header与buf数组在内存地址上前后相邻。</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+--------+-------------------------------+-----------+</span><br><span class=\"line\">| Header | Binary safe C alike string... | Null term |</span><br><span class=\"line\">+--------+-------------------------------+-----------+</span><br><span class=\"line\">         |</span><br><span class=\"line\">         `-&gt; Pointer returned to the user.</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">len: 记录buf数组中已使用的字节数量 等于保存的字符串的长度 （不算结尾的\\0 标识符）</span><br><span class=\"line\">alloc: 字符串最大的容量。（除开header和最后的null终止符） </span><br><span class=\"line\">flags: 总是会占用一个字节 8bit，加上unsigned是因为flags都是非负数 ，其中的最低3个bit用来表示header的类型还有 5个bit没有使用。</span><br><span class=\"line\">buf: 字符数组，用于保存字符串。  柔性数组</span><br></pre></td></tr></table></figure>\n<p>buf的大小=alloc+1；</p>\n<p>header类型定义中，注意的地方：</p>\n<ul>\n<li><p>在各个header的定义中使用了<strong>attribute</strong> ((packed))，是为了让<strong>编译器以紧凑模式来分配内存</strong>，取消字节对齐。</p>\n<ul>\n<li>结构体的成员内存是’”连续”的，但是这个连续是以对齐的单位而言的。比如说A成员的内存是3个字节，假设对齐单位是4个字节，会给A成员多分配一个字节。A成员后面才又紧接B成员的内存。</li>\n<li>如果没有这个属性，编译器可能会为struct的字段做优化对齐，在其中填充空字节。那样的话，就不能保证header和sds的数据部分紧紧前后相邻，也不能按照固定向低地址方向偏移1个字节的方式来获取flags字段了。</li>\n</ul>\n</li>\n<li><p>在各个header的定义中最后有一个char buf[]。我们注意到这是一个没有指明长度的字符数组，这是C语言中定义字符数组的一种特殊写法，称为<strong>柔性数组</strong>（<a href=\"https://en.wikipedia.org/wiki/Flexible_array_member\" target=\"_blank\" rel=\"noopener\">flexible array member</a>），只能定义在一个结构体的最后一个字段上。它在这里只是起到一个标记的作用，表示在flags字段后面就是一个字符数组，或者说，它指明了紧跟在flags字段后面的这个字符数组在结构体中的偏移位置。而程序在为header分配的内存的时候，它并不占用内存空间。如果计算sizeof(struct sdshdr16)的值，那么结果是5个字节，其中没有buf字段。</p>\n</li>\n<li><p>sdshdr5与其它几个header结构不同，它不包含alloc字段，而长度使用flags的高5位来存储。因此，它不能为字符串分配空余空间。如果字符串需要动态增长，那么它就必然要重新分配内存才行。所以说，这种类型的sds字符串更适合存储静态的短字符串（长度小于32）。 因为长度的范围是5个bit来存储的</p>\n<script type=\"math/tex; mode=display\">\n2^5-1 = 31</script></li>\n</ul>\n<p>sds字符串的header，其实隐藏在真正的字符串数据的前面（低地址方向）。这样的一个定义，有如下几个好处</p>\n<ul>\n<li>header和数据相邻，而不用分成两块内存空间来单独分配。这有利于减少内存碎片，提高存储效率（memory efficiency）。</li>\n<li>虽然header有多个类型，但sds可以用统一的char *来表达。且它与传统的C语言字符串保持类型兼容。如果一个sds里面存储的是可打印字符串，那么我们可以直接把它传给C函数，比如使用strcmp比较字符串大小，或者使用printf进行打印。<h3 id=\"2-2-SDS与C字符串的区别\"><a href=\"#2-2-SDS与C字符串的区别\" class=\"headerlink\" title=\"2.2 SDS与C字符串的区别\"></a>2.2 SDS与C字符串的区别</h3></li>\n</ul>\n<p>c语言使用N+1长度的字符数组来表示长度为N的字符串，因为需要增加一个<code>\\0</code> 字符终止</p>\n<h4 id=\"2-2-1-常数复杂度获取字符串长度\"><a href=\"#2-2-1-常数复杂度获取字符串长度\" class=\"headerlink\" title=\"2.2.1  常数复杂度获取字符串长度\"></a>2.2.1  常数复杂度获取字符串长度</h4><p>因为c语言要知道字符串的长度只能遍历数组，所以复杂度为O(N)。 </p>\n<p>而获取sds的字符串长度，只需要返回len的值就可以了复杂度为O(1)。这样对一个非常长的字符串键反复执行STRLEN命令，也不会对系统性能造成任何影响。</p>\n<h4 id=\"2-2-2-杜绝缓冲区溢出\"><a href=\"#2-2-2-杜绝缓冲区溢出\" class=\"headerlink\" title=\"2.2.2 杜绝缓冲区溢出\"></a>2.2.2 杜绝缓冲区溢出</h4><p>C字符串不记录自身长度会带来易造成缓冲区溢出的问题。 比如使用strcat函数拼接两个字符串，被拼接的字符串要是没有提前分配空间，就会造成缓冲区溢出。（溢出的字节会导致这个字符串内存紧邻的其他字符串的内容被修改）</p>\n<p>而SDS的空间分配策略完全杜绝了发生缓冲区溢出的可能，SDS的API需要修改SDS时，会先检查空间alloc是否满足修改所需的要求。不满足的话会先将空间扩展至修改所需的大小，再执行修改。</p>\n<h4 id=\"2-2-3-减少修改字符串时带来的内存重分配次数\"><a href=\"#2-2-3-减少修改字符串时带来的内存重分配次数\" class=\"headerlink\" title=\"2.2.3 减少修改字符串时带来的内存重分配次数\"></a>2.2.3 减少修改字符串时带来的内存重分配次数</h4><p>C语言字符串用N+1个字节长的数组来保存N个字节的字符串，因为这个关联性所以每次每次增长或者缩短一个C字符串，都要对这个字符串进行一次内存重分配操作。</p>\n<ul>\n<li>执行增长操作 比如append，需要首先通过内存重分配来扩展底层数组的空间大小，否则产生缓冲区溢出</li>\n<li>执行所动操作比如截断操作trime，需要首先通过内存重分配来释放字符串不再使用的空间，否则造成内存泄漏。</li>\n</ul>\n<p>内存重分配涉及复杂的算法，并且可能需要执行系统调用，所以通常是一个比较耗时的操作。这对Redis经常用于速度要求严苛，数据被频繁修改的场合来说，是不可接受的。</p>\n<p>因此SDS通过未使用空间解除了字符串长度和底层数组长度之间的关联：buf的长度可以大于len的长度。 <strong>（4.0版本的源码还未找到对应的函数，所以可能和书上说的有变化了）</strong></p>\n<ol>\n<li><p>空间预分配 ——减少连续执行字符串增长操作所需的内存重分配次数。</p>\n<ul>\n<li><p>用于优化字符串<strong>增长</strong>操作。</p>\n<p>当需要对SDS的空间进行空间扩展时，不仅会对SDS分配修改所必需的空间，还会额外分配未使用空间。</p>\n<p>当len &lt; 1Mb时 alloc = 2*len; 当len &gt;= 1 mb时 alloc= len +1Mb。</p>\n</li>\n</ul>\n<p>源码分析</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Enlarge the free space at the end of the sds string so that the caller</span></span><br><span class=\"line\"><span class=\"comment\"> * is sure that after calling this function can overwrite up to addlen</span></span><br><span class=\"line\"><span class=\"comment\"> * bytes after the end of the string, plus one more byte for nul term.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Note: this does not change the *length* of the sds string as returned</span></span><br><span class=\"line\"><span class=\"comment\"> * by sdslen(), but only the free buffer space we have. */</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdsMakeRoomFor</span><span class=\"params\">(sds s, <span class=\"keyword\">size_t</span> addlen)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *sh, *newsh;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> avail = sdsavail(s);</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> len, newlen;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> type, oldtype = s[<span class=\"number\">-1</span>] &amp; SDS_TYPE_MASK;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> hdrlen;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Return ASAP if there is enough space left. */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (avail &gt;= addlen) <span class=\"keyword\">return</span> s;</span><br><span class=\"line\"></span><br><span class=\"line\">    len = sdslen(s);</span><br><span class=\"line\">    sh = (<span class=\"keyword\">char</span>*)s-sdsHdrSize(oldtype);</span><br><span class=\"line\">    newlen = (len+addlen);  <span class=\"comment\">// 预分配</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newlen &lt; SDS_MAX_PREALLOC)</span><br><span class=\"line\">        newlen *= <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        newlen += SDS_MAX_PREALLOC;</span><br><span class=\"line\"></span><br><span class=\"line\">    type = sdsReqType(newlen);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Don't use type 5: the user is appending to the string and type 5 is</span></span><br><span class=\"line\"><span class=\"comment\">     * not able to remember empty space, so sdsMakeRoomFor() must be called</span></span><br><span class=\"line\"><span class=\"comment\">     * at every appending operation. */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type == SDS_TYPE_5) type = SDS_TYPE_8;</span><br><span class=\"line\"></span><br><span class=\"line\">    hdrlen = sdsHdrSize(type);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldtype==type) &#123;</span><br><span class=\"line\">        newsh = s_realloc(sh, hdrlen+newlen+<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newsh == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        s = (<span class=\"keyword\">char</span>*)newsh+hdrlen;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* Since the header size changes, need to move the string forward,</span></span><br><span class=\"line\"><span class=\"comment\">         * and can't use realloc */</span></span><br><span class=\"line\">        newsh = s_malloc(hdrlen+newlen+<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newsh == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"built_in\">memcpy</span>((<span class=\"keyword\">char</span>*)newsh+hdrlen, s, len+<span class=\"number\">1</span>);</span><br><span class=\"line\">        s_free(sh);</span><br><span class=\"line\">        s = (<span class=\"keyword\">char</span>*)newsh+hdrlen;</span><br><span class=\"line\">        s[<span class=\"number\">-1</span>] = type;</span><br><span class=\"line\">        sdssetlen(s, len);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sdssetalloc(s, newlen);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol>\n<li><p>惰性空间释放</p>\n<ul>\n<li><p>用于优化SDS的字符串<strong>缩短</strong>操作</p>\n<p>缩短SDS保存的字符串时，并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性，将这些字节的数量记录起来，并等待将来使用。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"2-2-4-二进制安全\"><a href=\"#2-2-4-二进制安全\" class=\"headerlink\" title=\"2.2.4 二进制安全\"></a>2.2.4 二进制安全</h4><p>C字符串中的字符必须符合某种编码（如ASCII），除了末尾字符串中间不能有<code>\\0</code> 这个空字符，否则最先被程序读取的空字符将被认为是结尾，导致C字符串只能保存文本数据，而不能保存图片、音频、视频、压缩文件这样的二进制数据。</p>\n<p>所谓二进制安全：以处理二进制的方式来处理SDS存放在buf数组里的数据，程序不会对其中的数据做任何限制、过滤、或者假设，数据在写入时是什么样的，被读取是就是什么样的。因为SDS使用len来判断字符串是否结束。</p>\n<p>所以buf是字节数组，而不是字符数组。</p>\n<h4 id=\"2-2-5-兼容部分C字符串函数\"><a href=\"#2-2-5-兼容部分C字符串函数\" class=\"headerlink\" title=\"2.2.5 兼容部分C字符串函数\"></a>2.2.5 兼容部分C字符串函数</h4><p>因为遵循C字符串以<code>\\0</code>结尾的惯例，所以可以兼容<code>&lt;string.h&gt;/strcasecmp</code> ,<code>&lt;stdio.h&gt;/printf</code> 这些函数。但是是否是书上的使用结构体指针还是博客说的可以直接使用sds来调用？还需验证。</p>\n<p>书：<code>printf(&quot;%s&quot;, sds-&gt;buf)</code>  sds是指向结构体的指针。</p>\n<p>博客：<a href=\"https://blog.csdn.net/yangbodong22011/article/details/78419966\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/yangbodong22011/article/details/78419966</a>   :<code>printf(%s, sds)</code></p>\n<p>源码中是直接使用sds</p>\n<h4 id=\"2-2-6-总结\"><a href=\"#2-2-6-总结\" class=\"headerlink\" title=\"2.2.6 总结\"></a>2.2.6 总结</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">C字符串</th>\n<th style=\"text-align:center\">SDS</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">获取字符串长度复杂度为O(N)</td>\n<td style=\"text-align:center\">获取字符串长度复杂度为O(1)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">API不安全，可能造成缓冲区溢出</td>\n<td style=\"text-align:center\">API安全，不会造成缓冲区溢出</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">修改字符串长度N次必然执行N次内存重分配</td>\n<td style=\"text-align:center\">最多执行N次内存重分配</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">只能保存文本数据</td>\n<td style=\"text-align:center\">二进制安全文本与二进制数据皆可</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">可使用<code>&lt;string.h&gt;</code>库中所有函数</td>\n<td style=\"text-align:center\">部分使用<code>&lt;string.h&gt;</code>库中函数</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"2-3-SDSAPI\"><a href=\"#2-3-SDSAPI\" class=\"headerlink\" title=\"2.3 SDSAPI\"></a>2.3 SDSAPI</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">函数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">sdslen(const sds s)</td>\n<td style=\"text-align:center\">获取sds字符串长度 O（1）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">sdssetlen(sds s, size_t newlen)</td>\n<td style=\"text-align:center\">设置sds字符串长度</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">sdsinclen(sds s, size_t inc)</td>\n<td style=\"text-align:center\">增加sds字符串长度</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">sdsalloc(const sds s)</td>\n<td style=\"text-align:center\">获取sds字符串容量</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">sdssetalloc(sds s, size_t newlen)</td>\n<td style=\"text-align:center\">设置sds字符串容量。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">sdsavail(const sds s)</td>\n<td style=\"text-align:center\">获取sds字符串空余空间（即alloc - len）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">sdsHdrSize(char type)</td>\n<td style=\"text-align:center\">根据header类型得到header大小</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">sdsReqType(size_t string_size)</td>\n<td style=\"text-align:center\">根据字符串数据长度计算所需要的header类型。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"sdsReqType函数源码分析\"><a href=\"#sdsReqType函数源码分析\" class=\"headerlink\" title=\"sdsReqType函数源码分析\"></a>sdsReqType函数源码分析</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">char</span> <span class=\"title\">sdsReqType</span><span class=\"params\">(<span class=\"keyword\">size_t</span> string_size)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (string_size &lt; <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">5</span>) <span class=\"comment\">// string_size &lt; 2^5</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> SDS_TYPE_5;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (string_size &lt; <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">8</span>)  <span class=\"comment\">//string_size &lt; 2^8</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> SDS_TYPE_8;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (string_size &lt; <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">16</span>)\t<span class=\"comment\">//string_size &lt; 2^16</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> SDS_TYPE_16;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> (LONG_MAX == LLONG_MAX)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (string_size &lt; <span class=\"number\">1l</span>l&lt;&lt;<span class=\"number\">32</span>)  <span class=\"comment\">//string_size &lt; 2^32</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> SDS_TYPE_32;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> SDS_TYPE_64; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>采用左移来计算对应多少位的范围，而不是用2^5 这样的乘法。<strong>直接移位比使用幂来计算快很多</strong>。</p>\n<p><code>1&lt;&lt;5</code>   计算出来就是2^5 次方。1是int型，4byte32位。最低8bit位的二进制为：00000001 左移5位后变成了：00100000 对应的十进制既是32。</p>\n<p>计算n个bit位的最大值：(1&lt;&lt;n) -1</p>\n<p>但是需要注意位数不够的情况。因为1是int型，只有32个bit。所以在左移32个bit时，需要使用long long int型。用1ll来表示，此时1ll为64个bit。</p>\n<p>还得考虑机器是否为64位机器，在32位机器上LONG_MAX = 2147483647L，64位机器上LONG_MAX = 9223372036854775807L 。不论32位机器还是64位机器上 LLONG_MAX 都是9223372036854775807L 。所以当LONG_MAX == LLONG_MAX 说明字长为64bit。加上条件编译，说明在32位机器上不使用sdshdr32而直接跳到了sdshdr64，仅仅在64位机器上使用sdshdr32。原因是什么？还没想通</p>\n<h4 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h4><ol>\n<li>为什么Redis需要自己实现字符串功能，而不直接使用c语言的传统字符串？<ul>\n<li>见第二节。</li>\n</ul>\n</li>\n<li>执行SET 与GET命令的过程。</li>\n<li><code>char buf[]</code> 为什么没有指定大小？一个数组占用的内存大小<ul>\n<li>在各个header的定义中最后有一个char buf[]。我们注意到这是一个没有指明长度的字符数组，这是C语言中定义字符数组的一种特殊写法，称为柔性数组（<a href=\"https://en.wikipedia.org/wiki/Flexible_array_member\" target=\"_blank\" rel=\"noopener\">flexible array member</a>），只能定义在一个结构体的最后一个字段上。它在这里只是起到一个标记的作用，表示在flags字段后面就是一个字符数组，或者说，它指明了紧跟在flags字段后面的这个字符数组在结构体中的偏移位置。而程序在为header分配的内存的时候，它并不占用内存空间。如果计算sizeof(struct sdshdr16)的值，那么结果是5个字节，其中没有buf字段。</li>\n<li>数组内存大小为分配的的长度*数组类型的内存大小</li>\n</ul>\n</li>\n<li>为什么redis 在32位机器上不使用sdshdr32？ </li>\n</ol>\n","site":{"data":{}},"length":7568,"excerpt":"<h1 id=\"Redis设计与实现读书笔记——第二章\"><a href=\"#Redis设计与实现读书笔记——第二章\" class=\"headerlink\" title=\"Redis设计与实现读书笔记——第二章\"></a>Redis设计与实现读书笔记——第二章</h1><p>为了做Redis相关实验，在网上粗略看了Redis设计与实现的电子版，感觉收获很多，但是因为是旧版，所以买了第二版，重读第二次。</p>","more":"<h2 id=\"第二章-简单动态字符串\"><a href=\"#第二章-简单动态字符串\" class=\"headerlink\" title=\"第二章 简单动态字符串\"></a>第二章 简单动态字符串</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><ol>\n<li>字符串值的键值对在底层都是由SDS实现的。</li>\n<li>sds的功能：<ol>\n<li>存储字符串值</li>\n<li>用作缓冲区<ol>\n<li>AOF模块缓冲区</li>\n<li>客户端状态的输入缓冲区</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"2-1-SDS的定义\"><a href=\"#2-1-SDS的定义\" class=\"headerlink\" title=\"2.1 SDS的定义\"></a>2.1 SDS的定义</h3><p>文件：sds.h/sdshdr 结构体 </p>\n<p>书中的为3.0版本，4.0版本有较大改动。</p>\n<p>version: redis-4.02 </p>\n<p>参考：<a href=\"https://www.cnblogs.com/chenpingzhao/p/7292182.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/chenpingzhao/p/7292182.html</a></p>\n<p><a href=\"https://www.codesheep.cn/2018/08/09/Redis%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E5%86%85%E9%83%A8%E7%BC%96%E7%A0%81%E5%89%96%E6%9E%90/\" target=\"_blank\" rel=\"noopener\">https://www.codesheep.cn/2018/08/09/Redis%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E5%86%85%E9%83%A8%E7%BC%96%E7%A0%81%E5%89%96%E6%9E%90/</a></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">char</span> *sds;  <span class=\"comment\">//注意，sds其实不是一个结构体类型，而是被typedef的char*</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Note: sdshdr5 is never used, we just access the flags byte directly.</span></span><br><span class=\"line\"><span class=\"comment\"> * However is here to document the layout of type 5 SDS strings. */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> __<span class=\"title\">attribute__</span> ((__<span class=\"title\">packed__</span>)) <span class=\"title\">sdshdr5</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> flags; <span class=\"comment\">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> __<span class=\"title\">attribute__</span> ((__<span class=\"title\">packed__</span>)) <span class=\"title\">sdshdr8</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">uint8_t</span> len; <span class=\"comment\">/* used */</span></span><br><span class=\"line\">    <span class=\"keyword\">uint8_t</span> alloc; <span class=\"comment\">/* excluding the header and null terminator */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> flags; <span class=\"comment\">/* 3 lsb of type, 5 unused bits */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> __<span class=\"title\">attribute__</span> ((__<span class=\"title\">packed__</span>)) <span class=\"title\">sdshdr16</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">uint16_t</span> len; <span class=\"comment\">/* used */</span></span><br><span class=\"line\">    <span class=\"keyword\">uint16_t</span> alloc; <span class=\"comment\">/* excluding the header and null terminator */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> flags; <span class=\"comment\">/* 3 lsb of type, 5 unused bits */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> __<span class=\"title\">attribute__</span> ((__<span class=\"title\">packed__</span>)) <span class=\"title\">sdshdr32</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> len; <span class=\"comment\">/* used */</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> alloc; <span class=\"comment\">/* excluding the header and null terminator */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> flags; <span class=\"comment\">/* 3 lsb of type, 5 unused bits */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> __<span class=\"title\">attribute__</span> ((__<span class=\"title\">packed__</span>)) <span class=\"title\">sdshdr64</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">uint64_t</span> len; <span class=\"comment\">/* used */</span></span><br><span class=\"line\">    <span class=\"keyword\">uint64_t</span> alloc; <span class=\"comment\">/* excluding the header and null terminator */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> flags; <span class=\"comment\">/* 3 lsb of type, 5 unused bits */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>除了结构体字段对len和alloc的数据类型的不同(<code>unit8, unit16， unit32, unit64</code>)，  其字段含义相差无几。其中header记录<code>len, alloc, flags</code> 信息。不同的header的目的是节省内存。<strong>header与buf数组在内存地址上前后相邻。</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+--------+-------------------------------+-----------+</span><br><span class=\"line\">| Header | Binary safe C alike string... | Null term |</span><br><span class=\"line\">+--------+-------------------------------+-----------+</span><br><span class=\"line\">         |</span><br><span class=\"line\">         `-&gt; Pointer returned to the user.</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">len: 记录buf数组中已使用的字节数量 等于保存的字符串的长度 （不算结尾的\\0 标识符）</span><br><span class=\"line\">alloc: 字符串最大的容量。（除开header和最后的null终止符） </span><br><span class=\"line\">flags: 总是会占用一个字节 8bit，加上unsigned是因为flags都是非负数 ，其中的最低3个bit用来表示header的类型还有 5个bit没有使用。</span><br><span class=\"line\">buf: 字符数组，用于保存字符串。  柔性数组</span><br></pre></td></tr></table></figure>\n<p>buf的大小=alloc+1；</p>\n<p>header类型定义中，注意的地方：</p>\n<ul>\n<li><p>在各个header的定义中使用了<strong>attribute</strong> ((packed))，是为了让<strong>编译器以紧凑模式来分配内存</strong>，取消字节对齐。</p>\n<ul>\n<li>结构体的成员内存是’”连续”的，但是这个连续是以对齐的单位而言的。比如说A成员的内存是3个字节，假设对齐单位是4个字节，会给A成员多分配一个字节。A成员后面才又紧接B成员的内存。</li>\n<li>如果没有这个属性，编译器可能会为struct的字段做优化对齐，在其中填充空字节。那样的话，就不能保证header和sds的数据部分紧紧前后相邻，也不能按照固定向低地址方向偏移1个字节的方式来获取flags字段了。</li>\n</ul>\n</li>\n<li><p>在各个header的定义中最后有一个char buf[]。我们注意到这是一个没有指明长度的字符数组，这是C语言中定义字符数组的一种特殊写法，称为<strong>柔性数组</strong>（<a href=\"https://en.wikipedia.org/wiki/Flexible_array_member\" target=\"_blank\" rel=\"noopener\">flexible array member</a>），只能定义在一个结构体的最后一个字段上。它在这里只是起到一个标记的作用，表示在flags字段后面就是一个字符数组，或者说，它指明了紧跟在flags字段后面的这个字符数组在结构体中的偏移位置。而程序在为header分配的内存的时候，它并不占用内存空间。如果计算sizeof(struct sdshdr16)的值，那么结果是5个字节，其中没有buf字段。</p>\n</li>\n<li><p>sdshdr5与其它几个header结构不同，它不包含alloc字段，而长度使用flags的高5位来存储。因此，它不能为字符串分配空余空间。如果字符串需要动态增长，那么它就必然要重新分配内存才行。所以说，这种类型的sds字符串更适合存储静态的短字符串（长度小于32）。 因为长度的范围是5个bit来存储的</p>\n<script type=\"math/tex; mode=display\">\n2^5-1 = 31</script></li>\n</ul>\n<p>sds字符串的header，其实隐藏在真正的字符串数据的前面（低地址方向）。这样的一个定义，有如下几个好处</p>\n<ul>\n<li>header和数据相邻，而不用分成两块内存空间来单独分配。这有利于减少内存碎片，提高存储效率（memory efficiency）。</li>\n<li>虽然header有多个类型，但sds可以用统一的char *来表达。且它与传统的C语言字符串保持类型兼容。如果一个sds里面存储的是可打印字符串，那么我们可以直接把它传给C函数，比如使用strcmp比较字符串大小，或者使用printf进行打印。<h3 id=\"2-2-SDS与C字符串的区别\"><a href=\"#2-2-SDS与C字符串的区别\" class=\"headerlink\" title=\"2.2 SDS与C字符串的区别\"></a>2.2 SDS与C字符串的区别</h3></li>\n</ul>\n<p>c语言使用N+1长度的字符数组来表示长度为N的字符串，因为需要增加一个<code>\\0</code> 字符终止</p>\n<h4 id=\"2-2-1-常数复杂度获取字符串长度\"><a href=\"#2-2-1-常数复杂度获取字符串长度\" class=\"headerlink\" title=\"2.2.1  常数复杂度获取字符串长度\"></a>2.2.1  常数复杂度获取字符串长度</h4><p>因为c语言要知道字符串的长度只能遍历数组，所以复杂度为O(N)。 </p>\n<p>而获取sds的字符串长度，只需要返回len的值就可以了复杂度为O(1)。这样对一个非常长的字符串键反复执行STRLEN命令，也不会对系统性能造成任何影响。</p>\n<h4 id=\"2-2-2-杜绝缓冲区溢出\"><a href=\"#2-2-2-杜绝缓冲区溢出\" class=\"headerlink\" title=\"2.2.2 杜绝缓冲区溢出\"></a>2.2.2 杜绝缓冲区溢出</h4><p>C字符串不记录自身长度会带来易造成缓冲区溢出的问题。 比如使用strcat函数拼接两个字符串，被拼接的字符串要是没有提前分配空间，就会造成缓冲区溢出。（溢出的字节会导致这个字符串内存紧邻的其他字符串的内容被修改）</p>\n<p>而SDS的空间分配策略完全杜绝了发生缓冲区溢出的可能，SDS的API需要修改SDS时，会先检查空间alloc是否满足修改所需的要求。不满足的话会先将空间扩展至修改所需的大小，再执行修改。</p>\n<h4 id=\"2-2-3-减少修改字符串时带来的内存重分配次数\"><a href=\"#2-2-3-减少修改字符串时带来的内存重分配次数\" class=\"headerlink\" title=\"2.2.3 减少修改字符串时带来的内存重分配次数\"></a>2.2.3 减少修改字符串时带来的内存重分配次数</h4><p>C语言字符串用N+1个字节长的数组来保存N个字节的字符串，因为这个关联性所以每次每次增长或者缩短一个C字符串，都要对这个字符串进行一次内存重分配操作。</p>\n<ul>\n<li>执行增长操作 比如append，需要首先通过内存重分配来扩展底层数组的空间大小，否则产生缓冲区溢出</li>\n<li>执行所动操作比如截断操作trime，需要首先通过内存重分配来释放字符串不再使用的空间，否则造成内存泄漏。</li>\n</ul>\n<p>内存重分配涉及复杂的算法，并且可能需要执行系统调用，所以通常是一个比较耗时的操作。这对Redis经常用于速度要求严苛，数据被频繁修改的场合来说，是不可接受的。</p>\n<p>因此SDS通过未使用空间解除了字符串长度和底层数组长度之间的关联：buf的长度可以大于len的长度。 <strong>（4.0版本的源码还未找到对应的函数，所以可能和书上说的有变化了）</strong></p>\n<ol>\n<li><p>空间预分配 ——减少连续执行字符串增长操作所需的内存重分配次数。</p>\n<ul>\n<li><p>用于优化字符串<strong>增长</strong>操作。</p>\n<p>当需要对SDS的空间进行空间扩展时，不仅会对SDS分配修改所必需的空间，还会额外分配未使用空间。</p>\n<p>当len &lt; 1Mb时 alloc = 2*len; 当len &gt;= 1 mb时 alloc= len +1Mb。</p>\n</li>\n</ul>\n<p>源码分析</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Enlarge the free space at the end of the sds string so that the caller</span></span><br><span class=\"line\"><span class=\"comment\"> * is sure that after calling this function can overwrite up to addlen</span></span><br><span class=\"line\"><span class=\"comment\"> * bytes after the end of the string, plus one more byte for nul term.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Note: this does not change the *length* of the sds string as returned</span></span><br><span class=\"line\"><span class=\"comment\"> * by sdslen(), but only the free buffer space we have. */</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdsMakeRoomFor</span><span class=\"params\">(sds s, <span class=\"keyword\">size_t</span> addlen)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *sh, *newsh;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> avail = sdsavail(s);</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> len, newlen;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> type, oldtype = s[<span class=\"number\">-1</span>] &amp; SDS_TYPE_MASK;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> hdrlen;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Return ASAP if there is enough space left. */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (avail &gt;= addlen) <span class=\"keyword\">return</span> s;</span><br><span class=\"line\"></span><br><span class=\"line\">    len = sdslen(s);</span><br><span class=\"line\">    sh = (<span class=\"keyword\">char</span>*)s-sdsHdrSize(oldtype);</span><br><span class=\"line\">    newlen = (len+addlen);  <span class=\"comment\">// 预分配</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newlen &lt; SDS_MAX_PREALLOC)</span><br><span class=\"line\">        newlen *= <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        newlen += SDS_MAX_PREALLOC;</span><br><span class=\"line\"></span><br><span class=\"line\">    type = sdsReqType(newlen);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Don't use type 5: the user is appending to the string and type 5 is</span></span><br><span class=\"line\"><span class=\"comment\">     * not able to remember empty space, so sdsMakeRoomFor() must be called</span></span><br><span class=\"line\"><span class=\"comment\">     * at every appending operation. */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type == SDS_TYPE_5) type = SDS_TYPE_8;</span><br><span class=\"line\"></span><br><span class=\"line\">    hdrlen = sdsHdrSize(type);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldtype==type) &#123;</span><br><span class=\"line\">        newsh = s_realloc(sh, hdrlen+newlen+<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newsh == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        s = (<span class=\"keyword\">char</span>*)newsh+hdrlen;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* Since the header size changes, need to move the string forward,</span></span><br><span class=\"line\"><span class=\"comment\">         * and can't use realloc */</span></span><br><span class=\"line\">        newsh = s_malloc(hdrlen+newlen+<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newsh == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"built_in\">memcpy</span>((<span class=\"keyword\">char</span>*)newsh+hdrlen, s, len+<span class=\"number\">1</span>);</span><br><span class=\"line\">        s_free(sh);</span><br><span class=\"line\">        s = (<span class=\"keyword\">char</span>*)newsh+hdrlen;</span><br><span class=\"line\">        s[<span class=\"number\">-1</span>] = type;</span><br><span class=\"line\">        sdssetlen(s, len);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sdssetalloc(s, newlen);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol>\n<li><p>惰性空间释放</p>\n<ul>\n<li><p>用于优化SDS的字符串<strong>缩短</strong>操作</p>\n<p>缩短SDS保存的字符串时，并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性，将这些字节的数量记录起来，并等待将来使用。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"2-2-4-二进制安全\"><a href=\"#2-2-4-二进制安全\" class=\"headerlink\" title=\"2.2.4 二进制安全\"></a>2.2.4 二进制安全</h4><p>C字符串中的字符必须符合某种编码（如ASCII），除了末尾字符串中间不能有<code>\\0</code> 这个空字符，否则最先被程序读取的空字符将被认为是结尾，导致C字符串只能保存文本数据，而不能保存图片、音频、视频、压缩文件这样的二进制数据。</p>\n<p>所谓二进制安全：以处理二进制的方式来处理SDS存放在buf数组里的数据，程序不会对其中的数据做任何限制、过滤、或者假设，数据在写入时是什么样的，被读取是就是什么样的。因为SDS使用len来判断字符串是否结束。</p>\n<p>所以buf是字节数组，而不是字符数组。</p>\n<h4 id=\"2-2-5-兼容部分C字符串函数\"><a href=\"#2-2-5-兼容部分C字符串函数\" class=\"headerlink\" title=\"2.2.5 兼容部分C字符串函数\"></a>2.2.5 兼容部分C字符串函数</h4><p>因为遵循C字符串以<code>\\0</code>结尾的惯例，所以可以兼容<code>&lt;string.h&gt;/strcasecmp</code> ,<code>&lt;stdio.h&gt;/printf</code> 这些函数。但是是否是书上的使用结构体指针还是博客说的可以直接使用sds来调用？还需验证。</p>\n<p>书：<code>printf(&quot;%s&quot;, sds-&gt;buf)</code>  sds是指向结构体的指针。</p>\n<p>博客：<a href=\"https://blog.csdn.net/yangbodong22011/article/details/78419966\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/yangbodong22011/article/details/78419966</a>   :<code>printf(%s, sds)</code></p>\n<p>源码中是直接使用sds</p>\n<h4 id=\"2-2-6-总结\"><a href=\"#2-2-6-总结\" class=\"headerlink\" title=\"2.2.6 总结\"></a>2.2.6 总结</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">C字符串</th>\n<th style=\"text-align:center\">SDS</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">获取字符串长度复杂度为O(N)</td>\n<td style=\"text-align:center\">获取字符串长度复杂度为O(1)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">API不安全，可能造成缓冲区溢出</td>\n<td style=\"text-align:center\">API安全，不会造成缓冲区溢出</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">修改字符串长度N次必然执行N次内存重分配</td>\n<td style=\"text-align:center\">最多执行N次内存重分配</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">只能保存文本数据</td>\n<td style=\"text-align:center\">二进制安全文本与二进制数据皆可</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">可使用<code>&lt;string.h&gt;</code>库中所有函数</td>\n<td style=\"text-align:center\">部分使用<code>&lt;string.h&gt;</code>库中函数</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"2-3-SDSAPI\"><a href=\"#2-3-SDSAPI\" class=\"headerlink\" title=\"2.3 SDSAPI\"></a>2.3 SDSAPI</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">函数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">sdslen(const sds s)</td>\n<td style=\"text-align:center\">获取sds字符串长度 O（1）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">sdssetlen(sds s, size_t newlen)</td>\n<td style=\"text-align:center\">设置sds字符串长度</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">sdsinclen(sds s, size_t inc)</td>\n<td style=\"text-align:center\">增加sds字符串长度</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">sdsalloc(const sds s)</td>\n<td style=\"text-align:center\">获取sds字符串容量</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">sdssetalloc(sds s, size_t newlen)</td>\n<td style=\"text-align:center\">设置sds字符串容量。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">sdsavail(const sds s)</td>\n<td style=\"text-align:center\">获取sds字符串空余空间（即alloc - len）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">sdsHdrSize(char type)</td>\n<td style=\"text-align:center\">根据header类型得到header大小</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">sdsReqType(size_t string_size)</td>\n<td style=\"text-align:center\">根据字符串数据长度计算所需要的header类型。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"sdsReqType函数源码分析\"><a href=\"#sdsReqType函数源码分析\" class=\"headerlink\" title=\"sdsReqType函数源码分析\"></a>sdsReqType函数源码分析</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">char</span> <span class=\"title\">sdsReqType</span><span class=\"params\">(<span class=\"keyword\">size_t</span> string_size)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (string_size &lt; <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">5</span>) <span class=\"comment\">// string_size &lt; 2^5</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> SDS_TYPE_5;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (string_size &lt; <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">8</span>)  <span class=\"comment\">//string_size &lt; 2^8</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> SDS_TYPE_8;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (string_size &lt; <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">16</span>)\t<span class=\"comment\">//string_size &lt; 2^16</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> SDS_TYPE_16;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> (LONG_MAX == LLONG_MAX)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (string_size &lt; <span class=\"number\">1l</span>l&lt;&lt;<span class=\"number\">32</span>)  <span class=\"comment\">//string_size &lt; 2^32</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> SDS_TYPE_32;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> SDS_TYPE_64; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>采用左移来计算对应多少位的范围，而不是用2^5 这样的乘法。<strong>直接移位比使用幂来计算快很多</strong>。</p>\n<p><code>1&lt;&lt;5</code>   计算出来就是2^5 次方。1是int型，4byte32位。最低8bit位的二进制为：00000001 左移5位后变成了：00100000 对应的十进制既是32。</p>\n<p>计算n个bit位的最大值：(1&lt;&lt;n) -1</p>\n<p>但是需要注意位数不够的情况。因为1是int型，只有32个bit。所以在左移32个bit时，需要使用long long int型。用1ll来表示，此时1ll为64个bit。</p>\n<p>还得考虑机器是否为64位机器，在32位机器上LONG_MAX = 2147483647L，64位机器上LONG_MAX = 9223372036854775807L 。不论32位机器还是64位机器上 LLONG_MAX 都是9223372036854775807L 。所以当LONG_MAX == LLONG_MAX 说明字长为64bit。加上条件编译，说明在32位机器上不使用sdshdr32而直接跳到了sdshdr64，仅仅在64位机器上使用sdshdr32。原因是什么？还没想通</p>\n<h4 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h4><ol>\n<li>为什么Redis需要自己实现字符串功能，而不直接使用c语言的传统字符串？<ul>\n<li>见第二节。</li>\n</ul>\n</li>\n<li>执行SET 与GET命令的过程。</li>\n<li><code>char buf[]</code> 为什么没有指定大小？一个数组占用的内存大小<ul>\n<li>在各个header的定义中最后有一个char buf[]。我们注意到这是一个没有指明长度的字符数组，这是C语言中定义字符数组的一种特殊写法，称为柔性数组（<a href=\"https://en.wikipedia.org/wiki/Flexible_array_member\" target=\"_blank\" rel=\"noopener\">flexible array member</a>），只能定义在一个结构体的最后一个字段上。它在这里只是起到一个标记的作用，表示在flags字段后面就是一个字符数组，或者说，它指明了紧跟在flags字段后面的这个字符数组在结构体中的偏移位置。而程序在为header分配的内存的时候，它并不占用内存空间。如果计算sizeof(struct sdshdr16)的值，那么结果是5个字节，其中没有buf字段。</li>\n<li>数组内存大小为分配的的长度*数组类型的内存大小</li>\n</ul>\n</li>\n<li>为什么redis 在32位机器上不使用sdshdr32？ </li>\n</ol>"},{"title":"使用Travis-CI自动部署博客","date":"2019-03-26T01:52:01.000Z","copyright":true,"_content":"\n# 使用Travis-CI自动部署博客\n\n因为在github上面存储的是编译好的html代码，不是hexo博客中的博客源文件，所以如果没有备份源文件的话，丢失了源文件（包括md,一堆配置文件）后就不能继续更新博客了，而且也不能多端部署Hexo。网上看到可以使用Travis-CI来自动部署，同时解决了博客源文件的备份问题。\n\n<!--more-->\n\n## 新建hexo分支来保存源文件\n\n### 新建分支\n\n直接在对应的github.io项目上的branch 按钮处点击新建分支 hexo。\n\n官方文档<https://help.github.com/en/articles/setting-the-default-branch> \n\n```\n# 克隆项目到本地\n> git clone https://github.com/BraveY/BraveY.github.io.git\n```\n\n### 设置默认分支\n\n参照官方文档设置<https://help.github.com/en/articles/setting-the-default-branch>\n\n### 修改推送hexo分支\n\n现将原来的文件BraveY.github.io 修改为BraveY.github.io.bak 避免拷贝的时候出现文件夹重名，同时将原来的hexo 目录blog文件也修改为blog.bak\n\n直接克隆到 本地\n\n ```\n# 克隆项目到本地\n> git clone https://github.com/BraveY/BraveY.github.io.git\n ```\n\n这时拷贝的项目已经是hexo分支下面的，因为之前是设置了hexo分支作为默认分支的。\n\n将克隆的BraveY.github.io文件夹重命名为blog\n\n在克隆的文件夹里面删除除了.git的所有文件\n\n**注意** ：因为主题的next也是个git仓库，所以需要先把next目录下的.git删除\n\n然后先把theme/next 目录下的.git 给删除掉，不然的话next这个主题本来就是个git仓库，里面的个性化配置是无法上传到自己的项目中的，而且以后也无法克隆。\n\n从blog.bak文件中把所有hexo的源码文件拷过来。\n\n在博客目录下初始化git仓库并将所有文件提交。\n\n添加到远程仓库\n\n```\ngit add . \ngit commit -m\"description\"\ngit push origin \n```\n\n现在hexo分支已经是存放了hexo的源文件了。\n\n## 设置Travis CI\n\n主要参考下面的三个博客，\n\n### Travis CI 官网登陆\n\n使用github账号登陆[Travis CI官网](https://travis-ci.org/)  ，选择博客项目启动。然后进行设置。\n\n没有文章中说的`Build only if .travis.yml is present` 选项，但好像没有影响，采用默认的选项。\n\n### github生成Access Token\n\n参考博客，不赘述。\n\n## Travis CI \n\n### 配置travis.yml\n\n在blog根目录下设置travis配置文件。\n\n.travis.yml 文件的配置为：\n\n```yaml\nlanguage: node_js # 设置语言\nnode_js: stable # 设置相应版本\ncache:\n  apt: true\n  directories:\n  - node_modules  # 缓存不经常更改的内容\nbefore_install:\n- export TZ='Asia/Shanghai' # 更改时区\ninstall:\n- npm install\nscript:\n- hexo clean\n- hexo g \nafter_script:\n- git clone https://${GH_REF} .deploy_git\n- cd .deploy_git\n- git checkout master\n- cd ../\n- mv .deploy_git/.git/ ./public/\n- cd ./public\n- git config user.name \"BraveY\"\n- git config user.email \"lsz_yky@163.com\"\n- git add .\n- git commit -m \"Travis CI Auto Builder at `date +\"%Y-%m-%d %H:%M\"`\"\n- git push --force --quiet \"https://${github_blog@${GH_REF}\" master:master\nbranches:\n  only:\n  - hexo\nenv:\n  global:\n  - GH_REF: github.com/BraveY/BraveY.github.io.git\nnotifications:\n  email:\n  - lsz_yky@163.com\n  on_success: change\n  on_failure: always\n```\n\n### 新增文章到_posts \n\n增减文章后，使用git push 命令即可，自动部署。\n\n可以看到 Travis CI 上面构建的一系列输出，但是博客并没有更新，而且github上的master分支也没有更改过。查看Travis CI 上的输出信息，发现在执行\n\n`git push --force --quiet \"https://${github_blog@${GH_REF}\" master:master` 这句后报错：\n\n```\n/home/travis/.travis/functions: eval: line 104: unexpected EOF while looking for matching `\"'\n/home/travis/.travis/functions: eval: line 105: syntax error: unexpected end of file\n```\n\n然后发现`${github_blog@${GH_REF}` 这句花括号没有对齐匹配，无语。加上漏掉的右边花括号} 重新执行操作。一切正常。\n\n## 博客更新操作\n\n后面就不用自己`hexo g -d ` 了\n\n在_posts目录下增加文章后\n\n```\ngit add .\ngit commit -m\"\"\ngit push origin\n```\n\n感觉可以写个脚本\n\n命名为git_script.ps1  以后直接用powershell运行这个脚本就可以了。\n\n```\ngit add .\n$date = get-date -uformat \"%Y-%m-%d %H:%M:%S\"\ngit commit -m\"new post $date\"\ngit push origin\n```\n\n\n\n## 参考\n\n<https://www.itfanr.cc/2017/08/09/using-travis-ci-automatic-deploy-hexo-blogs/>\n\n<http://www.dxjia.cn/2016/01/27/hexo-write-everywhere/>\n\n<http://www.yanglangjing.com/2018/08/28/travis_ci_auto_deploy_hexo_to_vps/>\n\n","source":"_posts/2019-03-26-使用Travis-CI自动部署博客.md","raw":"---\ntitle: 使用Travis-CI自动部署博客\ndate: 2019-03-26 09:52:01\ncategories: Hexo\ntags:\n- Hexo \n- Travis-CI\ncopyright: true\n---\n\n# 使用Travis-CI自动部署博客\n\n因为在github上面存储的是编译好的html代码，不是hexo博客中的博客源文件，所以如果没有备份源文件的话，丢失了源文件（包括md,一堆配置文件）后就不能继续更新博客了，而且也不能多端部署Hexo。网上看到可以使用Travis-CI来自动部署，同时解决了博客源文件的备份问题。\n\n<!--more-->\n\n## 新建hexo分支来保存源文件\n\n### 新建分支\n\n直接在对应的github.io项目上的branch 按钮处点击新建分支 hexo。\n\n官方文档<https://help.github.com/en/articles/setting-the-default-branch> \n\n```\n# 克隆项目到本地\n> git clone https://github.com/BraveY/BraveY.github.io.git\n```\n\n### 设置默认分支\n\n参照官方文档设置<https://help.github.com/en/articles/setting-the-default-branch>\n\n### 修改推送hexo分支\n\n现将原来的文件BraveY.github.io 修改为BraveY.github.io.bak 避免拷贝的时候出现文件夹重名，同时将原来的hexo 目录blog文件也修改为blog.bak\n\n直接克隆到 本地\n\n ```\n# 克隆项目到本地\n> git clone https://github.com/BraveY/BraveY.github.io.git\n ```\n\n这时拷贝的项目已经是hexo分支下面的，因为之前是设置了hexo分支作为默认分支的。\n\n将克隆的BraveY.github.io文件夹重命名为blog\n\n在克隆的文件夹里面删除除了.git的所有文件\n\n**注意** ：因为主题的next也是个git仓库，所以需要先把next目录下的.git删除\n\n然后先把theme/next 目录下的.git 给删除掉，不然的话next这个主题本来就是个git仓库，里面的个性化配置是无法上传到自己的项目中的，而且以后也无法克隆。\n\n从blog.bak文件中把所有hexo的源码文件拷过来。\n\n在博客目录下初始化git仓库并将所有文件提交。\n\n添加到远程仓库\n\n```\ngit add . \ngit commit -m\"description\"\ngit push origin \n```\n\n现在hexo分支已经是存放了hexo的源文件了。\n\n## 设置Travis CI\n\n主要参考下面的三个博客，\n\n### Travis CI 官网登陆\n\n使用github账号登陆[Travis CI官网](https://travis-ci.org/)  ，选择博客项目启动。然后进行设置。\n\n没有文章中说的`Build only if .travis.yml is present` 选项，但好像没有影响，采用默认的选项。\n\n### github生成Access Token\n\n参考博客，不赘述。\n\n## Travis CI \n\n### 配置travis.yml\n\n在blog根目录下设置travis配置文件。\n\n.travis.yml 文件的配置为：\n\n```yaml\nlanguage: node_js # 设置语言\nnode_js: stable # 设置相应版本\ncache:\n  apt: true\n  directories:\n  - node_modules  # 缓存不经常更改的内容\nbefore_install:\n- export TZ='Asia/Shanghai' # 更改时区\ninstall:\n- npm install\nscript:\n- hexo clean\n- hexo g \nafter_script:\n- git clone https://${GH_REF} .deploy_git\n- cd .deploy_git\n- git checkout master\n- cd ../\n- mv .deploy_git/.git/ ./public/\n- cd ./public\n- git config user.name \"BraveY\"\n- git config user.email \"lsz_yky@163.com\"\n- git add .\n- git commit -m \"Travis CI Auto Builder at `date +\"%Y-%m-%d %H:%M\"`\"\n- git push --force --quiet \"https://${github_blog@${GH_REF}\" master:master\nbranches:\n  only:\n  - hexo\nenv:\n  global:\n  - GH_REF: github.com/BraveY/BraveY.github.io.git\nnotifications:\n  email:\n  - lsz_yky@163.com\n  on_success: change\n  on_failure: always\n```\n\n### 新增文章到_posts \n\n增减文章后，使用git push 命令即可，自动部署。\n\n可以看到 Travis CI 上面构建的一系列输出，但是博客并没有更新，而且github上的master分支也没有更改过。查看Travis CI 上的输出信息，发现在执行\n\n`git push --force --quiet \"https://${github_blog@${GH_REF}\" master:master` 这句后报错：\n\n```\n/home/travis/.travis/functions: eval: line 104: unexpected EOF while looking for matching `\"'\n/home/travis/.travis/functions: eval: line 105: syntax error: unexpected end of file\n```\n\n然后发现`${github_blog@${GH_REF}` 这句花括号没有对齐匹配，无语。加上漏掉的右边花括号} 重新执行操作。一切正常。\n\n## 博客更新操作\n\n后面就不用自己`hexo g -d ` 了\n\n在_posts目录下增加文章后\n\n```\ngit add .\ngit commit -m\"\"\ngit push origin\n```\n\n感觉可以写个脚本\n\n命名为git_script.ps1  以后直接用powershell运行这个脚本就可以了。\n\n```\ngit add .\n$date = get-date -uformat \"%Y-%m-%d %H:%M:%S\"\ngit commit -m\"new post $date\"\ngit push origin\n```\n\n\n\n## 参考\n\n<https://www.itfanr.cc/2017/08/09/using-travis-ci-automatic-deploy-hexo-blogs/>\n\n<http://www.dxjia.cn/2016/01/27/hexo-write-everywhere/>\n\n<http://www.yanglangjing.com/2018/08/28/travis_ci_auto_deploy_hexo_to_vps/>\n\n","slug":"2019-03-26-使用Travis-CI自动部署博客","published":1,"updated":"2019-11-14T12:18:36.776Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6he13xy0004dstzz05m0d43","content":"<h1 id=\"使用Travis-CI自动部署博客\"><a href=\"#使用Travis-CI自动部署博客\" class=\"headerlink\" title=\"使用Travis-CI自动部署博客\"></a>使用Travis-CI自动部署博客</h1><p>因为在github上面存储的是编译好的html代码，不是hexo博客中的博客源文件，所以如果没有备份源文件的话，丢失了源文件（包括md,一堆配置文件）后就不能继续更新博客了，而且也不能多端部署Hexo。网上看到可以使用Travis-CI来自动部署，同时解决了博客源文件的备份问题。</p>\n<a id=\"more\"></a>\n<h2 id=\"新建hexo分支来保存源文件\"><a href=\"#新建hexo分支来保存源文件\" class=\"headerlink\" title=\"新建hexo分支来保存源文件\"></a>新建hexo分支来保存源文件</h2><h3 id=\"新建分支\"><a href=\"#新建分支\" class=\"headerlink\" title=\"新建分支\"></a>新建分支</h3><p>直接在对应的github.io项目上的branch 按钮处点击新建分支 hexo。</p>\n<p>官方文档<a href=\"https://help.github.com/en/articles/setting-the-default-branch\" target=\"_blank\" rel=\"noopener\">https://help.github.com/en/articles/setting-the-default-branch</a> </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 克隆项目到本地</span><br><span class=\"line\">&gt; git clone https://github.com/BraveY/BraveY.github.io.git</span><br></pre></td></tr></table></figure>\n<h3 id=\"设置默认分支\"><a href=\"#设置默认分支\" class=\"headerlink\" title=\"设置默认分支\"></a>设置默认分支</h3><p>参照官方文档设置<a href=\"https://help.github.com/en/articles/setting-the-default-branch\" target=\"_blank\" rel=\"noopener\">https://help.github.com/en/articles/setting-the-default-branch</a></p>\n<h3 id=\"修改推送hexo分支\"><a href=\"#修改推送hexo分支\" class=\"headerlink\" title=\"修改推送hexo分支\"></a>修改推送hexo分支</h3><p>现将原来的文件BraveY.github.io 修改为BraveY.github.io.bak 避免拷贝的时候出现文件夹重名，同时将原来的hexo 目录blog文件也修改为blog.bak</p>\n<p>直接克隆到 本地</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 克隆项目到本地</span><br><span class=\"line\">&gt; git clone https://github.com/BraveY/BraveY.github.io.git</span><br></pre></td></tr></table></figure>\n<p>这时拷贝的项目已经是hexo分支下面的，因为之前是设置了hexo分支作为默认分支的。</p>\n<p>将克隆的BraveY.github.io文件夹重命名为blog</p>\n<p>在克隆的文件夹里面删除除了.git的所有文件</p>\n<p><strong>注意</strong> ：因为主题的next也是个git仓库，所以需要先把next目录下的.git删除</p>\n<p>然后先把theme/next 目录下的.git 给删除掉，不然的话next这个主题本来就是个git仓库，里面的个性化配置是无法上传到自己的项目中的，而且以后也无法克隆。</p>\n<p>从blog.bak文件中把所有hexo的源码文件拷过来。</p>\n<p>在博客目录下初始化git仓库并将所有文件提交。</p>\n<p>添加到远程仓库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add . </span><br><span class=\"line\">git commit -m&quot;description&quot;</span><br><span class=\"line\">git push origin</span><br></pre></td></tr></table></figure>\n<p>现在hexo分支已经是存放了hexo的源文件了。</p>\n<h2 id=\"设置Travis-CI\"><a href=\"#设置Travis-CI\" class=\"headerlink\" title=\"设置Travis CI\"></a>设置Travis CI</h2><p>主要参考下面的三个博客，</p>\n<h3 id=\"Travis-CI-官网登陆\"><a href=\"#Travis-CI-官网登陆\" class=\"headerlink\" title=\"Travis CI 官网登陆\"></a>Travis CI 官网登陆</h3><p>使用github账号登陆<a href=\"https://travis-ci.org/\" target=\"_blank\" rel=\"noopener\">Travis CI官网</a>  ，选择博客项目启动。然后进行设置。</p>\n<p>没有文章中说的<code>Build only if .travis.yml is present</code> 选项，但好像没有影响，采用默认的选项。</p>\n<h3 id=\"github生成Access-Token\"><a href=\"#github生成Access-Token\" class=\"headerlink\" title=\"github生成Access Token\"></a>github生成Access Token</h3><p>参考博客，不赘述。</p>\n<h2 id=\"Travis-CI\"><a href=\"#Travis-CI\" class=\"headerlink\" title=\"Travis CI\"></a>Travis CI</h2><h3 id=\"配置travis-yml\"><a href=\"#配置travis-yml\" class=\"headerlink\" title=\"配置travis.yml\"></a>配置travis.yml</h3><p>在blog根目录下设置travis配置文件。</p>\n<p>.travis.yml 文件的配置为：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">language:</span> <span class=\"string\">node_js</span> <span class=\"comment\"># 设置语言</span></span><br><span class=\"line\"><span class=\"attr\">node_js:</span> <span class=\"string\">stable</span> <span class=\"comment\"># 设置相应版本</span></span><br><span class=\"line\"><span class=\"attr\">cache:</span></span><br><span class=\"line\"><span class=\"attr\">  apt:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">  directories:</span></span><br><span class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">node_modules</span>  <span class=\"comment\"># 缓存不经常更改的内容</span></span><br><span class=\"line\"><span class=\"attr\">before_install:</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">export</span> <span class=\"string\">TZ='Asia/Shanghai'</span> <span class=\"comment\"># 更改时区</span></span><br><span class=\"line\"><span class=\"attr\">install:</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">npm</span> <span class=\"string\">install</span></span><br><span class=\"line\"><span class=\"attr\">script:</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">hexo</span> <span class=\"string\">clean</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">hexo</span> <span class=\"string\">g</span> </span><br><span class=\"line\"><span class=\"attr\">after_script:</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">git</span> <span class=\"string\">clone</span> <span class=\"attr\">https://$&#123;GH_REF&#125;</span> <span class=\"string\">.deploy_git</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">cd</span> <span class=\"string\">.deploy_git</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">git</span> <span class=\"string\">checkout</span> <span class=\"string\">master</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">cd</span> <span class=\"string\">../</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">mv</span> <span class=\"string\">.deploy_git/.git/</span> <span class=\"string\">./public/</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">cd</span> <span class=\"string\">./public</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">git</span> <span class=\"string\">config</span> <span class=\"string\">user.name</span> <span class=\"string\">\"BraveY\"</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">git</span> <span class=\"string\">config</span> <span class=\"string\">user.email</span> <span class=\"string\">\"lsz_yky@163.com\"</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">git</span> <span class=\"string\">add</span> <span class=\"string\">.</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">git</span> <span class=\"string\">commit</span> <span class=\"bullet\">-m</span> <span class=\"string\">\"Travis CI Auto Builder at `date +\"</span><span class=\"string\">%Y-%m-%d</span> <span class=\"string\">%H:%M\"`\"</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">git</span> <span class=\"string\">push</span> <span class=\"bullet\">--force</span> <span class=\"bullet\">--quiet</span> <span class=\"string\">\"https://$&#123;github_blog@$&#123;GH_REF&#125;\"</span> <span class=\"attr\">master:master</span></span><br><span class=\"line\"><span class=\"attr\">branches:</span></span><br><span class=\"line\"><span class=\"attr\">  only:</span></span><br><span class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">hexo</span></span><br><span class=\"line\"><span class=\"attr\">env:</span></span><br><span class=\"line\"><span class=\"attr\">  global:</span></span><br><span class=\"line\"><span class=\"attr\">  - GH_REF:</span> <span class=\"string\">github.com/BraveY/BraveY.github.io.git</span></span><br><span class=\"line\"><span class=\"attr\">notifications:</span></span><br><span class=\"line\"><span class=\"attr\">  email:</span></span><br><span class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">lsz_yky@163.com</span></span><br><span class=\"line\"><span class=\"attr\">  on_success:</span> <span class=\"string\">change</span></span><br><span class=\"line\"><span class=\"attr\">  on_failure:</span> <span class=\"string\">always</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"新增文章到-posts\"><a href=\"#新增文章到-posts\" class=\"headerlink\" title=\"新增文章到_posts\"></a>新增文章到_posts</h3><p>增减文章后，使用git push 命令即可，自动部署。</p>\n<p>可以看到 Travis CI 上面构建的一系列输出，但是博客并没有更新，而且github上的master分支也没有更改过。查看Travis CI 上的输出信息，发现在执行</p>\n<p><code>git push --force --quiet &quot;https://${github_blog@${GH_REF}&quot; master:master</code> 这句后报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/home/travis/.travis/functions: eval: line 104: unexpected EOF while looking for matching `&quot;&apos;</span><br><span class=\"line\">/home/travis/.travis/functions: eval: line 105: syntax error: unexpected end of file</span><br></pre></td></tr></table></figure>\n<p>然后发现<code>${github_blog@${GH_REF}</code> 这句花括号没有对齐匹配，无语。加上漏掉的右边花括号} 重新执行操作。一切正常。</p>\n<h2 id=\"博客更新操作\"><a href=\"#博客更新操作\" class=\"headerlink\" title=\"博客更新操作\"></a>博客更新操作</h2><p>后面就不用自己<code>hexo g -d</code> 了</p>\n<p>在_posts目录下增加文章后</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m&quot;&quot;</span><br><span class=\"line\">git push origin</span><br></pre></td></tr></table></figure>\n<p>感觉可以写个脚本</p>\n<p>命名为git_script.ps1  以后直接用powershell运行这个脚本就可以了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">$date = get-date -uformat &quot;%Y-%m-%d %H:%M:%S&quot;</span><br><span class=\"line\">git commit -m&quot;new post $date&quot;</span><br><span class=\"line\">git push origin</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://www.itfanr.cc/2017/08/09/using-travis-ci-automatic-deploy-hexo-blogs/\" target=\"_blank\" rel=\"noopener\">https://www.itfanr.cc/2017/08/09/using-travis-ci-automatic-deploy-hexo-blogs/</a></p>\n<p><a href=\"http://www.dxjia.cn/2016/01/27/hexo-write-everywhere/\" target=\"_blank\" rel=\"noopener\">http://www.dxjia.cn/2016/01/27/hexo-write-everywhere/</a></p>\n<p><a href=\"http://www.yanglangjing.com/2018/08/28/travis_ci_auto_deploy_hexo_to_vps/\" target=\"_blank\" rel=\"noopener\">http://www.yanglangjing.com/2018/08/28/travis_ci_auto_deploy_hexo_to_vps/</a></p>\n","site":{"data":{}},"length":2794,"excerpt":"<h1 id=\"使用Travis-CI自动部署博客\"><a href=\"#使用Travis-CI自动部署博客\" class=\"headerlink\" title=\"使用Travis-CI自动部署博客\"></a>使用Travis-CI自动部署博客</h1><p>因为在github上面存储的是编译好的html代码，不是hexo博客中的博客源文件，所以如果没有备份源文件的话，丢失了源文件（包括md,一堆配置文件）后就不能继续更新博客了，而且也不能多端部署Hexo。网上看到可以使用Travis-CI来自动部署，同时解决了博客源文件的备份问题。</p>","more":"<h2 id=\"新建hexo分支来保存源文件\"><a href=\"#新建hexo分支来保存源文件\" class=\"headerlink\" title=\"新建hexo分支来保存源文件\"></a>新建hexo分支来保存源文件</h2><h3 id=\"新建分支\"><a href=\"#新建分支\" class=\"headerlink\" title=\"新建分支\"></a>新建分支</h3><p>直接在对应的github.io项目上的branch 按钮处点击新建分支 hexo。</p>\n<p>官方文档<a href=\"https://help.github.com/en/articles/setting-the-default-branch\" target=\"_blank\" rel=\"noopener\">https://help.github.com/en/articles/setting-the-default-branch</a> </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 克隆项目到本地</span><br><span class=\"line\">&gt; git clone https://github.com/BraveY/BraveY.github.io.git</span><br></pre></td></tr></table></figure>\n<h3 id=\"设置默认分支\"><a href=\"#设置默认分支\" class=\"headerlink\" title=\"设置默认分支\"></a>设置默认分支</h3><p>参照官方文档设置<a href=\"https://help.github.com/en/articles/setting-the-default-branch\" target=\"_blank\" rel=\"noopener\">https://help.github.com/en/articles/setting-the-default-branch</a></p>\n<h3 id=\"修改推送hexo分支\"><a href=\"#修改推送hexo分支\" class=\"headerlink\" title=\"修改推送hexo分支\"></a>修改推送hexo分支</h3><p>现将原来的文件BraveY.github.io 修改为BraveY.github.io.bak 避免拷贝的时候出现文件夹重名，同时将原来的hexo 目录blog文件也修改为blog.bak</p>\n<p>直接克隆到 本地</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 克隆项目到本地</span><br><span class=\"line\">&gt; git clone https://github.com/BraveY/BraveY.github.io.git</span><br></pre></td></tr></table></figure>\n<p>这时拷贝的项目已经是hexo分支下面的，因为之前是设置了hexo分支作为默认分支的。</p>\n<p>将克隆的BraveY.github.io文件夹重命名为blog</p>\n<p>在克隆的文件夹里面删除除了.git的所有文件</p>\n<p><strong>注意</strong> ：因为主题的next也是个git仓库，所以需要先把next目录下的.git删除</p>\n<p>然后先把theme/next 目录下的.git 给删除掉，不然的话next这个主题本来就是个git仓库，里面的个性化配置是无法上传到自己的项目中的，而且以后也无法克隆。</p>\n<p>从blog.bak文件中把所有hexo的源码文件拷过来。</p>\n<p>在博客目录下初始化git仓库并将所有文件提交。</p>\n<p>添加到远程仓库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add . </span><br><span class=\"line\">git commit -m&quot;description&quot;</span><br><span class=\"line\">git push origin</span><br></pre></td></tr></table></figure>\n<p>现在hexo分支已经是存放了hexo的源文件了。</p>\n<h2 id=\"设置Travis-CI\"><a href=\"#设置Travis-CI\" class=\"headerlink\" title=\"设置Travis CI\"></a>设置Travis CI</h2><p>主要参考下面的三个博客，</p>\n<h3 id=\"Travis-CI-官网登陆\"><a href=\"#Travis-CI-官网登陆\" class=\"headerlink\" title=\"Travis CI 官网登陆\"></a>Travis CI 官网登陆</h3><p>使用github账号登陆<a href=\"https://travis-ci.org/\" target=\"_blank\" rel=\"noopener\">Travis CI官网</a>  ，选择博客项目启动。然后进行设置。</p>\n<p>没有文章中说的<code>Build only if .travis.yml is present</code> 选项，但好像没有影响，采用默认的选项。</p>\n<h3 id=\"github生成Access-Token\"><a href=\"#github生成Access-Token\" class=\"headerlink\" title=\"github生成Access Token\"></a>github生成Access Token</h3><p>参考博客，不赘述。</p>\n<h2 id=\"Travis-CI\"><a href=\"#Travis-CI\" class=\"headerlink\" title=\"Travis CI\"></a>Travis CI</h2><h3 id=\"配置travis-yml\"><a href=\"#配置travis-yml\" class=\"headerlink\" title=\"配置travis.yml\"></a>配置travis.yml</h3><p>在blog根目录下设置travis配置文件。</p>\n<p>.travis.yml 文件的配置为：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">language:</span> <span class=\"string\">node_js</span> <span class=\"comment\"># 设置语言</span></span><br><span class=\"line\"><span class=\"attr\">node_js:</span> <span class=\"string\">stable</span> <span class=\"comment\"># 设置相应版本</span></span><br><span class=\"line\"><span class=\"attr\">cache:</span></span><br><span class=\"line\"><span class=\"attr\">  apt:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">  directories:</span></span><br><span class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">node_modules</span>  <span class=\"comment\"># 缓存不经常更改的内容</span></span><br><span class=\"line\"><span class=\"attr\">before_install:</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">export</span> <span class=\"string\">TZ='Asia/Shanghai'</span> <span class=\"comment\"># 更改时区</span></span><br><span class=\"line\"><span class=\"attr\">install:</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">npm</span> <span class=\"string\">install</span></span><br><span class=\"line\"><span class=\"attr\">script:</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">hexo</span> <span class=\"string\">clean</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">hexo</span> <span class=\"string\">g</span> </span><br><span class=\"line\"><span class=\"attr\">after_script:</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">git</span> <span class=\"string\">clone</span> <span class=\"attr\">https://$&#123;GH_REF&#125;</span> <span class=\"string\">.deploy_git</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">cd</span> <span class=\"string\">.deploy_git</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">git</span> <span class=\"string\">checkout</span> <span class=\"string\">master</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">cd</span> <span class=\"string\">../</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">mv</span> <span class=\"string\">.deploy_git/.git/</span> <span class=\"string\">./public/</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">cd</span> <span class=\"string\">./public</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">git</span> <span class=\"string\">config</span> <span class=\"string\">user.name</span> <span class=\"string\">\"BraveY\"</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">git</span> <span class=\"string\">config</span> <span class=\"string\">user.email</span> <span class=\"string\">\"lsz_yky@163.com\"</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">git</span> <span class=\"string\">add</span> <span class=\"string\">.</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">git</span> <span class=\"string\">commit</span> <span class=\"bullet\">-m</span> <span class=\"string\">\"Travis CI Auto Builder at `date +\"</span><span class=\"string\">%Y-%m-%d</span> <span class=\"string\">%H:%M\"`\"</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">git</span> <span class=\"string\">push</span> <span class=\"bullet\">--force</span> <span class=\"bullet\">--quiet</span> <span class=\"string\">\"https://$&#123;github_blog@$&#123;GH_REF&#125;\"</span> <span class=\"attr\">master:master</span></span><br><span class=\"line\"><span class=\"attr\">branches:</span></span><br><span class=\"line\"><span class=\"attr\">  only:</span></span><br><span class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">hexo</span></span><br><span class=\"line\"><span class=\"attr\">env:</span></span><br><span class=\"line\"><span class=\"attr\">  global:</span></span><br><span class=\"line\"><span class=\"attr\">  - GH_REF:</span> <span class=\"string\">github.com/BraveY/BraveY.github.io.git</span></span><br><span class=\"line\"><span class=\"attr\">notifications:</span></span><br><span class=\"line\"><span class=\"attr\">  email:</span></span><br><span class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">lsz_yky@163.com</span></span><br><span class=\"line\"><span class=\"attr\">  on_success:</span> <span class=\"string\">change</span></span><br><span class=\"line\"><span class=\"attr\">  on_failure:</span> <span class=\"string\">always</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"新增文章到-posts\"><a href=\"#新增文章到-posts\" class=\"headerlink\" title=\"新增文章到_posts\"></a>新增文章到_posts</h3><p>增减文章后，使用git push 命令即可，自动部署。</p>\n<p>可以看到 Travis CI 上面构建的一系列输出，但是博客并没有更新，而且github上的master分支也没有更改过。查看Travis CI 上的输出信息，发现在执行</p>\n<p><code>git push --force --quiet &quot;https://${github_blog@${GH_REF}&quot; master:master</code> 这句后报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/home/travis/.travis/functions: eval: line 104: unexpected EOF while looking for matching `&quot;&apos;</span><br><span class=\"line\">/home/travis/.travis/functions: eval: line 105: syntax error: unexpected end of file</span><br></pre></td></tr></table></figure>\n<p>然后发现<code>${github_blog@${GH_REF}</code> 这句花括号没有对齐匹配，无语。加上漏掉的右边花括号} 重新执行操作。一切正常。</p>\n<h2 id=\"博客更新操作\"><a href=\"#博客更新操作\" class=\"headerlink\" title=\"博客更新操作\"></a>博客更新操作</h2><p>后面就不用自己<code>hexo g -d</code> 了</p>\n<p>在_posts目录下增加文章后</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m&quot;&quot;</span><br><span class=\"line\">git push origin</span><br></pre></td></tr></table></figure>\n<p>感觉可以写个脚本</p>\n<p>命名为git_script.ps1  以后直接用powershell运行这个脚本就可以了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">$date = get-date -uformat &quot;%Y-%m-%d %H:%M:%S&quot;</span><br><span class=\"line\">git commit -m&quot;new post $date&quot;</span><br><span class=\"line\">git push origin</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://www.itfanr.cc/2017/08/09/using-travis-ci-automatic-deploy-hexo-blogs/\" target=\"_blank\" rel=\"noopener\">https://www.itfanr.cc/2017/08/09/using-travis-ci-automatic-deploy-hexo-blogs/</a></p>\n<p><a href=\"http://www.dxjia.cn/2016/01/27/hexo-write-everywhere/\" target=\"_blank\" rel=\"noopener\">http://www.dxjia.cn/2016/01/27/hexo-write-everywhere/</a></p>\n<p><a href=\"http://www.yanglangjing.com/2018/08/28/travis_ci_auto_deploy_hexo_to_vps/\" target=\"_blank\" rel=\"noopener\">http://www.yanglangjing.com/2018/08/28/travis_ci_auto_deploy_hexo_to_vps/</a></p>"},{"title":"Docker 学习","date":"2019-04-01T06:18:41.000Z","copyright":true,"_content":"\n# Docker 学习\n\n之前一直听说容器可以免去配置环境的麻烦，但是一直没有机会接触，现在刚好有机会可以使用。\n\n<!--more-->\n\n## 三大基础\n\n镜像、容器、仓库\n\n类比的话：镜像是类（iso），容器是实例（操作系统），仓库类似于git的仓库。\n\n镜像的构建是一层层的继承而来的，镜像和容器都是文件，容器退出的时候容器文件依然存在。除非手动使用-rm指定，才会删除。\n\n## 命令\n\n加载镜像，进入一个新的容器：`docker run image:tag command`\n\n实例 摘自：<https://yeasy.gitbooks.io/docker_practice/image/pull.html>\n\n```bash\ndocker run -it --rm \\\n    ubuntu:18.04 \\\n    bash\n```\n\n`docker run` 就是运行容器的命令 从镜像中新建一个容器\n\n- `-it`：这是两个参数，一个是 `-i`：交互式操作，一个是 `-t` 终端。我们这里打算进入 `bash` 执行一些命令并查看返回结果，因此我们需要交互式终端。\n- `--rm`：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 `docker rm`。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 `--rm` 可以避免浪费空间。\n- `ubuntu:18.04`：这是指用 `ubuntu:18.04` 镜像为基础来启动容器。\n- `bash`：放在镜像名后的是**命令**，这里我们希望有个交互式 Shell，因此用的是 `bash`。\n\n退出: 在容器中`exit`\n\n进入容器：\n\n`docker exec`  进入一个已有的容器。 （容器需要已经运行）\n\n`dcoker cp  `  容器的复制\n\n`docker ps ` 列出启动容器 `docker ps -a ` 列出所有容器包括关闭的。\n\n启动之前关闭的容器： `docker start container-name ` ， \n\n需要先启动容器，才能执行`docker exec  container-name`\n\n## 端口映射\n\n<https://blog.csdn.net/wanglei_storage/article/details/48471753>\n\n## 参考\n\n<https://juejin.im/entry/5b19e350e51d45069f5e1d66>\n\n<https://yeasy.gitbooks.io/docker_practice/basic_concept/container.html>\n\n<https://blog.csdn.net/u010246789/article/details/53958662>","source":"_posts/2019-04-01-Docker-学习.md","raw":"---\ntitle: Docker 学习\ndate: 2019-04-01 14:18:41\ncategories: Linux\ntags:\n- docker\n- 容器\ncopyright: true\n---\n\n# Docker 学习\n\n之前一直听说容器可以免去配置环境的麻烦，但是一直没有机会接触，现在刚好有机会可以使用。\n\n<!--more-->\n\n## 三大基础\n\n镜像、容器、仓库\n\n类比的话：镜像是类（iso），容器是实例（操作系统），仓库类似于git的仓库。\n\n镜像的构建是一层层的继承而来的，镜像和容器都是文件，容器退出的时候容器文件依然存在。除非手动使用-rm指定，才会删除。\n\n## 命令\n\n加载镜像，进入一个新的容器：`docker run image:tag command`\n\n实例 摘自：<https://yeasy.gitbooks.io/docker_practice/image/pull.html>\n\n```bash\ndocker run -it --rm \\\n    ubuntu:18.04 \\\n    bash\n```\n\n`docker run` 就是运行容器的命令 从镜像中新建一个容器\n\n- `-it`：这是两个参数，一个是 `-i`：交互式操作，一个是 `-t` 终端。我们这里打算进入 `bash` 执行一些命令并查看返回结果，因此我们需要交互式终端。\n- `--rm`：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 `docker rm`。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 `--rm` 可以避免浪费空间。\n- `ubuntu:18.04`：这是指用 `ubuntu:18.04` 镜像为基础来启动容器。\n- `bash`：放在镜像名后的是**命令**，这里我们希望有个交互式 Shell，因此用的是 `bash`。\n\n退出: 在容器中`exit`\n\n进入容器：\n\n`docker exec`  进入一个已有的容器。 （容器需要已经运行）\n\n`dcoker cp  `  容器的复制\n\n`docker ps ` 列出启动容器 `docker ps -a ` 列出所有容器包括关闭的。\n\n启动之前关闭的容器： `docker start container-name ` ， \n\n需要先启动容器，才能执行`docker exec  container-name`\n\n## 端口映射\n\n<https://blog.csdn.net/wanglei_storage/article/details/48471753>\n\n## 参考\n\n<https://juejin.im/entry/5b19e350e51d45069f5e1d66>\n\n<https://yeasy.gitbooks.io/docker_practice/basic_concept/container.html>\n\n<https://blog.csdn.net/u010246789/article/details/53958662>","slug":"2019-04-01-Docker-学习","published":1,"updated":"2019-11-08T13:13:52.912Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6he13y30007dstz9fcphdrz","content":"<h1 id=\"Docker-学习\"><a href=\"#Docker-学习\" class=\"headerlink\" title=\"Docker 学习\"></a>Docker 学习</h1><p>之前一直听说容器可以免去配置环境的麻烦，但是一直没有机会接触，现在刚好有机会可以使用。</p>\n<a id=\"more\"></a>\n<h2 id=\"三大基础\"><a href=\"#三大基础\" class=\"headerlink\" title=\"三大基础\"></a>三大基础</h2><p>镜像、容器、仓库</p>\n<p>类比的话：镜像是类（iso），容器是实例（操作系统），仓库类似于git的仓库。</p>\n<p>镜像的构建是一层层的继承而来的，镜像和容器都是文件，容器退出的时候容器文件依然存在。除非手动使用-rm指定，才会删除。</p>\n<h2 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h2><p>加载镜像，进入一个新的容器：<code>docker run image:tag command</code></p>\n<p>实例 摘自：<a href=\"https://yeasy.gitbooks.io/docker_practice/image/pull.html\" target=\"_blank\" rel=\"noopener\">https://yeasy.gitbooks.io/docker_practice/image/pull.html</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -it --rm \\</span><br><span class=\"line\">    ubuntu:18.04 \\</span><br><span class=\"line\">    bash</span><br></pre></td></tr></table></figure>\n<p><code>docker run</code> 就是运行容器的命令 从镜像中新建一个容器</p>\n<ul>\n<li><code>-it</code>：这是两个参数，一个是 <code>-i</code>：交互式操作，一个是 <code>-t</code> 终端。我们这里打算进入 <code>bash</code> 执行一些命令并查看返回结果，因此我们需要交互式终端。</li>\n<li><code>--rm</code>：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 <code>docker rm</code>。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 <code>--rm</code> 可以避免浪费空间。</li>\n<li><code>ubuntu:18.04</code>：这是指用 <code>ubuntu:18.04</code> 镜像为基础来启动容器。</li>\n<li><code>bash</code>：放在镜像名后的是<strong>命令</strong>，这里我们希望有个交互式 Shell，因此用的是 <code>bash</code>。</li>\n</ul>\n<p>退出: 在容器中<code>exit</code></p>\n<p>进入容器：</p>\n<p><code>docker exec</code>  进入一个已有的容器。 （容器需要已经运行）</p>\n<p><code>dcoker cp</code>  容器的复制</p>\n<p><code>docker ps</code> 列出启动容器 <code>docker ps -a</code> 列出所有容器包括关闭的。</p>\n<p>启动之前关闭的容器： <code>docker start container-name</code> ， </p>\n<p>需要先启动容器，才能执行<code>docker exec  container-name</code></p>\n<h2 id=\"端口映射\"><a href=\"#端口映射\" class=\"headerlink\" title=\"端口映射\"></a>端口映射</h2><p><a href=\"https://blog.csdn.net/wanglei_storage/article/details/48471753\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/wanglei_storage/article/details/48471753</a></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://juejin.im/entry/5b19e350e51d45069f5e1d66\" target=\"_blank\" rel=\"noopener\">https://juejin.im/entry/5b19e350e51d45069f5e1d66</a></p>\n<p><a href=\"https://yeasy.gitbooks.io/docker_practice/basic_concept/container.html\" target=\"_blank\" rel=\"noopener\">https://yeasy.gitbooks.io/docker_practice/basic_concept/container.html</a></p>\n<p><a href=\"https://blog.csdn.net/u010246789/article/details/53958662\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/u010246789/article/details/53958662</a></p>\n","site":{"data":{}},"length":1000,"excerpt":"<h1 id=\"Docker-学习\"><a href=\"#Docker-学习\" class=\"headerlink\" title=\"Docker 学习\"></a>Docker 学习</h1><p>之前一直听说容器可以免去配置环境的麻烦，但是一直没有机会接触，现在刚好有机会可以使用。</p>","more":"<h2 id=\"三大基础\"><a href=\"#三大基础\" class=\"headerlink\" title=\"三大基础\"></a>三大基础</h2><p>镜像、容器、仓库</p>\n<p>类比的话：镜像是类（iso），容器是实例（操作系统），仓库类似于git的仓库。</p>\n<p>镜像的构建是一层层的继承而来的，镜像和容器都是文件，容器退出的时候容器文件依然存在。除非手动使用-rm指定，才会删除。</p>\n<h2 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h2><p>加载镜像，进入一个新的容器：<code>docker run image:tag command</code></p>\n<p>实例 摘自：<a href=\"https://yeasy.gitbooks.io/docker_practice/image/pull.html\" target=\"_blank\" rel=\"noopener\">https://yeasy.gitbooks.io/docker_practice/image/pull.html</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -it --rm \\</span><br><span class=\"line\">    ubuntu:18.04 \\</span><br><span class=\"line\">    bash</span><br></pre></td></tr></table></figure>\n<p><code>docker run</code> 就是运行容器的命令 从镜像中新建一个容器</p>\n<ul>\n<li><code>-it</code>：这是两个参数，一个是 <code>-i</code>：交互式操作，一个是 <code>-t</code> 终端。我们这里打算进入 <code>bash</code> 执行一些命令并查看返回结果，因此我们需要交互式终端。</li>\n<li><code>--rm</code>：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 <code>docker rm</code>。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 <code>--rm</code> 可以避免浪费空间。</li>\n<li><code>ubuntu:18.04</code>：这是指用 <code>ubuntu:18.04</code> 镜像为基础来启动容器。</li>\n<li><code>bash</code>：放在镜像名后的是<strong>命令</strong>，这里我们希望有个交互式 Shell，因此用的是 <code>bash</code>。</li>\n</ul>\n<p>退出: 在容器中<code>exit</code></p>\n<p>进入容器：</p>\n<p><code>docker exec</code>  进入一个已有的容器。 （容器需要已经运行）</p>\n<p><code>dcoker cp</code>  容器的复制</p>\n<p><code>docker ps</code> 列出启动容器 <code>docker ps -a</code> 列出所有容器包括关闭的。</p>\n<p>启动之前关闭的容器： <code>docker start container-name</code> ， </p>\n<p>需要先启动容器，才能执行<code>docker exec  container-name</code></p>\n<h2 id=\"端口映射\"><a href=\"#端口映射\" class=\"headerlink\" title=\"端口映射\"></a>端口映射</h2><p><a href=\"https://blog.csdn.net/wanglei_storage/article/details/48471753\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/wanglei_storage/article/details/48471753</a></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://juejin.im/entry/5b19e350e51d45069f5e1d66\" target=\"_blank\" rel=\"noopener\">https://juejin.im/entry/5b19e350e51d45069f5e1d66</a></p>\n<p><a href=\"https://yeasy.gitbooks.io/docker_practice/basic_concept/container.html\" target=\"_blank\" rel=\"noopener\">https://yeasy.gitbooks.io/docker_practice/basic_concept/container.html</a></p>\n<p><a href=\"https://blog.csdn.net/u010246789/article/details/53958662\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/u010246789/article/details/53958662</a></p>"},{"title":"Redis 设计与实现读书笔记——第四章 字典","date":"2019-03-27T02:34:14.000Z","copyright":true,"_content":"\n# Redis 设计与实现读书笔记——第四章 字典\n\n字典在Redis中应用很广泛，Redis的数据库就是用字典作为底层实现的，对数据库的增删改查操作也是构建在对字典的操作之上的。\n\n<!--more-->\n\n## 简介\n\n作用：\n\n- 数据库底层实现\n- 哈希键底层实现\n  - 哈希键包含的键值对比较多，或者键值对中的元素都是比较长的字符串时，使用字典来实现。\n- 其他功能\n\n## 4.1 字典的实现\n\n字典使用哈希表实现，一个哈希表里面可以有多个哈希表节点，一个哈希表节点就保存了字典中的一个键值对。（python的dict也是使用哈希表实现的）。\n\n哈希的本质就是预留内存空间，将需要存储的元素计算索引值(通过哈希函数)来确定对应的存储位置。当需要访问的时候可以通过哈希函数直接获得对应的地址。（编译器将变量名与地址做了映射，变量名是地址的别名，哈希则是将键与地址做了映射（通过哈希函数），大大提高了访问的效率。访问任何元素都是O（1），感觉是两个层面的映射，有点相似的感觉）。\n\n### 4.1.1 哈希表\n\nRedis使用的哈希表由dict.h/dictht 结构定义。\n\n```c\ntypedef struct dictht {\n    //哈希表数组\n    dictEntry **table;\n    // 哈希表大小\n    unsigned long size;\n    //哈希表大小掩码，用于计算索引值\n    //总是等于size-1\n    unsigned long sizemask;\n    //该哈希表已有节点的数量\n    unsigned long used;\n} dictht;\n```\n\n`typedef Oldname newname` 所以这里是`typedef struct dictht dictht` 将struct dictht 取了个别名dictht。\n\n`dictEntry **table;` 书上解释的是table是数组，但是最直接的说法是table是一个指向（指向dictEntry类型的指针）的指针，是指向指针的指针。   \n\n数组获得内存是连续的，而指针不是，所以书中说是table数组，应该是分配内存的时候给指针分配了连续的内存，但是代码没找到。\n\n关于指针和数组的异同《C专家编程》一书有讲解（第四章、第九章、第十章）。\n\n- 主要的不同：指针存放的是地址，所以需要经过两次取地址的内容。（取指针的地址中的数据（变量的地址），取变量地址的数据）。而数组是直接存储数组的首元素的数据，所以只用一次取地址中的数据\n- 数组与指针相同\n  - 表达式中的数组名就是指针\n  - C语言把数组下标作为指针的偏移量。a是数组，a[6]就是首地址偏移6。b是指针，b[6]也是指针存储的地址向后偏移6.\n  - 作为函数参数的数组名等同于指针。只是把首地址传入给了参数，并没有把数组所有的内存区域都传入。所以传入数组，就是传入指针。\n\nsizemask和哈希值一起决定一个键应该被放到table数组的那个索引上面。\n\n![一个空的哈希表](http://redisbook.com/_images/graphviz-bd3eecd927a4d8fc33b4a1c7f5957c52d67c5021.png)\n\n### 4.1.2 哈希表节点\n\n使用dictEntry结构体表示节点，每一个dictEntry结构都保存着一个键值对。\n\n```c\ntypedef struct dictEntry {\n    // 键\n    void *key;\t\n    // 值\n    union {\n        void *val;\n        uint64_t u64;\n        int64_t s64;\n        double d;\n    } v;\n    //指向下一个哈希表节点   \n    struct dictEntry *next;\n} dictEntry;\n```\n\nkey指向键值对中的键，而v则保存键值对中的值，值可以是一个指针，或者uint64_t整数，或者有符号的int64_t整数,或者是double类型（double也占8byte无论32还是64位）。\n\n`union` 是c中的共用体（联合体），和结构体非常类似。和结构体的区别是\n\n- 结构体的各个成员会占用不同的内存，互相之间没有影响；而共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。\n- 结构体占用的内存大于等于所有成员占用的内存的总和（成员之间可能会存在缝隙），共用体占用的内存等于最长的成员占用的内存。共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。 所以这里面v占用8byte内存，但是属性却可以有4中。\n\nnext指针可以将多个哈希值相同的键值对链接在一起，用来解决哈希键冲突(索引相同)的问题。链式的方法。\n\n![](http://redisbook.com/_images/graphviz-d2641d962325fd58bf15d9fffb4208f70251a999.png)\n\n### 4.1.3 字典\n\nRedis中字典由dict.h/dict 结构体表示。\n\n```C\ntypedef struct dict {\n    //类型特定函数\n    dictType *type;\n    // 私有数据\n    void *privdata;\n    // 哈希表\n    dictht ht[2];\n    //rehash 索引\n    //当rehash不在进行是值为-1。用来记录是否在rehash\n    long rehashidx; /* rehashing not in progress if rehashidx == -1 */\n    //当前迭代的个数\n    unsigned long iterators; /* number of iterators currently running */\n} dict;\n```\n\ntype 和private属性是针对不同类型的键值对（redis支持5中数据类型），为创建多态字典而设置的。\n\n- type指向dictType结构，dictType结构保存了一簇用于操作特定类型键值对的函数，Redis为不同用途的字典设置了不同的类型的特定函数。（多态的表现。）\n- privadata属性保存了需要传给哪些类型特点函数的可选参数。\n\n```c\ntypedef struct dictType {\n    // 计算哈希值的函数\n    uint64_t (*hashFunction)(const void *key);\n    // 复制键的函数\n    void *(*keyDup)(void *privdata, const void *key);\n    // 复制值的函数\n    void *(*valDup)(void *privdata, const void *obj);\n    // 对比键的函数\n    int (*keyCompare)(void *privdata, const void *key1, const void *key2);\n    // 销毁键的函数\n    void (*keyDestructor)(void *privdata, void *key);\n    // 销毁值的函数\n    void (*valDestructor)(void *privdata, void *obj);\n} dictType;\n```\n\nht是长度为2的数组，而数组的元素就是哈希表dictht。一般情况只会使用ht[0],ht[1]只会在ht[0]空间不够的时候进行rehash的时候使用。\n\nrehashidx 用来标识是否在 rehash，没有的话值为-1,有的话rehasidx用来记录rehash的进度。\n\n![](http://redisbook.com/_images/graphviz-e73003b166b90094c8c4b7abbc8d59f691f91e27.png)\n\n## 4.2 哈希算法\n\n添加一个新的键值对的时候，\n\n \t1. 需要先根据键值使用hash函数计算哈希值\n\t\t2. 哈希值和sizemask并运算求得索引值\n\t\t3. 再根据索引值将包含键值对的哈希表节点放到哈希表数组table上的对应索引值上。\n\nRedis 计算哈希值和索引值的方法为\n\n```\n# 使用字典设置的哈希函数，计算键 key 的哈希值\nhash = dict->type->hashFunction(key);\n\n# 使用哈希表的 sizemask 属性和哈希值，计算出索引值\n# 根据情况不同， ht[x] 可以是 ht[0] 或者 ht[1]\nindex = hash & dict->ht[x].sizemask;\n```\n\n哈希值用hashFunction计算，index用hash值和sizemask进行并操作。\n\n对应在源码中为：\n\n```c\n//dict.h 中：\n#define dictHashKey(d, key) (d)->type->hashFunction(key) //计算哈希值\n//dict.c 中\nidx = hash & d->ht[table].sizemask;\nh = dictHashKey(d, de->key) & d->ht[1].sizemask;\n```\n\n插入一个键值对<k0,v0>到字典中的过程为：\n\n![](http://redisbook.com/_images/graphviz-ca9c88ba1713cb595c4e0e4a17ef2042b0008621.png)\n\n先使用语句\n\n```\nhash = dict->type->hashFunction(k0);\n```\n\n计算键 `k0` 的哈希值。\n\n假设计算得出的哈希值为 `8` ， 那么程序会继续使用语句\n\n```\nindex = hash & dict->ht[0].sizemask = 8 & 3 = 0;\n```\n\n计算出键 `k0` 的索引值 `0` ， 这表示包含键值对 `k0` 和 `v0` 的节点应该被放置到哈希表数组的索引 `0` 位置上。\n\n![](http://redisbook.com/_images/graphviz-2369cb08288f5e59548355042c4c40cc4339e339.png)\n\n当字典被用作数据库的底层实现， 或者哈希键的底层实现时， Redis 使用 MurmurHash2 算法来计算键的哈希值。算法的优点\n\n-  即使输入的键是有规律的， 算法仍能给出一个很好的随机分布性， 并且算法的计算速度也非常快。\n\nMurmurHash 算法目前的最新版本为 MurmurHash3 ， 而 Redis 使用的是 MurmurHash2 ， 关于 MurmurHash 算法的更多信息可以参考该算法的主页： <http://code.google.com/p/smhasher/> 。\n\n暂时没有找到hashFunction的源码。\n\n### 4.3 键冲突\n\n两个以上的键分配到了同一个索引就产生了冲突。\n\n使用链地址法解决，相同索引上面的节点可以用next指针来链接，这样同一个索引就可以存放多个哈希表节点了。\n\n哈希表节点没有指向链表链尾的节点，所以不能迅速的知道哪个节点是尾节点，（只能通过遍历才能找到指向null的尾节点O(N)）,所以为了速度考虑总是将新节点插入到最前面（dictht->table指针指向的第一个节点就是最前面的节点。）\n\n直接使用书上的图：\n\n还未发生键冲突\n\n![](http://redisbook.com/_images/graphviz-db40aa6d0f1265d74f1c1d12b8fa074c0bcda12a.png)\n\n键冲突发生后：新键值对<k2,v2> 插入到<k1,v1>前面。\n\n![](http://redisbook.com/_images/graphviz-4b52dcf6eb0768750e1c15480be3326ca37e05b3.png)\n\n## 4.4  rehash\n\n哈希表保存的键值对会增多或者减少，需要让负载因子（负载因子(load factor)，它用来衡量哈希表的 **空/满** 程度，一定程度上也可以体现查询的效率）维持在合理的范围，所以哈希节点太多的时候需要扩容（不然冲突太多，降低效率），这些哈希表的空间动态扩容或者缩容通过rehash操作来实现。\n\n步骤为：\n\n1. 为ht[1]分配空间\n   1. 扩容时ht[1].size = 大于等于ht[0].used*2的第一个2^n。\n   2. 收缩时ht[1].size = 大于等于ht[0].used的第一个2^n。\n2. 迁移：将ht[0]上面的哈希节点重新计算哈希值与索引值并放到ht[1]哈希表上面。\n3. 迁移完成后释放ht[0],把ht[1]设置成ht[0],并在ht[1]新创建一个空白哈希表，等待下一次rehash。\n\n注意：不管是扩容还是收缩，新分配的空间都会比原来用到的(used)大。设置ht[1]为ht[0] 的时候只需要简单的将原来ht[0]上面的指针指向ht[1]就好，但是需要把原来指向的哈希表的内存给释放掉。（指针是真的强，每次指针变换指向的地址的时候，都需要考虑下之前指向的地址是否还需要，不需要就要释放，不然会造成内存泄漏）。ht[1]则重新新建个哈希表结构体，然后把ht[1]的指针指过来就好了。\n\nrehash的过程图解参考书中的图讲的很详细。\n\n![](http://redisbook.com/_images/graphviz-93608325578e8e45848938ef420115bf2227639e.png)\n\n假设程序要对图 4-8 所示字典的 `ht[0]` 进行扩展操作。\n\n1. `ht[0].used` 当前的值为 `4` ， `4 * 2 = 8` ， 而 `8` （2^3）恰好是第一个大于等于 `4` 的 `2` 的 `n` 次方， 所以程序会将 `ht[1]` 哈希表的大小设置为 `8` 。图 4-9 展示了 `ht[1]` 在分配空间之后， 字典的样子：\n\n![](http://redisbook.com/_images/graphviz-b68acb4d868ec7d79a44935ce08a159746ca58da.png)\n\n2. 将 `ht[0]` 包含的四个键值对都 rehash 到 `ht[1]` ， 如图 4-10 所示。\n\n![](http://redisbook.com/_images/graphviz-92dc47e4329eabae941cddfd727b736ef738e8cf.png)\n\n3. 释放 `ht[0]` ，并将 `ht[1]` 设置为 `ht[0]` ，然后为 `ht[1]` 分配一个空白哈希表，如图 4-11 所示。\n\n![](http://redisbook.com/_images/graphviz-fa28d986a72f1f48b83c7f959ea217b1f9527d3c.png)\n\n哈希表的扩展与收缩（源码还没找到）\n\n当以下条件中的任意一个被满足时， 程序会自动开始对哈希表执行扩展操作：\n\n1. 服务器目前没有在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 `1` ；\n2. 服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 `5` ；\n\n其中哈希表的负载因子可以通过公式得到。\n\n```\n# 负载因子 = 哈希表已保存节点数量 / 哈希表大小\nload_factor = ht[0].used / ht[0].size\n```\n\n## 4.5 渐进式rehash\n\n考虑到redis数据库中存储的键值对很多的情况，如果一次性就rehash完，庞大的计算量可能会导致服务器性能急剧下降，甚至一段时间的停止服务，（经济学中的休克时疗法？）所以rehash这个过程需要渐进式的（软着陆）。\n\n步骤：\n\n1. 为 `ht[1]` 分配空间， 让字典同时持有 `ht[0]` 和 `ht[1]` 两个哈希表。\n2. 在dict中维持一个索引计数器变量 `rehashidx` ， 并将它的值设置为 `0` ， 表示 rehash 工作正式开始。\n3. 在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 `ht[0]` 哈希表在 `rehashidx` 索引上的所有键值对 rehash 到 `ht[1]` ， 当 rehash 工作完成之后， 程序将 `rehashidx` 属性的值增一。\n4. 随着字典操作的不断执行， 最终在某个时间点上， `ht[0]` 的所有键值对都会被 rehash 至 `ht[1]` ， 这时程序将 `rehashidx` 属性的值设为 `-1` ， 表示 rehash 操作已完成。\n\n注意：\n\n - rehashidx的范围是从-1到ht[0].size-1 ，也就是对应的哈希表的索引，不是之前理解的记录哈希节点的个数。\n - 迁移的过程不是拷贝，而是哈希表存储的哈希指针重新指向哈希节点的过程（指针对地址的操作）。\n\nrehash 键值对所需的计算工作均滩到对字典的每个添加、删除、查找和更新操作上， 从而避免了集中式 rehash 而带来的庞大计算量。\n\n过程图解依然copy自redis设计与实现的电子书。\n\n![](http://redisbook.com/_images/graphviz-4c43eaf38cbca10d8d368a5144db6f3c69ab3d84.png)\n\n![](http://redisbook.com/_images/graphviz-b91705b0d7a6c7fd5e37332a930534e0e136ae73.png)\n\n![](http://redisbook.com/_images/graphviz-9e2996e6ca9665776062470cdac346e8fc255374.png)\n\n![](http://redisbook.com/_images/graphviz-c871b5de1a7910aea237ca9dc86508b48da94769.png)\n\n![](http://redisbook.com/_images/graphviz-3b31e4e08cc3e212f986039eb08ae77224cdeec9.png)\n\n![](http://redisbook.com/_images/graphviz-86f810ac65c4e6ee58b17105dfeaa06973d8dd16.png)\n\n### 渐进式rehash期间的哈希表操作\n\n增删改查在两个表上操作，但是添加的新键只添加到ht[1]上，确保ht[0]最终变成空表。\n\n## 4.6 字典API\n\n\n\n## 疑惑\n\n- 为什么不直接用`dictEntry *table[]` 来表示，却要用指针？应该是指针更加灵活些？\n\n  - 因为dict有两个哈希表，而其中有个哈希表ht[1] 是只有在rehash的时候才会使用的，因此使用指针的的话，在不需要的时候将table直接指向null就可以简单的完成释放空间的操作，如果用数组的话,在分配内存的时候，就必须要为两个dictht都分配size个byte的内存存储空间，当rehash的时候size会变化，结构体中的数组就需要重新分配内存空间，而结构体的内存是相邻连续的，所以这时候要变化空间，只能重新再给这个结构体分配空间，这样效率肯定就很低了。所以使用指针的原因就是rehash的时候数组的大小会变化，如果用数组来记录就很麻烦和效率低了。\n  - 所以在dict中可以使用数组来存储dictht,因为ht这个数组是不会变化的。\n\n- 既然在rehash过程中会有增删改查的操作，那么这些操作是在哪个哈希表上进行的呢？\n\n  - 两个哈希表上面都会进行，但是增加的键值对会在ht[1] 上，不然ht[0]在减少的时候又新增键值对，不是在做无用之功吗。\n\n  \n\n  \n\n## 参考\n\n<http://redisbook.com/preview/dict/hash_algorithm.html>\n\n<https://blog.csdn.net/yangbodong22011/article/details/78467583>\n","source":"_posts/2019-03-27-Redis-设计与实现读书笔记——第四章-字典.md","raw":"---\ntitle: Redis 设计与实现读书笔记——第四章 字典\ndate: 2019-03-27 10:34:14\ncategories: 读书笔记\ntags:\n- redis\n- dict\ncopyright: true\n---\n\n# Redis 设计与实现读书笔记——第四章 字典\n\n字典在Redis中应用很广泛，Redis的数据库就是用字典作为底层实现的，对数据库的增删改查操作也是构建在对字典的操作之上的。\n\n<!--more-->\n\n## 简介\n\n作用：\n\n- 数据库底层实现\n- 哈希键底层实现\n  - 哈希键包含的键值对比较多，或者键值对中的元素都是比较长的字符串时，使用字典来实现。\n- 其他功能\n\n## 4.1 字典的实现\n\n字典使用哈希表实现，一个哈希表里面可以有多个哈希表节点，一个哈希表节点就保存了字典中的一个键值对。（python的dict也是使用哈希表实现的）。\n\n哈希的本质就是预留内存空间，将需要存储的元素计算索引值(通过哈希函数)来确定对应的存储位置。当需要访问的时候可以通过哈希函数直接获得对应的地址。（编译器将变量名与地址做了映射，变量名是地址的别名，哈希则是将键与地址做了映射（通过哈希函数），大大提高了访问的效率。访问任何元素都是O（1），感觉是两个层面的映射，有点相似的感觉）。\n\n### 4.1.1 哈希表\n\nRedis使用的哈希表由dict.h/dictht 结构定义。\n\n```c\ntypedef struct dictht {\n    //哈希表数组\n    dictEntry **table;\n    // 哈希表大小\n    unsigned long size;\n    //哈希表大小掩码，用于计算索引值\n    //总是等于size-1\n    unsigned long sizemask;\n    //该哈希表已有节点的数量\n    unsigned long used;\n} dictht;\n```\n\n`typedef Oldname newname` 所以这里是`typedef struct dictht dictht` 将struct dictht 取了个别名dictht。\n\n`dictEntry **table;` 书上解释的是table是数组，但是最直接的说法是table是一个指向（指向dictEntry类型的指针）的指针，是指向指针的指针。   \n\n数组获得内存是连续的，而指针不是，所以书中说是table数组，应该是分配内存的时候给指针分配了连续的内存，但是代码没找到。\n\n关于指针和数组的异同《C专家编程》一书有讲解（第四章、第九章、第十章）。\n\n- 主要的不同：指针存放的是地址，所以需要经过两次取地址的内容。（取指针的地址中的数据（变量的地址），取变量地址的数据）。而数组是直接存储数组的首元素的数据，所以只用一次取地址中的数据\n- 数组与指针相同\n  - 表达式中的数组名就是指针\n  - C语言把数组下标作为指针的偏移量。a是数组，a[6]就是首地址偏移6。b是指针，b[6]也是指针存储的地址向后偏移6.\n  - 作为函数参数的数组名等同于指针。只是把首地址传入给了参数，并没有把数组所有的内存区域都传入。所以传入数组，就是传入指针。\n\nsizemask和哈希值一起决定一个键应该被放到table数组的那个索引上面。\n\n![一个空的哈希表](http://redisbook.com/_images/graphviz-bd3eecd927a4d8fc33b4a1c7f5957c52d67c5021.png)\n\n### 4.1.2 哈希表节点\n\n使用dictEntry结构体表示节点，每一个dictEntry结构都保存着一个键值对。\n\n```c\ntypedef struct dictEntry {\n    // 键\n    void *key;\t\n    // 值\n    union {\n        void *val;\n        uint64_t u64;\n        int64_t s64;\n        double d;\n    } v;\n    //指向下一个哈希表节点   \n    struct dictEntry *next;\n} dictEntry;\n```\n\nkey指向键值对中的键，而v则保存键值对中的值，值可以是一个指针，或者uint64_t整数，或者有符号的int64_t整数,或者是double类型（double也占8byte无论32还是64位）。\n\n`union` 是c中的共用体（联合体），和结构体非常类似。和结构体的区别是\n\n- 结构体的各个成员会占用不同的内存，互相之间没有影响；而共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。\n- 结构体占用的内存大于等于所有成员占用的内存的总和（成员之间可能会存在缝隙），共用体占用的内存等于最长的成员占用的内存。共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。 所以这里面v占用8byte内存，但是属性却可以有4中。\n\nnext指针可以将多个哈希值相同的键值对链接在一起，用来解决哈希键冲突(索引相同)的问题。链式的方法。\n\n![](http://redisbook.com/_images/graphviz-d2641d962325fd58bf15d9fffb4208f70251a999.png)\n\n### 4.1.3 字典\n\nRedis中字典由dict.h/dict 结构体表示。\n\n```C\ntypedef struct dict {\n    //类型特定函数\n    dictType *type;\n    // 私有数据\n    void *privdata;\n    // 哈希表\n    dictht ht[2];\n    //rehash 索引\n    //当rehash不在进行是值为-1。用来记录是否在rehash\n    long rehashidx; /* rehashing not in progress if rehashidx == -1 */\n    //当前迭代的个数\n    unsigned long iterators; /* number of iterators currently running */\n} dict;\n```\n\ntype 和private属性是针对不同类型的键值对（redis支持5中数据类型），为创建多态字典而设置的。\n\n- type指向dictType结构，dictType结构保存了一簇用于操作特定类型键值对的函数，Redis为不同用途的字典设置了不同的类型的特定函数。（多态的表现。）\n- privadata属性保存了需要传给哪些类型特点函数的可选参数。\n\n```c\ntypedef struct dictType {\n    // 计算哈希值的函数\n    uint64_t (*hashFunction)(const void *key);\n    // 复制键的函数\n    void *(*keyDup)(void *privdata, const void *key);\n    // 复制值的函数\n    void *(*valDup)(void *privdata, const void *obj);\n    // 对比键的函数\n    int (*keyCompare)(void *privdata, const void *key1, const void *key2);\n    // 销毁键的函数\n    void (*keyDestructor)(void *privdata, void *key);\n    // 销毁值的函数\n    void (*valDestructor)(void *privdata, void *obj);\n} dictType;\n```\n\nht是长度为2的数组，而数组的元素就是哈希表dictht。一般情况只会使用ht[0],ht[1]只会在ht[0]空间不够的时候进行rehash的时候使用。\n\nrehashidx 用来标识是否在 rehash，没有的话值为-1,有的话rehasidx用来记录rehash的进度。\n\n![](http://redisbook.com/_images/graphviz-e73003b166b90094c8c4b7abbc8d59f691f91e27.png)\n\n## 4.2 哈希算法\n\n添加一个新的键值对的时候，\n\n \t1. 需要先根据键值使用hash函数计算哈希值\n\t\t2. 哈希值和sizemask并运算求得索引值\n\t\t3. 再根据索引值将包含键值对的哈希表节点放到哈希表数组table上的对应索引值上。\n\nRedis 计算哈希值和索引值的方法为\n\n```\n# 使用字典设置的哈希函数，计算键 key 的哈希值\nhash = dict->type->hashFunction(key);\n\n# 使用哈希表的 sizemask 属性和哈希值，计算出索引值\n# 根据情况不同， ht[x] 可以是 ht[0] 或者 ht[1]\nindex = hash & dict->ht[x].sizemask;\n```\n\n哈希值用hashFunction计算，index用hash值和sizemask进行并操作。\n\n对应在源码中为：\n\n```c\n//dict.h 中：\n#define dictHashKey(d, key) (d)->type->hashFunction(key) //计算哈希值\n//dict.c 中\nidx = hash & d->ht[table].sizemask;\nh = dictHashKey(d, de->key) & d->ht[1].sizemask;\n```\n\n插入一个键值对<k0,v0>到字典中的过程为：\n\n![](http://redisbook.com/_images/graphviz-ca9c88ba1713cb595c4e0e4a17ef2042b0008621.png)\n\n先使用语句\n\n```\nhash = dict->type->hashFunction(k0);\n```\n\n计算键 `k0` 的哈希值。\n\n假设计算得出的哈希值为 `8` ， 那么程序会继续使用语句\n\n```\nindex = hash & dict->ht[0].sizemask = 8 & 3 = 0;\n```\n\n计算出键 `k0` 的索引值 `0` ， 这表示包含键值对 `k0` 和 `v0` 的节点应该被放置到哈希表数组的索引 `0` 位置上。\n\n![](http://redisbook.com/_images/graphviz-2369cb08288f5e59548355042c4c40cc4339e339.png)\n\n当字典被用作数据库的底层实现， 或者哈希键的底层实现时， Redis 使用 MurmurHash2 算法来计算键的哈希值。算法的优点\n\n-  即使输入的键是有规律的， 算法仍能给出一个很好的随机分布性， 并且算法的计算速度也非常快。\n\nMurmurHash 算法目前的最新版本为 MurmurHash3 ， 而 Redis 使用的是 MurmurHash2 ， 关于 MurmurHash 算法的更多信息可以参考该算法的主页： <http://code.google.com/p/smhasher/> 。\n\n暂时没有找到hashFunction的源码。\n\n### 4.3 键冲突\n\n两个以上的键分配到了同一个索引就产生了冲突。\n\n使用链地址法解决，相同索引上面的节点可以用next指针来链接，这样同一个索引就可以存放多个哈希表节点了。\n\n哈希表节点没有指向链表链尾的节点，所以不能迅速的知道哪个节点是尾节点，（只能通过遍历才能找到指向null的尾节点O(N)）,所以为了速度考虑总是将新节点插入到最前面（dictht->table指针指向的第一个节点就是最前面的节点。）\n\n直接使用书上的图：\n\n还未发生键冲突\n\n![](http://redisbook.com/_images/graphviz-db40aa6d0f1265d74f1c1d12b8fa074c0bcda12a.png)\n\n键冲突发生后：新键值对<k2,v2> 插入到<k1,v1>前面。\n\n![](http://redisbook.com/_images/graphviz-4b52dcf6eb0768750e1c15480be3326ca37e05b3.png)\n\n## 4.4  rehash\n\n哈希表保存的键值对会增多或者减少，需要让负载因子（负载因子(load factor)，它用来衡量哈希表的 **空/满** 程度，一定程度上也可以体现查询的效率）维持在合理的范围，所以哈希节点太多的时候需要扩容（不然冲突太多，降低效率），这些哈希表的空间动态扩容或者缩容通过rehash操作来实现。\n\n步骤为：\n\n1. 为ht[1]分配空间\n   1. 扩容时ht[1].size = 大于等于ht[0].used*2的第一个2^n。\n   2. 收缩时ht[1].size = 大于等于ht[0].used的第一个2^n。\n2. 迁移：将ht[0]上面的哈希节点重新计算哈希值与索引值并放到ht[1]哈希表上面。\n3. 迁移完成后释放ht[0],把ht[1]设置成ht[0],并在ht[1]新创建一个空白哈希表，等待下一次rehash。\n\n注意：不管是扩容还是收缩，新分配的空间都会比原来用到的(used)大。设置ht[1]为ht[0] 的时候只需要简单的将原来ht[0]上面的指针指向ht[1]就好，但是需要把原来指向的哈希表的内存给释放掉。（指针是真的强，每次指针变换指向的地址的时候，都需要考虑下之前指向的地址是否还需要，不需要就要释放，不然会造成内存泄漏）。ht[1]则重新新建个哈希表结构体，然后把ht[1]的指针指过来就好了。\n\nrehash的过程图解参考书中的图讲的很详细。\n\n![](http://redisbook.com/_images/graphviz-93608325578e8e45848938ef420115bf2227639e.png)\n\n假设程序要对图 4-8 所示字典的 `ht[0]` 进行扩展操作。\n\n1. `ht[0].used` 当前的值为 `4` ， `4 * 2 = 8` ， 而 `8` （2^3）恰好是第一个大于等于 `4` 的 `2` 的 `n` 次方， 所以程序会将 `ht[1]` 哈希表的大小设置为 `8` 。图 4-9 展示了 `ht[1]` 在分配空间之后， 字典的样子：\n\n![](http://redisbook.com/_images/graphviz-b68acb4d868ec7d79a44935ce08a159746ca58da.png)\n\n2. 将 `ht[0]` 包含的四个键值对都 rehash 到 `ht[1]` ， 如图 4-10 所示。\n\n![](http://redisbook.com/_images/graphviz-92dc47e4329eabae941cddfd727b736ef738e8cf.png)\n\n3. 释放 `ht[0]` ，并将 `ht[1]` 设置为 `ht[0]` ，然后为 `ht[1]` 分配一个空白哈希表，如图 4-11 所示。\n\n![](http://redisbook.com/_images/graphviz-fa28d986a72f1f48b83c7f959ea217b1f9527d3c.png)\n\n哈希表的扩展与收缩（源码还没找到）\n\n当以下条件中的任意一个被满足时， 程序会自动开始对哈希表执行扩展操作：\n\n1. 服务器目前没有在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 `1` ；\n2. 服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 `5` ；\n\n其中哈希表的负载因子可以通过公式得到。\n\n```\n# 负载因子 = 哈希表已保存节点数量 / 哈希表大小\nload_factor = ht[0].used / ht[0].size\n```\n\n## 4.5 渐进式rehash\n\n考虑到redis数据库中存储的键值对很多的情况，如果一次性就rehash完，庞大的计算量可能会导致服务器性能急剧下降，甚至一段时间的停止服务，（经济学中的休克时疗法？）所以rehash这个过程需要渐进式的（软着陆）。\n\n步骤：\n\n1. 为 `ht[1]` 分配空间， 让字典同时持有 `ht[0]` 和 `ht[1]` 两个哈希表。\n2. 在dict中维持一个索引计数器变量 `rehashidx` ， 并将它的值设置为 `0` ， 表示 rehash 工作正式开始。\n3. 在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 `ht[0]` 哈希表在 `rehashidx` 索引上的所有键值对 rehash 到 `ht[1]` ， 当 rehash 工作完成之后， 程序将 `rehashidx` 属性的值增一。\n4. 随着字典操作的不断执行， 最终在某个时间点上， `ht[0]` 的所有键值对都会被 rehash 至 `ht[1]` ， 这时程序将 `rehashidx` 属性的值设为 `-1` ， 表示 rehash 操作已完成。\n\n注意：\n\n - rehashidx的范围是从-1到ht[0].size-1 ，也就是对应的哈希表的索引，不是之前理解的记录哈希节点的个数。\n - 迁移的过程不是拷贝，而是哈希表存储的哈希指针重新指向哈希节点的过程（指针对地址的操作）。\n\nrehash 键值对所需的计算工作均滩到对字典的每个添加、删除、查找和更新操作上， 从而避免了集中式 rehash 而带来的庞大计算量。\n\n过程图解依然copy自redis设计与实现的电子书。\n\n![](http://redisbook.com/_images/graphviz-4c43eaf38cbca10d8d368a5144db6f3c69ab3d84.png)\n\n![](http://redisbook.com/_images/graphviz-b91705b0d7a6c7fd5e37332a930534e0e136ae73.png)\n\n![](http://redisbook.com/_images/graphviz-9e2996e6ca9665776062470cdac346e8fc255374.png)\n\n![](http://redisbook.com/_images/graphviz-c871b5de1a7910aea237ca9dc86508b48da94769.png)\n\n![](http://redisbook.com/_images/graphviz-3b31e4e08cc3e212f986039eb08ae77224cdeec9.png)\n\n![](http://redisbook.com/_images/graphviz-86f810ac65c4e6ee58b17105dfeaa06973d8dd16.png)\n\n### 渐进式rehash期间的哈希表操作\n\n增删改查在两个表上操作，但是添加的新键只添加到ht[1]上，确保ht[0]最终变成空表。\n\n## 4.6 字典API\n\n\n\n## 疑惑\n\n- 为什么不直接用`dictEntry *table[]` 来表示，却要用指针？应该是指针更加灵活些？\n\n  - 因为dict有两个哈希表，而其中有个哈希表ht[1] 是只有在rehash的时候才会使用的，因此使用指针的的话，在不需要的时候将table直接指向null就可以简单的完成释放空间的操作，如果用数组的话,在分配内存的时候，就必须要为两个dictht都分配size个byte的内存存储空间，当rehash的时候size会变化，结构体中的数组就需要重新分配内存空间，而结构体的内存是相邻连续的，所以这时候要变化空间，只能重新再给这个结构体分配空间，这样效率肯定就很低了。所以使用指针的原因就是rehash的时候数组的大小会变化，如果用数组来记录就很麻烦和效率低了。\n  - 所以在dict中可以使用数组来存储dictht,因为ht这个数组是不会变化的。\n\n- 既然在rehash过程中会有增删改查的操作，那么这些操作是在哪个哈希表上进行的呢？\n\n  - 两个哈希表上面都会进行，但是增加的键值对会在ht[1] 上，不然ht[0]在减少的时候又新增键值对，不是在做无用之功吗。\n\n  \n\n  \n\n## 参考\n\n<http://redisbook.com/preview/dict/hash_algorithm.html>\n\n<https://blog.csdn.net/yangbodong22011/article/details/78467583>\n","slug":"2019-03-27-Redis-设计与实现读书笔记——第四章-字典","published":1,"updated":"2019-11-08T13:13:42.256Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6he13y40008dstzzvo6ibha","content":"<h1 id=\"Redis-设计与实现读书笔记——第四章-字典\"><a href=\"#Redis-设计与实现读书笔记——第四章-字典\" class=\"headerlink\" title=\"Redis 设计与实现读书笔记——第四章 字典\"></a>Redis 设计与实现读书笔记——第四章 字典</h1><p>字典在Redis中应用很广泛，Redis的数据库就是用字典作为底层实现的，对数据库的增删改查操作也是构建在对字典的操作之上的。</p>\n<a id=\"more\"></a>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>作用：</p>\n<ul>\n<li>数据库底层实现</li>\n<li>哈希键底层实现<ul>\n<li>哈希键包含的键值对比较多，或者键值对中的元素都是比较长的字符串时，使用字典来实现。</li>\n</ul>\n</li>\n<li>其他功能</li>\n</ul>\n<h2 id=\"4-1-字典的实现\"><a href=\"#4-1-字典的实现\" class=\"headerlink\" title=\"4.1 字典的实现\"></a>4.1 字典的实现</h2><p>字典使用哈希表实现，一个哈希表里面可以有多个哈希表节点，一个哈希表节点就保存了字典中的一个键值对。（python的dict也是使用哈希表实现的）。</p>\n<p>哈希的本质就是预留内存空间，将需要存储的元素计算索引值(通过哈希函数)来确定对应的存储位置。当需要访问的时候可以通过哈希函数直接获得对应的地址。（编译器将变量名与地址做了映射，变量名是地址的别名，哈希则是将键与地址做了映射（通过哈希函数），大大提高了访问的效率。访问任何元素都是O（1），感觉是两个层面的映射，有点相似的感觉）。</p>\n<h3 id=\"4-1-1-哈希表\"><a href=\"#4-1-1-哈希表\" class=\"headerlink\" title=\"4.1.1 哈希表\"></a>4.1.1 哈希表</h3><p>Redis使用的哈希表由dict.h/dictht 结构定义。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictht</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//哈希表数组</span></span><br><span class=\"line\">    dictEntry **table;</span><br><span class=\"line\">    <span class=\"comment\">// 哈希表大小</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> size;</span><br><span class=\"line\">    <span class=\"comment\">//哈希表大小掩码，用于计算索引值</span></span><br><span class=\"line\">    <span class=\"comment\">//总是等于size-1</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> sizemask;</span><br><span class=\"line\">    <span class=\"comment\">//该哈希表已有节点的数量</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> used;</span><br><span class=\"line\">&#125; dictht;</span><br></pre></td></tr></table></figure>\n<p><code>typedef Oldname newname</code> 所以这里是<code>typedef struct dictht dictht</code> 将struct dictht 取了个别名dictht。</p>\n<p><code>dictEntry **table;</code> 书上解释的是table是数组，但是最直接的说法是table是一个指向（指向dictEntry类型的指针）的指针，是指向指针的指针。   </p>\n<p>数组获得内存是连续的，而指针不是，所以书中说是table数组，应该是分配内存的时候给指针分配了连续的内存，但是代码没找到。</p>\n<p>关于指针和数组的异同《C专家编程》一书有讲解（第四章、第九章、第十章）。</p>\n<ul>\n<li>主要的不同：指针存放的是地址，所以需要经过两次取地址的内容。（取指针的地址中的数据（变量的地址），取变量地址的数据）。而数组是直接存储数组的首元素的数据，所以只用一次取地址中的数据</li>\n<li>数组与指针相同<ul>\n<li>表达式中的数组名就是指针</li>\n<li>C语言把数组下标作为指针的偏移量。a是数组，a[6]就是首地址偏移6。b是指针，b[6]也是指针存储的地址向后偏移6.</li>\n<li>作为函数参数的数组名等同于指针。只是把首地址传入给了参数，并没有把数组所有的内存区域都传入。所以传入数组，就是传入指针。</li>\n</ul>\n</li>\n</ul>\n<p>sizemask和哈希值一起决定一个键应该被放到table数组的那个索引上面。</p>\n<p><img src=\"http://redisbook.com/_images/graphviz-bd3eecd927a4d8fc33b4a1c7f5957c52d67c5021.png\" alt=\"一个空的哈希表\"></p>\n<h3 id=\"4-1-2-哈希表节点\"><a href=\"#4-1-2-哈希表节点\" class=\"headerlink\" title=\"4.1.2 哈希表节点\"></a>4.1.2 哈希表节点</h3><p>使用dictEntry结构体表示节点，每一个dictEntry结构都保存着一个键值对。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictEntry</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 键</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *key;\t</span><br><span class=\"line\">    <span class=\"comment\">// 值</span></span><br><span class=\"line\">    <span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">void</span> *val;</span><br><span class=\"line\">        <span class=\"keyword\">uint64_t</span> u64;</span><br><span class=\"line\">        <span class=\"keyword\">int64_t</span> s64;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> d;</span><br><span class=\"line\">    &#125; v;</span><br><span class=\"line\">    <span class=\"comment\">//指向下一个哈希表节点   </span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictEntry</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125; dictEntry;</span><br></pre></td></tr></table></figure>\n<p>key指向键值对中的键，而v则保存键值对中的值，值可以是一个指针，或者uint64_t整数，或者有符号的int64_t整数,或者是double类型（double也占8byte无论32还是64位）。</p>\n<p><code>union</code> 是c中的共用体（联合体），和结构体非常类似。和结构体的区别是</p>\n<ul>\n<li>结构体的各个成员会占用不同的内存，互相之间没有影响；而共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。</li>\n<li>结构体占用的内存大于等于所有成员占用的内存的总和（成员之间可能会存在缝隙），共用体占用的内存等于最长的成员占用的内存。共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。 所以这里面v占用8byte内存，但是属性却可以有4中。</li>\n</ul>\n<p>next指针可以将多个哈希值相同的键值对链接在一起，用来解决哈希键冲突(索引相同)的问题。链式的方法。</p>\n<p><img src=\"http://redisbook.com/_images/graphviz-d2641d962325fd58bf15d9fffb4208f70251a999.png\" alt=\"\"></p>\n<h3 id=\"4-1-3-字典\"><a href=\"#4-1-3-字典\" class=\"headerlink\" title=\"4.1.3 字典\"></a>4.1.3 字典</h3><p>Redis中字典由dict.h/dict 结构体表示。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dict</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//类型特定函数</span></span><br><span class=\"line\">    dictType *type;</span><br><span class=\"line\">    <span class=\"comment\">// 私有数据</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *privdata;</span><br><span class=\"line\">    <span class=\"comment\">// 哈希表</span></span><br><span class=\"line\">    dictht ht[<span class=\"number\">2</span>];</span><br><span class=\"line\">    <span class=\"comment\">//rehash 索引</span></span><br><span class=\"line\">    <span class=\"comment\">//当rehash不在进行是值为-1。用来记录是否在rehash</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> rehashidx; <span class=\"comment\">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class=\"line\">    <span class=\"comment\">//当前迭代的个数</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> iterators; <span class=\"comment\">/* number of iterators currently running */</span></span><br><span class=\"line\">&#125; dict;</span><br></pre></td></tr></table></figure>\n<p>type 和private属性是针对不同类型的键值对（redis支持5中数据类型），为创建多态字典而设置的。</p>\n<ul>\n<li>type指向dictType结构，dictType结构保存了一簇用于操作特定类型键值对的函数，Redis为不同用途的字典设置了不同的类型的特定函数。（多态的表现。）</li>\n<li>privadata属性保存了需要传给哪些类型特点函数的可选参数。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictType</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 计算哈希值的函数</span></span><br><span class=\"line\">    <span class=\"keyword\">uint64_t</span> (*hashFunction)(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key);</span><br><span class=\"line\">    <span class=\"comment\">// 复制键的函数</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *(*keyDup)(<span class=\"keyword\">void</span> *privdata, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key);</span><br><span class=\"line\">    <span class=\"comment\">// 复制值的函数</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *(*valDup)(<span class=\"keyword\">void</span> *privdata, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *obj);</span><br><span class=\"line\">    <span class=\"comment\">// 对比键的函数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*keyCompare)(<span class=\"keyword\">void</span> *privdata, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key1, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key2);</span><br><span class=\"line\">    <span class=\"comment\">// 销毁键的函数</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*keyDestructor)(<span class=\"keyword\">void</span> *privdata, <span class=\"keyword\">void</span> *key);</span><br><span class=\"line\">    <span class=\"comment\">// 销毁值的函数</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*valDestructor)(<span class=\"keyword\">void</span> *privdata, <span class=\"keyword\">void</span> *obj);</span><br><span class=\"line\">&#125; dictType;</span><br></pre></td></tr></table></figure>\n<p>ht是长度为2的数组，而数组的元素就是哈希表dictht。一般情况只会使用ht[0],ht[1]只会在ht[0]空间不够的时候进行rehash的时候使用。</p>\n<p>rehashidx 用来标识是否在 rehash，没有的话值为-1,有的话rehasidx用来记录rehash的进度。</p>\n<p><img src=\"http://redisbook.com/_images/graphviz-e73003b166b90094c8c4b7abbc8d59f691f91e27.png\" alt=\"\"></p>\n<h2 id=\"4-2-哈希算法\"><a href=\"#4-2-哈希算法\" class=\"headerlink\" title=\"4.2 哈希算法\"></a>4.2 哈希算法</h2><p>添加一个新的键值对的时候，</p>\n<pre><code> 1. 需要先根据键值使用hash函数计算哈希值\n    2. 哈希值和sizemask并运算求得索引值\n    3. 再根据索引值将包含键值对的哈希表节点放到哈希表数组table上的对应索引值上。\n</code></pre><p>Redis 计算哈希值和索引值的方法为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 使用字典设置的哈希函数，计算键 key 的哈希值</span><br><span class=\"line\">hash = dict-&gt;type-&gt;hashFunction(key);</span><br><span class=\"line\"></span><br><span class=\"line\"># 使用哈希表的 sizemask 属性和哈希值，计算出索引值</span><br><span class=\"line\"># 根据情况不同， ht[x] 可以是 ht[0] 或者 ht[1]</span><br><span class=\"line\">index = hash &amp; dict-&gt;ht[x].sizemask;</span><br></pre></td></tr></table></figure>\n<p>哈希值用hashFunction计算，index用hash值和sizemask进行并操作。</p>\n<p>对应在源码中为：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//dict.h 中：</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> dictHashKey(d, key) (d)-&gt;type-&gt;hashFunction(key) <span class=\"comment\">//计算哈希值</span></span></span><br><span class=\"line\"><span class=\"comment\">//dict.c 中</span></span><br><span class=\"line\">idx = hash &amp; d-&gt;ht[table].sizemask;</span><br><span class=\"line\">h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class=\"number\">1</span>].sizemask;</span><br></pre></td></tr></table></figure>\n<p>插入一个键值对<k0,v0>到字典中的过程为：</k0,v0></p>\n<p><img src=\"http://redisbook.com/_images/graphviz-ca9c88ba1713cb595c4e0e4a17ef2042b0008621.png\" alt=\"\"></p>\n<p>先使用语句</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hash = dict-&gt;type-&gt;hashFunction(k0);</span><br></pre></td></tr></table></figure>\n<p>计算键 <code>k0</code> 的哈希值。</p>\n<p>假设计算得出的哈希值为 <code>8</code> ， 那么程序会继续使用语句</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">index = hash &amp; dict-&gt;ht[0].sizemask = 8 &amp; 3 = 0;</span><br></pre></td></tr></table></figure>\n<p>计算出键 <code>k0</code> 的索引值 <code>0</code> ， 这表示包含键值对 <code>k0</code> 和 <code>v0</code> 的节点应该被放置到哈希表数组的索引 <code>0</code> 位置上。</p>\n<p><img src=\"http://redisbook.com/_images/graphviz-2369cb08288f5e59548355042c4c40cc4339e339.png\" alt=\"\"></p>\n<p>当字典被用作数据库的底层实现， 或者哈希键的底层实现时， Redis 使用 MurmurHash2 算法来计算键的哈希值。算法的优点</p>\n<ul>\n<li>即使输入的键是有规律的， 算法仍能给出一个很好的随机分布性， 并且算法的计算速度也非常快。</li>\n</ul>\n<p>MurmurHash 算法目前的最新版本为 MurmurHash3 ， 而 Redis 使用的是 MurmurHash2 ， 关于 MurmurHash 算法的更多信息可以参考该算法的主页： <a href=\"http://code.google.com/p/smhasher/\" target=\"_blank\" rel=\"noopener\">http://code.google.com/p/smhasher/</a> 。</p>\n<p>暂时没有找到hashFunction的源码。</p>\n<h3 id=\"4-3-键冲突\"><a href=\"#4-3-键冲突\" class=\"headerlink\" title=\"4.3 键冲突\"></a>4.3 键冲突</h3><p>两个以上的键分配到了同一个索引就产生了冲突。</p>\n<p>使用链地址法解决，相同索引上面的节点可以用next指针来链接，这样同一个索引就可以存放多个哈希表节点了。</p>\n<p>哈希表节点没有指向链表链尾的节点，所以不能迅速的知道哪个节点是尾节点，（只能通过遍历才能找到指向null的尾节点O(N)）,所以为了速度考虑总是将新节点插入到最前面（dictht-&gt;table指针指向的第一个节点就是最前面的节点。）</p>\n<p>直接使用书上的图：</p>\n<p>还未发生键冲突</p>\n<p><img src=\"http://redisbook.com/_images/graphviz-db40aa6d0f1265d74f1c1d12b8fa074c0bcda12a.png\" alt=\"\"></p>\n<p>键冲突发生后：新键值对<k2,v2> 插入到<k1,v1>前面。</k1,v1></k2,v2></p>\n<p><img src=\"http://redisbook.com/_images/graphviz-4b52dcf6eb0768750e1c15480be3326ca37e05b3.png\" alt=\"\"></p>\n<h2 id=\"4-4-rehash\"><a href=\"#4-4-rehash\" class=\"headerlink\" title=\"4.4  rehash\"></a>4.4  rehash</h2><p>哈希表保存的键值对会增多或者减少，需要让负载因子（负载因子(load factor)，它用来衡量哈希表的 <strong>空/满</strong> 程度，一定程度上也可以体现查询的效率）维持在合理的范围，所以哈希节点太多的时候需要扩容（不然冲突太多，降低效率），这些哈希表的空间动态扩容或者缩容通过rehash操作来实现。</p>\n<p>步骤为：</p>\n<ol>\n<li>为ht[1]分配空间<ol>\n<li>扩容时ht[1].size = 大于等于ht[0].used*2的第一个2^n。</li>\n<li>收缩时ht[1].size = 大于等于ht[0].used的第一个2^n。</li>\n</ol>\n</li>\n<li>迁移：将ht[0]上面的哈希节点重新计算哈希值与索引值并放到ht[1]哈希表上面。</li>\n<li>迁移完成后释放ht[0],把ht[1]设置成ht[0],并在ht[1]新创建一个空白哈希表，等待下一次rehash。</li>\n</ol>\n<p>注意：不管是扩容还是收缩，新分配的空间都会比原来用到的(used)大。设置ht[1]为ht[0] 的时候只需要简单的将原来ht[0]上面的指针指向ht[1]就好，但是需要把原来指向的哈希表的内存给释放掉。（指针是真的强，每次指针变换指向的地址的时候，都需要考虑下之前指向的地址是否还需要，不需要就要释放，不然会造成内存泄漏）。ht[1]则重新新建个哈希表结构体，然后把ht[1]的指针指过来就好了。</p>\n<p>rehash的过程图解参考书中的图讲的很详细。</p>\n<p><img src=\"http://redisbook.com/_images/graphviz-93608325578e8e45848938ef420115bf2227639e.png\" alt=\"\"></p>\n<p>假设程序要对图 4-8 所示字典的 <code>ht[0]</code> 进行扩展操作。</p>\n<ol>\n<li><code>ht[0].used</code> 当前的值为 <code>4</code> ， <code>4 * 2 = 8</code> ， 而 <code>8</code> （2^3）恰好是第一个大于等于 <code>4</code> 的 <code>2</code> 的 <code>n</code> 次方， 所以程序会将 <code>ht[1]</code> 哈希表的大小设置为 <code>8</code> 。图 4-9 展示了 <code>ht[1]</code> 在分配空间之后， 字典的样子：</li>\n</ol>\n<p><img src=\"http://redisbook.com/_images/graphviz-b68acb4d868ec7d79a44935ce08a159746ca58da.png\" alt=\"\"></p>\n<ol>\n<li>将 <code>ht[0]</code> 包含的四个键值对都 rehash 到 <code>ht[1]</code> ， 如图 4-10 所示。</li>\n</ol>\n<p><img src=\"http://redisbook.com/_images/graphviz-92dc47e4329eabae941cddfd727b736ef738e8cf.png\" alt=\"\"></p>\n<ol>\n<li>释放 <code>ht[0]</code> ，并将 <code>ht[1]</code> 设置为 <code>ht[0]</code> ，然后为 <code>ht[1]</code> 分配一个空白哈希表，如图 4-11 所示。</li>\n</ol>\n<p><img src=\"http://redisbook.com/_images/graphviz-fa28d986a72f1f48b83c7f959ea217b1f9527d3c.png\" alt=\"\"></p>\n<p>哈希表的扩展与收缩（源码还没找到）</p>\n<p>当以下条件中的任意一个被满足时， 程序会自动开始对哈希表执行扩展操作：</p>\n<ol>\n<li>服务器目前没有在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 <code>1</code> ；</li>\n<li>服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 <code>5</code> ；</li>\n</ol>\n<p>其中哈希表的负载因子可以通过公式得到。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 负载因子 = 哈希表已保存节点数量 / 哈希表大小</span><br><span class=\"line\">load_factor = ht[0].used / ht[0].size</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-5-渐进式rehash\"><a href=\"#4-5-渐进式rehash\" class=\"headerlink\" title=\"4.5 渐进式rehash\"></a>4.5 渐进式rehash</h2><p>考虑到redis数据库中存储的键值对很多的情况，如果一次性就rehash完，庞大的计算量可能会导致服务器性能急剧下降，甚至一段时间的停止服务，（经济学中的休克时疗法？）所以rehash这个过程需要渐进式的（软着陆）。</p>\n<p>步骤：</p>\n<ol>\n<li>为 <code>ht[1]</code> 分配空间， 让字典同时持有 <code>ht[0]</code> 和 <code>ht[1]</code> 两个哈希表。</li>\n<li>在dict中维持一个索引计数器变量 <code>rehashidx</code> ， 并将它的值设置为 <code>0</code> ， 表示 rehash 工作正式开始。</li>\n<li>在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 <code>ht[0]</code> 哈希表在 <code>rehashidx</code> 索引上的所有键值对 rehash 到 <code>ht[1]</code> ， 当 rehash 工作完成之后， 程序将 <code>rehashidx</code> 属性的值增一。</li>\n<li>随着字典操作的不断执行， 最终在某个时间点上， <code>ht[0]</code> 的所有键值对都会被 rehash 至 <code>ht[1]</code> ， 这时程序将 <code>rehashidx</code> 属性的值设为 <code>-1</code> ， 表示 rehash 操作已完成。</li>\n</ol>\n<p>注意：</p>\n<ul>\n<li>rehashidx的范围是从-1到ht[0].size-1 ，也就是对应的哈希表的索引，不是之前理解的记录哈希节点的个数。</li>\n<li>迁移的过程不是拷贝，而是哈希表存储的哈希指针重新指向哈希节点的过程（指针对地址的操作）。</li>\n</ul>\n<p>rehash 键值对所需的计算工作均滩到对字典的每个添加、删除、查找和更新操作上， 从而避免了集中式 rehash 而带来的庞大计算量。</p>\n<p>过程图解依然copy自redis设计与实现的电子书。</p>\n<p><img src=\"http://redisbook.com/_images/graphviz-4c43eaf38cbca10d8d368a5144db6f3c69ab3d84.png\" alt=\"\"></p>\n<p><img src=\"http://redisbook.com/_images/graphviz-b91705b0d7a6c7fd5e37332a930534e0e136ae73.png\" alt=\"\"></p>\n<p><img src=\"http://redisbook.com/_images/graphviz-9e2996e6ca9665776062470cdac346e8fc255374.png\" alt=\"\"></p>\n<p><img src=\"http://redisbook.com/_images/graphviz-c871b5de1a7910aea237ca9dc86508b48da94769.png\" alt=\"\"></p>\n<p><img src=\"http://redisbook.com/_images/graphviz-3b31e4e08cc3e212f986039eb08ae77224cdeec9.png\" alt=\"\"></p>\n<p><img src=\"http://redisbook.com/_images/graphviz-86f810ac65c4e6ee58b17105dfeaa06973d8dd16.png\" alt=\"\"></p>\n<h3 id=\"渐进式rehash期间的哈希表操作\"><a href=\"#渐进式rehash期间的哈希表操作\" class=\"headerlink\" title=\"渐进式rehash期间的哈希表操作\"></a>渐进式rehash期间的哈希表操作</h3><p>增删改查在两个表上操作，但是添加的新键只添加到ht[1]上，确保ht[0]最终变成空表。</p>\n<h2 id=\"4-6-字典API\"><a href=\"#4-6-字典API\" class=\"headerlink\" title=\"4.6 字典API\"></a>4.6 字典API</h2><h2 id=\"疑惑\"><a href=\"#疑惑\" class=\"headerlink\" title=\"疑惑\"></a>疑惑</h2><ul>\n<li><p>为什么不直接用<code>dictEntry *table[]</code> 来表示，却要用指针？应该是指针更加灵活些？</p>\n<ul>\n<li>因为dict有两个哈希表，而其中有个哈希表ht[1] 是只有在rehash的时候才会使用的，因此使用指针的的话，在不需要的时候将table直接指向null就可以简单的完成释放空间的操作，如果用数组的话,在分配内存的时候，就必须要为两个dictht都分配size个byte的内存存储空间，当rehash的时候size会变化，结构体中的数组就需要重新分配内存空间，而结构体的内存是相邻连续的，所以这时候要变化空间，只能重新再给这个结构体分配空间，这样效率肯定就很低了。所以使用指针的原因就是rehash的时候数组的大小会变化，如果用数组来记录就很麻烦和效率低了。</li>\n<li>所以在dict中可以使用数组来存储dictht,因为ht这个数组是不会变化的。</li>\n</ul>\n</li>\n<li><p>既然在rehash过程中会有增删改查的操作，那么这些操作是在哪个哈希表上进行的呢？</p>\n<ul>\n<li>两个哈希表上面都会进行，但是增加的键值对会在ht[1] 上，不然ht[0]在减少的时候又新增键值对，不是在做无用之功吗。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://redisbook.com/preview/dict/hash_algorithm.html\" target=\"_blank\" rel=\"noopener\">http://redisbook.com/preview/dict/hash_algorithm.html</a></p>\n<p><a href=\"https://blog.csdn.net/yangbodong22011/article/details/78467583\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/yangbodong22011/article/details/78467583</a></p>\n","site":{"data":{}},"length":6191,"excerpt":"<h1 id=\"Redis-设计与实现读书笔记——第四章-字典\"><a href=\"#Redis-设计与实现读书笔记——第四章-字典\" class=\"headerlink\" title=\"Redis 设计与实现读书笔记——第四章 字典\"></a>Redis 设计与实现读书笔记——第四章 字典</h1><p>字典在Redis中应用很广泛，Redis的数据库就是用字典作为底层实现的，对数据库的增删改查操作也是构建在对字典的操作之上的。</p>","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>作用：</p>\n<ul>\n<li>数据库底层实现</li>\n<li>哈希键底层实现<ul>\n<li>哈希键包含的键值对比较多，或者键值对中的元素都是比较长的字符串时，使用字典来实现。</li>\n</ul>\n</li>\n<li>其他功能</li>\n</ul>\n<h2 id=\"4-1-字典的实现\"><a href=\"#4-1-字典的实现\" class=\"headerlink\" title=\"4.1 字典的实现\"></a>4.1 字典的实现</h2><p>字典使用哈希表实现，一个哈希表里面可以有多个哈希表节点，一个哈希表节点就保存了字典中的一个键值对。（python的dict也是使用哈希表实现的）。</p>\n<p>哈希的本质就是预留内存空间，将需要存储的元素计算索引值(通过哈希函数)来确定对应的存储位置。当需要访问的时候可以通过哈希函数直接获得对应的地址。（编译器将变量名与地址做了映射，变量名是地址的别名，哈希则是将键与地址做了映射（通过哈希函数），大大提高了访问的效率。访问任何元素都是O（1），感觉是两个层面的映射，有点相似的感觉）。</p>\n<h3 id=\"4-1-1-哈希表\"><a href=\"#4-1-1-哈希表\" class=\"headerlink\" title=\"4.1.1 哈希表\"></a>4.1.1 哈希表</h3><p>Redis使用的哈希表由dict.h/dictht 结构定义。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictht</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//哈希表数组</span></span><br><span class=\"line\">    dictEntry **table;</span><br><span class=\"line\">    <span class=\"comment\">// 哈希表大小</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> size;</span><br><span class=\"line\">    <span class=\"comment\">//哈希表大小掩码，用于计算索引值</span></span><br><span class=\"line\">    <span class=\"comment\">//总是等于size-1</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> sizemask;</span><br><span class=\"line\">    <span class=\"comment\">//该哈希表已有节点的数量</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> used;</span><br><span class=\"line\">&#125; dictht;</span><br></pre></td></tr></table></figure>\n<p><code>typedef Oldname newname</code> 所以这里是<code>typedef struct dictht dictht</code> 将struct dictht 取了个别名dictht。</p>\n<p><code>dictEntry **table;</code> 书上解释的是table是数组，但是最直接的说法是table是一个指向（指向dictEntry类型的指针）的指针，是指向指针的指针。   </p>\n<p>数组获得内存是连续的，而指针不是，所以书中说是table数组，应该是分配内存的时候给指针分配了连续的内存，但是代码没找到。</p>\n<p>关于指针和数组的异同《C专家编程》一书有讲解（第四章、第九章、第十章）。</p>\n<ul>\n<li>主要的不同：指针存放的是地址，所以需要经过两次取地址的内容。（取指针的地址中的数据（变量的地址），取变量地址的数据）。而数组是直接存储数组的首元素的数据，所以只用一次取地址中的数据</li>\n<li>数组与指针相同<ul>\n<li>表达式中的数组名就是指针</li>\n<li>C语言把数组下标作为指针的偏移量。a是数组，a[6]就是首地址偏移6。b是指针，b[6]也是指针存储的地址向后偏移6.</li>\n<li>作为函数参数的数组名等同于指针。只是把首地址传入给了参数，并没有把数组所有的内存区域都传入。所以传入数组，就是传入指针。</li>\n</ul>\n</li>\n</ul>\n<p>sizemask和哈希值一起决定一个键应该被放到table数组的那个索引上面。</p>\n<p><img src=\"http://redisbook.com/_images/graphviz-bd3eecd927a4d8fc33b4a1c7f5957c52d67c5021.png\" alt=\"一个空的哈希表\"></p>\n<h3 id=\"4-1-2-哈希表节点\"><a href=\"#4-1-2-哈希表节点\" class=\"headerlink\" title=\"4.1.2 哈希表节点\"></a>4.1.2 哈希表节点</h3><p>使用dictEntry结构体表示节点，每一个dictEntry结构都保存着一个键值对。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictEntry</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 键</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *key;\t</span><br><span class=\"line\">    <span class=\"comment\">// 值</span></span><br><span class=\"line\">    <span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">void</span> *val;</span><br><span class=\"line\">        <span class=\"keyword\">uint64_t</span> u64;</span><br><span class=\"line\">        <span class=\"keyword\">int64_t</span> s64;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> d;</span><br><span class=\"line\">    &#125; v;</span><br><span class=\"line\">    <span class=\"comment\">//指向下一个哈希表节点   </span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictEntry</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125; dictEntry;</span><br></pre></td></tr></table></figure>\n<p>key指向键值对中的键，而v则保存键值对中的值，值可以是一个指针，或者uint64_t整数，或者有符号的int64_t整数,或者是double类型（double也占8byte无论32还是64位）。</p>\n<p><code>union</code> 是c中的共用体（联合体），和结构体非常类似。和结构体的区别是</p>\n<ul>\n<li>结构体的各个成员会占用不同的内存，互相之间没有影响；而共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。</li>\n<li>结构体占用的内存大于等于所有成员占用的内存的总和（成员之间可能会存在缝隙），共用体占用的内存等于最长的成员占用的内存。共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。 所以这里面v占用8byte内存，但是属性却可以有4中。</li>\n</ul>\n<p>next指针可以将多个哈希值相同的键值对链接在一起，用来解决哈希键冲突(索引相同)的问题。链式的方法。</p>\n<p><img src=\"http://redisbook.com/_images/graphviz-d2641d962325fd58bf15d9fffb4208f70251a999.png\" alt=\"\"></p>\n<h3 id=\"4-1-3-字典\"><a href=\"#4-1-3-字典\" class=\"headerlink\" title=\"4.1.3 字典\"></a>4.1.3 字典</h3><p>Redis中字典由dict.h/dict 结构体表示。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dict</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//类型特定函数</span></span><br><span class=\"line\">    dictType *type;</span><br><span class=\"line\">    <span class=\"comment\">// 私有数据</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *privdata;</span><br><span class=\"line\">    <span class=\"comment\">// 哈希表</span></span><br><span class=\"line\">    dictht ht[<span class=\"number\">2</span>];</span><br><span class=\"line\">    <span class=\"comment\">//rehash 索引</span></span><br><span class=\"line\">    <span class=\"comment\">//当rehash不在进行是值为-1。用来记录是否在rehash</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> rehashidx; <span class=\"comment\">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class=\"line\">    <span class=\"comment\">//当前迭代的个数</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> iterators; <span class=\"comment\">/* number of iterators currently running */</span></span><br><span class=\"line\">&#125; dict;</span><br></pre></td></tr></table></figure>\n<p>type 和private属性是针对不同类型的键值对（redis支持5中数据类型），为创建多态字典而设置的。</p>\n<ul>\n<li>type指向dictType结构，dictType结构保存了一簇用于操作特定类型键值对的函数，Redis为不同用途的字典设置了不同的类型的特定函数。（多态的表现。）</li>\n<li>privadata属性保存了需要传给哪些类型特点函数的可选参数。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictType</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 计算哈希值的函数</span></span><br><span class=\"line\">    <span class=\"keyword\">uint64_t</span> (*hashFunction)(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key);</span><br><span class=\"line\">    <span class=\"comment\">// 复制键的函数</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *(*keyDup)(<span class=\"keyword\">void</span> *privdata, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key);</span><br><span class=\"line\">    <span class=\"comment\">// 复制值的函数</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *(*valDup)(<span class=\"keyword\">void</span> *privdata, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *obj);</span><br><span class=\"line\">    <span class=\"comment\">// 对比键的函数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*keyCompare)(<span class=\"keyword\">void</span> *privdata, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key1, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key2);</span><br><span class=\"line\">    <span class=\"comment\">// 销毁键的函数</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*keyDestructor)(<span class=\"keyword\">void</span> *privdata, <span class=\"keyword\">void</span> *key);</span><br><span class=\"line\">    <span class=\"comment\">// 销毁值的函数</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*valDestructor)(<span class=\"keyword\">void</span> *privdata, <span class=\"keyword\">void</span> *obj);</span><br><span class=\"line\">&#125; dictType;</span><br></pre></td></tr></table></figure>\n<p>ht是长度为2的数组，而数组的元素就是哈希表dictht。一般情况只会使用ht[0],ht[1]只会在ht[0]空间不够的时候进行rehash的时候使用。</p>\n<p>rehashidx 用来标识是否在 rehash，没有的话值为-1,有的话rehasidx用来记录rehash的进度。</p>\n<p><img src=\"http://redisbook.com/_images/graphviz-e73003b166b90094c8c4b7abbc8d59f691f91e27.png\" alt=\"\"></p>\n<h2 id=\"4-2-哈希算法\"><a href=\"#4-2-哈希算法\" class=\"headerlink\" title=\"4.2 哈希算法\"></a>4.2 哈希算法</h2><p>添加一个新的键值对的时候，</p>\n<pre><code> 1. 需要先根据键值使用hash函数计算哈希值\n    2. 哈希值和sizemask并运算求得索引值\n    3. 再根据索引值将包含键值对的哈希表节点放到哈希表数组table上的对应索引值上。\n</code></pre><p>Redis 计算哈希值和索引值的方法为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 使用字典设置的哈希函数，计算键 key 的哈希值</span><br><span class=\"line\">hash = dict-&gt;type-&gt;hashFunction(key);</span><br><span class=\"line\"></span><br><span class=\"line\"># 使用哈希表的 sizemask 属性和哈希值，计算出索引值</span><br><span class=\"line\"># 根据情况不同， ht[x] 可以是 ht[0] 或者 ht[1]</span><br><span class=\"line\">index = hash &amp; dict-&gt;ht[x].sizemask;</span><br></pre></td></tr></table></figure>\n<p>哈希值用hashFunction计算，index用hash值和sizemask进行并操作。</p>\n<p>对应在源码中为：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//dict.h 中：</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> dictHashKey(d, key) (d)-&gt;type-&gt;hashFunction(key) <span class=\"comment\">//计算哈希值</span></span></span><br><span class=\"line\"><span class=\"comment\">//dict.c 中</span></span><br><span class=\"line\">idx = hash &amp; d-&gt;ht[table].sizemask;</span><br><span class=\"line\">h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class=\"number\">1</span>].sizemask;</span><br></pre></td></tr></table></figure>\n<p>插入一个键值对<k0,v0>到字典中的过程为：</k0,v0></p>\n<p><img src=\"http://redisbook.com/_images/graphviz-ca9c88ba1713cb595c4e0e4a17ef2042b0008621.png\" alt=\"\"></p>\n<p>先使用语句</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hash = dict-&gt;type-&gt;hashFunction(k0);</span><br></pre></td></tr></table></figure>\n<p>计算键 <code>k0</code> 的哈希值。</p>\n<p>假设计算得出的哈希值为 <code>8</code> ， 那么程序会继续使用语句</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">index = hash &amp; dict-&gt;ht[0].sizemask = 8 &amp; 3 = 0;</span><br></pre></td></tr></table></figure>\n<p>计算出键 <code>k0</code> 的索引值 <code>0</code> ， 这表示包含键值对 <code>k0</code> 和 <code>v0</code> 的节点应该被放置到哈希表数组的索引 <code>0</code> 位置上。</p>\n<p><img src=\"http://redisbook.com/_images/graphviz-2369cb08288f5e59548355042c4c40cc4339e339.png\" alt=\"\"></p>\n<p>当字典被用作数据库的底层实现， 或者哈希键的底层实现时， Redis 使用 MurmurHash2 算法来计算键的哈希值。算法的优点</p>\n<ul>\n<li>即使输入的键是有规律的， 算法仍能给出一个很好的随机分布性， 并且算法的计算速度也非常快。</li>\n</ul>\n<p>MurmurHash 算法目前的最新版本为 MurmurHash3 ， 而 Redis 使用的是 MurmurHash2 ， 关于 MurmurHash 算法的更多信息可以参考该算法的主页： <a href=\"http://code.google.com/p/smhasher/\" target=\"_blank\" rel=\"noopener\">http://code.google.com/p/smhasher/</a> 。</p>\n<p>暂时没有找到hashFunction的源码。</p>\n<h3 id=\"4-3-键冲突\"><a href=\"#4-3-键冲突\" class=\"headerlink\" title=\"4.3 键冲突\"></a>4.3 键冲突</h3><p>两个以上的键分配到了同一个索引就产生了冲突。</p>\n<p>使用链地址法解决，相同索引上面的节点可以用next指针来链接，这样同一个索引就可以存放多个哈希表节点了。</p>\n<p>哈希表节点没有指向链表链尾的节点，所以不能迅速的知道哪个节点是尾节点，（只能通过遍历才能找到指向null的尾节点O(N)）,所以为了速度考虑总是将新节点插入到最前面（dictht-&gt;table指针指向的第一个节点就是最前面的节点。）</p>\n<p>直接使用书上的图：</p>\n<p>还未发生键冲突</p>\n<p><img src=\"http://redisbook.com/_images/graphviz-db40aa6d0f1265d74f1c1d12b8fa074c0bcda12a.png\" alt=\"\"></p>\n<p>键冲突发生后：新键值对<k2,v2> 插入到<k1,v1>前面。</k1,v1></k2,v2></p>\n<p><img src=\"http://redisbook.com/_images/graphviz-4b52dcf6eb0768750e1c15480be3326ca37e05b3.png\" alt=\"\"></p>\n<h2 id=\"4-4-rehash\"><a href=\"#4-4-rehash\" class=\"headerlink\" title=\"4.4  rehash\"></a>4.4  rehash</h2><p>哈希表保存的键值对会增多或者减少，需要让负载因子（负载因子(load factor)，它用来衡量哈希表的 <strong>空/满</strong> 程度，一定程度上也可以体现查询的效率）维持在合理的范围，所以哈希节点太多的时候需要扩容（不然冲突太多，降低效率），这些哈希表的空间动态扩容或者缩容通过rehash操作来实现。</p>\n<p>步骤为：</p>\n<ol>\n<li>为ht[1]分配空间<ol>\n<li>扩容时ht[1].size = 大于等于ht[0].used*2的第一个2^n。</li>\n<li>收缩时ht[1].size = 大于等于ht[0].used的第一个2^n。</li>\n</ol>\n</li>\n<li>迁移：将ht[0]上面的哈希节点重新计算哈希值与索引值并放到ht[1]哈希表上面。</li>\n<li>迁移完成后释放ht[0],把ht[1]设置成ht[0],并在ht[1]新创建一个空白哈希表，等待下一次rehash。</li>\n</ol>\n<p>注意：不管是扩容还是收缩，新分配的空间都会比原来用到的(used)大。设置ht[1]为ht[0] 的时候只需要简单的将原来ht[0]上面的指针指向ht[1]就好，但是需要把原来指向的哈希表的内存给释放掉。（指针是真的强，每次指针变换指向的地址的时候，都需要考虑下之前指向的地址是否还需要，不需要就要释放，不然会造成内存泄漏）。ht[1]则重新新建个哈希表结构体，然后把ht[1]的指针指过来就好了。</p>\n<p>rehash的过程图解参考书中的图讲的很详细。</p>\n<p><img src=\"http://redisbook.com/_images/graphviz-93608325578e8e45848938ef420115bf2227639e.png\" alt=\"\"></p>\n<p>假设程序要对图 4-8 所示字典的 <code>ht[0]</code> 进行扩展操作。</p>\n<ol>\n<li><code>ht[0].used</code> 当前的值为 <code>4</code> ， <code>4 * 2 = 8</code> ， 而 <code>8</code> （2^3）恰好是第一个大于等于 <code>4</code> 的 <code>2</code> 的 <code>n</code> 次方， 所以程序会将 <code>ht[1]</code> 哈希表的大小设置为 <code>8</code> 。图 4-9 展示了 <code>ht[1]</code> 在分配空间之后， 字典的样子：</li>\n</ol>\n<p><img src=\"http://redisbook.com/_images/graphviz-b68acb4d868ec7d79a44935ce08a159746ca58da.png\" alt=\"\"></p>\n<ol>\n<li>将 <code>ht[0]</code> 包含的四个键值对都 rehash 到 <code>ht[1]</code> ， 如图 4-10 所示。</li>\n</ol>\n<p><img src=\"http://redisbook.com/_images/graphviz-92dc47e4329eabae941cddfd727b736ef738e8cf.png\" alt=\"\"></p>\n<ol>\n<li>释放 <code>ht[0]</code> ，并将 <code>ht[1]</code> 设置为 <code>ht[0]</code> ，然后为 <code>ht[1]</code> 分配一个空白哈希表，如图 4-11 所示。</li>\n</ol>\n<p><img src=\"http://redisbook.com/_images/graphviz-fa28d986a72f1f48b83c7f959ea217b1f9527d3c.png\" alt=\"\"></p>\n<p>哈希表的扩展与收缩（源码还没找到）</p>\n<p>当以下条件中的任意一个被满足时， 程序会自动开始对哈希表执行扩展操作：</p>\n<ol>\n<li>服务器目前没有在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 <code>1</code> ；</li>\n<li>服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 <code>5</code> ；</li>\n</ol>\n<p>其中哈希表的负载因子可以通过公式得到。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 负载因子 = 哈希表已保存节点数量 / 哈希表大小</span><br><span class=\"line\">load_factor = ht[0].used / ht[0].size</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-5-渐进式rehash\"><a href=\"#4-5-渐进式rehash\" class=\"headerlink\" title=\"4.5 渐进式rehash\"></a>4.5 渐进式rehash</h2><p>考虑到redis数据库中存储的键值对很多的情况，如果一次性就rehash完，庞大的计算量可能会导致服务器性能急剧下降，甚至一段时间的停止服务，（经济学中的休克时疗法？）所以rehash这个过程需要渐进式的（软着陆）。</p>\n<p>步骤：</p>\n<ol>\n<li>为 <code>ht[1]</code> 分配空间， 让字典同时持有 <code>ht[0]</code> 和 <code>ht[1]</code> 两个哈希表。</li>\n<li>在dict中维持一个索引计数器变量 <code>rehashidx</code> ， 并将它的值设置为 <code>0</code> ， 表示 rehash 工作正式开始。</li>\n<li>在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 <code>ht[0]</code> 哈希表在 <code>rehashidx</code> 索引上的所有键值对 rehash 到 <code>ht[1]</code> ， 当 rehash 工作完成之后， 程序将 <code>rehashidx</code> 属性的值增一。</li>\n<li>随着字典操作的不断执行， 最终在某个时间点上， <code>ht[0]</code> 的所有键值对都会被 rehash 至 <code>ht[1]</code> ， 这时程序将 <code>rehashidx</code> 属性的值设为 <code>-1</code> ， 表示 rehash 操作已完成。</li>\n</ol>\n<p>注意：</p>\n<ul>\n<li>rehashidx的范围是从-1到ht[0].size-1 ，也就是对应的哈希表的索引，不是之前理解的记录哈希节点的个数。</li>\n<li>迁移的过程不是拷贝，而是哈希表存储的哈希指针重新指向哈希节点的过程（指针对地址的操作）。</li>\n</ul>\n<p>rehash 键值对所需的计算工作均滩到对字典的每个添加、删除、查找和更新操作上， 从而避免了集中式 rehash 而带来的庞大计算量。</p>\n<p>过程图解依然copy自redis设计与实现的电子书。</p>\n<p><img src=\"http://redisbook.com/_images/graphviz-4c43eaf38cbca10d8d368a5144db6f3c69ab3d84.png\" alt=\"\"></p>\n<p><img src=\"http://redisbook.com/_images/graphviz-b91705b0d7a6c7fd5e37332a930534e0e136ae73.png\" alt=\"\"></p>\n<p><img src=\"http://redisbook.com/_images/graphviz-9e2996e6ca9665776062470cdac346e8fc255374.png\" alt=\"\"></p>\n<p><img src=\"http://redisbook.com/_images/graphviz-c871b5de1a7910aea237ca9dc86508b48da94769.png\" alt=\"\"></p>\n<p><img src=\"http://redisbook.com/_images/graphviz-3b31e4e08cc3e212f986039eb08ae77224cdeec9.png\" alt=\"\"></p>\n<p><img src=\"http://redisbook.com/_images/graphviz-86f810ac65c4e6ee58b17105dfeaa06973d8dd16.png\" alt=\"\"></p>\n<h3 id=\"渐进式rehash期间的哈希表操作\"><a href=\"#渐进式rehash期间的哈希表操作\" class=\"headerlink\" title=\"渐进式rehash期间的哈希表操作\"></a>渐进式rehash期间的哈希表操作</h3><p>增删改查在两个表上操作，但是添加的新键只添加到ht[1]上，确保ht[0]最终变成空表。</p>\n<h2 id=\"4-6-字典API\"><a href=\"#4-6-字典API\" class=\"headerlink\" title=\"4.6 字典API\"></a>4.6 字典API</h2><h2 id=\"疑惑\"><a href=\"#疑惑\" class=\"headerlink\" title=\"疑惑\"></a>疑惑</h2><ul>\n<li><p>为什么不直接用<code>dictEntry *table[]</code> 来表示，却要用指针？应该是指针更加灵活些？</p>\n<ul>\n<li>因为dict有两个哈希表，而其中有个哈希表ht[1] 是只有在rehash的时候才会使用的，因此使用指针的的话，在不需要的时候将table直接指向null就可以简单的完成释放空间的操作，如果用数组的话,在分配内存的时候，就必须要为两个dictht都分配size个byte的内存存储空间，当rehash的时候size会变化，结构体中的数组就需要重新分配内存空间，而结构体的内存是相邻连续的，所以这时候要变化空间，只能重新再给这个结构体分配空间，这样效率肯定就很低了。所以使用指针的原因就是rehash的时候数组的大小会变化，如果用数组来记录就很麻烦和效率低了。</li>\n<li>所以在dict中可以使用数组来存储dictht,因为ht这个数组是不会变化的。</li>\n</ul>\n</li>\n<li><p>既然在rehash过程中会有增删改查的操作，那么这些操作是在哪个哈希表上进行的呢？</p>\n<ul>\n<li>两个哈希表上面都会进行，但是增加的键值对会在ht[1] 上，不然ht[0]在减少的时候又新增键值对，不是在做无用之功吗。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://redisbook.com/preview/dict/hash_algorithm.html\" target=\"_blank\" rel=\"noopener\">http://redisbook.com/preview/dict/hash_algorithm.html</a></p>\n<p><a href=\"https://blog.csdn.net/yangbodong22011/article/details/78467583\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/yangbodong22011/article/details/78467583</a></p>"},{"title":"gdb 调试","date":"2019-04-03T08:29:00.000Z","copyright":true,"_content":"\n# gdb调试\n\n以前学习过，用得少，又忘记了，现在刚好为了调试redis 的dict 模块，所以再次记录。\n\n<!--more-->\n\n## 使用\n\n摘自参考<<https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html>>。 主要是补充实例\n\n对C/C++程序的调试，需要在编译前就加上-g选项:\n\n```\n$g++ -g hello.cpp -o hello\n```\n\n自己的Makefile里面修改成：\n\n```\ndict-benchmark: dict.c sds.c siphash.c\n        $(CC) -g -o $@ $^\n```\n\n但是好像没加之前也是可以直接就使用gdb  了？ 不知道为什么（可以使用但是出错不会显示所在的行，相当于没有调试）\n\n调试可执行文件:\n\n```\n$gdb <program>\n```\n\nprogram也就是你的执行文件，一般在当前目录下。\n\n调试core文件(core是程序非法执行后core dump后产生的文件):\n\n```\n$gdb <program> <core dump file>\n$gdb program core.11127\n```\n\n调试服务程序:\n\n```\n$gdb <program> <PID>\n$gdb hello 11127\n```\n\n如果你的程序是一个服务程序，那么你可以指定这个服务程序运行时的进程ID。gdb会自动attach上去，并调试他。program应该在PATH环境变量中搜索得到。\n\n## gdb交互命令\n\n启动gdb后，进入到交互模式，通过以下命令完成对程序的调试；注意高频使用的命令一般都会有缩写，熟练使用这些缩写命令能提高调试的效率；\n\n### 运行\n\n- run：简记为 r ，其作用是运行程序，当遇到断点后，程序会在断点处停止运行，等待用户输入下一步的命令。\n- continue （简写c ）：继续执行，到下一个断点处（或运行结束）\n- next：（简写 n），单步跟踪程序，当遇到函数调用时，也不进入此函数体；此命令同 step 的主要区别是，step 遇到用户自定义的函数，将步进到函数中去运行，而 next 则直接调用函数，不会进入到函数体内。\n- step （简写s）：单步调试如果有函数调用，则进入函数；与命令n不同，n是不进入调用的函数的\n- until：当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。\n- until+行号： 运行至某行，不仅仅用来跳出循环\n- finish： 运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址和返回值及参数值等信息。\n- call 函数(参数)：调用程序中可见的函数，并传递“参数”，如：call gdb_test(55)\n- quit：简记为 q ，退出gdb\n\n### 设置断点\n\n- break n （简写b n）:在第n行处设置断点\n\n  （可以带上代码路径和代码名称： b OAGUPDATE.cpp:578）\n\n- b fn1 if a＞b：条件断点设置\n\n- break func（break缩写为b）：在函数func()的入口处设置断点，如：break cb_button\n\n- delete 断点号n：删除第n个断点\n\n- disable 断点号n：暂停第n个断点\n\n- enable 断点号n：开启第n个断点\n\n- clear 行号n：清除第n行的断点\n\n- info b （info breakpoints） ：显示当前程序的断点设置情况\n\n- delete breakpoints：清除所有断点：\n\n### 查看源代码\n\n- list ：简记为 l ，其作用就是列出程序的源代码，默认每次显示10行。\n- list 行号：将显示当前文件以“行号”为中心的前后10行代码，如：list 12\n- list 函数名：将显示“函数名”所在函数的源代码，如：list main\n- list ：不带参数，将接着上一次 list 命令的，输出下边的内容。\n\n### 打印表达式\n\n- print 表达式：简记为 p ，其中“表达式”可以是任何当前正在被测试程序的有效表达式，比如当前正在调试C语言的程序，那么“表达式”可以是任何C语言的有效表达式，包括数字，变量甚至是函数调用。\n- print a：将显示整数 a 的值\n- print ++a：将把 a 中的值加1,并显示出来\n- print name：将显示字符串 name 的值\n- print gdb_test(22)：将以整数22作为参数调用 gdb_test() 函数\n- print gdb_test(a)：将以变量 a 作为参数调用 gdb_test() 函数\n- display 表达式：在单步运行时将非常有用，使用display命令设置一个表达式后，它将在每次单步进行指令后，紧接着输出被设置的表达式及值。如： display a\n- watch 表达式：设置一个监视点，一旦被监视的“表达式”的值改变，gdb将强行终止正在被调试的程序。如： watch a\n- whatis ：查询变量或函数\n- info function： 查询函数\n- 扩展info locals： 显示当前堆栈页的所有变量\n\n### 查询运行信息\n\n- where/bt ：当前运行的堆栈列表；\n- bt backtrace 显示当前调用堆栈\n- up/down 改变堆栈显示的深度\n- set args 参数:指定运行时的参数\n- show args：查看设置好的参数\n- info program： 来查看程序的是否在运行，进程号，被暂停的原因。\n\n### 分割窗口\n\n- layout：用于分割窗口，可以一边查看代码，一边测试：\n- layout src：显示源代码窗口\n- layout asm：显示反汇编窗口\n- layout regs：显示源代码/反汇编和CPU寄存器窗口\n- layout split：显示源代码和反汇编窗口\n- Ctrl + L：刷新窗口\n\n## 实例\n\n调试程序dict-benchmark\n\n开始调试：\n\n```\nroot@hw103:/home/yky/test/redis_dict/dict-benchmark# gdb dict-benchmark \nGNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1\nCopyright (C) 2016 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.  Type \"show copying\"\nand \"show warranty\" for details.\nThis GDB was configured as \"x86_64-linux-gnu\".\nType \"show configuration\" for configuration details.\nFor bug reporting instructions, please see:\n<http://www.gnu.org/software/gdb/bugs/>.\nFind the GDB manual and other documentation resources online at:\n<http://www.gnu.org/software/gdb/documentation/>.\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\"...\nReading symbols from dict-benchmark...done.\n(gdb) \n```\n\n使用 r 运行：\n\n```\n(gdb) r\nStarting program: /home/yky/test/redis_dict/dict-benchmark/dict-benchmark \nAdd elements to dict\nAdd ret0 is :0, ht[0].used:1, ht[0].size:4,ht[1].used:0, ht[1].size:0\nAdd ret1 is :0, ht[0].used:2, ht[0].size:4,ht[1].used:0, ht[1].size:0\nAdd ret2 is :0, ht[0].used:3, ht[0].size:4,ht[1].used:0, ht[1].size:0\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x000000000040288b in _dictKeyIndex (d=0x60a050, key=0x60a011, hash=3050426978, existing=0x0) at dict.c:975\n975                 if (key==he->key || dictCompareKeys(d, key, he->key)) {\n(gdb) \n\n```\n\n在_dictKeyIndex ()函数也就是计算索引的时候出错。\n\nl 列出代码：\n\n```\n(gdb) l\n970         for (table = 0; table <= 1; table++) {\n971             idx = hash & d->ht[table].sizemask;\n972             /* Search if this slot does not already contain the given key */\n973             he = d->ht[table].table[idx];\n974             while(he) {\n975                 if (key==he->key || dictCompareKeys(d, key, he->key)) {\n976                     if (existing) *existing = he;\n977                     return -1;\n978                 }\n979                 he = he->next;\n\n```\n\n在975行加入断点  b n\n\n```\n(gdb) b 975\nBreakpoint 2 at 0x402887: file dict.c, line 975.\n\n```\n\n输出对应变量的值：print\n\n```\n(gdb) print key \n$1 = (const void *) 0x60a011\n```\n\n\n\n## 参考\n\n<https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html>","source":"_posts/2019-04-03-gdb-调试.md","raw":"---\ntitle: gdb 调试\ndate: 2019-04-03 16:29:00\ncategories: Linux\ntags:\n- gdb\n- 工具\ncopyright: true\n---\n\n# gdb调试\n\n以前学习过，用得少，又忘记了，现在刚好为了调试redis 的dict 模块，所以再次记录。\n\n<!--more-->\n\n## 使用\n\n摘自参考<<https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html>>。 主要是补充实例\n\n对C/C++程序的调试，需要在编译前就加上-g选项:\n\n```\n$g++ -g hello.cpp -o hello\n```\n\n自己的Makefile里面修改成：\n\n```\ndict-benchmark: dict.c sds.c siphash.c\n        $(CC) -g -o $@ $^\n```\n\n但是好像没加之前也是可以直接就使用gdb  了？ 不知道为什么（可以使用但是出错不会显示所在的行，相当于没有调试）\n\n调试可执行文件:\n\n```\n$gdb <program>\n```\n\nprogram也就是你的执行文件，一般在当前目录下。\n\n调试core文件(core是程序非法执行后core dump后产生的文件):\n\n```\n$gdb <program> <core dump file>\n$gdb program core.11127\n```\n\n调试服务程序:\n\n```\n$gdb <program> <PID>\n$gdb hello 11127\n```\n\n如果你的程序是一个服务程序，那么你可以指定这个服务程序运行时的进程ID。gdb会自动attach上去，并调试他。program应该在PATH环境变量中搜索得到。\n\n## gdb交互命令\n\n启动gdb后，进入到交互模式，通过以下命令完成对程序的调试；注意高频使用的命令一般都会有缩写，熟练使用这些缩写命令能提高调试的效率；\n\n### 运行\n\n- run：简记为 r ，其作用是运行程序，当遇到断点后，程序会在断点处停止运行，等待用户输入下一步的命令。\n- continue （简写c ）：继续执行，到下一个断点处（或运行结束）\n- next：（简写 n），单步跟踪程序，当遇到函数调用时，也不进入此函数体；此命令同 step 的主要区别是，step 遇到用户自定义的函数，将步进到函数中去运行，而 next 则直接调用函数，不会进入到函数体内。\n- step （简写s）：单步调试如果有函数调用，则进入函数；与命令n不同，n是不进入调用的函数的\n- until：当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。\n- until+行号： 运行至某行，不仅仅用来跳出循环\n- finish： 运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址和返回值及参数值等信息。\n- call 函数(参数)：调用程序中可见的函数，并传递“参数”，如：call gdb_test(55)\n- quit：简记为 q ，退出gdb\n\n### 设置断点\n\n- break n （简写b n）:在第n行处设置断点\n\n  （可以带上代码路径和代码名称： b OAGUPDATE.cpp:578）\n\n- b fn1 if a＞b：条件断点设置\n\n- break func（break缩写为b）：在函数func()的入口处设置断点，如：break cb_button\n\n- delete 断点号n：删除第n个断点\n\n- disable 断点号n：暂停第n个断点\n\n- enable 断点号n：开启第n个断点\n\n- clear 行号n：清除第n行的断点\n\n- info b （info breakpoints） ：显示当前程序的断点设置情况\n\n- delete breakpoints：清除所有断点：\n\n### 查看源代码\n\n- list ：简记为 l ，其作用就是列出程序的源代码，默认每次显示10行。\n- list 行号：将显示当前文件以“行号”为中心的前后10行代码，如：list 12\n- list 函数名：将显示“函数名”所在函数的源代码，如：list main\n- list ：不带参数，将接着上一次 list 命令的，输出下边的内容。\n\n### 打印表达式\n\n- print 表达式：简记为 p ，其中“表达式”可以是任何当前正在被测试程序的有效表达式，比如当前正在调试C语言的程序，那么“表达式”可以是任何C语言的有效表达式，包括数字，变量甚至是函数调用。\n- print a：将显示整数 a 的值\n- print ++a：将把 a 中的值加1,并显示出来\n- print name：将显示字符串 name 的值\n- print gdb_test(22)：将以整数22作为参数调用 gdb_test() 函数\n- print gdb_test(a)：将以变量 a 作为参数调用 gdb_test() 函数\n- display 表达式：在单步运行时将非常有用，使用display命令设置一个表达式后，它将在每次单步进行指令后，紧接着输出被设置的表达式及值。如： display a\n- watch 表达式：设置一个监视点，一旦被监视的“表达式”的值改变，gdb将强行终止正在被调试的程序。如： watch a\n- whatis ：查询变量或函数\n- info function： 查询函数\n- 扩展info locals： 显示当前堆栈页的所有变量\n\n### 查询运行信息\n\n- where/bt ：当前运行的堆栈列表；\n- bt backtrace 显示当前调用堆栈\n- up/down 改变堆栈显示的深度\n- set args 参数:指定运行时的参数\n- show args：查看设置好的参数\n- info program： 来查看程序的是否在运行，进程号，被暂停的原因。\n\n### 分割窗口\n\n- layout：用于分割窗口，可以一边查看代码，一边测试：\n- layout src：显示源代码窗口\n- layout asm：显示反汇编窗口\n- layout regs：显示源代码/反汇编和CPU寄存器窗口\n- layout split：显示源代码和反汇编窗口\n- Ctrl + L：刷新窗口\n\n## 实例\n\n调试程序dict-benchmark\n\n开始调试：\n\n```\nroot@hw103:/home/yky/test/redis_dict/dict-benchmark# gdb dict-benchmark \nGNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1\nCopyright (C) 2016 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.  Type \"show copying\"\nand \"show warranty\" for details.\nThis GDB was configured as \"x86_64-linux-gnu\".\nType \"show configuration\" for configuration details.\nFor bug reporting instructions, please see:\n<http://www.gnu.org/software/gdb/bugs/>.\nFind the GDB manual and other documentation resources online at:\n<http://www.gnu.org/software/gdb/documentation/>.\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\"...\nReading symbols from dict-benchmark...done.\n(gdb) \n```\n\n使用 r 运行：\n\n```\n(gdb) r\nStarting program: /home/yky/test/redis_dict/dict-benchmark/dict-benchmark \nAdd elements to dict\nAdd ret0 is :0, ht[0].used:1, ht[0].size:4,ht[1].used:0, ht[1].size:0\nAdd ret1 is :0, ht[0].used:2, ht[0].size:4,ht[1].used:0, ht[1].size:0\nAdd ret2 is :0, ht[0].used:3, ht[0].size:4,ht[1].used:0, ht[1].size:0\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x000000000040288b in _dictKeyIndex (d=0x60a050, key=0x60a011, hash=3050426978, existing=0x0) at dict.c:975\n975                 if (key==he->key || dictCompareKeys(d, key, he->key)) {\n(gdb) \n\n```\n\n在_dictKeyIndex ()函数也就是计算索引的时候出错。\n\nl 列出代码：\n\n```\n(gdb) l\n970         for (table = 0; table <= 1; table++) {\n971             idx = hash & d->ht[table].sizemask;\n972             /* Search if this slot does not already contain the given key */\n973             he = d->ht[table].table[idx];\n974             while(he) {\n975                 if (key==he->key || dictCompareKeys(d, key, he->key)) {\n976                     if (existing) *existing = he;\n977                     return -1;\n978                 }\n979                 he = he->next;\n\n```\n\n在975行加入断点  b n\n\n```\n(gdb) b 975\nBreakpoint 2 at 0x402887: file dict.c, line 975.\n\n```\n\n输出对应变量的值：print\n\n```\n(gdb) print key \n$1 = (const void *) 0x60a011\n```\n\n\n\n## 参考\n\n<https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html>","slug":"2019-04-03-gdb-调试","published":1,"updated":"2019-11-28T04:02:56.772Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6he13y50009dstzxyum8dbx","content":"<h1 id=\"gdb调试\"><a href=\"#gdb调试\" class=\"headerlink\" title=\"gdb调试\"></a>gdb调试</h1><p>以前学习过，用得少，又忘记了，现在刚好为了调试redis 的dict 模块，所以再次记录。</p>\n<a id=\"more\"></a>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>摘自参考<a href=\"&lt;https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html\">&lt;https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html</a>&gt;。 主要是补充实例</p>\n<p>对C/C++程序的调试，需要在编译前就加上-g选项:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$g++ -g hello.cpp -o hello</span><br></pre></td></tr></table></figure>\n<p>自己的Makefile里面修改成：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dict-benchmark: dict.c sds.c siphash.c</span><br><span class=\"line\">        $(CC) -g -o $@ $^</span><br></pre></td></tr></table></figure>\n<p>但是好像没加之前也是可以直接就使用gdb  了？ 不知道为什么（可以使用但是出错不会显示所在的行，相当于没有调试）</p>\n<p>调试可执行文件:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$gdb &lt;program&gt;</span><br></pre></td></tr></table></figure>\n<p>program也就是你的执行文件，一般在当前目录下。</p>\n<p>调试core文件(core是程序非法执行后core dump后产生的文件):</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$gdb &lt;program&gt; &lt;core dump file&gt;</span><br><span class=\"line\">$gdb program core.11127</span><br></pre></td></tr></table></figure>\n<p>调试服务程序:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$gdb &lt;program&gt; &lt;PID&gt;</span><br><span class=\"line\">$gdb hello 11127</span><br></pre></td></tr></table></figure>\n<p>如果你的程序是一个服务程序，那么你可以指定这个服务程序运行时的进程ID。gdb会自动attach上去，并调试他。program应该在PATH环境变量中搜索得到。</p>\n<h2 id=\"gdb交互命令\"><a href=\"#gdb交互命令\" class=\"headerlink\" title=\"gdb交互命令\"></a>gdb交互命令</h2><p>启动gdb后，进入到交互模式，通过以下命令完成对程序的调试；注意高频使用的命令一般都会有缩写，熟练使用这些缩写命令能提高调试的效率；</p>\n<h3 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h3><ul>\n<li>run：简记为 r ，其作用是运行程序，当遇到断点后，程序会在断点处停止运行，等待用户输入下一步的命令。</li>\n<li>continue （简写c ）：继续执行，到下一个断点处（或运行结束）</li>\n<li>next：（简写 n），单步跟踪程序，当遇到函数调用时，也不进入此函数体；此命令同 step 的主要区别是，step 遇到用户自定义的函数，将步进到函数中去运行，而 next 则直接调用函数，不会进入到函数体内。</li>\n<li>step （简写s）：单步调试如果有函数调用，则进入函数；与命令n不同，n是不进入调用的函数的</li>\n<li>until：当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。</li>\n<li>until+行号： 运行至某行，不仅仅用来跳出循环</li>\n<li>finish： 运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址和返回值及参数值等信息。</li>\n<li>call 函数(参数)：调用程序中可见的函数，并传递“参数”，如：call gdb_test(55)</li>\n<li>quit：简记为 q ，退出gdb</li>\n</ul>\n<h3 id=\"设置断点\"><a href=\"#设置断点\" class=\"headerlink\" title=\"设置断点\"></a>设置断点</h3><ul>\n<li><p>break n （简写b n）:在第n行处设置断点</p>\n<p>（可以带上代码路径和代码名称： b OAGUPDATE.cpp:578）</p>\n</li>\n<li><p>b fn1 if a＞b：条件断点设置</p>\n</li>\n<li><p>break func（break缩写为b）：在函数func()的入口处设置断点，如：break cb_button</p>\n</li>\n<li><p>delete 断点号n：删除第n个断点</p>\n</li>\n<li><p>disable 断点号n：暂停第n个断点</p>\n</li>\n<li><p>enable 断点号n：开启第n个断点</p>\n</li>\n<li><p>clear 行号n：清除第n行的断点</p>\n</li>\n<li><p>info b （info breakpoints） ：显示当前程序的断点设置情况</p>\n</li>\n<li><p>delete breakpoints：清除所有断点：</p>\n</li>\n</ul>\n<h3 id=\"查看源代码\"><a href=\"#查看源代码\" class=\"headerlink\" title=\"查看源代码\"></a>查看源代码</h3><ul>\n<li>list ：简记为 l ，其作用就是列出程序的源代码，默认每次显示10行。</li>\n<li>list 行号：将显示当前文件以“行号”为中心的前后10行代码，如：list 12</li>\n<li>list 函数名：将显示“函数名”所在函数的源代码，如：list main</li>\n<li>list ：不带参数，将接着上一次 list 命令的，输出下边的内容。</li>\n</ul>\n<h3 id=\"打印表达式\"><a href=\"#打印表达式\" class=\"headerlink\" title=\"打印表达式\"></a>打印表达式</h3><ul>\n<li>print 表达式：简记为 p ，其中“表达式”可以是任何当前正在被测试程序的有效表达式，比如当前正在调试C语言的程序，那么“表达式”可以是任何C语言的有效表达式，包括数字，变量甚至是函数调用。</li>\n<li>print a：将显示整数 a 的值</li>\n<li>print ++a：将把 a 中的值加1,并显示出来</li>\n<li>print name：将显示字符串 name 的值</li>\n<li>print gdb_test(22)：将以整数22作为参数调用 gdb_test() 函数</li>\n<li>print gdb_test(a)：将以变量 a 作为参数调用 gdb_test() 函数</li>\n<li>display 表达式：在单步运行时将非常有用，使用display命令设置一个表达式后，它将在每次单步进行指令后，紧接着输出被设置的表达式及值。如： display a</li>\n<li>watch 表达式：设置一个监视点，一旦被监视的“表达式”的值改变，gdb将强行终止正在被调试的程序。如： watch a</li>\n<li>whatis ：查询变量或函数</li>\n<li>info function： 查询函数</li>\n<li>扩展info locals： 显示当前堆栈页的所有变量</li>\n</ul>\n<h3 id=\"查询运行信息\"><a href=\"#查询运行信息\" class=\"headerlink\" title=\"查询运行信息\"></a>查询运行信息</h3><ul>\n<li>where/bt ：当前运行的堆栈列表；</li>\n<li>bt backtrace 显示当前调用堆栈</li>\n<li>up/down 改变堆栈显示的深度</li>\n<li>set args 参数:指定运行时的参数</li>\n<li>show args：查看设置好的参数</li>\n<li>info program： 来查看程序的是否在运行，进程号，被暂停的原因。</li>\n</ul>\n<h3 id=\"分割窗口\"><a href=\"#分割窗口\" class=\"headerlink\" title=\"分割窗口\"></a>分割窗口</h3><ul>\n<li>layout：用于分割窗口，可以一边查看代码，一边测试：</li>\n<li>layout src：显示源代码窗口</li>\n<li>layout asm：显示反汇编窗口</li>\n<li>layout regs：显示源代码/反汇编和CPU寄存器窗口</li>\n<li>layout split：显示源代码和反汇编窗口</li>\n<li>Ctrl + L：刷新窗口</li>\n</ul>\n<h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2><p>调试程序dict-benchmark</p>\n<p>开始调试：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@hw103:/home/yky/test/redis_dict/dict-benchmark# gdb dict-benchmark </span><br><span class=\"line\">GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1</span><br><span class=\"line\">Copyright (C) 2016 Free Software Foundation, Inc.</span><br><span class=\"line\">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class=\"line\">This is free software: you are free to change and redistribute it.</span><br><span class=\"line\">There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;</span><br><span class=\"line\">and &quot;show warranty&quot; for details.</span><br><span class=\"line\">This GDB was configured as &quot;x86_64-linux-gnu&quot;.</span><br><span class=\"line\">Type &quot;show configuration&quot; for configuration details.</span><br><span class=\"line\">For bug reporting instructions, please see:</span><br><span class=\"line\">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class=\"line\">Find the GDB manual and other documentation resources online at:</span><br><span class=\"line\">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class=\"line\">For help, type &quot;help&quot;.</span><br><span class=\"line\">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...</span><br><span class=\"line\">Reading symbols from dict-benchmark...done.</span><br><span class=\"line\">(gdb)</span><br></pre></td></tr></table></figure>\n<p>使用 r 运行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(gdb) r</span><br><span class=\"line\">Starting program: /home/yky/test/redis_dict/dict-benchmark/dict-benchmark </span><br><span class=\"line\">Add elements to dict</span><br><span class=\"line\">Add ret0 is :0, ht[0].used:1, ht[0].size:4,ht[1].used:0, ht[1].size:0</span><br><span class=\"line\">Add ret1 is :0, ht[0].used:2, ht[0].size:4,ht[1].used:0, ht[1].size:0</span><br><span class=\"line\">Add ret2 is :0, ht[0].used:3, ht[0].size:4,ht[1].used:0, ht[1].size:0</span><br><span class=\"line\"></span><br><span class=\"line\">Program received signal SIGSEGV, Segmentation fault.</span><br><span class=\"line\">0x000000000040288b in _dictKeyIndex (d=0x60a050, key=0x60a011, hash=3050426978, existing=0x0) at dict.c:975</span><br><span class=\"line\">975                 if (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key)) &#123;</span><br><span class=\"line\">(gdb)</span><br></pre></td></tr></table></figure>\n<p>在_dictKeyIndex ()函数也就是计算索引的时候出错。</p>\n<p>l 列出代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(gdb) l</span><br><span class=\"line\">970         for (table = 0; table &lt;= 1; table++) &#123;</span><br><span class=\"line\">971             idx = hash &amp; d-&gt;ht[table].sizemask;</span><br><span class=\"line\">972             /* Search if this slot does not already contain the given key */</span><br><span class=\"line\">973             he = d-&gt;ht[table].table[idx];</span><br><span class=\"line\">974             while(he) &#123;</span><br><span class=\"line\">975                 if (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key)) &#123;</span><br><span class=\"line\">976                     if (existing) *existing = he;</span><br><span class=\"line\">977                     return -1;</span><br><span class=\"line\">978                 &#125;</span><br><span class=\"line\">979                 he = he-&gt;next;</span><br></pre></td></tr></table></figure>\n<p>在975行加入断点  b n</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(gdb) b 975</span><br><span class=\"line\">Breakpoint 2 at 0x402887: file dict.c, line 975.</span><br></pre></td></tr></table></figure>\n<p>输出对应变量的值：print</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(gdb) print key </span><br><span class=\"line\">$1 = (const void *) 0x60a011</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html\" target=\"_blank\" rel=\"noopener\">https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html</a></p>\n","site":{"data":{}},"length":4137,"excerpt":"<h1 id=\"gdb调试\"><a href=\"#gdb调试\" class=\"headerlink\" title=\"gdb调试\"></a>gdb调试</h1><p>以前学习过，用得少，又忘记了，现在刚好为了调试redis 的dict 模块，所以再次记录。</p>","more":"<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>摘自参考<a href=\"&lt;https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html\">&lt;https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html</a>&gt;。 主要是补充实例</p>\n<p>对C/C++程序的调试，需要在编译前就加上-g选项:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$g++ -g hello.cpp -o hello</span><br></pre></td></tr></table></figure>\n<p>自己的Makefile里面修改成：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dict-benchmark: dict.c sds.c siphash.c</span><br><span class=\"line\">        $(CC) -g -o $@ $^</span><br></pre></td></tr></table></figure>\n<p>但是好像没加之前也是可以直接就使用gdb  了？ 不知道为什么（可以使用但是出错不会显示所在的行，相当于没有调试）</p>\n<p>调试可执行文件:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$gdb &lt;program&gt;</span><br></pre></td></tr></table></figure>\n<p>program也就是你的执行文件，一般在当前目录下。</p>\n<p>调试core文件(core是程序非法执行后core dump后产生的文件):</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$gdb &lt;program&gt; &lt;core dump file&gt;</span><br><span class=\"line\">$gdb program core.11127</span><br></pre></td></tr></table></figure>\n<p>调试服务程序:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$gdb &lt;program&gt; &lt;PID&gt;</span><br><span class=\"line\">$gdb hello 11127</span><br></pre></td></tr></table></figure>\n<p>如果你的程序是一个服务程序，那么你可以指定这个服务程序运行时的进程ID。gdb会自动attach上去，并调试他。program应该在PATH环境变量中搜索得到。</p>\n<h2 id=\"gdb交互命令\"><a href=\"#gdb交互命令\" class=\"headerlink\" title=\"gdb交互命令\"></a>gdb交互命令</h2><p>启动gdb后，进入到交互模式，通过以下命令完成对程序的调试；注意高频使用的命令一般都会有缩写，熟练使用这些缩写命令能提高调试的效率；</p>\n<h3 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h3><ul>\n<li>run：简记为 r ，其作用是运行程序，当遇到断点后，程序会在断点处停止运行，等待用户输入下一步的命令。</li>\n<li>continue （简写c ）：继续执行，到下一个断点处（或运行结束）</li>\n<li>next：（简写 n），单步跟踪程序，当遇到函数调用时，也不进入此函数体；此命令同 step 的主要区别是，step 遇到用户自定义的函数，将步进到函数中去运行，而 next 则直接调用函数，不会进入到函数体内。</li>\n<li>step （简写s）：单步调试如果有函数调用，则进入函数；与命令n不同，n是不进入调用的函数的</li>\n<li>until：当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。</li>\n<li>until+行号： 运行至某行，不仅仅用来跳出循环</li>\n<li>finish： 运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址和返回值及参数值等信息。</li>\n<li>call 函数(参数)：调用程序中可见的函数，并传递“参数”，如：call gdb_test(55)</li>\n<li>quit：简记为 q ，退出gdb</li>\n</ul>\n<h3 id=\"设置断点\"><a href=\"#设置断点\" class=\"headerlink\" title=\"设置断点\"></a>设置断点</h3><ul>\n<li><p>break n （简写b n）:在第n行处设置断点</p>\n<p>（可以带上代码路径和代码名称： b OAGUPDATE.cpp:578）</p>\n</li>\n<li><p>b fn1 if a＞b：条件断点设置</p>\n</li>\n<li><p>break func（break缩写为b）：在函数func()的入口处设置断点，如：break cb_button</p>\n</li>\n<li><p>delete 断点号n：删除第n个断点</p>\n</li>\n<li><p>disable 断点号n：暂停第n个断点</p>\n</li>\n<li><p>enable 断点号n：开启第n个断点</p>\n</li>\n<li><p>clear 行号n：清除第n行的断点</p>\n</li>\n<li><p>info b （info breakpoints） ：显示当前程序的断点设置情况</p>\n</li>\n<li><p>delete breakpoints：清除所有断点：</p>\n</li>\n</ul>\n<h3 id=\"查看源代码\"><a href=\"#查看源代码\" class=\"headerlink\" title=\"查看源代码\"></a>查看源代码</h3><ul>\n<li>list ：简记为 l ，其作用就是列出程序的源代码，默认每次显示10行。</li>\n<li>list 行号：将显示当前文件以“行号”为中心的前后10行代码，如：list 12</li>\n<li>list 函数名：将显示“函数名”所在函数的源代码，如：list main</li>\n<li>list ：不带参数，将接着上一次 list 命令的，输出下边的内容。</li>\n</ul>\n<h3 id=\"打印表达式\"><a href=\"#打印表达式\" class=\"headerlink\" title=\"打印表达式\"></a>打印表达式</h3><ul>\n<li>print 表达式：简记为 p ，其中“表达式”可以是任何当前正在被测试程序的有效表达式，比如当前正在调试C语言的程序，那么“表达式”可以是任何C语言的有效表达式，包括数字，变量甚至是函数调用。</li>\n<li>print a：将显示整数 a 的值</li>\n<li>print ++a：将把 a 中的值加1,并显示出来</li>\n<li>print name：将显示字符串 name 的值</li>\n<li>print gdb_test(22)：将以整数22作为参数调用 gdb_test() 函数</li>\n<li>print gdb_test(a)：将以变量 a 作为参数调用 gdb_test() 函数</li>\n<li>display 表达式：在单步运行时将非常有用，使用display命令设置一个表达式后，它将在每次单步进行指令后，紧接着输出被设置的表达式及值。如： display a</li>\n<li>watch 表达式：设置一个监视点，一旦被监视的“表达式”的值改变，gdb将强行终止正在被调试的程序。如： watch a</li>\n<li>whatis ：查询变量或函数</li>\n<li>info function： 查询函数</li>\n<li>扩展info locals： 显示当前堆栈页的所有变量</li>\n</ul>\n<h3 id=\"查询运行信息\"><a href=\"#查询运行信息\" class=\"headerlink\" title=\"查询运行信息\"></a>查询运行信息</h3><ul>\n<li>where/bt ：当前运行的堆栈列表；</li>\n<li>bt backtrace 显示当前调用堆栈</li>\n<li>up/down 改变堆栈显示的深度</li>\n<li>set args 参数:指定运行时的参数</li>\n<li>show args：查看设置好的参数</li>\n<li>info program： 来查看程序的是否在运行，进程号，被暂停的原因。</li>\n</ul>\n<h3 id=\"分割窗口\"><a href=\"#分割窗口\" class=\"headerlink\" title=\"分割窗口\"></a>分割窗口</h3><ul>\n<li>layout：用于分割窗口，可以一边查看代码，一边测试：</li>\n<li>layout src：显示源代码窗口</li>\n<li>layout asm：显示反汇编窗口</li>\n<li>layout regs：显示源代码/反汇编和CPU寄存器窗口</li>\n<li>layout split：显示源代码和反汇编窗口</li>\n<li>Ctrl + L：刷新窗口</li>\n</ul>\n<h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2><p>调试程序dict-benchmark</p>\n<p>开始调试：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@hw103:/home/yky/test/redis_dict/dict-benchmark# gdb dict-benchmark </span><br><span class=\"line\">GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1</span><br><span class=\"line\">Copyright (C) 2016 Free Software Foundation, Inc.</span><br><span class=\"line\">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class=\"line\">This is free software: you are free to change and redistribute it.</span><br><span class=\"line\">There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;</span><br><span class=\"line\">and &quot;show warranty&quot; for details.</span><br><span class=\"line\">This GDB was configured as &quot;x86_64-linux-gnu&quot;.</span><br><span class=\"line\">Type &quot;show configuration&quot; for configuration details.</span><br><span class=\"line\">For bug reporting instructions, please see:</span><br><span class=\"line\">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class=\"line\">Find the GDB manual and other documentation resources online at:</span><br><span class=\"line\">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class=\"line\">For help, type &quot;help&quot;.</span><br><span class=\"line\">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...</span><br><span class=\"line\">Reading symbols from dict-benchmark...done.</span><br><span class=\"line\">(gdb)</span><br></pre></td></tr></table></figure>\n<p>使用 r 运行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(gdb) r</span><br><span class=\"line\">Starting program: /home/yky/test/redis_dict/dict-benchmark/dict-benchmark </span><br><span class=\"line\">Add elements to dict</span><br><span class=\"line\">Add ret0 is :0, ht[0].used:1, ht[0].size:4,ht[1].used:0, ht[1].size:0</span><br><span class=\"line\">Add ret1 is :0, ht[0].used:2, ht[0].size:4,ht[1].used:0, ht[1].size:0</span><br><span class=\"line\">Add ret2 is :0, ht[0].used:3, ht[0].size:4,ht[1].used:0, ht[1].size:0</span><br><span class=\"line\"></span><br><span class=\"line\">Program received signal SIGSEGV, Segmentation fault.</span><br><span class=\"line\">0x000000000040288b in _dictKeyIndex (d=0x60a050, key=0x60a011, hash=3050426978, existing=0x0) at dict.c:975</span><br><span class=\"line\">975                 if (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key)) &#123;</span><br><span class=\"line\">(gdb)</span><br></pre></td></tr></table></figure>\n<p>在_dictKeyIndex ()函数也就是计算索引的时候出错。</p>\n<p>l 列出代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(gdb) l</span><br><span class=\"line\">970         for (table = 0; table &lt;= 1; table++) &#123;</span><br><span class=\"line\">971             idx = hash &amp; d-&gt;ht[table].sizemask;</span><br><span class=\"line\">972             /* Search if this slot does not already contain the given key */</span><br><span class=\"line\">973             he = d-&gt;ht[table].table[idx];</span><br><span class=\"line\">974             while(he) &#123;</span><br><span class=\"line\">975                 if (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key)) &#123;</span><br><span class=\"line\">976                     if (existing) *existing = he;</span><br><span class=\"line\">977                     return -1;</span><br><span class=\"line\">978                 &#125;</span><br><span class=\"line\">979                 he = he-&gt;next;</span><br></pre></td></tr></table></figure>\n<p>在975行加入断点  b n</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(gdb) b 975</span><br><span class=\"line\">Breakpoint 2 at 0x402887: file dict.c, line 975.</span><br></pre></td></tr></table></figure>\n<p>输出对应变量的值：print</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(gdb) print key </span><br><span class=\"line\">$1 = (const void *) 0x60a011</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html\" target=\"_blank\" rel=\"noopener\">https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html</a></p>"},{"title":"Redis设计与实现读书笔记——第8章 对象","date":"2019-03-29T01:28:19.000Z","copyright":true,"_content":"\n# Redis设计与实现读书笔记——第8章 对象\n\nRedis 并没有直接使用sds、dict等数据结构来实现键值对数据库， 而是基于这些数据结构创建了一个对象系统， 这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象， 每种对象都用到了至少一种前面所介绍的数据结构。\n\n<!--more-->\n\n## 简介\n\n对象的好处：\n\n- 根据对象的类型来判断是否可以执行给定的命令。\n- 针对不同的使用场景， 为对象设置多种不同的数据结构实现， 从而优化对象在不同场景下的使用效率。\n\n对象的特性：\n\n- 基于引用计数技术的内存回收机制（和java的是否原理相似）\n- 通过引用计数技术实现对象共享机制，多个键共享同一个对象来节约内存\n- 带有访问时间记录信息，可以用来删除空转时长较大的键\n\n## 8.1 对象的类型与编码\n\nRedis 使用对象来表示数据库中的键和值，创建一个新的键值对的时候，至少包含两个对象：1. 键对象 2. 值对象\n\n对象都由一个 `redisObject` 结构表示，保存数据相关的属性\n\n```c\ntypedef struct redisObject {\n    // 对象类型\n    unsigned type:4;\n    // 编码\n    unsigned encoding:4;\n    //lru 时钟 记录最后被访问的时间，也就是空转时长\n    unsigned lru:LRU_BITS; /* LRU time (relative to global lru_clock) or\n                            * LFU data (least significant 8 bits frequency\n                            * and most significant 16 bits decreas time). */\n    // 引用计数 实现内存自动回收等。\n    int refcount;\n    // 指向底层实现数据结构的指针\n    void *ptr;\n} robj;\n\n```\n\nptr指向的就是之前的sds，dict这些数据结构的内存地址。\n\n变量申明加冒号的用法： 是C语言的位域的用法。`:`后面的数字用来限定成员变量占用的位数。冒号后面的数字说明只会用到对应多少个bit位。type只会用到4个bit，encoding 也只会用的4个bit。变量占用的内存不再是有类型决定，而是位域。\n\n### 8.1.1 类型\n\ntype属性的值包括5种：\n\n| 类型常量       | 对象的名称   |\n| :------------- | :----------- |\n| `REDIS_STRING` | 字符串对象   |\n| `REDIS_LIST`   | 列表对象     |\n| `REDIS_HASH`   | 哈希对象     |\n| `REDIS_SET`    | 集合对象     |\n| `REDIS_ZSET`   | 有序集合对象 |\n\n键对象只能是字符串对象，而值对象则5种之一。所以执行TYPE命令返回的是键值对中值对象的类型。\n\ntype命令的\n\n| 对象         | 对象 `type` 属性的值 | TYPE 命令的输出 |\n| :----------- | :------------------- | :-------------- |\n| 字符串对象   | `REDIS_STRING`       | `\"string\"`      |\n| 列表对象     | `REDIS_LIST`         | `\"list\"`        |\n| 哈希对象     | `REDIS_HASH`         | `\"hash\"`        |\n| 集合对象     | `REDIS_SET`          | `\"set\"`         |\n| 有序集合对象 | `REDIS_ZSET`         | `\"zset\"`        |\n\n### 8.2 编码和底层实现\n\nptr指向底层数据结构，而encoding则决定了具体应该指向什么样的数据结构实现。之所以不能用type来决定指向的具体数据结构，是因为同一种对象，但是底层实现会有不同的数据结构。\n\n| 编码常量                    | 编码所对应的底层数据结构      |\n| :-------------------------- | :---------------------------- |\n| `REDIS_ENCODING_INT`        | `long` 类型的整数             |\n| `REDIS_ENCODING_EMBSTR`     | `embstr` 编码的简单动态字符串 |\n| `REDIS_ENCODING_RAW`        | 简单动态字符串                |\n| `REDIS_ENCODING_HT`         | 字典                          |\n| `REDIS_ENCODING_LINKEDLIST` | 双端链表                      |\n| `REDIS_ENCODING_ZIPLIST`    | 压缩列表                      |\n| `REDIS_ENCODING_INTSET`     | 整数集合                      |\n| `REDIS_ENCODING_SKIPLIST`   | 跳跃表和字典                  |\n\n每种类型的对象都至少使用了两种不同的编码，对应关系为：\n\n| 类型           | 编码                        | 对象                                                 |\n| :------------- | :-------------------------- | :--------------------------------------------------- |\n| `REDIS_STRING` | `REDIS_ENCODING_INT`        | 使用整数值实现的字符串对象。                         |\n| `REDIS_STRING` | `REDIS_ENCODING_EMBSTR`     | 使用 `embstr` 编码的简单动态字符串实现的字符串对象。 |\n| `REDIS_STRING` | `REDIS_ENCODING_RAW`        | 使用简单动态字符串实现的字符串对象。                 |\n| `REDIS_LIST`   | `REDIS_ENCODING_ZIPLIST`    | 使用压缩列表实现的列表对象。                         |\n| `REDIS_LIST`   | `REDIS_ENCODING_LINKEDLIST` | 使用双端链表实现的列表对象。                         |\n| `REDIS_HASH`   | `REDIS_ENCODING_ZIPLIST`    | 使用压缩列表实现的哈希对象。                         |\n| `REDIS_HASH`   | `REDIS_ENCODING_HT`         | 使用字典实现的哈希对象。                             |\n| `REDIS_SET`    | `REDIS_ENCODING_INTSET`     | 使用整数集合实现的集合对象。                         |\n| `REDIS_SET`    | `REDIS_ENCODING_HT`         | 使用字典实现的集合对象。                             |\n| `REDIS_ZSET`   | `REDIS_ENCODING_ZIPLIST`    | 使用压缩列表实现的有序集合对象。                     |\n| `REDIS_ZSET`   | `REDIS_ENCODING_SKIPLIST`   | 使用跳跃表和字典实现的有序集合对象。                 |\n\n使用 OBJECT ENCODING 命令可以查看一个数据库键的值对象的编码：\n\n```\nredis> SET msg \"hello wrold\"\nOK\n\nredis> OBJECT ENCODING msg\n\"embstr\"\n```\n\n不同编码的对象所对应的OBJECT ENCODING输出：\n\n表 8-5 OBJECT ENCODING 对不同编码的输出\n\n| 对象所使用的底层数据结构             | 编码常量                    | OBJECT ENCODING 命令输出 |\n| :----------------------------------- | :-------------------------- | :----------------------- |\n| 整数                                 | `REDIS_ENCODING_INT`        | `\"int\"`                  |\n| `embstr` 编码的简单动态字符串（SDS） | `REDIS_ENCODING_EMBSTR`     | `\"embstr\"`               |\n| 简单动态字符串                       | `REDIS_ENCODING_RAW`        | `\"raw\"`                  |\n| 字典                                 | `REDIS_ENCODING_HT`         | `\"hashtable\"`            |\n| 双端链表                             | `REDIS_ENCODING_LINKEDLIST` | `\"linkedlist\"`           |\n| 压缩列表                             | `REDIS_ENCODING_ZIPLIST`    | `\"ziplist\"`              |\n| 整数集合                             | `REDIS_ENCODING_INTSET`     | `\"intset\"`               |\n| 跳跃表和字典                         | `REDIS_ENCODING_SKIPLIST`   | `\"skiplist\"`             |\n\n使用encoding属性来设定对象指向的具体数据结构实现的好处：灵活与效率。根据不同场景来给同一种对象设置不同的数据结构实现。\n\n举个例子， 在列表对象包含的元素比较少时， Redis 使用压缩列表作为列表对象的底层实现：\n\n- 因为压缩列表比双端链表更节约内存， 并且在元素数量较少时， 在内存中以连续块方式保存的压缩列表比起双端链表可以更快被载入到缓存中；\n- 随着列表对象包含的元素越来越多， 使用压缩列表来保存元素的优势逐渐消失时， 对象就会将底层实现从压缩列表转向功能更强、也更适合保存大量元素的双端链表上面；\n\n是不是也可以理解成多态呢？\n\n## 8.2 字符串对象\n\n字符串对象的编码可以是 `int` 、 `raw` 或者 `embstr` 。\n\n1. 保存的对象是整数，而且可以用long类型表示：ptr指针指向一个long类型的内存地址。（是不是不用指向sdshdr了），然后将encoding 设置为REDIS_ENCODING_INT (应该在源码中有个宏定义)\n2. 保存的对象是字符串值，长度小于44字节（书上的39字节，但是先版本已经更新）。这种短字符串对象，直接**只调用一次内存分配**函数来分配一块**连续的空间**  依次包含redisObject和sdshdr两个结构。\n3. 字符串长度大于等于44字节的时候使用raw编码。会调用两次内存分配函数来创建redisObject结构和sdshdr结构。\n\nembstr编码的好处：\n\n- 只用分配一次内存，raw编码需要两次\n- 释放embstr的sds也只需要一次内存释放函数，raw两次\n- embstr的所有数据（对象结构，字符串结构）在连续的一块内存里面，从而可以更好地利用缓存带来的优势\n\nembstr和raw的示意图，摘自书上，但是注意sds的结构稍有变化。\n\nraw编码：\n\n![](http://redisbook.com/_images/graphviz-8731210637d0567af28d3a9d4089d5f864d29950.png)\n\nembstr编码：\n\n![](http://redisbook.com/_images/graphviz-900c13b23ce79372939259603be936c955ccaa62.png)\n\n注意：\n\nlong double类型的浮点数是转换成字符串值来保存的。执行的时候取出字符串再转换成long double 类型。\n\n| 值                                                           | 编码                |\n| :----------------------------------------------------------- | :------------------ |\n| 可以用 `long` 类型保存的整数。                               | `int`               |\n| 可以用 `long double` 类型保存的浮点数。                      | `embstr` 或者 `raw` |\n| 字符串值， 或者因为长度太大而没办法用 `long` 类型表示的整数， 又或者因为长度太大而没办法用 `long double` 类型表示的浮点数。 | `embstr` 或者 `raw` |\n\n### 8.2.1 编码的转换\n\n当保存的值发生变化的时候会进行转换，比如保存的整数值变成了字符串，那么编码从int 变成raw或者embstr。\n\n**注意**： Redis 没有为embstr编写任何修改程序，只有int和raw编码的字符串对象有这些程序，所以embstr编码的对象是只读，因此发生修改的话会从embstr变成raw。\n\n发生修改的源码中应该是将原来的ptr指向的数据结构内存释放掉后，重新指向新创建的对象。\n\n### 8.2.2 字符串命令的实现\n\n所有命令都是针对字符串对象的。\n\n| 命令        | `int` 编码的实现方法                                         | `embstr` 编码的实现方法                                      | `raw` 编码的实现方法                                         |\n| :---------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |\n| SET         | 使用 `int` 编码保存值。                                      | 使用 `embstr` 编码保存值。                                   | 使用 `raw` 编码保存值。                                      |\n| GET         | 拷贝对象所保存的整数值， 将这个拷贝转换成字符串值， 然后向客户端返回这个字符串值。 | 直接向客户端返回字符串值。                                   | 直接向客户端返回字符串值。                                   |\n| APPEND      | 将对象转换成 `raw` 编码， 然后按 `raw`编码的方式执行此操作。 | 将对象转换成 `raw` 编码， 然后按 `raw`编码的方式执行此操作。 | 调用 `sdscatlen` 函数， 将给定字符串追加到现有字符串的末尾。 |\n| INCRBYFLOAT | 取出整数值并将其转换成 `longdouble` 类型的浮点数， 对这个浮点数进行加法计算， 然后将得出的浮点数结果保存起来。 | 取出字符串值并尝试将其转换成`long double` 类型的浮点数， 对这个浮点数进行加法计算， 然后将得出的浮点数结果保存起来。 如果字符串值不能被转换成浮点数， 那么向客户端返回一个错误。 | 取出字符串值并尝试将其转换成 `longdouble` 类型的浮点数， 对这个浮点数进行加法计算， 然后将得出的浮点数结果保存起来。 如果字符串值不能被转换成浮点数， 那么向客户端返回一个错误。 |\n| INCRBY      | 对整数值进行加法计算， 得出的计算结果会作为整数被保存起来。  | `embstr` 编码不能执行此命令， 向客户端返回一个错误。         | `raw` 编码不能执行此命令， 向客户端返回一个错误。            |\n| DECRBY      | 对整数值进行减法计算， 得出的计算结果会作为整数被保存起来。  | `embstr` 编码不能执行此命令， 向客户端返回一个错误。         | `raw` 编码不能执行此命令， 向客户端返回一个错误。            |\n| STRLEN      | 拷贝对象所保存的整数值， 将这个拷贝转换成字符串值， 计算并返回这个字符串值的长度。 | 调用 `sdslen` 函数， 返回字符串的长度。                      | 调用 `sdslen` 函数， 返回字符串的长度。                      |\n| SETRANGE    | 将对象转换成 `raw` 编码， 然后按 `raw`编码的方式执行此命令。 | 将对象转换成 `raw` 编码， 然后按 `raw`编码的方式执行此命令。 | 将字符串特定索引上的值设置为给定的字符。                     |\n| GETRANGE    | 拷贝对象所保存的整数值， 将这个拷贝转换成字符串值， 然后取出并返回字符串指定索引上的字符。 | 直接取出并返回字符串指定索引上的字符。                       | 直接取出并返回字符串指定索引上的字符。                       |\n\n## 8.8 内存回收\n\nRedis通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收。\n\n计数信息由 `redisObject` 结构的 `refcount` 属性记录\n\n- 在创建一个新对象时， 引用计数的值会被初始化为 `1` ；\n- 当对象被一个新程序使用时， 它的引用计数值会被增一；\n- 当对象不再被一个程序使用时， 它的引用计数值会被减一；\n- 当对象的引用计数值变为 `0` 时， 对象所占用的内存会被释放。\n\n对应的API：\n\n| 函数            | 作用                                                         |\n| :-------------- | :----------------------------------------------------------- |\n| `incrRefCount`  | 将对象的引用计数值增一。                                     |\n| `decrRefCount`  | 将对象的引用计数值减一， 当对象的引用计数值等于 `0` 时， 释放对象。 |\n| `resetRefCount` | 将对象的引用计数值设置为 `0` ， 但并不释放对象， 这个函数通常在需要重新设置对象的引用计数值时使用。 |\n\n对象生命周期可以划分为创建对象、操作对象、释放对象三个阶段\n\n一个字符串对象从创建到释放的整个过程：\n\n```c\n// 创建一个字符串对象 s ，对象的引用计数为 1\nrobj *s = createStringObject(...)\n\n// 对象 s 执行各种操作 ...\n\n// 将对象 s 的引用计数减一，使得对象的引用计数变为 0\n// 导致对象 s 被释放\ndecrRefCount(s)\n```\n\n是不是通过计算指向对象这块内存的指针数量来实现的？\n\n### 8.9 对象共享\n\n对于整数值的字符串对象（int编码），在新创建一个字符串对象的时候如果有这个值的字符串对象存在，就不再为新键创建字符串对象，而是将这个新键指向之前已经存在了的字符串对象。然后将这个字符串对象的引用+1。主要目的是节约内存。\n\nRedis初始化服务器的时候创建一万个字符串对象， 这些对象包含了从 `0` 到 `9999` 的所有整数值， 当服务器需要用到值为 `0`到 `9999` 的字符串对象时， 服务器就会使用这些共享对象， 而不是新创建对象。\n\n创建共享字符串对象的数量可以通过修改 `redis.h/REDIS_SHARED_INTEGERS` 常量来修改。\n\n**为什么 Redis 不共享包含字符串的对象？**\n\n当服务器考虑将一个共享对象设置为键的值对象时， 程序需要先检查给定的共享对象和键想创建的目标对象是否完全相同， 只有在共享对象和目标对象完全相同的情况下， 程序才会将共享对象用作键的值对象， 而一个共享对象保存的值越复杂， 验证共享对象和目标对象是否相同所需的复杂度就会越高， 消耗的 CPU 时间也会越多：\n\n- 如果共享对象是保存整数值的字符串对象， 那么验证操作的复杂度为 O(1) ；\n- 如果共享对象是保存字符串值的字符串对象， 那么验证操作的复杂度为 O(N) ；\n- 如果共享对象是包含了多个值（或者对象的）对象， 比如列表对象或者哈希对象， 那么验证操作的复杂度将会是 O(N^2) 。\n\n因此， 尽管共享更复杂的对象可以节约更多的内存， 但受到 CPU 时间的限制， Redis 只对包含整数值的字符串对象进行共享。 （时刻在空间与时间上做权衡）\n\n## 8.9 对象的空转时长\n\n`lru` 属性， 该属性记录了对象最后一次被**命令程序访问**的时间。\n\nOBJECT IDLETIME 命令可以打印出给定键的空转时长， 这一空转时长就是通过将当前时间减去键的值对象的 `lru` 时间计算得出的。\n\nOBJECT IDLETIME 命令的实现是特殊的， 这个命令在访问键的值对象时， 不会修改值对象的 `lru` 属性。\n\nlru的主要作用就是配合maxmemory选项，淘汰不常用的键值对。\n\n如果服务器打开了 `maxmemory` 选项， 并且服务器用于回收内存的算法为 `volatile-lru` 或者 `allkeys-lru` ， 那么当服务器占用的内存数超过了 `maxmemory` 选项所设置的上限值时， 空转时长较高的那部分键会优先被服务器释放， 从而回收内存。\n\n## 疑惑\n\n1. 为什么在一块连续的内存里面可以更好地利用缓存带来的优势？\n2. 引用计数的程序怎么定义？是指线程吗？\n3. 引用计数的具体实现？\n4. 对象共享的时候怎么去判断存不存在已经创建了这个整数值的对象？对整个数据库遍历吗？\n\n","source":"_posts/2019-03-29-Redis设计与实现读书笔记——第8章-对象.md","raw":"---\ntitle: Redis设计与实现读书笔记——第8章 对象\ndate: 2019-03-29 09:28:19\ncategories: 读书笔记\ntags:\n- redis\n- object\ncopyright: true\n---\n\n# Redis设计与实现读书笔记——第8章 对象\n\nRedis 并没有直接使用sds、dict等数据结构来实现键值对数据库， 而是基于这些数据结构创建了一个对象系统， 这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象， 每种对象都用到了至少一种前面所介绍的数据结构。\n\n<!--more-->\n\n## 简介\n\n对象的好处：\n\n- 根据对象的类型来判断是否可以执行给定的命令。\n- 针对不同的使用场景， 为对象设置多种不同的数据结构实现， 从而优化对象在不同场景下的使用效率。\n\n对象的特性：\n\n- 基于引用计数技术的内存回收机制（和java的是否原理相似）\n- 通过引用计数技术实现对象共享机制，多个键共享同一个对象来节约内存\n- 带有访问时间记录信息，可以用来删除空转时长较大的键\n\n## 8.1 对象的类型与编码\n\nRedis 使用对象来表示数据库中的键和值，创建一个新的键值对的时候，至少包含两个对象：1. 键对象 2. 值对象\n\n对象都由一个 `redisObject` 结构表示，保存数据相关的属性\n\n```c\ntypedef struct redisObject {\n    // 对象类型\n    unsigned type:4;\n    // 编码\n    unsigned encoding:4;\n    //lru 时钟 记录最后被访问的时间，也就是空转时长\n    unsigned lru:LRU_BITS; /* LRU time (relative to global lru_clock) or\n                            * LFU data (least significant 8 bits frequency\n                            * and most significant 16 bits decreas time). */\n    // 引用计数 实现内存自动回收等。\n    int refcount;\n    // 指向底层实现数据结构的指针\n    void *ptr;\n} robj;\n\n```\n\nptr指向的就是之前的sds，dict这些数据结构的内存地址。\n\n变量申明加冒号的用法： 是C语言的位域的用法。`:`后面的数字用来限定成员变量占用的位数。冒号后面的数字说明只会用到对应多少个bit位。type只会用到4个bit，encoding 也只会用的4个bit。变量占用的内存不再是有类型决定，而是位域。\n\n### 8.1.1 类型\n\ntype属性的值包括5种：\n\n| 类型常量       | 对象的名称   |\n| :------------- | :----------- |\n| `REDIS_STRING` | 字符串对象   |\n| `REDIS_LIST`   | 列表对象     |\n| `REDIS_HASH`   | 哈希对象     |\n| `REDIS_SET`    | 集合对象     |\n| `REDIS_ZSET`   | 有序集合对象 |\n\n键对象只能是字符串对象，而值对象则5种之一。所以执行TYPE命令返回的是键值对中值对象的类型。\n\ntype命令的\n\n| 对象         | 对象 `type` 属性的值 | TYPE 命令的输出 |\n| :----------- | :------------------- | :-------------- |\n| 字符串对象   | `REDIS_STRING`       | `\"string\"`      |\n| 列表对象     | `REDIS_LIST`         | `\"list\"`        |\n| 哈希对象     | `REDIS_HASH`         | `\"hash\"`        |\n| 集合对象     | `REDIS_SET`          | `\"set\"`         |\n| 有序集合对象 | `REDIS_ZSET`         | `\"zset\"`        |\n\n### 8.2 编码和底层实现\n\nptr指向底层数据结构，而encoding则决定了具体应该指向什么样的数据结构实现。之所以不能用type来决定指向的具体数据结构，是因为同一种对象，但是底层实现会有不同的数据结构。\n\n| 编码常量                    | 编码所对应的底层数据结构      |\n| :-------------------------- | :---------------------------- |\n| `REDIS_ENCODING_INT`        | `long` 类型的整数             |\n| `REDIS_ENCODING_EMBSTR`     | `embstr` 编码的简单动态字符串 |\n| `REDIS_ENCODING_RAW`        | 简单动态字符串                |\n| `REDIS_ENCODING_HT`         | 字典                          |\n| `REDIS_ENCODING_LINKEDLIST` | 双端链表                      |\n| `REDIS_ENCODING_ZIPLIST`    | 压缩列表                      |\n| `REDIS_ENCODING_INTSET`     | 整数集合                      |\n| `REDIS_ENCODING_SKIPLIST`   | 跳跃表和字典                  |\n\n每种类型的对象都至少使用了两种不同的编码，对应关系为：\n\n| 类型           | 编码                        | 对象                                                 |\n| :------------- | :-------------------------- | :--------------------------------------------------- |\n| `REDIS_STRING` | `REDIS_ENCODING_INT`        | 使用整数值实现的字符串对象。                         |\n| `REDIS_STRING` | `REDIS_ENCODING_EMBSTR`     | 使用 `embstr` 编码的简单动态字符串实现的字符串对象。 |\n| `REDIS_STRING` | `REDIS_ENCODING_RAW`        | 使用简单动态字符串实现的字符串对象。                 |\n| `REDIS_LIST`   | `REDIS_ENCODING_ZIPLIST`    | 使用压缩列表实现的列表对象。                         |\n| `REDIS_LIST`   | `REDIS_ENCODING_LINKEDLIST` | 使用双端链表实现的列表对象。                         |\n| `REDIS_HASH`   | `REDIS_ENCODING_ZIPLIST`    | 使用压缩列表实现的哈希对象。                         |\n| `REDIS_HASH`   | `REDIS_ENCODING_HT`         | 使用字典实现的哈希对象。                             |\n| `REDIS_SET`    | `REDIS_ENCODING_INTSET`     | 使用整数集合实现的集合对象。                         |\n| `REDIS_SET`    | `REDIS_ENCODING_HT`         | 使用字典实现的集合对象。                             |\n| `REDIS_ZSET`   | `REDIS_ENCODING_ZIPLIST`    | 使用压缩列表实现的有序集合对象。                     |\n| `REDIS_ZSET`   | `REDIS_ENCODING_SKIPLIST`   | 使用跳跃表和字典实现的有序集合对象。                 |\n\n使用 OBJECT ENCODING 命令可以查看一个数据库键的值对象的编码：\n\n```\nredis> SET msg \"hello wrold\"\nOK\n\nredis> OBJECT ENCODING msg\n\"embstr\"\n```\n\n不同编码的对象所对应的OBJECT ENCODING输出：\n\n表 8-5 OBJECT ENCODING 对不同编码的输出\n\n| 对象所使用的底层数据结构             | 编码常量                    | OBJECT ENCODING 命令输出 |\n| :----------------------------------- | :-------------------------- | :----------------------- |\n| 整数                                 | `REDIS_ENCODING_INT`        | `\"int\"`                  |\n| `embstr` 编码的简单动态字符串（SDS） | `REDIS_ENCODING_EMBSTR`     | `\"embstr\"`               |\n| 简单动态字符串                       | `REDIS_ENCODING_RAW`        | `\"raw\"`                  |\n| 字典                                 | `REDIS_ENCODING_HT`         | `\"hashtable\"`            |\n| 双端链表                             | `REDIS_ENCODING_LINKEDLIST` | `\"linkedlist\"`           |\n| 压缩列表                             | `REDIS_ENCODING_ZIPLIST`    | `\"ziplist\"`              |\n| 整数集合                             | `REDIS_ENCODING_INTSET`     | `\"intset\"`               |\n| 跳跃表和字典                         | `REDIS_ENCODING_SKIPLIST`   | `\"skiplist\"`             |\n\n使用encoding属性来设定对象指向的具体数据结构实现的好处：灵活与效率。根据不同场景来给同一种对象设置不同的数据结构实现。\n\n举个例子， 在列表对象包含的元素比较少时， Redis 使用压缩列表作为列表对象的底层实现：\n\n- 因为压缩列表比双端链表更节约内存， 并且在元素数量较少时， 在内存中以连续块方式保存的压缩列表比起双端链表可以更快被载入到缓存中；\n- 随着列表对象包含的元素越来越多， 使用压缩列表来保存元素的优势逐渐消失时， 对象就会将底层实现从压缩列表转向功能更强、也更适合保存大量元素的双端链表上面；\n\n是不是也可以理解成多态呢？\n\n## 8.2 字符串对象\n\n字符串对象的编码可以是 `int` 、 `raw` 或者 `embstr` 。\n\n1. 保存的对象是整数，而且可以用long类型表示：ptr指针指向一个long类型的内存地址。（是不是不用指向sdshdr了），然后将encoding 设置为REDIS_ENCODING_INT (应该在源码中有个宏定义)\n2. 保存的对象是字符串值，长度小于44字节（书上的39字节，但是先版本已经更新）。这种短字符串对象，直接**只调用一次内存分配**函数来分配一块**连续的空间**  依次包含redisObject和sdshdr两个结构。\n3. 字符串长度大于等于44字节的时候使用raw编码。会调用两次内存分配函数来创建redisObject结构和sdshdr结构。\n\nembstr编码的好处：\n\n- 只用分配一次内存，raw编码需要两次\n- 释放embstr的sds也只需要一次内存释放函数，raw两次\n- embstr的所有数据（对象结构，字符串结构）在连续的一块内存里面，从而可以更好地利用缓存带来的优势\n\nembstr和raw的示意图，摘自书上，但是注意sds的结构稍有变化。\n\nraw编码：\n\n![](http://redisbook.com/_images/graphviz-8731210637d0567af28d3a9d4089d5f864d29950.png)\n\nembstr编码：\n\n![](http://redisbook.com/_images/graphviz-900c13b23ce79372939259603be936c955ccaa62.png)\n\n注意：\n\nlong double类型的浮点数是转换成字符串值来保存的。执行的时候取出字符串再转换成long double 类型。\n\n| 值                                                           | 编码                |\n| :----------------------------------------------------------- | :------------------ |\n| 可以用 `long` 类型保存的整数。                               | `int`               |\n| 可以用 `long double` 类型保存的浮点数。                      | `embstr` 或者 `raw` |\n| 字符串值， 或者因为长度太大而没办法用 `long` 类型表示的整数， 又或者因为长度太大而没办法用 `long double` 类型表示的浮点数。 | `embstr` 或者 `raw` |\n\n### 8.2.1 编码的转换\n\n当保存的值发生变化的时候会进行转换，比如保存的整数值变成了字符串，那么编码从int 变成raw或者embstr。\n\n**注意**： Redis 没有为embstr编写任何修改程序，只有int和raw编码的字符串对象有这些程序，所以embstr编码的对象是只读，因此发生修改的话会从embstr变成raw。\n\n发生修改的源码中应该是将原来的ptr指向的数据结构内存释放掉后，重新指向新创建的对象。\n\n### 8.2.2 字符串命令的实现\n\n所有命令都是针对字符串对象的。\n\n| 命令        | `int` 编码的实现方法                                         | `embstr` 编码的实现方法                                      | `raw` 编码的实现方法                                         |\n| :---------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |\n| SET         | 使用 `int` 编码保存值。                                      | 使用 `embstr` 编码保存值。                                   | 使用 `raw` 编码保存值。                                      |\n| GET         | 拷贝对象所保存的整数值， 将这个拷贝转换成字符串值， 然后向客户端返回这个字符串值。 | 直接向客户端返回字符串值。                                   | 直接向客户端返回字符串值。                                   |\n| APPEND      | 将对象转换成 `raw` 编码， 然后按 `raw`编码的方式执行此操作。 | 将对象转换成 `raw` 编码， 然后按 `raw`编码的方式执行此操作。 | 调用 `sdscatlen` 函数， 将给定字符串追加到现有字符串的末尾。 |\n| INCRBYFLOAT | 取出整数值并将其转换成 `longdouble` 类型的浮点数， 对这个浮点数进行加法计算， 然后将得出的浮点数结果保存起来。 | 取出字符串值并尝试将其转换成`long double` 类型的浮点数， 对这个浮点数进行加法计算， 然后将得出的浮点数结果保存起来。 如果字符串值不能被转换成浮点数， 那么向客户端返回一个错误。 | 取出字符串值并尝试将其转换成 `longdouble` 类型的浮点数， 对这个浮点数进行加法计算， 然后将得出的浮点数结果保存起来。 如果字符串值不能被转换成浮点数， 那么向客户端返回一个错误。 |\n| INCRBY      | 对整数值进行加法计算， 得出的计算结果会作为整数被保存起来。  | `embstr` 编码不能执行此命令， 向客户端返回一个错误。         | `raw` 编码不能执行此命令， 向客户端返回一个错误。            |\n| DECRBY      | 对整数值进行减法计算， 得出的计算结果会作为整数被保存起来。  | `embstr` 编码不能执行此命令， 向客户端返回一个错误。         | `raw` 编码不能执行此命令， 向客户端返回一个错误。            |\n| STRLEN      | 拷贝对象所保存的整数值， 将这个拷贝转换成字符串值， 计算并返回这个字符串值的长度。 | 调用 `sdslen` 函数， 返回字符串的长度。                      | 调用 `sdslen` 函数， 返回字符串的长度。                      |\n| SETRANGE    | 将对象转换成 `raw` 编码， 然后按 `raw`编码的方式执行此命令。 | 将对象转换成 `raw` 编码， 然后按 `raw`编码的方式执行此命令。 | 将字符串特定索引上的值设置为给定的字符。                     |\n| GETRANGE    | 拷贝对象所保存的整数值， 将这个拷贝转换成字符串值， 然后取出并返回字符串指定索引上的字符。 | 直接取出并返回字符串指定索引上的字符。                       | 直接取出并返回字符串指定索引上的字符。                       |\n\n## 8.8 内存回收\n\nRedis通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收。\n\n计数信息由 `redisObject` 结构的 `refcount` 属性记录\n\n- 在创建一个新对象时， 引用计数的值会被初始化为 `1` ；\n- 当对象被一个新程序使用时， 它的引用计数值会被增一；\n- 当对象不再被一个程序使用时， 它的引用计数值会被减一；\n- 当对象的引用计数值变为 `0` 时， 对象所占用的内存会被释放。\n\n对应的API：\n\n| 函数            | 作用                                                         |\n| :-------------- | :----------------------------------------------------------- |\n| `incrRefCount`  | 将对象的引用计数值增一。                                     |\n| `decrRefCount`  | 将对象的引用计数值减一， 当对象的引用计数值等于 `0` 时， 释放对象。 |\n| `resetRefCount` | 将对象的引用计数值设置为 `0` ， 但并不释放对象， 这个函数通常在需要重新设置对象的引用计数值时使用。 |\n\n对象生命周期可以划分为创建对象、操作对象、释放对象三个阶段\n\n一个字符串对象从创建到释放的整个过程：\n\n```c\n// 创建一个字符串对象 s ，对象的引用计数为 1\nrobj *s = createStringObject(...)\n\n// 对象 s 执行各种操作 ...\n\n// 将对象 s 的引用计数减一，使得对象的引用计数变为 0\n// 导致对象 s 被释放\ndecrRefCount(s)\n```\n\n是不是通过计算指向对象这块内存的指针数量来实现的？\n\n### 8.9 对象共享\n\n对于整数值的字符串对象（int编码），在新创建一个字符串对象的时候如果有这个值的字符串对象存在，就不再为新键创建字符串对象，而是将这个新键指向之前已经存在了的字符串对象。然后将这个字符串对象的引用+1。主要目的是节约内存。\n\nRedis初始化服务器的时候创建一万个字符串对象， 这些对象包含了从 `0` 到 `9999` 的所有整数值， 当服务器需要用到值为 `0`到 `9999` 的字符串对象时， 服务器就会使用这些共享对象， 而不是新创建对象。\n\n创建共享字符串对象的数量可以通过修改 `redis.h/REDIS_SHARED_INTEGERS` 常量来修改。\n\n**为什么 Redis 不共享包含字符串的对象？**\n\n当服务器考虑将一个共享对象设置为键的值对象时， 程序需要先检查给定的共享对象和键想创建的目标对象是否完全相同， 只有在共享对象和目标对象完全相同的情况下， 程序才会将共享对象用作键的值对象， 而一个共享对象保存的值越复杂， 验证共享对象和目标对象是否相同所需的复杂度就会越高， 消耗的 CPU 时间也会越多：\n\n- 如果共享对象是保存整数值的字符串对象， 那么验证操作的复杂度为 O(1) ；\n- 如果共享对象是保存字符串值的字符串对象， 那么验证操作的复杂度为 O(N) ；\n- 如果共享对象是包含了多个值（或者对象的）对象， 比如列表对象或者哈希对象， 那么验证操作的复杂度将会是 O(N^2) 。\n\n因此， 尽管共享更复杂的对象可以节约更多的内存， 但受到 CPU 时间的限制， Redis 只对包含整数值的字符串对象进行共享。 （时刻在空间与时间上做权衡）\n\n## 8.9 对象的空转时长\n\n`lru` 属性， 该属性记录了对象最后一次被**命令程序访问**的时间。\n\nOBJECT IDLETIME 命令可以打印出给定键的空转时长， 这一空转时长就是通过将当前时间减去键的值对象的 `lru` 时间计算得出的。\n\nOBJECT IDLETIME 命令的实现是特殊的， 这个命令在访问键的值对象时， 不会修改值对象的 `lru` 属性。\n\nlru的主要作用就是配合maxmemory选项，淘汰不常用的键值对。\n\n如果服务器打开了 `maxmemory` 选项， 并且服务器用于回收内存的算法为 `volatile-lru` 或者 `allkeys-lru` ， 那么当服务器占用的内存数超过了 `maxmemory` 选项所设置的上限值时， 空转时长较高的那部分键会优先被服务器释放， 从而回收内存。\n\n## 疑惑\n\n1. 为什么在一块连续的内存里面可以更好地利用缓存带来的优势？\n2. 引用计数的程序怎么定义？是指线程吗？\n3. 引用计数的具体实现？\n4. 对象共享的时候怎么去判断存不存在已经创建了这个整数值的对象？对整个数据库遍历吗？\n\n","slug":"2019-03-29-Redis设计与实现读书笔记——第8章-对象","published":1,"updated":"2019-11-08T13:15:10.743Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6he13y7000cdstzd4cuv3bb","content":"<h1 id=\"Redis设计与实现读书笔记——第8章-对象\"><a href=\"#Redis设计与实现读书笔记——第8章-对象\" class=\"headerlink\" title=\"Redis设计与实现读书笔记——第8章 对象\"></a>Redis设计与实现读书笔记——第8章 对象</h1><p>Redis 并没有直接使用sds、dict等数据结构来实现键值对数据库， 而是基于这些数据结构创建了一个对象系统， 这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象， 每种对象都用到了至少一种前面所介绍的数据结构。</p>\n<a id=\"more\"></a>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>对象的好处：</p>\n<ul>\n<li>根据对象的类型来判断是否可以执行给定的命令。</li>\n<li>针对不同的使用场景， 为对象设置多种不同的数据结构实现， 从而优化对象在不同场景下的使用效率。</li>\n</ul>\n<p>对象的特性：</p>\n<ul>\n<li>基于引用计数技术的内存回收机制（和java的是否原理相似）</li>\n<li>通过引用计数技术实现对象共享机制，多个键共享同一个对象来节约内存</li>\n<li>带有访问时间记录信息，可以用来删除空转时长较大的键</li>\n</ul>\n<h2 id=\"8-1-对象的类型与编码\"><a href=\"#8-1-对象的类型与编码\" class=\"headerlink\" title=\"8.1 对象的类型与编码\"></a>8.1 对象的类型与编码</h2><p>Redis 使用对象来表示数据库中的键和值，创建一个新的键值对的时候，至少包含两个对象：1. 键对象 2. 值对象</p>\n<p>对象都由一个 <code>redisObject</code> 结构表示，保存数据相关的属性</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">redisObject</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 对象类型</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> type:<span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 编码</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> encoding:<span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"comment\">//lru 时钟 记录最后被访问的时间，也就是空转时长</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> lru:LRU_BITS; <span class=\"comment\">/* LRU time (relative to global lru_clock) or</span></span><br><span class=\"line\"><span class=\"comment\">                            * LFU data (least significant 8 bits frequency</span></span><br><span class=\"line\"><span class=\"comment\">                            * and most significant 16 bits decreas time). */</span></span><br><span class=\"line\">    <span class=\"comment\">// 引用计数 实现内存自动回收等。</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> refcount;</span><br><span class=\"line\">    <span class=\"comment\">// 指向底层实现数据结构的指针</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *ptr;</span><br><span class=\"line\">&#125; robj;</span><br></pre></td></tr></table></figure>\n<p>ptr指向的就是之前的sds，dict这些数据结构的内存地址。</p>\n<p>变量申明加冒号的用法： 是C语言的位域的用法。<code>:</code>后面的数字用来限定成员变量占用的位数。冒号后面的数字说明只会用到对应多少个bit位。type只会用到4个bit，encoding 也只会用的4个bit。变量占用的内存不再是有类型决定，而是位域。</p>\n<h3 id=\"8-1-1-类型\"><a href=\"#8-1-1-类型\" class=\"headerlink\" title=\"8.1.1 类型\"></a>8.1.1 类型</h3><p>type属性的值包括5种：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">类型常量</th>\n<th style=\"text-align:left\">对象的名称</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_STRING</code></td>\n<td style=\"text-align:left\">字符串对象</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_LIST</code></td>\n<td style=\"text-align:left\">列表对象</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_HASH</code></td>\n<td style=\"text-align:left\">哈希对象</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_SET</code></td>\n<td style=\"text-align:left\">集合对象</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_ZSET</code></td>\n<td style=\"text-align:left\">有序集合对象</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>键对象只能是字符串对象，而值对象则5种之一。所以执行TYPE命令返回的是键值对中值对象的类型。</p>\n<p>type命令的</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">对象</th>\n<th style=\"text-align:left\">对象 <code>type</code> 属性的值</th>\n<th style=\"text-align:left\">TYPE 命令的输出</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">字符串对象</td>\n<td style=\"text-align:left\"><code>REDIS_STRING</code></td>\n<td style=\"text-align:left\"><code>&quot;string&quot;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表对象</td>\n<td style=\"text-align:left\"><code>REDIS_LIST</code></td>\n<td style=\"text-align:left\"><code>&quot;list&quot;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">哈希对象</td>\n<td style=\"text-align:left\"><code>REDIS_HASH</code></td>\n<td style=\"text-align:left\"><code>&quot;hash&quot;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">集合对象</td>\n<td style=\"text-align:left\"><code>REDIS_SET</code></td>\n<td style=\"text-align:left\"><code>&quot;set&quot;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">有序集合对象</td>\n<td style=\"text-align:left\"><code>REDIS_ZSET</code></td>\n<td style=\"text-align:left\"><code>&quot;zset&quot;</code></td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"8-2-编码和底层实现\"><a href=\"#8-2-编码和底层实现\" class=\"headerlink\" title=\"8.2 编码和底层实现\"></a>8.2 编码和底层实现</h3><p>ptr指向底层数据结构，而encoding则决定了具体应该指向什么样的数据结构实现。之所以不能用type来决定指向的具体数据结构，是因为同一种对象，但是底层实现会有不同的数据结构。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">编码常量</th>\n<th style=\"text-align:left\">编码所对应的底层数据结构</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_INT</code></td>\n<td style=\"text-align:left\"><code>long</code> 类型的整数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_EMBSTR</code></td>\n<td style=\"text-align:left\"><code>embstr</code> 编码的简单动态字符串</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_RAW</code></td>\n<td style=\"text-align:left\">简单动态字符串</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_HT</code></td>\n<td style=\"text-align:left\">字典</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_LINKEDLIST</code></td>\n<td style=\"text-align:left\">双端链表</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_ZIPLIST</code></td>\n<td style=\"text-align:left\">压缩列表</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_INTSET</code></td>\n<td style=\"text-align:left\">整数集合</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_SKIPLIST</code></td>\n<td style=\"text-align:left\">跳跃表和字典</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>每种类型的对象都至少使用了两种不同的编码，对应关系为：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">编码</th>\n<th style=\"text-align:left\">对象</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_STRING</code></td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_INT</code></td>\n<td style=\"text-align:left\">使用整数值实现的字符串对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_STRING</code></td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_EMBSTR</code></td>\n<td style=\"text-align:left\">使用 <code>embstr</code> 编码的简单动态字符串实现的字符串对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_STRING</code></td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_RAW</code></td>\n<td style=\"text-align:left\">使用简单动态字符串实现的字符串对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_LIST</code></td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_ZIPLIST</code></td>\n<td style=\"text-align:left\">使用压缩列表实现的列表对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_LIST</code></td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_LINKEDLIST</code></td>\n<td style=\"text-align:left\">使用双端链表实现的列表对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_HASH</code></td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_ZIPLIST</code></td>\n<td style=\"text-align:left\">使用压缩列表实现的哈希对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_HASH</code></td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_HT</code></td>\n<td style=\"text-align:left\">使用字典实现的哈希对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_SET</code></td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_INTSET</code></td>\n<td style=\"text-align:left\">使用整数集合实现的集合对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_SET</code></td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_HT</code></td>\n<td style=\"text-align:left\">使用字典实现的集合对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_ZSET</code></td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_ZIPLIST</code></td>\n<td style=\"text-align:left\">使用压缩列表实现的有序集合对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_ZSET</code></td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_SKIPLIST</code></td>\n<td style=\"text-align:left\">使用跳跃表和字典实现的有序集合对象。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>使用 OBJECT ENCODING 命令可以查看一个数据库键的值对象的编码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SET msg &quot;hello wrold&quot;</span><br><span class=\"line\">OK</span><br><span class=\"line\"></span><br><span class=\"line\">redis&gt; OBJECT ENCODING msg</span><br><span class=\"line\">&quot;embstr&quot;</span><br></pre></td></tr></table></figure>\n<p>不同编码的对象所对应的OBJECT ENCODING输出：</p>\n<p>表 8-5 OBJECT ENCODING 对不同编码的输出</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">对象所使用的底层数据结构</th>\n<th style=\"text-align:left\">编码常量</th>\n<th style=\"text-align:left\">OBJECT ENCODING 命令输出</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">整数</td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_INT</code></td>\n<td style=\"text-align:left\"><code>&quot;int&quot;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>embstr</code> 编码的简单动态字符串（SDS）</td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_EMBSTR</code></td>\n<td style=\"text-align:left\"><code>&quot;embstr&quot;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">简单动态字符串</td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_RAW</code></td>\n<td style=\"text-align:left\"><code>&quot;raw&quot;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">字典</td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_HT</code></td>\n<td style=\"text-align:left\"><code>&quot;hashtable&quot;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">双端链表</td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_LINKEDLIST</code></td>\n<td style=\"text-align:left\"><code>&quot;linkedlist&quot;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">压缩列表</td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_ZIPLIST</code></td>\n<td style=\"text-align:left\"><code>&quot;ziplist&quot;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">整数集合</td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_INTSET</code></td>\n<td style=\"text-align:left\"><code>&quot;intset&quot;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">跳跃表和字典</td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_SKIPLIST</code></td>\n<td style=\"text-align:left\"><code>&quot;skiplist&quot;</code></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>使用encoding属性来设定对象指向的具体数据结构实现的好处：灵活与效率。根据不同场景来给同一种对象设置不同的数据结构实现。</p>\n<p>举个例子， 在列表对象包含的元素比较少时， Redis 使用压缩列表作为列表对象的底层实现：</p>\n<ul>\n<li>因为压缩列表比双端链表更节约内存， 并且在元素数量较少时， 在内存中以连续块方式保存的压缩列表比起双端链表可以更快被载入到缓存中；</li>\n<li>随着列表对象包含的元素越来越多， 使用压缩列表来保存元素的优势逐渐消失时， 对象就会将底层实现从压缩列表转向功能更强、也更适合保存大量元素的双端链表上面；</li>\n</ul>\n<p>是不是也可以理解成多态呢？</p>\n<h2 id=\"8-2-字符串对象\"><a href=\"#8-2-字符串对象\" class=\"headerlink\" title=\"8.2 字符串对象\"></a>8.2 字符串对象</h2><p>字符串对象的编码可以是 <code>int</code> 、 <code>raw</code> 或者 <code>embstr</code> 。</p>\n<ol>\n<li>保存的对象是整数，而且可以用long类型表示：ptr指针指向一个long类型的内存地址。（是不是不用指向sdshdr了），然后将encoding 设置为REDIS_ENCODING_INT (应该在源码中有个宏定义)</li>\n<li>保存的对象是字符串值，长度小于44字节（书上的39字节，但是先版本已经更新）。这种短字符串对象，直接<strong>只调用一次内存分配</strong>函数来分配一块<strong>连续的空间</strong>  依次包含redisObject和sdshdr两个结构。</li>\n<li>字符串长度大于等于44字节的时候使用raw编码。会调用两次内存分配函数来创建redisObject结构和sdshdr结构。</li>\n</ol>\n<p>embstr编码的好处：</p>\n<ul>\n<li>只用分配一次内存，raw编码需要两次</li>\n<li>释放embstr的sds也只需要一次内存释放函数，raw两次</li>\n<li>embstr的所有数据（对象结构，字符串结构）在连续的一块内存里面，从而可以更好地利用缓存带来的优势</li>\n</ul>\n<p>embstr和raw的示意图，摘自书上，但是注意sds的结构稍有变化。</p>\n<p>raw编码：</p>\n<p><img src=\"http://redisbook.com/_images/graphviz-8731210637d0567af28d3a9d4089d5f864d29950.png\" alt=\"\"></p>\n<p>embstr编码：</p>\n<p><img src=\"http://redisbook.com/_images/graphviz-900c13b23ce79372939259603be936c955ccaa62.png\" alt=\"\"></p>\n<p>注意：</p>\n<p>long double类型的浮点数是转换成字符串值来保存的。执行的时候取出字符串再转换成long double 类型。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">值</th>\n<th style=\"text-align:left\">编码</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">可以用 <code>long</code> 类型保存的整数。</td>\n<td style=\"text-align:left\"><code>int</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">可以用 <code>long double</code> 类型保存的浮点数。</td>\n<td style=\"text-align:left\"><code>embstr</code> 或者 <code>raw</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">字符串值， 或者因为长度太大而没办法用 <code>long</code> 类型表示的整数， 又或者因为长度太大而没办法用 <code>long double</code> 类型表示的浮点数。</td>\n<td style=\"text-align:left\"><code>embstr</code> 或者 <code>raw</code></td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"8-2-1-编码的转换\"><a href=\"#8-2-1-编码的转换\" class=\"headerlink\" title=\"8.2.1 编码的转换\"></a>8.2.1 编码的转换</h3><p>当保存的值发生变化的时候会进行转换，比如保存的整数值变成了字符串，那么编码从int 变成raw或者embstr。</p>\n<p><strong>注意</strong>： Redis 没有为embstr编写任何修改程序，只有int和raw编码的字符串对象有这些程序，所以embstr编码的对象是只读，因此发生修改的话会从embstr变成raw。</p>\n<p>发生修改的源码中应该是将原来的ptr指向的数据结构内存释放掉后，重新指向新创建的对象。</p>\n<h3 id=\"8-2-2-字符串命令的实现\"><a href=\"#8-2-2-字符串命令的实现\" class=\"headerlink\" title=\"8.2.2 字符串命令的实现\"></a>8.2.2 字符串命令的实现</h3><p>所有命令都是针对字符串对象的。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">命令</th>\n<th style=\"text-align:left\"><code>int</code> 编码的实现方法</th>\n<th style=\"text-align:left\"><code>embstr</code> 编码的实现方法</th>\n<th style=\"text-align:left\"><code>raw</code> 编码的实现方法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">SET</td>\n<td style=\"text-align:left\">使用 <code>int</code> 编码保存值。</td>\n<td style=\"text-align:left\">使用 <code>embstr</code> 编码保存值。</td>\n<td style=\"text-align:left\">使用 <code>raw</code> 编码保存值。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">GET</td>\n<td style=\"text-align:left\">拷贝对象所保存的整数值， 将这个拷贝转换成字符串值， 然后向客户端返回这个字符串值。</td>\n<td style=\"text-align:left\">直接向客户端返回字符串值。</td>\n<td style=\"text-align:left\">直接向客户端返回字符串值。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">APPEND</td>\n<td style=\"text-align:left\">将对象转换成 <code>raw</code> 编码， 然后按 <code>raw</code>编码的方式执行此操作。</td>\n<td style=\"text-align:left\">将对象转换成 <code>raw</code> 编码， 然后按 <code>raw</code>编码的方式执行此操作。</td>\n<td style=\"text-align:left\">调用 <code>sdscatlen</code> 函数， 将给定字符串追加到现有字符串的末尾。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">INCRBYFLOAT</td>\n<td style=\"text-align:left\">取出整数值并将其转换成 <code>longdouble</code> 类型的浮点数， 对这个浮点数进行加法计算， 然后将得出的浮点数结果保存起来。</td>\n<td style=\"text-align:left\">取出字符串值并尝试将其转换成<code>long double</code> 类型的浮点数， 对这个浮点数进行加法计算， 然后将得出的浮点数结果保存起来。 如果字符串值不能被转换成浮点数， 那么向客户端返回一个错误。</td>\n<td style=\"text-align:left\">取出字符串值并尝试将其转换成 <code>longdouble</code> 类型的浮点数， 对这个浮点数进行加法计算， 然后将得出的浮点数结果保存起来。 如果字符串值不能被转换成浮点数， 那么向客户端返回一个错误。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">INCRBY</td>\n<td style=\"text-align:left\">对整数值进行加法计算， 得出的计算结果会作为整数被保存起来。</td>\n<td style=\"text-align:left\"><code>embstr</code> 编码不能执行此命令， 向客户端返回一个错误。</td>\n<td style=\"text-align:left\"><code>raw</code> 编码不能执行此命令， 向客户端返回一个错误。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">DECRBY</td>\n<td style=\"text-align:left\">对整数值进行减法计算， 得出的计算结果会作为整数被保存起来。</td>\n<td style=\"text-align:left\"><code>embstr</code> 编码不能执行此命令， 向客户端返回一个错误。</td>\n<td style=\"text-align:left\"><code>raw</code> 编码不能执行此命令， 向客户端返回一个错误。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">STRLEN</td>\n<td style=\"text-align:left\">拷贝对象所保存的整数值， 将这个拷贝转换成字符串值， 计算并返回这个字符串值的长度。</td>\n<td style=\"text-align:left\">调用 <code>sdslen</code> 函数， 返回字符串的长度。</td>\n<td style=\"text-align:left\">调用 <code>sdslen</code> 函数， 返回字符串的长度。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">SETRANGE</td>\n<td style=\"text-align:left\">将对象转换成 <code>raw</code> 编码， 然后按 <code>raw</code>编码的方式执行此命令。</td>\n<td style=\"text-align:left\">将对象转换成 <code>raw</code> 编码， 然后按 <code>raw</code>编码的方式执行此命令。</td>\n<td style=\"text-align:left\">将字符串特定索引上的值设置为给定的字符。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">GETRANGE</td>\n<td style=\"text-align:left\">拷贝对象所保存的整数值， 将这个拷贝转换成字符串值， 然后取出并返回字符串指定索引上的字符。</td>\n<td style=\"text-align:left\">直接取出并返回字符串指定索引上的字符。</td>\n<td style=\"text-align:left\">直接取出并返回字符串指定索引上的字符。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"8-8-内存回收\"><a href=\"#8-8-内存回收\" class=\"headerlink\" title=\"8.8 内存回收\"></a>8.8 内存回收</h2><p>Redis通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收。</p>\n<p>计数信息由 <code>redisObject</code> 结构的 <code>refcount</code> 属性记录</p>\n<ul>\n<li>在创建一个新对象时， 引用计数的值会被初始化为 <code>1</code> ；</li>\n<li>当对象被一个新程序使用时， 它的引用计数值会被增一；</li>\n<li>当对象不再被一个程序使用时， 它的引用计数值会被减一；</li>\n<li>当对象的引用计数值变为 <code>0</code> 时， 对象所占用的内存会被释放。</li>\n</ul>\n<p>对应的API：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">函数</th>\n<th style=\"text-align:left\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>incrRefCount</code></td>\n<td style=\"text-align:left\">将对象的引用计数值增一。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>decrRefCount</code></td>\n<td style=\"text-align:left\">将对象的引用计数值减一， 当对象的引用计数值等于 <code>0</code> 时， 释放对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>resetRefCount</code></td>\n<td style=\"text-align:left\">将对象的引用计数值设置为 <code>0</code> ， 但并不释放对象， 这个函数通常在需要重新设置对象的引用计数值时使用。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>对象生命周期可以划分为创建对象、操作对象、释放对象三个阶段</p>\n<p>一个字符串对象从创建到释放的整个过程：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建一个字符串对象 s ，对象的引用计数为 1</span></span><br><span class=\"line\">robj *s = createStringObject(...)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对象 s 执行各种操作 ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将对象 s 的引用计数减一，使得对象的引用计数变为 0</span></span><br><span class=\"line\"><span class=\"comment\">// 导致对象 s 被释放</span></span><br><span class=\"line\">decrRefCount(s)</span><br></pre></td></tr></table></figure>\n<p>是不是通过计算指向对象这块内存的指针数量来实现的？</p>\n<h3 id=\"8-9-对象共享\"><a href=\"#8-9-对象共享\" class=\"headerlink\" title=\"8.9 对象共享\"></a>8.9 对象共享</h3><p>对于整数值的字符串对象（int编码），在新创建一个字符串对象的时候如果有这个值的字符串对象存在，就不再为新键创建字符串对象，而是将这个新键指向之前已经存在了的字符串对象。然后将这个字符串对象的引用+1。主要目的是节约内存。</p>\n<p>Redis初始化服务器的时候创建一万个字符串对象， 这些对象包含了从 <code>0</code> 到 <code>9999</code> 的所有整数值， 当服务器需要用到值为 <code>0</code>到 <code>9999</code> 的字符串对象时， 服务器就会使用这些共享对象， 而不是新创建对象。</p>\n<p>创建共享字符串对象的数量可以通过修改 <code>redis.h/REDIS_SHARED_INTEGERS</code> 常量来修改。</p>\n<p><strong>为什么 Redis 不共享包含字符串的对象？</strong></p>\n<p>当服务器考虑将一个共享对象设置为键的值对象时， 程序需要先检查给定的共享对象和键想创建的目标对象是否完全相同， 只有在共享对象和目标对象完全相同的情况下， 程序才会将共享对象用作键的值对象， 而一个共享对象保存的值越复杂， 验证共享对象和目标对象是否相同所需的复杂度就会越高， 消耗的 CPU 时间也会越多：</p>\n<ul>\n<li>如果共享对象是保存整数值的字符串对象， 那么验证操作的复杂度为 O(1) ；</li>\n<li>如果共享对象是保存字符串值的字符串对象， 那么验证操作的复杂度为 O(N) ；</li>\n<li>如果共享对象是包含了多个值（或者对象的）对象， 比如列表对象或者哈希对象， 那么验证操作的复杂度将会是 O(N^2) 。</li>\n</ul>\n<p>因此， 尽管共享更复杂的对象可以节约更多的内存， 但受到 CPU 时间的限制， Redis 只对包含整数值的字符串对象进行共享。 （时刻在空间与时间上做权衡）</p>\n<h2 id=\"8-9-对象的空转时长\"><a href=\"#8-9-对象的空转时长\" class=\"headerlink\" title=\"8.9 对象的空转时长\"></a>8.9 对象的空转时长</h2><p><code>lru</code> 属性， 该属性记录了对象最后一次被<strong>命令程序访问</strong>的时间。</p>\n<p>OBJECT IDLETIME 命令可以打印出给定键的空转时长， 这一空转时长就是通过将当前时间减去键的值对象的 <code>lru</code> 时间计算得出的。</p>\n<p>OBJECT IDLETIME 命令的实现是特殊的， 这个命令在访问键的值对象时， 不会修改值对象的 <code>lru</code> 属性。</p>\n<p>lru的主要作用就是配合maxmemory选项，淘汰不常用的键值对。</p>\n<p>如果服务器打开了 <code>maxmemory</code> 选项， 并且服务器用于回收内存的算法为 <code>volatile-lru</code> 或者 <code>allkeys-lru</code> ， 那么当服务器占用的内存数超过了 <code>maxmemory</code> 选项所设置的上限值时， 空转时长较高的那部分键会优先被服务器释放， 从而回收内存。</p>\n<h2 id=\"疑惑\"><a href=\"#疑惑\" class=\"headerlink\" title=\"疑惑\"></a>疑惑</h2><ol>\n<li>为什么在一块连续的内存里面可以更好地利用缓存带来的优势？</li>\n<li>引用计数的程序怎么定义？是指线程吗？</li>\n<li>引用计数的具体实现？</li>\n<li>对象共享的时候怎么去判断存不存在已经创建了这个整数值的对象？对整个数据库遍历吗？</li>\n</ol>\n","site":{"data":{}},"length":6261,"excerpt":"<h1 id=\"Redis设计与实现读书笔记——第8章-对象\"><a href=\"#Redis设计与实现读书笔记——第8章-对象\" class=\"headerlink\" title=\"Redis设计与实现读书笔记——第8章 对象\"></a>Redis设计与实现读书笔记——第8章 对象</h1><p>Redis 并没有直接使用sds、dict等数据结构来实现键值对数据库， 而是基于这些数据结构创建了一个对象系统， 这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象， 每种对象都用到了至少一种前面所介绍的数据结构。</p>","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>对象的好处：</p>\n<ul>\n<li>根据对象的类型来判断是否可以执行给定的命令。</li>\n<li>针对不同的使用场景， 为对象设置多种不同的数据结构实现， 从而优化对象在不同场景下的使用效率。</li>\n</ul>\n<p>对象的特性：</p>\n<ul>\n<li>基于引用计数技术的内存回收机制（和java的是否原理相似）</li>\n<li>通过引用计数技术实现对象共享机制，多个键共享同一个对象来节约内存</li>\n<li>带有访问时间记录信息，可以用来删除空转时长较大的键</li>\n</ul>\n<h2 id=\"8-1-对象的类型与编码\"><a href=\"#8-1-对象的类型与编码\" class=\"headerlink\" title=\"8.1 对象的类型与编码\"></a>8.1 对象的类型与编码</h2><p>Redis 使用对象来表示数据库中的键和值，创建一个新的键值对的时候，至少包含两个对象：1. 键对象 2. 值对象</p>\n<p>对象都由一个 <code>redisObject</code> 结构表示，保存数据相关的属性</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">redisObject</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 对象类型</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> type:<span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 编码</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> encoding:<span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"comment\">//lru 时钟 记录最后被访问的时间，也就是空转时长</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> lru:LRU_BITS; <span class=\"comment\">/* LRU time (relative to global lru_clock) or</span></span><br><span class=\"line\"><span class=\"comment\">                            * LFU data (least significant 8 bits frequency</span></span><br><span class=\"line\"><span class=\"comment\">                            * and most significant 16 bits decreas time). */</span></span><br><span class=\"line\">    <span class=\"comment\">// 引用计数 实现内存自动回收等。</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> refcount;</span><br><span class=\"line\">    <span class=\"comment\">// 指向底层实现数据结构的指针</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *ptr;</span><br><span class=\"line\">&#125; robj;</span><br></pre></td></tr></table></figure>\n<p>ptr指向的就是之前的sds，dict这些数据结构的内存地址。</p>\n<p>变量申明加冒号的用法： 是C语言的位域的用法。<code>:</code>后面的数字用来限定成员变量占用的位数。冒号后面的数字说明只会用到对应多少个bit位。type只会用到4个bit，encoding 也只会用的4个bit。变量占用的内存不再是有类型决定，而是位域。</p>\n<h3 id=\"8-1-1-类型\"><a href=\"#8-1-1-类型\" class=\"headerlink\" title=\"8.1.1 类型\"></a>8.1.1 类型</h3><p>type属性的值包括5种：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">类型常量</th>\n<th style=\"text-align:left\">对象的名称</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_STRING</code></td>\n<td style=\"text-align:left\">字符串对象</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_LIST</code></td>\n<td style=\"text-align:left\">列表对象</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_HASH</code></td>\n<td style=\"text-align:left\">哈希对象</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_SET</code></td>\n<td style=\"text-align:left\">集合对象</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_ZSET</code></td>\n<td style=\"text-align:left\">有序集合对象</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>键对象只能是字符串对象，而值对象则5种之一。所以执行TYPE命令返回的是键值对中值对象的类型。</p>\n<p>type命令的</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">对象</th>\n<th style=\"text-align:left\">对象 <code>type</code> 属性的值</th>\n<th style=\"text-align:left\">TYPE 命令的输出</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">字符串对象</td>\n<td style=\"text-align:left\"><code>REDIS_STRING</code></td>\n<td style=\"text-align:left\"><code>&quot;string&quot;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表对象</td>\n<td style=\"text-align:left\"><code>REDIS_LIST</code></td>\n<td style=\"text-align:left\"><code>&quot;list&quot;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">哈希对象</td>\n<td style=\"text-align:left\"><code>REDIS_HASH</code></td>\n<td style=\"text-align:left\"><code>&quot;hash&quot;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">集合对象</td>\n<td style=\"text-align:left\"><code>REDIS_SET</code></td>\n<td style=\"text-align:left\"><code>&quot;set&quot;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">有序集合对象</td>\n<td style=\"text-align:left\"><code>REDIS_ZSET</code></td>\n<td style=\"text-align:left\"><code>&quot;zset&quot;</code></td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"8-2-编码和底层实现\"><a href=\"#8-2-编码和底层实现\" class=\"headerlink\" title=\"8.2 编码和底层实现\"></a>8.2 编码和底层实现</h3><p>ptr指向底层数据结构，而encoding则决定了具体应该指向什么样的数据结构实现。之所以不能用type来决定指向的具体数据结构，是因为同一种对象，但是底层实现会有不同的数据结构。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">编码常量</th>\n<th style=\"text-align:left\">编码所对应的底层数据结构</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_INT</code></td>\n<td style=\"text-align:left\"><code>long</code> 类型的整数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_EMBSTR</code></td>\n<td style=\"text-align:left\"><code>embstr</code> 编码的简单动态字符串</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_RAW</code></td>\n<td style=\"text-align:left\">简单动态字符串</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_HT</code></td>\n<td style=\"text-align:left\">字典</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_LINKEDLIST</code></td>\n<td style=\"text-align:left\">双端链表</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_ZIPLIST</code></td>\n<td style=\"text-align:left\">压缩列表</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_INTSET</code></td>\n<td style=\"text-align:left\">整数集合</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_SKIPLIST</code></td>\n<td style=\"text-align:left\">跳跃表和字典</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>每种类型的对象都至少使用了两种不同的编码，对应关系为：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">编码</th>\n<th style=\"text-align:left\">对象</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_STRING</code></td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_INT</code></td>\n<td style=\"text-align:left\">使用整数值实现的字符串对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_STRING</code></td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_EMBSTR</code></td>\n<td style=\"text-align:left\">使用 <code>embstr</code> 编码的简单动态字符串实现的字符串对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_STRING</code></td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_RAW</code></td>\n<td style=\"text-align:left\">使用简单动态字符串实现的字符串对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_LIST</code></td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_ZIPLIST</code></td>\n<td style=\"text-align:left\">使用压缩列表实现的列表对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_LIST</code></td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_LINKEDLIST</code></td>\n<td style=\"text-align:left\">使用双端链表实现的列表对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_HASH</code></td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_ZIPLIST</code></td>\n<td style=\"text-align:left\">使用压缩列表实现的哈希对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_HASH</code></td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_HT</code></td>\n<td style=\"text-align:left\">使用字典实现的哈希对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_SET</code></td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_INTSET</code></td>\n<td style=\"text-align:left\">使用整数集合实现的集合对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_SET</code></td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_HT</code></td>\n<td style=\"text-align:left\">使用字典实现的集合对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_ZSET</code></td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_ZIPLIST</code></td>\n<td style=\"text-align:left\">使用压缩列表实现的有序集合对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_ZSET</code></td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_SKIPLIST</code></td>\n<td style=\"text-align:left\">使用跳跃表和字典实现的有序集合对象。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>使用 OBJECT ENCODING 命令可以查看一个数据库键的值对象的编码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SET msg &quot;hello wrold&quot;</span><br><span class=\"line\">OK</span><br><span class=\"line\"></span><br><span class=\"line\">redis&gt; OBJECT ENCODING msg</span><br><span class=\"line\">&quot;embstr&quot;</span><br></pre></td></tr></table></figure>\n<p>不同编码的对象所对应的OBJECT ENCODING输出：</p>\n<p>表 8-5 OBJECT ENCODING 对不同编码的输出</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">对象所使用的底层数据结构</th>\n<th style=\"text-align:left\">编码常量</th>\n<th style=\"text-align:left\">OBJECT ENCODING 命令输出</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">整数</td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_INT</code></td>\n<td style=\"text-align:left\"><code>&quot;int&quot;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>embstr</code> 编码的简单动态字符串（SDS）</td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_EMBSTR</code></td>\n<td style=\"text-align:left\"><code>&quot;embstr&quot;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">简单动态字符串</td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_RAW</code></td>\n<td style=\"text-align:left\"><code>&quot;raw&quot;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">字典</td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_HT</code></td>\n<td style=\"text-align:left\"><code>&quot;hashtable&quot;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">双端链表</td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_LINKEDLIST</code></td>\n<td style=\"text-align:left\"><code>&quot;linkedlist&quot;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">压缩列表</td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_ZIPLIST</code></td>\n<td style=\"text-align:left\"><code>&quot;ziplist&quot;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">整数集合</td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_INTSET</code></td>\n<td style=\"text-align:left\"><code>&quot;intset&quot;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">跳跃表和字典</td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_SKIPLIST</code></td>\n<td style=\"text-align:left\"><code>&quot;skiplist&quot;</code></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>使用encoding属性来设定对象指向的具体数据结构实现的好处：灵活与效率。根据不同场景来给同一种对象设置不同的数据结构实现。</p>\n<p>举个例子， 在列表对象包含的元素比较少时， Redis 使用压缩列表作为列表对象的底层实现：</p>\n<ul>\n<li>因为压缩列表比双端链表更节约内存， 并且在元素数量较少时， 在内存中以连续块方式保存的压缩列表比起双端链表可以更快被载入到缓存中；</li>\n<li>随着列表对象包含的元素越来越多， 使用压缩列表来保存元素的优势逐渐消失时， 对象就会将底层实现从压缩列表转向功能更强、也更适合保存大量元素的双端链表上面；</li>\n</ul>\n<p>是不是也可以理解成多态呢？</p>\n<h2 id=\"8-2-字符串对象\"><a href=\"#8-2-字符串对象\" class=\"headerlink\" title=\"8.2 字符串对象\"></a>8.2 字符串对象</h2><p>字符串对象的编码可以是 <code>int</code> 、 <code>raw</code> 或者 <code>embstr</code> 。</p>\n<ol>\n<li>保存的对象是整数，而且可以用long类型表示：ptr指针指向一个long类型的内存地址。（是不是不用指向sdshdr了），然后将encoding 设置为REDIS_ENCODING_INT (应该在源码中有个宏定义)</li>\n<li>保存的对象是字符串值，长度小于44字节（书上的39字节，但是先版本已经更新）。这种短字符串对象，直接<strong>只调用一次内存分配</strong>函数来分配一块<strong>连续的空间</strong>  依次包含redisObject和sdshdr两个结构。</li>\n<li>字符串长度大于等于44字节的时候使用raw编码。会调用两次内存分配函数来创建redisObject结构和sdshdr结构。</li>\n</ol>\n<p>embstr编码的好处：</p>\n<ul>\n<li>只用分配一次内存，raw编码需要两次</li>\n<li>释放embstr的sds也只需要一次内存释放函数，raw两次</li>\n<li>embstr的所有数据（对象结构，字符串结构）在连续的一块内存里面，从而可以更好地利用缓存带来的优势</li>\n</ul>\n<p>embstr和raw的示意图，摘自书上，但是注意sds的结构稍有变化。</p>\n<p>raw编码：</p>\n<p><img src=\"http://redisbook.com/_images/graphviz-8731210637d0567af28d3a9d4089d5f864d29950.png\" alt=\"\"></p>\n<p>embstr编码：</p>\n<p><img src=\"http://redisbook.com/_images/graphviz-900c13b23ce79372939259603be936c955ccaa62.png\" alt=\"\"></p>\n<p>注意：</p>\n<p>long double类型的浮点数是转换成字符串值来保存的。执行的时候取出字符串再转换成long double 类型。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">值</th>\n<th style=\"text-align:left\">编码</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">可以用 <code>long</code> 类型保存的整数。</td>\n<td style=\"text-align:left\"><code>int</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">可以用 <code>long double</code> 类型保存的浮点数。</td>\n<td style=\"text-align:left\"><code>embstr</code> 或者 <code>raw</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">字符串值， 或者因为长度太大而没办法用 <code>long</code> 类型表示的整数， 又或者因为长度太大而没办法用 <code>long double</code> 类型表示的浮点数。</td>\n<td style=\"text-align:left\"><code>embstr</code> 或者 <code>raw</code></td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"8-2-1-编码的转换\"><a href=\"#8-2-1-编码的转换\" class=\"headerlink\" title=\"8.2.1 编码的转换\"></a>8.2.1 编码的转换</h3><p>当保存的值发生变化的时候会进行转换，比如保存的整数值变成了字符串，那么编码从int 变成raw或者embstr。</p>\n<p><strong>注意</strong>： Redis 没有为embstr编写任何修改程序，只有int和raw编码的字符串对象有这些程序，所以embstr编码的对象是只读，因此发生修改的话会从embstr变成raw。</p>\n<p>发生修改的源码中应该是将原来的ptr指向的数据结构内存释放掉后，重新指向新创建的对象。</p>\n<h3 id=\"8-2-2-字符串命令的实现\"><a href=\"#8-2-2-字符串命令的实现\" class=\"headerlink\" title=\"8.2.2 字符串命令的实现\"></a>8.2.2 字符串命令的实现</h3><p>所有命令都是针对字符串对象的。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">命令</th>\n<th style=\"text-align:left\"><code>int</code> 编码的实现方法</th>\n<th style=\"text-align:left\"><code>embstr</code> 编码的实现方法</th>\n<th style=\"text-align:left\"><code>raw</code> 编码的实现方法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">SET</td>\n<td style=\"text-align:left\">使用 <code>int</code> 编码保存值。</td>\n<td style=\"text-align:left\">使用 <code>embstr</code> 编码保存值。</td>\n<td style=\"text-align:left\">使用 <code>raw</code> 编码保存值。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">GET</td>\n<td style=\"text-align:left\">拷贝对象所保存的整数值， 将这个拷贝转换成字符串值， 然后向客户端返回这个字符串值。</td>\n<td style=\"text-align:left\">直接向客户端返回字符串值。</td>\n<td style=\"text-align:left\">直接向客户端返回字符串值。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">APPEND</td>\n<td style=\"text-align:left\">将对象转换成 <code>raw</code> 编码， 然后按 <code>raw</code>编码的方式执行此操作。</td>\n<td style=\"text-align:left\">将对象转换成 <code>raw</code> 编码， 然后按 <code>raw</code>编码的方式执行此操作。</td>\n<td style=\"text-align:left\">调用 <code>sdscatlen</code> 函数， 将给定字符串追加到现有字符串的末尾。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">INCRBYFLOAT</td>\n<td style=\"text-align:left\">取出整数值并将其转换成 <code>longdouble</code> 类型的浮点数， 对这个浮点数进行加法计算， 然后将得出的浮点数结果保存起来。</td>\n<td style=\"text-align:left\">取出字符串值并尝试将其转换成<code>long double</code> 类型的浮点数， 对这个浮点数进行加法计算， 然后将得出的浮点数结果保存起来。 如果字符串值不能被转换成浮点数， 那么向客户端返回一个错误。</td>\n<td style=\"text-align:left\">取出字符串值并尝试将其转换成 <code>longdouble</code> 类型的浮点数， 对这个浮点数进行加法计算， 然后将得出的浮点数结果保存起来。 如果字符串值不能被转换成浮点数， 那么向客户端返回一个错误。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">INCRBY</td>\n<td style=\"text-align:left\">对整数值进行加法计算， 得出的计算结果会作为整数被保存起来。</td>\n<td style=\"text-align:left\"><code>embstr</code> 编码不能执行此命令， 向客户端返回一个错误。</td>\n<td style=\"text-align:left\"><code>raw</code> 编码不能执行此命令， 向客户端返回一个错误。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">DECRBY</td>\n<td style=\"text-align:left\">对整数值进行减法计算， 得出的计算结果会作为整数被保存起来。</td>\n<td style=\"text-align:left\"><code>embstr</code> 编码不能执行此命令， 向客户端返回一个错误。</td>\n<td style=\"text-align:left\"><code>raw</code> 编码不能执行此命令， 向客户端返回一个错误。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">STRLEN</td>\n<td style=\"text-align:left\">拷贝对象所保存的整数值， 将这个拷贝转换成字符串值， 计算并返回这个字符串值的长度。</td>\n<td style=\"text-align:left\">调用 <code>sdslen</code> 函数， 返回字符串的长度。</td>\n<td style=\"text-align:left\">调用 <code>sdslen</code> 函数， 返回字符串的长度。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">SETRANGE</td>\n<td style=\"text-align:left\">将对象转换成 <code>raw</code> 编码， 然后按 <code>raw</code>编码的方式执行此命令。</td>\n<td style=\"text-align:left\">将对象转换成 <code>raw</code> 编码， 然后按 <code>raw</code>编码的方式执行此命令。</td>\n<td style=\"text-align:left\">将字符串特定索引上的值设置为给定的字符。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">GETRANGE</td>\n<td style=\"text-align:left\">拷贝对象所保存的整数值， 将这个拷贝转换成字符串值， 然后取出并返回字符串指定索引上的字符。</td>\n<td style=\"text-align:left\">直接取出并返回字符串指定索引上的字符。</td>\n<td style=\"text-align:left\">直接取出并返回字符串指定索引上的字符。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"8-8-内存回收\"><a href=\"#8-8-内存回收\" class=\"headerlink\" title=\"8.8 内存回收\"></a>8.8 内存回收</h2><p>Redis通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收。</p>\n<p>计数信息由 <code>redisObject</code> 结构的 <code>refcount</code> 属性记录</p>\n<ul>\n<li>在创建一个新对象时， 引用计数的值会被初始化为 <code>1</code> ；</li>\n<li>当对象被一个新程序使用时， 它的引用计数值会被增一；</li>\n<li>当对象不再被一个程序使用时， 它的引用计数值会被减一；</li>\n<li>当对象的引用计数值变为 <code>0</code> 时， 对象所占用的内存会被释放。</li>\n</ul>\n<p>对应的API：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">函数</th>\n<th style=\"text-align:left\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>incrRefCount</code></td>\n<td style=\"text-align:left\">将对象的引用计数值增一。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>decrRefCount</code></td>\n<td style=\"text-align:left\">将对象的引用计数值减一， 当对象的引用计数值等于 <code>0</code> 时， 释放对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>resetRefCount</code></td>\n<td style=\"text-align:left\">将对象的引用计数值设置为 <code>0</code> ， 但并不释放对象， 这个函数通常在需要重新设置对象的引用计数值时使用。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>对象生命周期可以划分为创建对象、操作对象、释放对象三个阶段</p>\n<p>一个字符串对象从创建到释放的整个过程：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建一个字符串对象 s ，对象的引用计数为 1</span></span><br><span class=\"line\">robj *s = createStringObject(...)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对象 s 执行各种操作 ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将对象 s 的引用计数减一，使得对象的引用计数变为 0</span></span><br><span class=\"line\"><span class=\"comment\">// 导致对象 s 被释放</span></span><br><span class=\"line\">decrRefCount(s)</span><br></pre></td></tr></table></figure>\n<p>是不是通过计算指向对象这块内存的指针数量来实现的？</p>\n<h3 id=\"8-9-对象共享\"><a href=\"#8-9-对象共享\" class=\"headerlink\" title=\"8.9 对象共享\"></a>8.9 对象共享</h3><p>对于整数值的字符串对象（int编码），在新创建一个字符串对象的时候如果有这个值的字符串对象存在，就不再为新键创建字符串对象，而是将这个新键指向之前已经存在了的字符串对象。然后将这个字符串对象的引用+1。主要目的是节约内存。</p>\n<p>Redis初始化服务器的时候创建一万个字符串对象， 这些对象包含了从 <code>0</code> 到 <code>9999</code> 的所有整数值， 当服务器需要用到值为 <code>0</code>到 <code>9999</code> 的字符串对象时， 服务器就会使用这些共享对象， 而不是新创建对象。</p>\n<p>创建共享字符串对象的数量可以通过修改 <code>redis.h/REDIS_SHARED_INTEGERS</code> 常量来修改。</p>\n<p><strong>为什么 Redis 不共享包含字符串的对象？</strong></p>\n<p>当服务器考虑将一个共享对象设置为键的值对象时， 程序需要先检查给定的共享对象和键想创建的目标对象是否完全相同， 只有在共享对象和目标对象完全相同的情况下， 程序才会将共享对象用作键的值对象， 而一个共享对象保存的值越复杂， 验证共享对象和目标对象是否相同所需的复杂度就会越高， 消耗的 CPU 时间也会越多：</p>\n<ul>\n<li>如果共享对象是保存整数值的字符串对象， 那么验证操作的复杂度为 O(1) ；</li>\n<li>如果共享对象是保存字符串值的字符串对象， 那么验证操作的复杂度为 O(N) ；</li>\n<li>如果共享对象是包含了多个值（或者对象的）对象， 比如列表对象或者哈希对象， 那么验证操作的复杂度将会是 O(N^2) 。</li>\n</ul>\n<p>因此， 尽管共享更复杂的对象可以节约更多的内存， 但受到 CPU 时间的限制， Redis 只对包含整数值的字符串对象进行共享。 （时刻在空间与时间上做权衡）</p>\n<h2 id=\"8-9-对象的空转时长\"><a href=\"#8-9-对象的空转时长\" class=\"headerlink\" title=\"8.9 对象的空转时长\"></a>8.9 对象的空转时长</h2><p><code>lru</code> 属性， 该属性记录了对象最后一次被<strong>命令程序访问</strong>的时间。</p>\n<p>OBJECT IDLETIME 命令可以打印出给定键的空转时长， 这一空转时长就是通过将当前时间减去键的值对象的 <code>lru</code> 时间计算得出的。</p>\n<p>OBJECT IDLETIME 命令的实现是特殊的， 这个命令在访问键的值对象时， 不会修改值对象的 <code>lru</code> 属性。</p>\n<p>lru的主要作用就是配合maxmemory选项，淘汰不常用的键值对。</p>\n<p>如果服务器打开了 <code>maxmemory</code> 选项， 并且服务器用于回收内存的算法为 <code>volatile-lru</code> 或者 <code>allkeys-lru</code> ， 那么当服务器占用的内存数超过了 <code>maxmemory</code> 选项所设置的上限值时， 空转时长较高的那部分键会优先被服务器释放， 从而回收内存。</p>\n<h2 id=\"疑惑\"><a href=\"#疑惑\" class=\"headerlink\" title=\"疑惑\"></a>疑惑</h2><ol>\n<li>为什么在一块连续的内存里面可以更好地利用缓存带来的优势？</li>\n<li>引用计数的程序怎么定义？是指线程吗？</li>\n<li>引用计数的具体实现？</li>\n<li>对象共享的时候怎么去判断存不存在已经创建了这个整数值的对象？对整个数据库遍历吗？</li>\n</ol>"},{"title":"计算Linux系统的CPU利用率","date":"2019-03-31T03:44:01.000Z","copyright":true,"_content":"\n# 计算Linux系统的CPU利用率\n\n通过读取系统的/proc/stat 信息来计算CPU的利用率\n\n<!--more-->\n\n## cpu 信息的读取\n\n摘自参考博客：https://blog.csdn.net/x_i_y_u_e/article/details/50684508\n\n在Linux/Unix下，CPU利用率分为用户态，系统态和空闲态，分别表示CPU处于用户态执行的时间，系统内核执行的时间，和空闲系统进程执行的时间。平时所说的CPU利用率是指：CPU执行非系统空闲进程的时间 / CPU总的执行时间。\n\n在Linux的内核中，有一个全局变量：Jiffies。 Jiffies代表时间。它的单位随硬件平台的不同而不同。系统里定义了一个常数HZ，代表每秒种最小时间间隔的数目。这样jiffies的单位就是1/HZ。Intel平台jiffies的单位是1/100秒，这就是系统所能分辨的最小时间间隔了。每个CPU时间片，Jiffies都要加1。 CPU的利用率就是用执行用户态+系统态的Jiffies除以总的Jifffies来表示。\n\n在Linux系统中，可以用/proc/stat文件来计算cpu的利用率(详细的解释可参考：<http://www.linuxhowtos.org/System/procstat.htm>)。这个文件包含了所有CPU活动的信息，该文件中的所有值都是从系统启动开始累计到当前时刻。\n\n在本机上的信息如下：\n\n```\n root@hw103:/home/yky# cat/proc/stat \ncpu  7283854 35392 293546 204419077 75835 0 8385 0 0 0\ncpu0 365010 48 18204 8453603 767 0 4306 0 0 0\ncpu1 292817 9 14990 8526563 1358 0 2114 0 0 0\ncpu2 286689 0 11880 8538662 1033 0 752 0 0 0\ncpu3 287106 14624 12945 8523209 641 0 320 0 0 0\ncpu4 293293 0 11784 8532282 604 0 147 0 0 0\ncpu5 371312 2824 13669 8408187 40794 0 406 0 0 0\ncpu6 358116 10934 14014 8453775 1230 0 68 0 0 0\ncpu7 313971 6281 12243 8504303 1575 0 28 0 0 0\ncpu8 318084 0 11598 8506770 2036 0 15 0 0 0\ncpu9 294503 0 11137 8530318 2185 0 10 0 0 0\ncpu10 307922 144 12434 8516570 1177 0 15 0 0 0\ncpu11 291752 0 11502 8533957 1128 0 4 0 0 0\ncpu12 315096 0 15927 8503001 3528 0 3 0 0 0\ncpu13 375976 0 17927 8442873 2041 0 1 0 0 0\ncpu14 299344 0 10140 8523716 2818 0 1 0 0 0\ncpu15 288470 3 10146 8538685 1240 0 0 0 0 0\ncpu16 301148 0 10681 8523612 2185 0 0 0 0 0\ncpu17 263183 4 9149 8565345 771 0 0 0 0 0\ncpu18 262518 370 10343 8562955 2105 0 11 0 0 0\ncpu19 280230 3 10399 8546414 1227 0 6 0 0 0\ncpu20 278962 0 10346 8547585 1221 0 9 0 0 0\ncpu21 277042 143 11502 8547940 1048 0 2 0 0 0\ncpu22 275560 0 9458 8549093 1271 0 153 0 0 0\ncpu23 285740 0 11118 8539648 1838 0 6 0 0 0\nintr 91288599 43 2 0 0 0 0 0 0 1 0 0 0 4 0 0 0 41 0 2 0 0 0 0 0 0 0 334158 0 1 2473208 45518 96917 44876 138077 45263 45258 54441 0 0 44198 44198 44198 44198 44198 44198 441\n98 44198 0 0 44198 44198 44198 44198 44198 44198 44198 44198 0 0 44199 44199 44199 44199 44199 44199 44199 44199 0 0 44199 44199 44199 44199 44199 44199 44199 44199 0 0 44198 44198 44198 44198 44198 44198 44198 44198 0 0 44198 44198 44198 44198 44198 44198 44198 44198 0 0 44199 44199 44199 44199 44199 44199 44199 44199 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0ctxt 42731429\nbtime 1553933982\nprocesses 190449\nprocs_running 5\nprocs_blocked 0\nsoftirq 57291816 8 26401645 17536 5419485 334063 0 1044 10019160 0 15098875\n\n```\n\n第一行cpu是总的cpu信息，其他的cpu0-cpu23 是24个核的信息。\n\n计算cpu利用率只用到前7个参数， 对应的参数解释为：\n\n```\n\t user\t nice  system idle      iowait   irq  softirq\ncpu  7283854 35392 293546 204419077 75835    0    8385     \n```\n\nuser (7283854) 从系统启动开始累计到当前时刻，用户态的CPU时间（单位：jiffies） ，不包含 nice值为负进程。1jiffies=0.01秒\nnice (35392) 从系统启动开始累计到当前时刻，nice值为负的进程所占用的CPU时间（单位：jiffies）\nsystem (293546) 从系统启动开始累计到当前时刻，核心时间（单位：jiffies）\nidle (204419077) 从系统启动开始累计到当前时刻，除硬盘IO等待时间以外其它等待时间（单位：jiffies）\niowait (75835) 从系统启动开始累计到当前时刻，硬盘IO等待时间（单位：jiffies） ，\nirq (0) 从系统启动开始累计到当前时刻，硬中断时间（单位：jiffies）\nsoftirq (8385) 从系统启动开始累计到当前时刻，软中断时间（单位：jiffies）\n\nCPU时间=user+system+nice+idle+iowait+irq+softirq\n\n“intr”这行给出中断的信息，第一个为自系统启动以来，发生的所有的中断的次数；然后每个数对应一个特定的中断自系统启动以来所发生的次数。\n“ctxt”给出了自系统启动以来CPU发生的上下文交换的次数。\n“btime”给出了从系统启动到现在为止的时间，单位为秒。\n“processes (total_forks) 自系统启动以来所创建的任务的个数目。\n“procs_running”：当前运行队列的任务的数目。\n“procs_blocked”：当前被阻塞的任务的数目。\n\n\n\n计算cpu利用率的方法就是计算出在一段时间里面，cpu工作的时间/总得时间\n\n```\ncpu usage=(idle2-idle1)/(cpu2-cpu1)*100\ncpu usage=[(user_2 +sys_2+nice_2) - (user_1 + sys_1+nice_1)]/(total_2 - total_1)*100\n```\n\n第二中方法只把user+sys+nice 这三个时间看作cpu的工作时间，因为其他的几个比较小。\n\n## shell脚本\n\n```shell\n#!/bin/bash\n\n##echo user nice system idle iowait irq softirq\n\ncpulog_start=$(cat /proc/stat | grep 'cpu'| awk 'NR==1{print $2 \"\\t\" $3 \"\\t\" $4 \"\\t\" $5 \"\\t\" $6 \"\\t\" $7 \"\\t\" $8}' )\ncpu_use_start=$(echo $cpulog_start | awk '{print $1+$2+$3}')\ncpu_iowait_start=$(echo $cpulog_start | awk '{print $5}')\ncpu_total_start=$(echo $cpulog_start | awk '{print $1+$2+$3+$4+$5+$6+$7}')\n\nsleep 10\n\ncpulog_end=$(cat /proc/stat | grep 'cpu'| awk 'NR==1{print $2 \"\\t\" $3 \"\\t\" $4 \"\\t\" $5 \"\\t\" $6 \"\\t\" $7 \"\\t\" $8}' )\ncpu_use_end=$(echo $cpulog_end | awk '{print $1+$2+$3}')\ncpu_iowait_end=$(echo $cpulog_end | awk '{print $5}')\ncpu_total_end=$(echo $cpulog_end | awk '{print $1+$2+$3+$4+$5+$6+$7}')\n\ncpu_use_diff=`expr $cpu_use_end - $cpu_use_start`\ncpu_iowait_diff=`expr $cpu_iowait_end - $cpu_iowait_start`\ncpu_total_diff=`expr $cpu_total_end - $cpu_total_start`\n\ncpu_use_rate=`expr $cpu_use_diff/$cpu_total_diff*100 | bc -l`\ncpu_iowait_rate=`expr $cpu_iowait_diff/$cpu_total_diff*100 | bc -l`\n\necho \"---------------cpuinfo----------------------\"\necho \"cpu_usage_rate (%) : $cpu_use_rate\"\necho \"cpu_iowait_rate (%): $cpu_iowait_rate\"\n\n```\n\n主要的知识点讲解：\n\n```shell\ncpulog_start=$(cat /proc/stat | grep 'cpu'| awk 'NR==1{print $2 \"\\t\" $3 \"\\t\" $4 \"\\t\" $5 \"\\t\" $6 \"\\t\" $7 \"\\t\" $8}' )\n```\n\n这一句先将/proc/stat文件的信息读取出来然后用管道| 传递给grep 命令 ,grep 将包含cpu的信息给提取出来\n\n`cat /proc/stat | grep 'cpu'` 输出为：\n\n```bash\nroot@hw103:/home/yky# cat /proc/stat | grep 'cpu'\ncpu  7645369 35392 318219 206250476 80895 0 9870 0 0 0\ncpu0 365256 48 18792 8544685 767 0 5678 0 0 0\ncpu1 292983 9 15427 8618292 1389 0 2206 0 0 0\ncpu2 287020 0 12884 8629895 1033 0 760 0 0 0\ncpu3 288372 14624 13910 8613386 681 0 320 0 0 0\ncpu4 293707 0 13074 8623117 646 0 147 0 0 0\ncpu5 390012 2824 15130 8477387 44027 0 418 0 0 0\ncpu6 362140 10934 15217 8541127 1233 0 69 0 0 0\ncpu7 377620 6281 12915 8532734 1700 0 28 0 0 0\ncpu8 333520 0 12524 8582987 2100 0 15 0 0 0\ncpu9 348913 0 12619 8567005 2453 0 10 0 0 0\ncpu10 333584 144 14002 8581939 1297 0 15 0 0 0\ncpu11 292980 0 12966 8623861 1137 0 4 0 0 0\ncpu12 350188 0 16793 8559301 4017 0 3 0 0 0\ncpu13 430200 0 19278 8479849 2344 0 1 0 0 0\ncpu14 312421 0 11483 8601843 2906 0 1 0 0 0\ncpu15 343656 3 10768 8575706 1268 0 0 0 0 0\ncpu16 302673 0 12190 8613170 2190 0 0 0 0 0\ncpu17 263473 4 9906 8656857 771 0 0 0 0 0\ncpu18 263094 370 11278 8653940 2165 0 11 0 0 0\ncpu19 281216 3 11166 8637253 1280 0 6 0 0 0\ncpu20 280412 0 11645 8637433 1221 0 9 0 0 0\ncpu21 277219 143 11967 8639929 1048 0 2 0 0 0\ncpu22 275894 0 10291 8640508 1271 0 153 0 0 0\ncpu23 298806 0 11985 8618261 1939 0 6 0 0 0\n```\n\n### awk 命令\n\n之后使用awk命令再次进行操作。这个命令之前用的很少，参考《鸟哥的Linux私房菜》介绍：\n\nsed常用于一整行的处理，awk则倾向于将一行分成数个“字段”来处理，awk适合处理小型的数据。\n\n用法为：\n\n`awk '条件类型1{操作1} 条件类型1{操作2}...'  filename`\n\n| 变量名称 | 意义                        |\n| -------- | --------------------------- |\n| NF       | 每一行（$0） 拥有的字段总数 |\n| NR       | awk当前处理的第几行数据     |\n| FS       | 目前的分割符，默认空格键    |\n\n\n\n```shell\ncpulog_start=$(cat /proc/stat | grep 'cpu'| awk 'NR==1{print $2 \"\\t\" $3 \"\\t\" $4 \"\\t\" $5 \"\\t\" $6 \"\\t\" $7 \"\\t\" $8}' )\n```\n\n`NR==1 ` 限定条件为第一行，因为第一行的数据才是cpu的总信息，{}里面的操作是输出字段，$N 就是第N个字段。\n\n```\n $1\t$2\t\t$3\t\t$4\t  $5\t\t$6\t\t $7\t  $8\n     user\t nice  system idle      iowait   irq  softirq\ncpu  7283854 35392 293546 204419077 75835    0    8385    \n```\n\n### expr\n\n```bash\ncpu_use_diff=`expr $cpu_use_end - $cpu_use_start`\n```\n\n\n\n使用expr 执行变量计算，然后是`` 进行反引用将值赋值给cpu_use_diff\n\n注意shell 脚本中= 不能用空格分开 需要直接相邻\n\n### bc 命令\n\nbc 命令是任意精度计算器语言，通常在linux下当计算器用。\n\n简单的描述参考：<http://www.runoob.com/linux/linux-comm-bc.html>\n\n而expr命令不支持小数运算，所以需要使用bc进行计算。\n\n语法为：\n\n```\nbc(选项)(参数)\n```\n\n**选项值**\n\n- -i：强制进入交互式模式；\n- -l：定义使用的标准数学库\n- ； -w：对POSIX bc的扩展给出警告信息；\n- -q：不打印正常的GNU bc环境信息；\n- -v：显示指令版本信息；\n- -h：显示指令的帮助信息。\n\n**参数**\n\n文件：指定包含计算任务的文件。\n\n## 参考\n\n<https://blog.csdn.net/x_i_y_u_e/article/details/50684508>","source":"_posts/2019-03-31-计算Linux系统的CPU利用率.md","raw":"---\ntitle: 计算Linux系统的CPU利用率\ndate: 2019-03-31 11:44:01\ncategories: Linux\ntags:\n- Linux\n- shell\ncopyright: true\n---\n\n# 计算Linux系统的CPU利用率\n\n通过读取系统的/proc/stat 信息来计算CPU的利用率\n\n<!--more-->\n\n## cpu 信息的读取\n\n摘自参考博客：https://blog.csdn.net/x_i_y_u_e/article/details/50684508\n\n在Linux/Unix下，CPU利用率分为用户态，系统态和空闲态，分别表示CPU处于用户态执行的时间，系统内核执行的时间，和空闲系统进程执行的时间。平时所说的CPU利用率是指：CPU执行非系统空闲进程的时间 / CPU总的执行时间。\n\n在Linux的内核中，有一个全局变量：Jiffies。 Jiffies代表时间。它的单位随硬件平台的不同而不同。系统里定义了一个常数HZ，代表每秒种最小时间间隔的数目。这样jiffies的单位就是1/HZ。Intel平台jiffies的单位是1/100秒，这就是系统所能分辨的最小时间间隔了。每个CPU时间片，Jiffies都要加1。 CPU的利用率就是用执行用户态+系统态的Jiffies除以总的Jifffies来表示。\n\n在Linux系统中，可以用/proc/stat文件来计算cpu的利用率(详细的解释可参考：<http://www.linuxhowtos.org/System/procstat.htm>)。这个文件包含了所有CPU活动的信息，该文件中的所有值都是从系统启动开始累计到当前时刻。\n\n在本机上的信息如下：\n\n```\n root@hw103:/home/yky# cat/proc/stat \ncpu  7283854 35392 293546 204419077 75835 0 8385 0 0 0\ncpu0 365010 48 18204 8453603 767 0 4306 0 0 0\ncpu1 292817 9 14990 8526563 1358 0 2114 0 0 0\ncpu2 286689 0 11880 8538662 1033 0 752 0 0 0\ncpu3 287106 14624 12945 8523209 641 0 320 0 0 0\ncpu4 293293 0 11784 8532282 604 0 147 0 0 0\ncpu5 371312 2824 13669 8408187 40794 0 406 0 0 0\ncpu6 358116 10934 14014 8453775 1230 0 68 0 0 0\ncpu7 313971 6281 12243 8504303 1575 0 28 0 0 0\ncpu8 318084 0 11598 8506770 2036 0 15 0 0 0\ncpu9 294503 0 11137 8530318 2185 0 10 0 0 0\ncpu10 307922 144 12434 8516570 1177 0 15 0 0 0\ncpu11 291752 0 11502 8533957 1128 0 4 0 0 0\ncpu12 315096 0 15927 8503001 3528 0 3 0 0 0\ncpu13 375976 0 17927 8442873 2041 0 1 0 0 0\ncpu14 299344 0 10140 8523716 2818 0 1 0 0 0\ncpu15 288470 3 10146 8538685 1240 0 0 0 0 0\ncpu16 301148 0 10681 8523612 2185 0 0 0 0 0\ncpu17 263183 4 9149 8565345 771 0 0 0 0 0\ncpu18 262518 370 10343 8562955 2105 0 11 0 0 0\ncpu19 280230 3 10399 8546414 1227 0 6 0 0 0\ncpu20 278962 0 10346 8547585 1221 0 9 0 0 0\ncpu21 277042 143 11502 8547940 1048 0 2 0 0 0\ncpu22 275560 0 9458 8549093 1271 0 153 0 0 0\ncpu23 285740 0 11118 8539648 1838 0 6 0 0 0\nintr 91288599 43 2 0 0 0 0 0 0 1 0 0 0 4 0 0 0 41 0 2 0 0 0 0 0 0 0 334158 0 1 2473208 45518 96917 44876 138077 45263 45258 54441 0 0 44198 44198 44198 44198 44198 44198 441\n98 44198 0 0 44198 44198 44198 44198 44198 44198 44198 44198 0 0 44199 44199 44199 44199 44199 44199 44199 44199 0 0 44199 44199 44199 44199 44199 44199 44199 44199 0 0 44198 44198 44198 44198 44198 44198 44198 44198 0 0 44198 44198 44198 44198 44198 44198 44198 44198 0 0 44199 44199 44199 44199 44199 44199 44199 44199 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0ctxt 42731429\nbtime 1553933982\nprocesses 190449\nprocs_running 5\nprocs_blocked 0\nsoftirq 57291816 8 26401645 17536 5419485 334063 0 1044 10019160 0 15098875\n\n```\n\n第一行cpu是总的cpu信息，其他的cpu0-cpu23 是24个核的信息。\n\n计算cpu利用率只用到前7个参数， 对应的参数解释为：\n\n```\n\t user\t nice  system idle      iowait   irq  softirq\ncpu  7283854 35392 293546 204419077 75835    0    8385     \n```\n\nuser (7283854) 从系统启动开始累计到当前时刻，用户态的CPU时间（单位：jiffies） ，不包含 nice值为负进程。1jiffies=0.01秒\nnice (35392) 从系统启动开始累计到当前时刻，nice值为负的进程所占用的CPU时间（单位：jiffies）\nsystem (293546) 从系统启动开始累计到当前时刻，核心时间（单位：jiffies）\nidle (204419077) 从系统启动开始累计到当前时刻，除硬盘IO等待时间以外其它等待时间（单位：jiffies）\niowait (75835) 从系统启动开始累计到当前时刻，硬盘IO等待时间（单位：jiffies） ，\nirq (0) 从系统启动开始累计到当前时刻，硬中断时间（单位：jiffies）\nsoftirq (8385) 从系统启动开始累计到当前时刻，软中断时间（单位：jiffies）\n\nCPU时间=user+system+nice+idle+iowait+irq+softirq\n\n“intr”这行给出中断的信息，第一个为自系统启动以来，发生的所有的中断的次数；然后每个数对应一个特定的中断自系统启动以来所发生的次数。\n“ctxt”给出了自系统启动以来CPU发生的上下文交换的次数。\n“btime”给出了从系统启动到现在为止的时间，单位为秒。\n“processes (total_forks) 自系统启动以来所创建的任务的个数目。\n“procs_running”：当前运行队列的任务的数目。\n“procs_blocked”：当前被阻塞的任务的数目。\n\n\n\n计算cpu利用率的方法就是计算出在一段时间里面，cpu工作的时间/总得时间\n\n```\ncpu usage=(idle2-idle1)/(cpu2-cpu1)*100\ncpu usage=[(user_2 +sys_2+nice_2) - (user_1 + sys_1+nice_1)]/(total_2 - total_1)*100\n```\n\n第二中方法只把user+sys+nice 这三个时间看作cpu的工作时间，因为其他的几个比较小。\n\n## shell脚本\n\n```shell\n#!/bin/bash\n\n##echo user nice system idle iowait irq softirq\n\ncpulog_start=$(cat /proc/stat | grep 'cpu'| awk 'NR==1{print $2 \"\\t\" $3 \"\\t\" $4 \"\\t\" $5 \"\\t\" $6 \"\\t\" $7 \"\\t\" $8}' )\ncpu_use_start=$(echo $cpulog_start | awk '{print $1+$2+$3}')\ncpu_iowait_start=$(echo $cpulog_start | awk '{print $5}')\ncpu_total_start=$(echo $cpulog_start | awk '{print $1+$2+$3+$4+$5+$6+$7}')\n\nsleep 10\n\ncpulog_end=$(cat /proc/stat | grep 'cpu'| awk 'NR==1{print $2 \"\\t\" $3 \"\\t\" $4 \"\\t\" $5 \"\\t\" $6 \"\\t\" $7 \"\\t\" $8}' )\ncpu_use_end=$(echo $cpulog_end | awk '{print $1+$2+$3}')\ncpu_iowait_end=$(echo $cpulog_end | awk '{print $5}')\ncpu_total_end=$(echo $cpulog_end | awk '{print $1+$2+$3+$4+$5+$6+$7}')\n\ncpu_use_diff=`expr $cpu_use_end - $cpu_use_start`\ncpu_iowait_diff=`expr $cpu_iowait_end - $cpu_iowait_start`\ncpu_total_diff=`expr $cpu_total_end - $cpu_total_start`\n\ncpu_use_rate=`expr $cpu_use_diff/$cpu_total_diff*100 | bc -l`\ncpu_iowait_rate=`expr $cpu_iowait_diff/$cpu_total_diff*100 | bc -l`\n\necho \"---------------cpuinfo----------------------\"\necho \"cpu_usage_rate (%) : $cpu_use_rate\"\necho \"cpu_iowait_rate (%): $cpu_iowait_rate\"\n\n```\n\n主要的知识点讲解：\n\n```shell\ncpulog_start=$(cat /proc/stat | grep 'cpu'| awk 'NR==1{print $2 \"\\t\" $3 \"\\t\" $4 \"\\t\" $5 \"\\t\" $6 \"\\t\" $7 \"\\t\" $8}' )\n```\n\n这一句先将/proc/stat文件的信息读取出来然后用管道| 传递给grep 命令 ,grep 将包含cpu的信息给提取出来\n\n`cat /proc/stat | grep 'cpu'` 输出为：\n\n```bash\nroot@hw103:/home/yky# cat /proc/stat | grep 'cpu'\ncpu  7645369 35392 318219 206250476 80895 0 9870 0 0 0\ncpu0 365256 48 18792 8544685 767 0 5678 0 0 0\ncpu1 292983 9 15427 8618292 1389 0 2206 0 0 0\ncpu2 287020 0 12884 8629895 1033 0 760 0 0 0\ncpu3 288372 14624 13910 8613386 681 0 320 0 0 0\ncpu4 293707 0 13074 8623117 646 0 147 0 0 0\ncpu5 390012 2824 15130 8477387 44027 0 418 0 0 0\ncpu6 362140 10934 15217 8541127 1233 0 69 0 0 0\ncpu7 377620 6281 12915 8532734 1700 0 28 0 0 0\ncpu8 333520 0 12524 8582987 2100 0 15 0 0 0\ncpu9 348913 0 12619 8567005 2453 0 10 0 0 0\ncpu10 333584 144 14002 8581939 1297 0 15 0 0 0\ncpu11 292980 0 12966 8623861 1137 0 4 0 0 0\ncpu12 350188 0 16793 8559301 4017 0 3 0 0 0\ncpu13 430200 0 19278 8479849 2344 0 1 0 0 0\ncpu14 312421 0 11483 8601843 2906 0 1 0 0 0\ncpu15 343656 3 10768 8575706 1268 0 0 0 0 0\ncpu16 302673 0 12190 8613170 2190 0 0 0 0 0\ncpu17 263473 4 9906 8656857 771 0 0 0 0 0\ncpu18 263094 370 11278 8653940 2165 0 11 0 0 0\ncpu19 281216 3 11166 8637253 1280 0 6 0 0 0\ncpu20 280412 0 11645 8637433 1221 0 9 0 0 0\ncpu21 277219 143 11967 8639929 1048 0 2 0 0 0\ncpu22 275894 0 10291 8640508 1271 0 153 0 0 0\ncpu23 298806 0 11985 8618261 1939 0 6 0 0 0\n```\n\n### awk 命令\n\n之后使用awk命令再次进行操作。这个命令之前用的很少，参考《鸟哥的Linux私房菜》介绍：\n\nsed常用于一整行的处理，awk则倾向于将一行分成数个“字段”来处理，awk适合处理小型的数据。\n\n用法为：\n\n`awk '条件类型1{操作1} 条件类型1{操作2}...'  filename`\n\n| 变量名称 | 意义                        |\n| -------- | --------------------------- |\n| NF       | 每一行（$0） 拥有的字段总数 |\n| NR       | awk当前处理的第几行数据     |\n| FS       | 目前的分割符，默认空格键    |\n\n\n\n```shell\ncpulog_start=$(cat /proc/stat | grep 'cpu'| awk 'NR==1{print $2 \"\\t\" $3 \"\\t\" $4 \"\\t\" $5 \"\\t\" $6 \"\\t\" $7 \"\\t\" $8}' )\n```\n\n`NR==1 ` 限定条件为第一行，因为第一行的数据才是cpu的总信息，{}里面的操作是输出字段，$N 就是第N个字段。\n\n```\n $1\t$2\t\t$3\t\t$4\t  $5\t\t$6\t\t $7\t  $8\n     user\t nice  system idle      iowait   irq  softirq\ncpu  7283854 35392 293546 204419077 75835    0    8385    \n```\n\n### expr\n\n```bash\ncpu_use_diff=`expr $cpu_use_end - $cpu_use_start`\n```\n\n\n\n使用expr 执行变量计算，然后是`` 进行反引用将值赋值给cpu_use_diff\n\n注意shell 脚本中= 不能用空格分开 需要直接相邻\n\n### bc 命令\n\nbc 命令是任意精度计算器语言，通常在linux下当计算器用。\n\n简单的描述参考：<http://www.runoob.com/linux/linux-comm-bc.html>\n\n而expr命令不支持小数运算，所以需要使用bc进行计算。\n\n语法为：\n\n```\nbc(选项)(参数)\n```\n\n**选项值**\n\n- -i：强制进入交互式模式；\n- -l：定义使用的标准数学库\n- ； -w：对POSIX bc的扩展给出警告信息；\n- -q：不打印正常的GNU bc环境信息；\n- -v：显示指令版本信息；\n- -h：显示指令的帮助信息。\n\n**参数**\n\n文件：指定包含计算任务的文件。\n\n## 参考\n\n<https://blog.csdn.net/x_i_y_u_e/article/details/50684508>","slug":"2019-03-31-计算Linux系统的CPU利用率","published":1,"updated":"2019-11-08T13:14:53.661Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6he13y9000ddstzi0wx2pu2","content":"<h1 id=\"计算Linux系统的CPU利用率\"><a href=\"#计算Linux系统的CPU利用率\" class=\"headerlink\" title=\"计算Linux系统的CPU利用率\"></a>计算Linux系统的CPU利用率</h1><p>通过读取系统的/proc/stat 信息来计算CPU的利用率</p>\n<a id=\"more\"></a>\n<h2 id=\"cpu-信息的读取\"><a href=\"#cpu-信息的读取\" class=\"headerlink\" title=\"cpu 信息的读取\"></a>cpu 信息的读取</h2><p>摘自参考博客：<a href=\"https://blog.csdn.net/x_i_y_u_e/article/details/50684508\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/x_i_y_u_e/article/details/50684508</a></p>\n<p>在Linux/Unix下，CPU利用率分为用户态，系统态和空闲态，分别表示CPU处于用户态执行的时间，系统内核执行的时间，和空闲系统进程执行的时间。平时所说的CPU利用率是指：CPU执行非系统空闲进程的时间 / CPU总的执行时间。</p>\n<p>在Linux的内核中，有一个全局变量：Jiffies。 Jiffies代表时间。它的单位随硬件平台的不同而不同。系统里定义了一个常数HZ，代表每秒种最小时间间隔的数目。这样jiffies的单位就是1/HZ。Intel平台jiffies的单位是1/100秒，这就是系统所能分辨的最小时间间隔了。每个CPU时间片，Jiffies都要加1。 CPU的利用率就是用执行用户态+系统态的Jiffies除以总的Jifffies来表示。</p>\n<p>在Linux系统中，可以用/proc/stat文件来计算cpu的利用率(详细的解释可参考：<a href=\"http://www.linuxhowtos.org/System/procstat.htm\" target=\"_blank\" rel=\"noopener\">http://www.linuxhowtos.org/System/procstat.htm</a>)。这个文件包含了所有CPU活动的信息，该文件中的所有值都是从系统启动开始累计到当前时刻。</p>\n<p>在本机上的信息如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> root@hw103:/home/yky# cat/proc/stat </span><br><span class=\"line\">cpu  7283854 35392 293546 204419077 75835 0 8385 0 0 0</span><br><span class=\"line\">cpu0 365010 48 18204 8453603 767 0 4306 0 0 0</span><br><span class=\"line\">cpu1 292817 9 14990 8526563 1358 0 2114 0 0 0</span><br><span class=\"line\">cpu2 286689 0 11880 8538662 1033 0 752 0 0 0</span><br><span class=\"line\">cpu3 287106 14624 12945 8523209 641 0 320 0 0 0</span><br><span class=\"line\">cpu4 293293 0 11784 8532282 604 0 147 0 0 0</span><br><span class=\"line\">cpu5 371312 2824 13669 8408187 40794 0 406 0 0 0</span><br><span class=\"line\">cpu6 358116 10934 14014 8453775 1230 0 68 0 0 0</span><br><span class=\"line\">cpu7 313971 6281 12243 8504303 1575 0 28 0 0 0</span><br><span class=\"line\">cpu8 318084 0 11598 8506770 2036 0 15 0 0 0</span><br><span class=\"line\">cpu9 294503 0 11137 8530318 2185 0 10 0 0 0</span><br><span class=\"line\">cpu10 307922 144 12434 8516570 1177 0 15 0 0 0</span><br><span class=\"line\">cpu11 291752 0 11502 8533957 1128 0 4 0 0 0</span><br><span class=\"line\">cpu12 315096 0 15927 8503001 3528 0 3 0 0 0</span><br><span class=\"line\">cpu13 375976 0 17927 8442873 2041 0 1 0 0 0</span><br><span class=\"line\">cpu14 299344 0 10140 8523716 2818 0 1 0 0 0</span><br><span class=\"line\">cpu15 288470 3 10146 8538685 1240 0 0 0 0 0</span><br><span class=\"line\">cpu16 301148 0 10681 8523612 2185 0 0 0 0 0</span><br><span class=\"line\">cpu17 263183 4 9149 8565345 771 0 0 0 0 0</span><br><span class=\"line\">cpu18 262518 370 10343 8562955 2105 0 11 0 0 0</span><br><span class=\"line\">cpu19 280230 3 10399 8546414 1227 0 6 0 0 0</span><br><span class=\"line\">cpu20 278962 0 10346 8547585 1221 0 9 0 0 0</span><br><span class=\"line\">cpu21 277042 143 11502 8547940 1048 0 2 0 0 0</span><br><span class=\"line\">cpu22 275560 0 9458 8549093 1271 0 153 0 0 0</span><br><span class=\"line\">cpu23 285740 0 11118 8539648 1838 0 6 0 0 0</span><br><span class=\"line\">intr 91288599 43 2 0 0 0 0 0 0 1 0 0 0 4 0 0 0 41 0 2 0 0 0 0 0 0 0 334158 0 1 2473208 45518 96917 44876 138077 45263 45258 54441 0 0 44198 44198 44198 44198 44198 44198 441</span><br><span class=\"line\">98 44198 0 0 44198 44198 44198 44198 44198 44198 44198 44198 0 0 44199 44199 44199 44199 44199 44199 44199 44199 0 0 44199 44199 44199 44199 44199 44199 44199 44199 0 0 44198 44198 44198 44198 44198 44198 44198 44198 0 0 44198 44198 44198 44198 44198 44198 44198 44198 0 0 44199 44199 44199 44199 44199 44199 44199 44199 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0ctxt 42731429</span><br><span class=\"line\">btime 1553933982</span><br><span class=\"line\">processes 190449</span><br><span class=\"line\">procs_running 5</span><br><span class=\"line\">procs_blocked 0</span><br><span class=\"line\">softirq 57291816 8 26401645 17536 5419485 334063 0 1044 10019160 0 15098875</span><br></pre></td></tr></table></figure>\n<p>第一行cpu是总的cpu信息，其他的cpu0-cpu23 是24个核的信息。</p>\n<p>计算cpu利用率只用到前7个参数， 对应的参数解释为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t user\t nice  system idle      iowait   irq  softirq</span><br><span class=\"line\">cpu  7283854 35392 293546 204419077 75835    0    8385</span><br></pre></td></tr></table></figure>\n<p>user (7283854) 从系统启动开始累计到当前时刻，用户态的CPU时间（单位：jiffies） ，不包含 nice值为负进程。1jiffies=0.01秒<br>nice (35392) 从系统启动开始累计到当前时刻，nice值为负的进程所占用的CPU时间（单位：jiffies）<br>system (293546) 从系统启动开始累计到当前时刻，核心时间（单位：jiffies）<br>idle (204419077) 从系统启动开始累计到当前时刻，除硬盘IO等待时间以外其它等待时间（单位：jiffies）<br>iowait (75835) 从系统启动开始累计到当前时刻，硬盘IO等待时间（单位：jiffies） ，<br>irq (0) 从系统启动开始累计到当前时刻，硬中断时间（单位：jiffies）<br>softirq (8385) 从系统启动开始累计到当前时刻，软中断时间（单位：jiffies）</p>\n<p>CPU时间=user+system+nice+idle+iowait+irq+softirq</p>\n<p>“intr”这行给出中断的信息，第一个为自系统启动以来，发生的所有的中断的次数；然后每个数对应一个特定的中断自系统启动以来所发生的次数。<br>“ctxt”给出了自系统启动以来CPU发生的上下文交换的次数。<br>“btime”给出了从系统启动到现在为止的时间，单位为秒。<br>“processes (total_forks) 自系统启动以来所创建的任务的个数目。<br>“procs_running”：当前运行队列的任务的数目。<br>“procs_blocked”：当前被阻塞的任务的数目。</p>\n<p>计算cpu利用率的方法就是计算出在一段时间里面，cpu工作的时间/总得时间</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cpu usage=(idle2-idle1)/(cpu2-cpu1)*100</span><br><span class=\"line\">cpu usage=[(user_2 +sys_2+nice_2) - (user_1 + sys_1+nice_1)]/(total_2 - total_1)*100</span><br></pre></td></tr></table></figure>\n<p>第二中方法只把user+sys+nice 这三个时间看作cpu的工作时间，因为其他的几个比较小。</p>\n<h2 id=\"shell脚本\"><a href=\"#shell脚本\" class=\"headerlink\" title=\"shell脚本\"></a>shell脚本</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\">#echo user nice system idle iowait irq softirq</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">cpulog_start=$(cat /proc/stat | grep 'cpu'| awk 'NR==1&#123;print $2 \"\\t\" $3 \"\\t\" $4 \"\\t\" $5 \"\\t\" $6 \"\\t\" $7 \"\\t\" $8&#125;' )</span><br><span class=\"line\">cpu_use_start=$(echo $cpulog_start | awk '&#123;print $1+$2+$3&#125;')</span><br><span class=\"line\">cpu_iowait_start=$(echo $cpulog_start | awk '&#123;print $5&#125;')</span><br><span class=\"line\">cpu_total_start=$(echo $cpulog_start | awk '&#123;print $1+$2+$3+$4+$5+$6+$7&#125;')</span><br><span class=\"line\"></span><br><span class=\"line\">sleep 10</span><br><span class=\"line\"></span><br><span class=\"line\">cpulog_end=$(cat /proc/stat | grep 'cpu'| awk 'NR==1&#123;print $2 \"\\t\" $3 \"\\t\" $4 \"\\t\" $5 \"\\t\" $6 \"\\t\" $7 \"\\t\" $8&#125;' )</span><br><span class=\"line\">cpu_use_end=$(echo $cpulog_end | awk '&#123;print $1+$2+$3&#125;')</span><br><span class=\"line\">cpu_iowait_end=$(echo $cpulog_end | awk '&#123;print $5&#125;')</span><br><span class=\"line\">cpu_total_end=$(echo $cpulog_end | awk '&#123;print $1+$2+$3+$4+$5+$6+$7&#125;')</span><br><span class=\"line\"></span><br><span class=\"line\">cpu_use_diff=`expr $cpu_use_end - $cpu_use_start`</span><br><span class=\"line\">cpu_iowait_diff=`expr $cpu_iowait_end - $cpu_iowait_start`</span><br><span class=\"line\">cpu_total_diff=`expr $cpu_total_end - $cpu_total_start`</span><br><span class=\"line\"></span><br><span class=\"line\">cpu_use_rate=`expr $cpu_use_diff/$cpu_total_diff*100 | bc -l`</span><br><span class=\"line\">cpu_iowait_rate=`expr $cpu_iowait_diff/$cpu_total_diff*100 | bc -l`</span><br><span class=\"line\"></span><br><span class=\"line\">echo \"---------------cpuinfo----------------------\"</span><br><span class=\"line\">echo \"cpu_usage_rate (%) : $cpu_use_rate\"</span><br><span class=\"line\">echo \"cpu_iowait_rate (%): $cpu_iowait_rate\"</span><br></pre></td></tr></table></figure>\n<p>主要的知识点讲解：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cpulog_start=$(cat /proc/stat | grep 'cpu'| awk 'NR==1&#123;print $2 \"\\t\" $3 \"\\t\" $4 \"\\t\" $5 \"\\t\" $6 \"\\t\" $7 \"\\t\" $8&#125;' )</span><br></pre></td></tr></table></figure>\n<p>这一句先将/proc/stat文件的信息读取出来然后用管道| 传递给grep 命令 ,grep 将包含cpu的信息给提取出来</p>\n<p><code>cat /proc/stat | grep &#39;cpu&#39;</code> 输出为：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@hw103:/home/yky<span class=\"comment\"># cat /proc/stat | grep 'cpu'</span></span><br><span class=\"line\">cpu  7645369 35392 318219 206250476 80895 0 9870 0 0 0</span><br><span class=\"line\">cpu0 365256 48 18792 8544685 767 0 5678 0 0 0</span><br><span class=\"line\">cpu1 292983 9 15427 8618292 1389 0 2206 0 0 0</span><br><span class=\"line\">cpu2 287020 0 12884 8629895 1033 0 760 0 0 0</span><br><span class=\"line\">cpu3 288372 14624 13910 8613386 681 0 320 0 0 0</span><br><span class=\"line\">cpu4 293707 0 13074 8623117 646 0 147 0 0 0</span><br><span class=\"line\">cpu5 390012 2824 15130 8477387 44027 0 418 0 0 0</span><br><span class=\"line\">cpu6 362140 10934 15217 8541127 1233 0 69 0 0 0</span><br><span class=\"line\">cpu7 377620 6281 12915 8532734 1700 0 28 0 0 0</span><br><span class=\"line\">cpu8 333520 0 12524 8582987 2100 0 15 0 0 0</span><br><span class=\"line\">cpu9 348913 0 12619 8567005 2453 0 10 0 0 0</span><br><span class=\"line\">cpu10 333584 144 14002 8581939 1297 0 15 0 0 0</span><br><span class=\"line\">cpu11 292980 0 12966 8623861 1137 0 4 0 0 0</span><br><span class=\"line\">cpu12 350188 0 16793 8559301 4017 0 3 0 0 0</span><br><span class=\"line\">cpu13 430200 0 19278 8479849 2344 0 1 0 0 0</span><br><span class=\"line\">cpu14 312421 0 11483 8601843 2906 0 1 0 0 0</span><br><span class=\"line\">cpu15 343656 3 10768 8575706 1268 0 0 0 0 0</span><br><span class=\"line\">cpu16 302673 0 12190 8613170 2190 0 0 0 0 0</span><br><span class=\"line\">cpu17 263473 4 9906 8656857 771 0 0 0 0 0</span><br><span class=\"line\">cpu18 263094 370 11278 8653940 2165 0 11 0 0 0</span><br><span class=\"line\">cpu19 281216 3 11166 8637253 1280 0 6 0 0 0</span><br><span class=\"line\">cpu20 280412 0 11645 8637433 1221 0 9 0 0 0</span><br><span class=\"line\">cpu21 277219 143 11967 8639929 1048 0 2 0 0 0</span><br><span class=\"line\">cpu22 275894 0 10291 8640508 1271 0 153 0 0 0</span><br><span class=\"line\">cpu23 298806 0 11985 8618261 1939 0 6 0 0 0</span><br></pre></td></tr></table></figure>\n<h3 id=\"awk-命令\"><a href=\"#awk-命令\" class=\"headerlink\" title=\"awk 命令\"></a>awk 命令</h3><p>之后使用awk命令再次进行操作。这个命令之前用的很少，参考《鸟哥的Linux私房菜》介绍：</p>\n<p>sed常用于一整行的处理，awk则倾向于将一行分成数个“字段”来处理，awk适合处理小型的数据。</p>\n<p>用法为：</p>\n<p><code>awk &#39;条件类型1{操作1} 条件类型1{操作2}...&#39;  filename</code></p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>变量名称</th>\n<th>意义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>NF</td>\n<td>每一行（$0） 拥有的字段总数</td>\n</tr>\n<tr>\n<td>NR</td>\n<td>awk当前处理的第几行数据</td>\n</tr>\n<tr>\n<td>FS</td>\n<td>目前的分割符，默认空格键</td>\n</tr>\n</tbody>\n</table>\n</div>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cpulog_start=$(cat /proc/stat | grep 'cpu'| awk 'NR==1&#123;print $2 \"\\t\" $3 \"\\t\" $4 \"\\t\" $5 \"\\t\" $6 \"\\t\" $7 \"\\t\" $8&#125;' )</span><br></pre></td></tr></table></figure>\n<p><code>NR==1</code> 限定条件为第一行，因为第一行的数据才是cpu的总信息，{}里面的操作是输出字段，$N 就是第N个字段。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> $1\t$2\t\t$3\t\t$4\t  $5\t\t$6\t\t $7\t  $8</span><br><span class=\"line\">     user\t nice  system idle      iowait   irq  softirq</span><br><span class=\"line\">cpu  7283854 35392 293546 204419077 75835    0    8385</span><br></pre></td></tr></table></figure>\n<h3 id=\"expr\"><a href=\"#expr\" class=\"headerlink\" title=\"expr\"></a>expr</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cpu_use_diff=`expr <span class=\"variable\">$cpu_use_end</span> - <span class=\"variable\">$cpu_use_start</span>`</span><br></pre></td></tr></table></figure>\n<p>使用expr 执行变量计算，然后是`` 进行反引用将值赋值给cpu_use_diff</p>\n<p>注意shell 脚本中= 不能用空格分开 需要直接相邻</p>\n<h3 id=\"bc-命令\"><a href=\"#bc-命令\" class=\"headerlink\" title=\"bc 命令\"></a>bc 命令</h3><p>bc 命令是任意精度计算器语言，通常在linux下当计算器用。</p>\n<p>简单的描述参考：<a href=\"http://www.runoob.com/linux/linux-comm-bc.html\" target=\"_blank\" rel=\"noopener\">http://www.runoob.com/linux/linux-comm-bc.html</a></p>\n<p>而expr命令不支持小数运算，所以需要使用bc进行计算。</p>\n<p>语法为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bc(选项)(参数)</span><br></pre></td></tr></table></figure>\n<p><strong>选项值</strong></p>\n<ul>\n<li>-i：强制进入交互式模式；</li>\n<li>-l：定义使用的标准数学库</li>\n<li>； -w：对POSIX bc的扩展给出警告信息；</li>\n<li>-q：不打印正常的GNU bc环境信息；</li>\n<li>-v：显示指令版本信息；</li>\n<li>-h：显示指令的帮助信息。</li>\n</ul>\n<p><strong>参数</strong></p>\n<p>文件：指定包含计算任务的文件。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://blog.csdn.net/x_i_y_u_e/article/details/50684508\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/x_i_y_u_e/article/details/50684508</a></p>\n","site":{"data":{}},"length":7099,"excerpt":"<h1 id=\"计算Linux系统的CPU利用率\"><a href=\"#计算Linux系统的CPU利用率\" class=\"headerlink\" title=\"计算Linux系统的CPU利用率\"></a>计算Linux系统的CPU利用率</h1><p>通过读取系统的/proc/stat 信息来计算CPU的利用率</p>","more":"<h2 id=\"cpu-信息的读取\"><a href=\"#cpu-信息的读取\" class=\"headerlink\" title=\"cpu 信息的读取\"></a>cpu 信息的读取</h2><p>摘自参考博客：<a href=\"https://blog.csdn.net/x_i_y_u_e/article/details/50684508\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/x_i_y_u_e/article/details/50684508</a></p>\n<p>在Linux/Unix下，CPU利用率分为用户态，系统态和空闲态，分别表示CPU处于用户态执行的时间，系统内核执行的时间，和空闲系统进程执行的时间。平时所说的CPU利用率是指：CPU执行非系统空闲进程的时间 / CPU总的执行时间。</p>\n<p>在Linux的内核中，有一个全局变量：Jiffies。 Jiffies代表时间。它的单位随硬件平台的不同而不同。系统里定义了一个常数HZ，代表每秒种最小时间间隔的数目。这样jiffies的单位就是1/HZ。Intel平台jiffies的单位是1/100秒，这就是系统所能分辨的最小时间间隔了。每个CPU时间片，Jiffies都要加1。 CPU的利用率就是用执行用户态+系统态的Jiffies除以总的Jifffies来表示。</p>\n<p>在Linux系统中，可以用/proc/stat文件来计算cpu的利用率(详细的解释可参考：<a href=\"http://www.linuxhowtos.org/System/procstat.htm\" target=\"_blank\" rel=\"noopener\">http://www.linuxhowtos.org/System/procstat.htm</a>)。这个文件包含了所有CPU活动的信息，该文件中的所有值都是从系统启动开始累计到当前时刻。</p>\n<p>在本机上的信息如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> root@hw103:/home/yky# cat/proc/stat </span><br><span class=\"line\">cpu  7283854 35392 293546 204419077 75835 0 8385 0 0 0</span><br><span class=\"line\">cpu0 365010 48 18204 8453603 767 0 4306 0 0 0</span><br><span class=\"line\">cpu1 292817 9 14990 8526563 1358 0 2114 0 0 0</span><br><span class=\"line\">cpu2 286689 0 11880 8538662 1033 0 752 0 0 0</span><br><span class=\"line\">cpu3 287106 14624 12945 8523209 641 0 320 0 0 0</span><br><span class=\"line\">cpu4 293293 0 11784 8532282 604 0 147 0 0 0</span><br><span class=\"line\">cpu5 371312 2824 13669 8408187 40794 0 406 0 0 0</span><br><span class=\"line\">cpu6 358116 10934 14014 8453775 1230 0 68 0 0 0</span><br><span class=\"line\">cpu7 313971 6281 12243 8504303 1575 0 28 0 0 0</span><br><span class=\"line\">cpu8 318084 0 11598 8506770 2036 0 15 0 0 0</span><br><span class=\"line\">cpu9 294503 0 11137 8530318 2185 0 10 0 0 0</span><br><span class=\"line\">cpu10 307922 144 12434 8516570 1177 0 15 0 0 0</span><br><span class=\"line\">cpu11 291752 0 11502 8533957 1128 0 4 0 0 0</span><br><span class=\"line\">cpu12 315096 0 15927 8503001 3528 0 3 0 0 0</span><br><span class=\"line\">cpu13 375976 0 17927 8442873 2041 0 1 0 0 0</span><br><span class=\"line\">cpu14 299344 0 10140 8523716 2818 0 1 0 0 0</span><br><span class=\"line\">cpu15 288470 3 10146 8538685 1240 0 0 0 0 0</span><br><span class=\"line\">cpu16 301148 0 10681 8523612 2185 0 0 0 0 0</span><br><span class=\"line\">cpu17 263183 4 9149 8565345 771 0 0 0 0 0</span><br><span class=\"line\">cpu18 262518 370 10343 8562955 2105 0 11 0 0 0</span><br><span class=\"line\">cpu19 280230 3 10399 8546414 1227 0 6 0 0 0</span><br><span class=\"line\">cpu20 278962 0 10346 8547585 1221 0 9 0 0 0</span><br><span class=\"line\">cpu21 277042 143 11502 8547940 1048 0 2 0 0 0</span><br><span class=\"line\">cpu22 275560 0 9458 8549093 1271 0 153 0 0 0</span><br><span class=\"line\">cpu23 285740 0 11118 8539648 1838 0 6 0 0 0</span><br><span class=\"line\">intr 91288599 43 2 0 0 0 0 0 0 1 0 0 0 4 0 0 0 41 0 2 0 0 0 0 0 0 0 334158 0 1 2473208 45518 96917 44876 138077 45263 45258 54441 0 0 44198 44198 44198 44198 44198 44198 441</span><br><span class=\"line\">98 44198 0 0 44198 44198 44198 44198 44198 44198 44198 44198 0 0 44199 44199 44199 44199 44199 44199 44199 44199 0 0 44199 44199 44199 44199 44199 44199 44199 44199 0 0 44198 44198 44198 44198 44198 44198 44198 44198 0 0 44198 44198 44198 44198 44198 44198 44198 44198 0 0 44199 44199 44199 44199 44199 44199 44199 44199 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0ctxt 42731429</span><br><span class=\"line\">btime 1553933982</span><br><span class=\"line\">processes 190449</span><br><span class=\"line\">procs_running 5</span><br><span class=\"line\">procs_blocked 0</span><br><span class=\"line\">softirq 57291816 8 26401645 17536 5419485 334063 0 1044 10019160 0 15098875</span><br></pre></td></tr></table></figure>\n<p>第一行cpu是总的cpu信息，其他的cpu0-cpu23 是24个核的信息。</p>\n<p>计算cpu利用率只用到前7个参数， 对应的参数解释为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t user\t nice  system idle      iowait   irq  softirq</span><br><span class=\"line\">cpu  7283854 35392 293546 204419077 75835    0    8385</span><br></pre></td></tr></table></figure>\n<p>user (7283854) 从系统启动开始累计到当前时刻，用户态的CPU时间（单位：jiffies） ，不包含 nice值为负进程。1jiffies=0.01秒<br>nice (35392) 从系统启动开始累计到当前时刻，nice值为负的进程所占用的CPU时间（单位：jiffies）<br>system (293546) 从系统启动开始累计到当前时刻，核心时间（单位：jiffies）<br>idle (204419077) 从系统启动开始累计到当前时刻，除硬盘IO等待时间以外其它等待时间（单位：jiffies）<br>iowait (75835) 从系统启动开始累计到当前时刻，硬盘IO等待时间（单位：jiffies） ，<br>irq (0) 从系统启动开始累计到当前时刻，硬中断时间（单位：jiffies）<br>softirq (8385) 从系统启动开始累计到当前时刻，软中断时间（单位：jiffies）</p>\n<p>CPU时间=user+system+nice+idle+iowait+irq+softirq</p>\n<p>“intr”这行给出中断的信息，第一个为自系统启动以来，发生的所有的中断的次数；然后每个数对应一个特定的中断自系统启动以来所发生的次数。<br>“ctxt”给出了自系统启动以来CPU发生的上下文交换的次数。<br>“btime”给出了从系统启动到现在为止的时间，单位为秒。<br>“processes (total_forks) 自系统启动以来所创建的任务的个数目。<br>“procs_running”：当前运行队列的任务的数目。<br>“procs_blocked”：当前被阻塞的任务的数目。</p>\n<p>计算cpu利用率的方法就是计算出在一段时间里面，cpu工作的时间/总得时间</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cpu usage=(idle2-idle1)/(cpu2-cpu1)*100</span><br><span class=\"line\">cpu usage=[(user_2 +sys_2+nice_2) - (user_1 + sys_1+nice_1)]/(total_2 - total_1)*100</span><br></pre></td></tr></table></figure>\n<p>第二中方法只把user+sys+nice 这三个时间看作cpu的工作时间，因为其他的几个比较小。</p>\n<h2 id=\"shell脚本\"><a href=\"#shell脚本\" class=\"headerlink\" title=\"shell脚本\"></a>shell脚本</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\">#echo user nice system idle iowait irq softirq</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">cpulog_start=$(cat /proc/stat | grep 'cpu'| awk 'NR==1&#123;print $2 \"\\t\" $3 \"\\t\" $4 \"\\t\" $5 \"\\t\" $6 \"\\t\" $7 \"\\t\" $8&#125;' )</span><br><span class=\"line\">cpu_use_start=$(echo $cpulog_start | awk '&#123;print $1+$2+$3&#125;')</span><br><span class=\"line\">cpu_iowait_start=$(echo $cpulog_start | awk '&#123;print $5&#125;')</span><br><span class=\"line\">cpu_total_start=$(echo $cpulog_start | awk '&#123;print $1+$2+$3+$4+$5+$6+$7&#125;')</span><br><span class=\"line\"></span><br><span class=\"line\">sleep 10</span><br><span class=\"line\"></span><br><span class=\"line\">cpulog_end=$(cat /proc/stat | grep 'cpu'| awk 'NR==1&#123;print $2 \"\\t\" $3 \"\\t\" $4 \"\\t\" $5 \"\\t\" $6 \"\\t\" $7 \"\\t\" $8&#125;' )</span><br><span class=\"line\">cpu_use_end=$(echo $cpulog_end | awk '&#123;print $1+$2+$3&#125;')</span><br><span class=\"line\">cpu_iowait_end=$(echo $cpulog_end | awk '&#123;print $5&#125;')</span><br><span class=\"line\">cpu_total_end=$(echo $cpulog_end | awk '&#123;print $1+$2+$3+$4+$5+$6+$7&#125;')</span><br><span class=\"line\"></span><br><span class=\"line\">cpu_use_diff=`expr $cpu_use_end - $cpu_use_start`</span><br><span class=\"line\">cpu_iowait_diff=`expr $cpu_iowait_end - $cpu_iowait_start`</span><br><span class=\"line\">cpu_total_diff=`expr $cpu_total_end - $cpu_total_start`</span><br><span class=\"line\"></span><br><span class=\"line\">cpu_use_rate=`expr $cpu_use_diff/$cpu_total_diff*100 | bc -l`</span><br><span class=\"line\">cpu_iowait_rate=`expr $cpu_iowait_diff/$cpu_total_diff*100 | bc -l`</span><br><span class=\"line\"></span><br><span class=\"line\">echo \"---------------cpuinfo----------------------\"</span><br><span class=\"line\">echo \"cpu_usage_rate (%) : $cpu_use_rate\"</span><br><span class=\"line\">echo \"cpu_iowait_rate (%): $cpu_iowait_rate\"</span><br></pre></td></tr></table></figure>\n<p>主要的知识点讲解：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cpulog_start=$(cat /proc/stat | grep 'cpu'| awk 'NR==1&#123;print $2 \"\\t\" $3 \"\\t\" $4 \"\\t\" $5 \"\\t\" $6 \"\\t\" $7 \"\\t\" $8&#125;' )</span><br></pre></td></tr></table></figure>\n<p>这一句先将/proc/stat文件的信息读取出来然后用管道| 传递给grep 命令 ,grep 将包含cpu的信息给提取出来</p>\n<p><code>cat /proc/stat | grep &#39;cpu&#39;</code> 输出为：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@hw103:/home/yky<span class=\"comment\"># cat /proc/stat | grep 'cpu'</span></span><br><span class=\"line\">cpu  7645369 35392 318219 206250476 80895 0 9870 0 0 0</span><br><span class=\"line\">cpu0 365256 48 18792 8544685 767 0 5678 0 0 0</span><br><span class=\"line\">cpu1 292983 9 15427 8618292 1389 0 2206 0 0 0</span><br><span class=\"line\">cpu2 287020 0 12884 8629895 1033 0 760 0 0 0</span><br><span class=\"line\">cpu3 288372 14624 13910 8613386 681 0 320 0 0 0</span><br><span class=\"line\">cpu4 293707 0 13074 8623117 646 0 147 0 0 0</span><br><span class=\"line\">cpu5 390012 2824 15130 8477387 44027 0 418 0 0 0</span><br><span class=\"line\">cpu6 362140 10934 15217 8541127 1233 0 69 0 0 0</span><br><span class=\"line\">cpu7 377620 6281 12915 8532734 1700 0 28 0 0 0</span><br><span class=\"line\">cpu8 333520 0 12524 8582987 2100 0 15 0 0 0</span><br><span class=\"line\">cpu9 348913 0 12619 8567005 2453 0 10 0 0 0</span><br><span class=\"line\">cpu10 333584 144 14002 8581939 1297 0 15 0 0 0</span><br><span class=\"line\">cpu11 292980 0 12966 8623861 1137 0 4 0 0 0</span><br><span class=\"line\">cpu12 350188 0 16793 8559301 4017 0 3 0 0 0</span><br><span class=\"line\">cpu13 430200 0 19278 8479849 2344 0 1 0 0 0</span><br><span class=\"line\">cpu14 312421 0 11483 8601843 2906 0 1 0 0 0</span><br><span class=\"line\">cpu15 343656 3 10768 8575706 1268 0 0 0 0 0</span><br><span class=\"line\">cpu16 302673 0 12190 8613170 2190 0 0 0 0 0</span><br><span class=\"line\">cpu17 263473 4 9906 8656857 771 0 0 0 0 0</span><br><span class=\"line\">cpu18 263094 370 11278 8653940 2165 0 11 0 0 0</span><br><span class=\"line\">cpu19 281216 3 11166 8637253 1280 0 6 0 0 0</span><br><span class=\"line\">cpu20 280412 0 11645 8637433 1221 0 9 0 0 0</span><br><span class=\"line\">cpu21 277219 143 11967 8639929 1048 0 2 0 0 0</span><br><span class=\"line\">cpu22 275894 0 10291 8640508 1271 0 153 0 0 0</span><br><span class=\"line\">cpu23 298806 0 11985 8618261 1939 0 6 0 0 0</span><br></pre></td></tr></table></figure>\n<h3 id=\"awk-命令\"><a href=\"#awk-命令\" class=\"headerlink\" title=\"awk 命令\"></a>awk 命令</h3><p>之后使用awk命令再次进行操作。这个命令之前用的很少，参考《鸟哥的Linux私房菜》介绍：</p>\n<p>sed常用于一整行的处理，awk则倾向于将一行分成数个“字段”来处理，awk适合处理小型的数据。</p>\n<p>用法为：</p>\n<p><code>awk &#39;条件类型1{操作1} 条件类型1{操作2}...&#39;  filename</code></p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>变量名称</th>\n<th>意义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>NF</td>\n<td>每一行（$0） 拥有的字段总数</td>\n</tr>\n<tr>\n<td>NR</td>\n<td>awk当前处理的第几行数据</td>\n</tr>\n<tr>\n<td>FS</td>\n<td>目前的分割符，默认空格键</td>\n</tr>\n</tbody>\n</table>\n</div>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cpulog_start=$(cat /proc/stat | grep 'cpu'| awk 'NR==1&#123;print $2 \"\\t\" $3 \"\\t\" $4 \"\\t\" $5 \"\\t\" $6 \"\\t\" $7 \"\\t\" $8&#125;' )</span><br></pre></td></tr></table></figure>\n<p><code>NR==1</code> 限定条件为第一行，因为第一行的数据才是cpu的总信息，{}里面的操作是输出字段，$N 就是第N个字段。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> $1\t$2\t\t$3\t\t$4\t  $5\t\t$6\t\t $7\t  $8</span><br><span class=\"line\">     user\t nice  system idle      iowait   irq  softirq</span><br><span class=\"line\">cpu  7283854 35392 293546 204419077 75835    0    8385</span><br></pre></td></tr></table></figure>\n<h3 id=\"expr\"><a href=\"#expr\" class=\"headerlink\" title=\"expr\"></a>expr</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cpu_use_diff=`expr <span class=\"variable\">$cpu_use_end</span> - <span class=\"variable\">$cpu_use_start</span>`</span><br></pre></td></tr></table></figure>\n<p>使用expr 执行变量计算，然后是`` 进行反引用将值赋值给cpu_use_diff</p>\n<p>注意shell 脚本中= 不能用空格分开 需要直接相邻</p>\n<h3 id=\"bc-命令\"><a href=\"#bc-命令\" class=\"headerlink\" title=\"bc 命令\"></a>bc 命令</h3><p>bc 命令是任意精度计算器语言，通常在linux下当计算器用。</p>\n<p>简单的描述参考：<a href=\"http://www.runoob.com/linux/linux-comm-bc.html\" target=\"_blank\" rel=\"noopener\">http://www.runoob.com/linux/linux-comm-bc.html</a></p>\n<p>而expr命令不支持小数运算，所以需要使用bc进行计算。</p>\n<p>语法为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bc(选项)(参数)</span><br></pre></td></tr></table></figure>\n<p><strong>选项值</strong></p>\n<ul>\n<li>-i：强制进入交互式模式；</li>\n<li>-l：定义使用的标准数学库</li>\n<li>； -w：对POSIX bc的扩展给出警告信息；</li>\n<li>-q：不打印正常的GNU bc环境信息；</li>\n<li>-v：显示指令版本信息；</li>\n<li>-h：显示指令的帮助信息。</li>\n</ul>\n<p><strong>参数</strong></p>\n<p>文件：指定包含计算任务的文件。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://blog.csdn.net/x_i_y_u_e/article/details/50684508\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/x_i_y_u_e/article/details/50684508</a></p>"},{"title":"剑指offer 读书笔记——第2章","date":"2019-03-27T12:31:08.000Z","copyright":true,"_content":"\n# 剑指offer 读书笔记——第2章 \n\n感觉自己的代码能力还在很弱，所以又第二遍仔细的阅读剑指offer了\n\n第二章 面试需要的基础知识\n\n<!--more-->\n\n## 面试题1 赋值运算函数\n\n所谓赋值运算函数就是对=这个操作符进行重载，从而使等号能够直接用于两个实例之间的赋值。这个C++课上学过，不过现在忘完了，只记得学过。\n\n### 经典解法\n\n需要考虑的点\n\n1. **返回值的类型**声明为该类型的引用，在函数结束前返回实例自身的引用(***this**)。只有返回一个引用，才可以连续赋值。`object1=object2=object3`就是连续赋值。赋值采用右结合律，从最右边开始计算。不然的话当首先执行完`object2=object3` 后，`object2` 虽然自己的成员已经得到了更改，但是它不能再作为`object1=object2` 这个等号的右值，因为在前一个=的执行中，它没有获得返回值。而返回对象的话，就需要重新执行新建一个对象和销毁对象的构造与析构操作，增加不必要开销，降低赋值函数的效率。\n2. 传入的参数申明为**常量引用**\n3. **释放**实例自身已有的**内存**\n4. **判断**传入参数是否和当前的**实例相同**，相同的话不进行赋值操作，直接返回实例。\n\n\n\n代码：初级版\n\n```c++\nCMyString& CMyString::operator = (const CMyString& str)\n{\n    if(this == &str)\n        return *this;\n\n    delete []m_pData;\n    m_pData = nullptr;\n\n    m_pData = new char[strlen(str.m_pData) + 1]; //给strcpy复制的字符串申请空间\n    strcpy(m_pData, str.m_pData);\n\n    return *this;\n}\n```\n\n代码：高级版\n\n```c++\nCMyString& CMyString::operator = (const CMyString& str)\n{\n    if(this != &str){\n    \tCMyString strTemp(str);   // 新建一个实例 \n        \n        char *pTemp=strTemp.m_pData;   // 新建一个临时指针保存数据\n        strTemp.m_pData = m_pData; \t\t// 交换\n        m_pData = pTemp;\n    }\n    return *this;\n}\n```\n\n初级版在使用new分配内存的时候，已经把原来的数据给清楚了（`delete []m_pData;`）,这时在新分配内存的时候，如果内存不足会导致new char抛出异常，使得m_pData 变成一个空指针，这样很容易导致程序崩溃。因为在抛出异常之后，原来的CMyString实例因为数据被delete了，所以不再保持有效的状态，违背了异常安全性的原则。 （可以先将原来的数据备份，等new 成功了，再将原来的数据delete给释放掉）\n\n代码思路：新建一个实例，新建一个临时指针从而用于数据交换。\n\n````\ntmp    tmp\n^       |\n|       \nstr<--this \n先将str的值备份到tmp中，然后将str的值更新为this的值，然后在把this的值更新为tmp的值\n两个数据的交换必然需要新建第三个变量来存放其中一个变量的值。\n````\n\n\n\n之所以需要新建一个实例是因为实例是个临时变量，所以完成操作后会自动释放掉他的数据，也就是原来的数据。\n\n指针与引用的异同\n\n常量指针与常量引用。\n\n对于引用只有两种描述：\n\n```\n// 对常量类型的引用  \nconst type &ref = type a;\n//对变量类型的引用\ntype &ref = type a;\n```\n\n对常量类型的引用  实际上既可以对常量类型引用，也可以对变量类型引用，但是不能通过引用来修改它引用的对象。\n\n对于指针的修饰有4种：\n\n````\n// 普通的指针 poi is a pointer point to a type  ，\n//指针的值（指向的地址，可以改变），被指向的变量的值也可以改变\ntype *poi;\n\n//常量指针 poi is a const pointer point to a type \n//指针的值（指向的地址）不能改变，被指向的变量的值可以改变\ntype *const poi;\n\n// poi is a pointer point to a const type\n//指针的值（指向的地址）可以改变，所以指针可以指向其他变量，\n//被指向的变量的值不可以改变，所以指针不能修改指向的变量的值，\nconst type *poi;\n\n// poi is a const pointer point to a const type\n// 指针的值（指向的地址）不能改变，所以指针不能指向其他变量，\n//被指向的变量的不可以改变，所以指针不能修改指向的变量的值\nconst type *const poi;\n````\n\n以* &作为分割符进行读取，const作为前缀修饰的对象,对象存储的值不变。\n\n对于指向const type 的指针或者引用而言，指向的（引用的）变量类型不一定是常量，但是无法通过指针或者引用来修改其指向的（引用的）变量的值。《C++primer》中所说：所谓指向常量的指针或引用，不过是指针自以为自己指向了一个常量，所以自觉地不去改变所指对象的值。\n\n## 疑惑\n\n1. 为什么申明的返回值是引用，而返回的却是指针？\n   - 引用是地址的别名,但是不分配内存空间。 `CMyString &A= *this`   这里*this是指向CMyString这个类的实例的地址，而A是CMyString的一个实例的引用，是引用就需要与这个实例的内存地址相关联，所以可以传入 *this ，也就是实例的地址。 本来 =号用于赋值的时候，左值是地址，右值是变量地址上的数据也就是变量的值，但是引用的=号的右值是变量的地址。所以可以传入地址，也就是指针。\n2. 传入的参数是个常量引用，为什么不使用常量指针： `const CMyString *str`\n   - 虽然`const CMyString *str` 和`congst CMyString &str` 都不能去修改实参的值了，但是引用不是对象，是不分配内存的啊，使用指针的话，肯定会占用内存，然后不用的时候销毁内存，所以效率会降低。而且引用是一定不会空的，所以不用考虑所指的对象是否为空。（提升效率的关键，可以不申请内存就不申请内存，因为不管是自己去释放，还是系统自动回收，分配和回收都会带来效率的下降。所以能用指针就用指针，能用引用就用引用，最坏的情况才是值拷贝。）（ **对象**是指一块能存储数据并具有某种类型的内存空间）","source":"_posts/2019-03-27-剑指offer-读书笔记——第2章.md","raw":"---\ntitle: 剑指offer 读书笔记——第2章\ndate: 2019-03-27 20:31:08\ncategories: 读书笔记\ntags:\n- coding\n- c++\ncopyright: true\n---\n\n# 剑指offer 读书笔记——第2章 \n\n感觉自己的代码能力还在很弱，所以又第二遍仔细的阅读剑指offer了\n\n第二章 面试需要的基础知识\n\n<!--more-->\n\n## 面试题1 赋值运算函数\n\n所谓赋值运算函数就是对=这个操作符进行重载，从而使等号能够直接用于两个实例之间的赋值。这个C++课上学过，不过现在忘完了，只记得学过。\n\n### 经典解法\n\n需要考虑的点\n\n1. **返回值的类型**声明为该类型的引用，在函数结束前返回实例自身的引用(***this**)。只有返回一个引用，才可以连续赋值。`object1=object2=object3`就是连续赋值。赋值采用右结合律，从最右边开始计算。不然的话当首先执行完`object2=object3` 后，`object2` 虽然自己的成员已经得到了更改，但是它不能再作为`object1=object2` 这个等号的右值，因为在前一个=的执行中，它没有获得返回值。而返回对象的话，就需要重新执行新建一个对象和销毁对象的构造与析构操作，增加不必要开销，降低赋值函数的效率。\n2. 传入的参数申明为**常量引用**\n3. **释放**实例自身已有的**内存**\n4. **判断**传入参数是否和当前的**实例相同**，相同的话不进行赋值操作，直接返回实例。\n\n\n\n代码：初级版\n\n```c++\nCMyString& CMyString::operator = (const CMyString& str)\n{\n    if(this == &str)\n        return *this;\n\n    delete []m_pData;\n    m_pData = nullptr;\n\n    m_pData = new char[strlen(str.m_pData) + 1]; //给strcpy复制的字符串申请空间\n    strcpy(m_pData, str.m_pData);\n\n    return *this;\n}\n```\n\n代码：高级版\n\n```c++\nCMyString& CMyString::operator = (const CMyString& str)\n{\n    if(this != &str){\n    \tCMyString strTemp(str);   // 新建一个实例 \n        \n        char *pTemp=strTemp.m_pData;   // 新建一个临时指针保存数据\n        strTemp.m_pData = m_pData; \t\t// 交换\n        m_pData = pTemp;\n    }\n    return *this;\n}\n```\n\n初级版在使用new分配内存的时候，已经把原来的数据给清楚了（`delete []m_pData;`）,这时在新分配内存的时候，如果内存不足会导致new char抛出异常，使得m_pData 变成一个空指针，这样很容易导致程序崩溃。因为在抛出异常之后，原来的CMyString实例因为数据被delete了，所以不再保持有效的状态，违背了异常安全性的原则。 （可以先将原来的数据备份，等new 成功了，再将原来的数据delete给释放掉）\n\n代码思路：新建一个实例，新建一个临时指针从而用于数据交换。\n\n````\ntmp    tmp\n^       |\n|       \nstr<--this \n先将str的值备份到tmp中，然后将str的值更新为this的值，然后在把this的值更新为tmp的值\n两个数据的交换必然需要新建第三个变量来存放其中一个变量的值。\n````\n\n\n\n之所以需要新建一个实例是因为实例是个临时变量，所以完成操作后会自动释放掉他的数据，也就是原来的数据。\n\n指针与引用的异同\n\n常量指针与常量引用。\n\n对于引用只有两种描述：\n\n```\n// 对常量类型的引用  \nconst type &ref = type a;\n//对变量类型的引用\ntype &ref = type a;\n```\n\n对常量类型的引用  实际上既可以对常量类型引用，也可以对变量类型引用，但是不能通过引用来修改它引用的对象。\n\n对于指针的修饰有4种：\n\n````\n// 普通的指针 poi is a pointer point to a type  ，\n//指针的值（指向的地址，可以改变），被指向的变量的值也可以改变\ntype *poi;\n\n//常量指针 poi is a const pointer point to a type \n//指针的值（指向的地址）不能改变，被指向的变量的值可以改变\ntype *const poi;\n\n// poi is a pointer point to a const type\n//指针的值（指向的地址）可以改变，所以指针可以指向其他变量，\n//被指向的变量的值不可以改变，所以指针不能修改指向的变量的值，\nconst type *poi;\n\n// poi is a const pointer point to a const type\n// 指针的值（指向的地址）不能改变，所以指针不能指向其他变量，\n//被指向的变量的不可以改变，所以指针不能修改指向的变量的值\nconst type *const poi;\n````\n\n以* &作为分割符进行读取，const作为前缀修饰的对象,对象存储的值不变。\n\n对于指向const type 的指针或者引用而言，指向的（引用的）变量类型不一定是常量，但是无法通过指针或者引用来修改其指向的（引用的）变量的值。《C++primer》中所说：所谓指向常量的指针或引用，不过是指针自以为自己指向了一个常量，所以自觉地不去改变所指对象的值。\n\n## 疑惑\n\n1. 为什么申明的返回值是引用，而返回的却是指针？\n   - 引用是地址的别名,但是不分配内存空间。 `CMyString &A= *this`   这里*this是指向CMyString这个类的实例的地址，而A是CMyString的一个实例的引用，是引用就需要与这个实例的内存地址相关联，所以可以传入 *this ，也就是实例的地址。 本来 =号用于赋值的时候，左值是地址，右值是变量地址上的数据也就是变量的值，但是引用的=号的右值是变量的地址。所以可以传入地址，也就是指针。\n2. 传入的参数是个常量引用，为什么不使用常量指针： `const CMyString *str`\n   - 虽然`const CMyString *str` 和`congst CMyString &str` 都不能去修改实参的值了，但是引用不是对象，是不分配内存的啊，使用指针的话，肯定会占用内存，然后不用的时候销毁内存，所以效率会降低。而且引用是一定不会空的，所以不用考虑所指的对象是否为空。（提升效率的关键，可以不申请内存就不申请内存，因为不管是自己去释放，还是系统自动回收，分配和回收都会带来效率的下降。所以能用指针就用指针，能用引用就用引用，最坏的情况才是值拷贝。）（ **对象**是指一块能存储数据并具有某种类型的内存空间）","slug":"2019-03-27-剑指offer-读书笔记——第2章","published":1,"updated":"2019-11-08T13:14:34.631Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6he13yb000hdstz6ep5ds97","content":"<h1 id=\"剑指offer-读书笔记——第2章\"><a href=\"#剑指offer-读书笔记——第2章\" class=\"headerlink\" title=\"剑指offer 读书笔记——第2章\"></a>剑指offer 读书笔记——第2章</h1><p>感觉自己的代码能力还在很弱，所以又第二遍仔细的阅读剑指offer了</p>\n<p>第二章 面试需要的基础知识</p>\n<a id=\"more\"></a>\n<h2 id=\"面试题1-赋值运算函数\"><a href=\"#面试题1-赋值运算函数\" class=\"headerlink\" title=\"面试题1 赋值运算函数\"></a>面试题1 赋值运算函数</h2><p>所谓赋值运算函数就是对=这个操作符进行重载，从而使等号能够直接用于两个实例之间的赋值。这个C++课上学过，不过现在忘完了，只记得学过。</p>\n<h3 id=\"经典解法\"><a href=\"#经典解法\" class=\"headerlink\" title=\"经典解法\"></a>经典解法</h3><p>需要考虑的点</p>\n<ol>\n<li><strong>返回值的类型</strong>声明为该类型的引用，在函数结束前返回实例自身的引用(<strong>*this</strong>)。只有返回一个引用，才可以连续赋值。<code>object1=object2=object3</code>就是连续赋值。赋值采用右结合律，从最右边开始计算。不然的话当首先执行完<code>object2=object3</code> 后，<code>object2</code> 虽然自己的成员已经得到了更改，但是它不能再作为<code>object1=object2</code> 这个等号的右值，因为在前一个=的执行中，它没有获得返回值。而返回对象的话，就需要重新执行新建一个对象和销毁对象的构造与析构操作，增加不必要开销，降低赋值函数的效率。</li>\n<li>传入的参数申明为<strong>常量引用</strong></li>\n<li><strong>释放</strong>实例自身已有的<strong>内存</strong></li>\n<li><strong>判断</strong>传入参数是否和当前的<strong>实例相同</strong>，相同的话不进行赋值操作，直接返回实例。</li>\n</ol>\n<p>代码：初级版</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CMyString&amp; CMyString::<span class=\"keyword\">operator</span> = (<span class=\"keyword\">const</span> CMyString&amp; str)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span> == &amp;str)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">delete</span> []m_pData;</span><br><span class=\"line\">    m_pData = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    m_pData = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"built_in\">strlen</span>(str.m_pData) + <span class=\"number\">1</span>]; <span class=\"comment\">//给strcpy复制的字符串申请空间</span></span><br><span class=\"line\">    <span class=\"built_in\">strcpy</span>(m_pData, str.m_pData);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代码：高级版</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CMyString&amp; CMyString::<span class=\"keyword\">operator</span> = (<span class=\"keyword\">const</span> CMyString&amp; str)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span> != &amp;str)&#123;</span><br><span class=\"line\">    \tCMyString strTemp(str);   <span class=\"comment\">// 新建一个实例 </span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">char</span> *pTemp=strTemp.m_pData;   <span class=\"comment\">// 新建一个临时指针保存数据</span></span><br><span class=\"line\">        strTemp.m_pData = m_pData; \t\t<span class=\"comment\">// 交换</span></span><br><span class=\"line\">        m_pData = pTemp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>初级版在使用new分配内存的时候，已经把原来的数据给清楚了（<code>delete []m_pData;</code>）,这时在新分配内存的时候，如果内存不足会导致new char抛出异常，使得m_pData 变成一个空指针，这样很容易导致程序崩溃。因为在抛出异常之后，原来的CMyString实例因为数据被delete了，所以不再保持有效的状态，违背了异常安全性的原则。 （可以先将原来的数据备份，等new 成功了，再将原来的数据delete给释放掉）</p>\n<p>代码思路：新建一个实例，新建一个临时指针从而用于数据交换。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tmp    tmp</span><br><span class=\"line\">^       |</span><br><span class=\"line\">|       </span><br><span class=\"line\">str&lt;--this </span><br><span class=\"line\">先将str的值备份到tmp中，然后将str的值更新为this的值，然后在把this的值更新为tmp的值</span><br><span class=\"line\">两个数据的交换必然需要新建第三个变量来存放其中一个变量的值。</span><br></pre></td></tr></table></figure>\n<p>之所以需要新建一个实例是因为实例是个临时变量，所以完成操作后会自动释放掉他的数据，也就是原来的数据。</p>\n<p>指针与引用的异同</p>\n<p>常量指针与常量引用。</p>\n<p>对于引用只有两种描述：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 对常量类型的引用  </span><br><span class=\"line\">const type &amp;ref = type a;</span><br><span class=\"line\">//对变量类型的引用</span><br><span class=\"line\">type &amp;ref = type a;</span><br></pre></td></tr></table></figure>\n<p>对常量类型的引用  实际上既可以对常量类型引用，也可以对变量类型引用，但是不能通过引用来修改它引用的对象。</p>\n<p>对于指针的修饰有4种：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 普通的指针 poi is a pointer point to a type  ，</span><br><span class=\"line\">//指针的值（指向的地址，可以改变），被指向的变量的值也可以改变</span><br><span class=\"line\">type *poi;</span><br><span class=\"line\"></span><br><span class=\"line\">//常量指针 poi is a const pointer point to a type </span><br><span class=\"line\">//指针的值（指向的地址）不能改变，被指向的变量的值可以改变</span><br><span class=\"line\">type *const poi;</span><br><span class=\"line\"></span><br><span class=\"line\">// poi is a pointer point to a const type</span><br><span class=\"line\">//指针的值（指向的地址）可以改变，所以指针可以指向其他变量，</span><br><span class=\"line\">//被指向的变量的值不可以改变，所以指针不能修改指向的变量的值，</span><br><span class=\"line\">const type *poi;</span><br><span class=\"line\"></span><br><span class=\"line\">// poi is a const pointer point to a const type</span><br><span class=\"line\">// 指针的值（指向的地址）不能改变，所以指针不能指向其他变量，</span><br><span class=\"line\">//被指向的变量的不可以改变，所以指针不能修改指向的变量的值</span><br><span class=\"line\">const type *const poi;</span><br></pre></td></tr></table></figure>\n<p>以* &amp;作为分割符进行读取，const作为前缀修饰的对象,对象存储的值不变。</p>\n<p>对于指向const type 的指针或者引用而言，指向的（引用的）变量类型不一定是常量，但是无法通过指针或者引用来修改其指向的（引用的）变量的值。《C++primer》中所说：所谓指向常量的指针或引用，不过是指针自以为自己指向了一个常量，所以自觉地不去改变所指对象的值。</p>\n<h2 id=\"疑惑\"><a href=\"#疑惑\" class=\"headerlink\" title=\"疑惑\"></a>疑惑</h2><ol>\n<li>为什么申明的返回值是引用，而返回的却是指针？<ul>\n<li>引用是地址的别名,但是不分配内存空间。 <code>CMyString &amp;A= *this</code>   这里<em>this是指向CMyString这个类的实例的地址，而A是CMyString的一个实例的引用，是引用就需要与这个实例的内存地址相关联，所以可以传入 </em>this ，也就是实例的地址。 本来 =号用于赋值的时候，左值是地址，右值是变量地址上的数据也就是变量的值，但是引用的=号的右值是变量的地址。所以可以传入地址，也就是指针。</li>\n</ul>\n</li>\n<li>传入的参数是个常量引用，为什么不使用常量指针： <code>const CMyString *str</code><ul>\n<li>虽然<code>const CMyString *str</code> 和<code>congst CMyString &amp;str</code> 都不能去修改实参的值了，但是引用不是对象，是不分配内存的啊，使用指针的话，肯定会占用内存，然后不用的时候销毁内存，所以效率会降低。而且引用是一定不会空的，所以不用考虑所指的对象是否为空。（提升效率的关键，可以不申请内存就不申请内存，因为不管是自己去释放，还是系统自动回收，分配和回收都会带来效率的下降。所以能用指针就用指针，能用引用就用引用，最坏的情况才是值拷贝。）（ <strong>对象</strong>是指一块能存储数据并具有某种类型的内存空间）</li>\n</ul>\n</li>\n</ol>\n","site":{"data":{}},"length":2612,"excerpt":"<h1 id=\"剑指offer-读书笔记——第2章\"><a href=\"#剑指offer-读书笔记——第2章\" class=\"headerlink\" title=\"剑指offer 读书笔记——第2章\"></a>剑指offer 读书笔记——第2章</h1><p>感觉自己的代码能力还在很弱，所以又第二遍仔细的阅读剑指offer了</p>\n<p>第二章 面试需要的基础知识</p>","more":"<h2 id=\"面试题1-赋值运算函数\"><a href=\"#面试题1-赋值运算函数\" class=\"headerlink\" title=\"面试题1 赋值运算函数\"></a>面试题1 赋值运算函数</h2><p>所谓赋值运算函数就是对=这个操作符进行重载，从而使等号能够直接用于两个实例之间的赋值。这个C++课上学过，不过现在忘完了，只记得学过。</p>\n<h3 id=\"经典解法\"><a href=\"#经典解法\" class=\"headerlink\" title=\"经典解法\"></a>经典解法</h3><p>需要考虑的点</p>\n<ol>\n<li><strong>返回值的类型</strong>声明为该类型的引用，在函数结束前返回实例自身的引用(<strong>*this</strong>)。只有返回一个引用，才可以连续赋值。<code>object1=object2=object3</code>就是连续赋值。赋值采用右结合律，从最右边开始计算。不然的话当首先执行完<code>object2=object3</code> 后，<code>object2</code> 虽然自己的成员已经得到了更改，但是它不能再作为<code>object1=object2</code> 这个等号的右值，因为在前一个=的执行中，它没有获得返回值。而返回对象的话，就需要重新执行新建一个对象和销毁对象的构造与析构操作，增加不必要开销，降低赋值函数的效率。</li>\n<li>传入的参数申明为<strong>常量引用</strong></li>\n<li><strong>释放</strong>实例自身已有的<strong>内存</strong></li>\n<li><strong>判断</strong>传入参数是否和当前的<strong>实例相同</strong>，相同的话不进行赋值操作，直接返回实例。</li>\n</ol>\n<p>代码：初级版</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CMyString&amp; CMyString::<span class=\"keyword\">operator</span> = (<span class=\"keyword\">const</span> CMyString&amp; str)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span> == &amp;str)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">delete</span> []m_pData;</span><br><span class=\"line\">    m_pData = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    m_pData = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"built_in\">strlen</span>(str.m_pData) + <span class=\"number\">1</span>]; <span class=\"comment\">//给strcpy复制的字符串申请空间</span></span><br><span class=\"line\">    <span class=\"built_in\">strcpy</span>(m_pData, str.m_pData);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代码：高级版</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CMyString&amp; CMyString::<span class=\"keyword\">operator</span> = (<span class=\"keyword\">const</span> CMyString&amp; str)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span> != &amp;str)&#123;</span><br><span class=\"line\">    \tCMyString strTemp(str);   <span class=\"comment\">// 新建一个实例 </span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">char</span> *pTemp=strTemp.m_pData;   <span class=\"comment\">// 新建一个临时指针保存数据</span></span><br><span class=\"line\">        strTemp.m_pData = m_pData; \t\t<span class=\"comment\">// 交换</span></span><br><span class=\"line\">        m_pData = pTemp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>初级版在使用new分配内存的时候，已经把原来的数据给清楚了（<code>delete []m_pData;</code>）,这时在新分配内存的时候，如果内存不足会导致new char抛出异常，使得m_pData 变成一个空指针，这样很容易导致程序崩溃。因为在抛出异常之后，原来的CMyString实例因为数据被delete了，所以不再保持有效的状态，违背了异常安全性的原则。 （可以先将原来的数据备份，等new 成功了，再将原来的数据delete给释放掉）</p>\n<p>代码思路：新建一个实例，新建一个临时指针从而用于数据交换。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tmp    tmp</span><br><span class=\"line\">^       |</span><br><span class=\"line\">|       </span><br><span class=\"line\">str&lt;--this </span><br><span class=\"line\">先将str的值备份到tmp中，然后将str的值更新为this的值，然后在把this的值更新为tmp的值</span><br><span class=\"line\">两个数据的交换必然需要新建第三个变量来存放其中一个变量的值。</span><br></pre></td></tr></table></figure>\n<p>之所以需要新建一个实例是因为实例是个临时变量，所以完成操作后会自动释放掉他的数据，也就是原来的数据。</p>\n<p>指针与引用的异同</p>\n<p>常量指针与常量引用。</p>\n<p>对于引用只有两种描述：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 对常量类型的引用  </span><br><span class=\"line\">const type &amp;ref = type a;</span><br><span class=\"line\">//对变量类型的引用</span><br><span class=\"line\">type &amp;ref = type a;</span><br></pre></td></tr></table></figure>\n<p>对常量类型的引用  实际上既可以对常量类型引用，也可以对变量类型引用，但是不能通过引用来修改它引用的对象。</p>\n<p>对于指针的修饰有4种：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 普通的指针 poi is a pointer point to a type  ，</span><br><span class=\"line\">//指针的值（指向的地址，可以改变），被指向的变量的值也可以改变</span><br><span class=\"line\">type *poi;</span><br><span class=\"line\"></span><br><span class=\"line\">//常量指针 poi is a const pointer point to a type </span><br><span class=\"line\">//指针的值（指向的地址）不能改变，被指向的变量的值可以改变</span><br><span class=\"line\">type *const poi;</span><br><span class=\"line\"></span><br><span class=\"line\">// poi is a pointer point to a const type</span><br><span class=\"line\">//指针的值（指向的地址）可以改变，所以指针可以指向其他变量，</span><br><span class=\"line\">//被指向的变量的值不可以改变，所以指针不能修改指向的变量的值，</span><br><span class=\"line\">const type *poi;</span><br><span class=\"line\"></span><br><span class=\"line\">// poi is a const pointer point to a const type</span><br><span class=\"line\">// 指针的值（指向的地址）不能改变，所以指针不能指向其他变量，</span><br><span class=\"line\">//被指向的变量的不可以改变，所以指针不能修改指向的变量的值</span><br><span class=\"line\">const type *const poi;</span><br></pre></td></tr></table></figure>\n<p>以* &amp;作为分割符进行读取，const作为前缀修饰的对象,对象存储的值不变。</p>\n<p>对于指向const type 的指针或者引用而言，指向的（引用的）变量类型不一定是常量，但是无法通过指针或者引用来修改其指向的（引用的）变量的值。《C++primer》中所说：所谓指向常量的指针或引用，不过是指针自以为自己指向了一个常量，所以自觉地不去改变所指对象的值。</p>\n<h2 id=\"疑惑\"><a href=\"#疑惑\" class=\"headerlink\" title=\"疑惑\"></a>疑惑</h2><ol>\n<li>为什么申明的返回值是引用，而返回的却是指针？<ul>\n<li>引用是地址的别名,但是不分配内存空间。 <code>CMyString &amp;A= *this</code>   这里<em>this是指向CMyString这个类的实例的地址，而A是CMyString的一个实例的引用，是引用就需要与这个实例的内存地址相关联，所以可以传入 </em>this ，也就是实例的地址。 本来 =号用于赋值的时候，左值是地址，右值是变量地址上的数据也就是变量的值，但是引用的=号的右值是变量的地址。所以可以传入地址，也就是指针。</li>\n</ul>\n</li>\n<li>传入的参数是个常量引用，为什么不使用常量指针： <code>const CMyString *str</code><ul>\n<li>虽然<code>const CMyString *str</code> 和<code>congst CMyString &amp;str</code> 都不能去修改实参的值了，但是引用不是对象，是不分配内存的啊，使用指针的话，肯定会占用内存，然后不用的时候销毁内存，所以效率会降低。而且引用是一定不会空的，所以不用考虑所指的对象是否为空。（提升效率的关键，可以不申请内存就不申请内存，因为不管是自己去释放，还是系统自动回收，分配和回收都会带来效率的下降。所以能用指针就用指针，能用引用就用引用，最坏的情况才是值拷贝。）（ <strong>对象</strong>是指一块能存储数据并具有某种类型的内存空间）</li>\n</ul>\n</li>\n</ol>"},{"title":"青蛙跳台阶问题","date":"2019-04-17T14:02:40.000Z","copyright":true,"mathjax":true,"_content":"\n# 青蛙跳台阶问题\n\n一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 公式不能在hexo上显示出来\n\n<!--more-->\n\n[题目来源](<https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&tqId=11161&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking>)\n\n解题思路：函数思想，把n阶台阶的跳法看成是关于n的函数 f(n)。当n>2的时候：\n\n假设第一次跳一个台阶，那么还剩n-1个台阶需要跳，也就是还有f(n-1)的跳法。\n\n假设第一次跳两个台阶，那么还剩n-2个台阶需要跳，也就是还有f(n-2)的跳法\n\n所以n阶的跳法总共有f(n-1) + f(n-2)  种，也就是 f(n) = f(n-1) +f(n-2)。\n\n所以函数就是 ：\n$$\nf(n)=\n\\begin{cases}\n0& \\text{n=0}\\\\\n1& \\text{n=1}\\\\\n2& \\text {n=2}\\\\\nf(n-1)+f(n-2)& \\text {n>2}\n\\end{cases}\n$$\n也就是一个斐波那契数列，代码也就比较简单了。参考斐波那契数列的解法:\n\n<https://github.com/BraveY/Coding/blob/master/%E5%89%91%E6%8C%87offer/Fibonacci.cc>\n\n代码为：\n\n```c++\n\nclass Solution {\npublic:\n    int jumpFloor(int number) {\n        int result[3] = {0,1,2};\n        if(number<3) return result[number];\n        int fib_one = result[1];\n        int fib_two = result[2];\n        int fib;\n        for(int i=3; i<=number; i++){\n            fib = fib_one + fib_two;\n            fib_one = fib_two;\n            fib_two = fib;\n        }\n        return fib;\n    }\n};\n```\n\n## 变种题目：\n\n一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。\n\n思路也是一样的：第一次跳1级台阶，则有f(n-1)的解法，第一次跳2级台阶，则有f(n-2)的解法，第一次跳n-1级台阶，则有f(2)的解法， 第一次跳n级台阶则还有一种解法。用f(0)表示第一次跳n级的情况,f(0)=1。\n\n归纳成函数就是：\n$$\nf(n)=\n\\begin{cases}\n1& \\text{n=0}\\\\\n1& \\text{n=1}\\\\\nf(n-1)+f(n-2)...+f(1)+f(0)& \\text {n>1}\n\\end{cases}\n$$\n所以代码为：\n\n```c++\nclass Solution {\npublic:\n    int jumpFloorII(int number) {\n        vector<int> result;\n        result.push_back(1); // f(0) =1 ;\n        for(int i=1; i<=number; i++){\n            int sum = 0;\n            for(int j=0; j<i; j++){ // f(n)=f(n-1)+f(n-2)+...f(1)+f(0)\n                sum += result[j];\n            }\n            result.push_back(sum);\n        }\n        return result[number];\n    }\n};\n```\n\n另一个斐波那契数列数列问题：\n\n## 矩形覆盖\n\n<https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&tqId=11163&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking>\n\n我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？\n\n最开始的时候没有想清楚，以为不是斐波那契数列。\n\n思路：\n\n同样的方法为n的函数：f(n); 对于n=1的情况，只能竖着放：所以f(1)=1; n=2的时候，竖着放之后就变成了f(1)种方法，横着放的时候只有一种，总共有两种，所以f(2)=2;\n\n所以函数为：\n$$\nf(n)=\n\\begin{cases}\n0& \\text{n=0}\\\\\n1& \\text{n=1}\\\\\n2& \\text {n=2}\\\\\nf(n-1)+f(n-2)& \\text {n>2}\n\\end{cases}\n$$\n因此代码也是同第一个青蛙跳台阶一样的。\n\n代码：\n\n```c++\n//https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&tqId=11163&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking\nclass Solution {\npublic:\n    int rectCover(int number) {\n        int result[3] = {0,1,2};\n        if(number<3) return result[number];\n        int fib_one = result[1];\n        int fib_two = result[2];\n        int fib;\n        for(int i=3; i<=number; i++){\n            fib = fib_one + fib_two;\n            fib_one = fib_two;\n            fib_two = fib;\n        }\n       return fib;\n    }\n};\n```\n\n## 总结\n\n总结一下，对于斐波那契数列问题思路都是一样：\n\n- 输出是输入的函数， f(n)\n- 考虑第一次是如何选择的，就可以把问题给切分出来了。","source":"_posts/2019-04-17-青蛙跳台阶问题.md","raw":"---\ntitle: 青蛙跳台阶问题\ndate: 2019-04-17 22:02:40\ncategories: 题解\ntags:\n- 牛客\n- 斐波拉契数列\n- 剑指offer\ncopyright: true\nmathjax: true \t\n---\n\n# 青蛙跳台阶问题\n\n一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 公式不能在hexo上显示出来\n\n<!--more-->\n\n[题目来源](<https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&tqId=11161&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking>)\n\n解题思路：函数思想，把n阶台阶的跳法看成是关于n的函数 f(n)。当n>2的时候：\n\n假设第一次跳一个台阶，那么还剩n-1个台阶需要跳，也就是还有f(n-1)的跳法。\n\n假设第一次跳两个台阶，那么还剩n-2个台阶需要跳，也就是还有f(n-2)的跳法\n\n所以n阶的跳法总共有f(n-1) + f(n-2)  种，也就是 f(n) = f(n-1) +f(n-2)。\n\n所以函数就是 ：\n$$\nf(n)=\n\\begin{cases}\n0& \\text{n=0}\\\\\n1& \\text{n=1}\\\\\n2& \\text {n=2}\\\\\nf(n-1)+f(n-2)& \\text {n>2}\n\\end{cases}\n$$\n也就是一个斐波那契数列，代码也就比较简单了。参考斐波那契数列的解法:\n\n<https://github.com/BraveY/Coding/blob/master/%E5%89%91%E6%8C%87offer/Fibonacci.cc>\n\n代码为：\n\n```c++\n\nclass Solution {\npublic:\n    int jumpFloor(int number) {\n        int result[3] = {0,1,2};\n        if(number<3) return result[number];\n        int fib_one = result[1];\n        int fib_two = result[2];\n        int fib;\n        for(int i=3; i<=number; i++){\n            fib = fib_one + fib_two;\n            fib_one = fib_two;\n            fib_two = fib;\n        }\n        return fib;\n    }\n};\n```\n\n## 变种题目：\n\n一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。\n\n思路也是一样的：第一次跳1级台阶，则有f(n-1)的解法，第一次跳2级台阶，则有f(n-2)的解法，第一次跳n-1级台阶，则有f(2)的解法， 第一次跳n级台阶则还有一种解法。用f(0)表示第一次跳n级的情况,f(0)=1。\n\n归纳成函数就是：\n$$\nf(n)=\n\\begin{cases}\n1& \\text{n=0}\\\\\n1& \\text{n=1}\\\\\nf(n-1)+f(n-2)...+f(1)+f(0)& \\text {n>1}\n\\end{cases}\n$$\n所以代码为：\n\n```c++\nclass Solution {\npublic:\n    int jumpFloorII(int number) {\n        vector<int> result;\n        result.push_back(1); // f(0) =1 ;\n        for(int i=1; i<=number; i++){\n            int sum = 0;\n            for(int j=0; j<i; j++){ // f(n)=f(n-1)+f(n-2)+...f(1)+f(0)\n                sum += result[j];\n            }\n            result.push_back(sum);\n        }\n        return result[number];\n    }\n};\n```\n\n另一个斐波那契数列数列问题：\n\n## 矩形覆盖\n\n<https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&tqId=11163&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking>\n\n我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？\n\n最开始的时候没有想清楚，以为不是斐波那契数列。\n\n思路：\n\n同样的方法为n的函数：f(n); 对于n=1的情况，只能竖着放：所以f(1)=1; n=2的时候，竖着放之后就变成了f(1)种方法，横着放的时候只有一种，总共有两种，所以f(2)=2;\n\n所以函数为：\n$$\nf(n)=\n\\begin{cases}\n0& \\text{n=0}\\\\\n1& \\text{n=1}\\\\\n2& \\text {n=2}\\\\\nf(n-1)+f(n-2)& \\text {n>2}\n\\end{cases}\n$$\n因此代码也是同第一个青蛙跳台阶一样的。\n\n代码：\n\n```c++\n//https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&tqId=11163&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking\nclass Solution {\npublic:\n    int rectCover(int number) {\n        int result[3] = {0,1,2};\n        if(number<3) return result[number];\n        int fib_one = result[1];\n        int fib_two = result[2];\n        int fib;\n        for(int i=3; i<=number; i++){\n            fib = fib_one + fib_two;\n            fib_one = fib_two;\n            fib_two = fib;\n        }\n       return fib;\n    }\n};\n```\n\n## 总结\n\n总结一下，对于斐波那契数列问题思路都是一样：\n\n- 输出是输入的函数， f(n)\n- 考虑第一次是如何选择的，就可以把问题给切分出来了。","slug":"2019-04-17-青蛙跳台阶问题","published":1,"updated":"2019-11-28T03:59:19.907Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6he13yd000kdstzitbkvm3z","content":"<h1 id=\"青蛙跳台阶问题\"><a href=\"#青蛙跳台阶问题\" class=\"headerlink\" title=\"青蛙跳台阶问题\"></a>青蛙跳台阶问题</h1><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 公式不能在hexo上显示出来</p>\n<a id=\"more\"></a>\n<p><a href=\"https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&amp;tqId=11161&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking\" target=\"_blank\" rel=\"noopener\">题目来源</a></p>\n<p>解题思路：函数思想，把n阶台阶的跳法看成是关于n的函数 f(n)。当n&gt;2的时候：</p>\n<p>假设第一次跳一个台阶，那么还剩n-1个台阶需要跳，也就是还有f(n-1)的跳法。</p>\n<p>假设第一次跳两个台阶，那么还剩n-2个台阶需要跳，也就是还有f(n-2)的跳法</p>\n<p>所以n阶的跳法总共有f(n-1) + f(n-2)  种，也就是 f(n) = f(n-1) +f(n-2)。</p>\n<p>所以函数就是 ：</p>\n<script type=\"math/tex; mode=display\">\nf(n)=\n\\begin{cases}\n0& \\text{n=0}\\\\\n1& \\text{n=1}\\\\\n2& \\text {n=2}\\\\\nf(n-1)+f(n-2)& \\text {n>2}\n\\end{cases}</script><p>也就是一个斐波那契数列，代码也就比较简单了。参考斐波那契数列的解法:</p>\n<p><a href=\"https://github.com/BraveY/Coding/blob/master/%E5%89%91%E6%8C%87offer/Fibonacci.cc\" target=\"_blank\" rel=\"noopener\">https://github.com/BraveY/Coding/blob/master/%E5%89%91%E6%8C%87offer/Fibonacci.cc</a></p>\n<p>代码为：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">jumpFloor</span><span class=\"params\">(<span class=\"keyword\">int</span> number)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result[<span class=\"number\">3</span>] = &#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(number&lt;<span class=\"number\">3</span>) <span class=\"keyword\">return</span> result[number];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> fib_one = result[<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> fib_two = result[<span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> fib;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">3</span>; i&lt;=number; i++)&#123;</span><br><span class=\"line\">            fib = fib_one + fib_two;</span><br><span class=\"line\">            fib_one = fib_two;</span><br><span class=\"line\">            fib_two = fib;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fib;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"变种题目：\"><a href=\"#变种题目：\" class=\"headerlink\" title=\"变种题目：\"></a>变种题目：</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>\n<p>思路也是一样的：第一次跳1级台阶，则有f(n-1)的解法，第一次跳2级台阶，则有f(n-2)的解法，第一次跳n-1级台阶，则有f(2)的解法， 第一次跳n级台阶则还有一种解法。用f(0)表示第一次跳n级的情况,f(0)=1。</p>\n<p>归纳成函数就是：</p>\n<script type=\"math/tex; mode=display\">\nf(n)=\n\\begin{cases}\n1& \\text{n=0}\\\\\n1& \\text{n=1}\\\\\nf(n-1)+f(n-2)...+f(1)+f(0)& \\text {n>1}\n\\end{cases}</script><p>所以代码为：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">jumpFloorII</span><span class=\"params\">(<span class=\"keyword\">int</span> number)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; result;</span><br><span class=\"line\">        result.push_back(<span class=\"number\">1</span>); <span class=\"comment\">// f(0) =1 ;</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;=number; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>; j&lt;i; j++)&#123; <span class=\"comment\">// f(n)=f(n-1)+f(n-2)+...f(1)+f(0)</span></span><br><span class=\"line\">                sum += result[j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            result.push_back(sum);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result[number];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>另一个斐波那契数列数列问题：</p>\n<h2 id=\"矩形覆盖\"><a href=\"#矩形覆盖\" class=\"headerlink\" title=\"矩形覆盖\"></a>矩形覆盖</h2><p><a href=\"https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&amp;tqId=11163&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking\" target=\"_blank\" rel=\"noopener\">https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&amp;tqId=11163&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p>\n<p>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p>\n<p>最开始的时候没有想清楚，以为不是斐波那契数列。</p>\n<p>思路：</p>\n<p>同样的方法为n的函数：f(n); 对于n=1的情况，只能竖着放：所以f(1)=1; n=2的时候，竖着放之后就变成了f(1)种方法，横着放的时候只有一种，总共有两种，所以f(2)=2;</p>\n<p>所以函数为：</p>\n<script type=\"math/tex; mode=display\">\nf(n)=\n\\begin{cases}\n0& \\text{n=0}\\\\\n1& \\text{n=1}\\\\\n2& \\text {n=2}\\\\\nf(n-1)+f(n-2)& \\text {n>2}\n\\end{cases}</script><p>因此代码也是同第一个青蛙跳台阶一样的。</p>\n<p>代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&amp;tqId=11163&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">rectCover</span><span class=\"params\">(<span class=\"keyword\">int</span> number)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result[<span class=\"number\">3</span>] = &#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(number&lt;<span class=\"number\">3</span>) <span class=\"keyword\">return</span> result[number];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> fib_one = result[<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> fib_two = result[<span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> fib;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">3</span>; i&lt;=number; i++)&#123;</span><br><span class=\"line\">            fib = fib_one + fib_two;</span><br><span class=\"line\">            fib_one = fib_two;</span><br><span class=\"line\">            fib_two = fib;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> fib;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>总结一下，对于斐波那契数列问题思路都是一样：</p>\n<ul>\n<li>输出是输入的函数， f(n)</li>\n<li>考虑第一次是如何选择的，就可以把问题给切分出来了。</li>\n</ul>\n","site":{"data":{}},"length":2416,"excerpt":"<h1 id=\"青蛙跳台阶问题\"><a href=\"#青蛙跳台阶问题\" class=\"headerlink\" title=\"青蛙跳台阶问题\"></a>青蛙跳台阶问题</h1><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 公式不能在hexo上显示出来</p>","more":"<p><a href=\"https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&amp;tqId=11161&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking\" target=\"_blank\" rel=\"noopener\">题目来源</a></p>\n<p>解题思路：函数思想，把n阶台阶的跳法看成是关于n的函数 f(n)。当n&gt;2的时候：</p>\n<p>假设第一次跳一个台阶，那么还剩n-1个台阶需要跳，也就是还有f(n-1)的跳法。</p>\n<p>假设第一次跳两个台阶，那么还剩n-2个台阶需要跳，也就是还有f(n-2)的跳法</p>\n<p>所以n阶的跳法总共有f(n-1) + f(n-2)  种，也就是 f(n) = f(n-1) +f(n-2)。</p>\n<p>所以函数就是 ：</p>\n<script type=\"math/tex; mode=display\">\nf(n)=\n\\begin{cases}\n0& \\text{n=0}\\\\\n1& \\text{n=1}\\\\\n2& \\text {n=2}\\\\\nf(n-1)+f(n-2)& \\text {n>2}\n\\end{cases}</script><p>也就是一个斐波那契数列，代码也就比较简单了。参考斐波那契数列的解法:</p>\n<p><a href=\"https://github.com/BraveY/Coding/blob/master/%E5%89%91%E6%8C%87offer/Fibonacci.cc\" target=\"_blank\" rel=\"noopener\">https://github.com/BraveY/Coding/blob/master/%E5%89%91%E6%8C%87offer/Fibonacci.cc</a></p>\n<p>代码为：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">jumpFloor</span><span class=\"params\">(<span class=\"keyword\">int</span> number)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result[<span class=\"number\">3</span>] = &#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(number&lt;<span class=\"number\">3</span>) <span class=\"keyword\">return</span> result[number];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> fib_one = result[<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> fib_two = result[<span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> fib;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">3</span>; i&lt;=number; i++)&#123;</span><br><span class=\"line\">            fib = fib_one + fib_two;</span><br><span class=\"line\">            fib_one = fib_two;</span><br><span class=\"line\">            fib_two = fib;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fib;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"变种题目：\"><a href=\"#变种题目：\" class=\"headerlink\" title=\"变种题目：\"></a>变种题目：</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>\n<p>思路也是一样的：第一次跳1级台阶，则有f(n-1)的解法，第一次跳2级台阶，则有f(n-2)的解法，第一次跳n-1级台阶，则有f(2)的解法， 第一次跳n级台阶则还有一种解法。用f(0)表示第一次跳n级的情况,f(0)=1。</p>\n<p>归纳成函数就是：</p>\n<script type=\"math/tex; mode=display\">\nf(n)=\n\\begin{cases}\n1& \\text{n=0}\\\\\n1& \\text{n=1}\\\\\nf(n-1)+f(n-2)...+f(1)+f(0)& \\text {n>1}\n\\end{cases}</script><p>所以代码为：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">jumpFloorII</span><span class=\"params\">(<span class=\"keyword\">int</span> number)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; result;</span><br><span class=\"line\">        result.push_back(<span class=\"number\">1</span>); <span class=\"comment\">// f(0) =1 ;</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;=number; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>; j&lt;i; j++)&#123; <span class=\"comment\">// f(n)=f(n-1)+f(n-2)+...f(1)+f(0)</span></span><br><span class=\"line\">                sum += result[j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            result.push_back(sum);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result[number];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>另一个斐波那契数列数列问题：</p>\n<h2 id=\"矩形覆盖\"><a href=\"#矩形覆盖\" class=\"headerlink\" title=\"矩形覆盖\"></a>矩形覆盖</h2><p><a href=\"https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&amp;tqId=11163&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking\" target=\"_blank\" rel=\"noopener\">https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&amp;tqId=11163&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p>\n<p>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p>\n<p>最开始的时候没有想清楚，以为不是斐波那契数列。</p>\n<p>思路：</p>\n<p>同样的方法为n的函数：f(n); 对于n=1的情况，只能竖着放：所以f(1)=1; n=2的时候，竖着放之后就变成了f(1)种方法，横着放的时候只有一种，总共有两种，所以f(2)=2;</p>\n<p>所以函数为：</p>\n<script type=\"math/tex; mode=display\">\nf(n)=\n\\begin{cases}\n0& \\text{n=0}\\\\\n1& \\text{n=1}\\\\\n2& \\text {n=2}\\\\\nf(n-1)+f(n-2)& \\text {n>2}\n\\end{cases}</script><p>因此代码也是同第一个青蛙跳台阶一样的。</p>\n<p>代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&amp;tqId=11163&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">rectCover</span><span class=\"params\">(<span class=\"keyword\">int</span> number)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result[<span class=\"number\">3</span>] = &#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(number&lt;<span class=\"number\">3</span>) <span class=\"keyword\">return</span> result[number];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> fib_one = result[<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> fib_two = result[<span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> fib;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">3</span>; i&lt;=number; i++)&#123;</span><br><span class=\"line\">            fib = fib_one + fib_two;</span><br><span class=\"line\">            fib_one = fib_two;</span><br><span class=\"line\">            fib_two = fib;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> fib;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>总结一下，对于斐波那契数列问题思路都是一样：</p>\n<ul>\n<li>输出是输入的函数， f(n)</li>\n<li>考虑第一次是如何选择的，就可以把问题给切分出来了。</li>\n</ul>"},{"title":"Linux shell脚本计算运行时间","date":"2019-04-10T15:27:45.000Z","copyright":true,"_content":"\n# Linux shell脚本计算运行时间\n\n这个功能经常用但是，总是现用现查，很麻烦。\n\n<!--more-->\n\n代码\n\n```bash\n# filename: msec_diff.sh\n\nfunction timediff() {\n\n# time format:date +\"%s.%N\", such as 1502758855.907197692\n    start_time=$1\n    end_time=$2\n    \n    start_s=${start_time%.*}\n    start_nanos=${start_time#*.}\n    end_s=${end_time%.*}\n    end_nanos=${end_time#*.}\n    \n    # end_nanos > start_nanos? \n    # Another way, the time part may start with 0, which means\n    # it will be regarded as oct format, use \"10#\" to ensure\n    # calculateing with decimal\n    if [ \"$end_nanos\" -lt \"$start_nanos\" ];then\n        end_s=$(( 10#$end_s - 1 ))\n        end_nanos=$(( 10#$end_nanos + 10**9 ))\n    fi\n    \n# get timediff\n    time=$(( 10#$end_s - 10#$start_s )).`printf \"%03d\\n\" $(( (10#$end_nanos - 10#$start_nanos)/10**6 ))`\n    \n    echo $time\n}\n\n#start=$(date +\"%s.%N\")\n# Now exec some command\n#end=$(date +\"%s.%N\")\n# here give the values\nstart=1502758855.907197692\nend=1502758865.066894173\n\ntimediff $start $end\n```\n\n## 参考\n\n<https://www.cnblogs.com/f-ck-need-u/p/7426987.html>","source":"_posts/2019-04-10-Linux-shell脚本计算运行时间.md","raw":"---\ntitle: Linux shell脚本计算运行时间\ndate: 2019-04-10 23:27:45\ncategories: Linux\ntags: shell\ncopyright: true\n---\n\n# Linux shell脚本计算运行时间\n\n这个功能经常用但是，总是现用现查，很麻烦。\n\n<!--more-->\n\n代码\n\n```bash\n# filename: msec_diff.sh\n\nfunction timediff() {\n\n# time format:date +\"%s.%N\", such as 1502758855.907197692\n    start_time=$1\n    end_time=$2\n    \n    start_s=${start_time%.*}\n    start_nanos=${start_time#*.}\n    end_s=${end_time%.*}\n    end_nanos=${end_time#*.}\n    \n    # end_nanos > start_nanos? \n    # Another way, the time part may start with 0, which means\n    # it will be regarded as oct format, use \"10#\" to ensure\n    # calculateing with decimal\n    if [ \"$end_nanos\" -lt \"$start_nanos\" ];then\n        end_s=$(( 10#$end_s - 1 ))\n        end_nanos=$(( 10#$end_nanos + 10**9 ))\n    fi\n    \n# get timediff\n    time=$(( 10#$end_s - 10#$start_s )).`printf \"%03d\\n\" $(( (10#$end_nanos - 10#$start_nanos)/10**6 ))`\n    \n    echo $time\n}\n\n#start=$(date +\"%s.%N\")\n# Now exec some command\n#end=$(date +\"%s.%N\")\n# here give the values\nstart=1502758855.907197692\nend=1502758865.066894173\n\ntimediff $start $end\n```\n\n## 参考\n\n<https://www.cnblogs.com/f-ck-need-u/p/7426987.html>","slug":"2019-04-10-Linux-shell脚本计算运行时间","published":1,"updated":"2019-11-08T13:14:02.619Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6he13yg000pdstzz831w9xd","content":"<h1 id=\"Linux-shell脚本计算运行时间\"><a href=\"#Linux-shell脚本计算运行时间\" class=\"headerlink\" title=\"Linux shell脚本计算运行时间\"></a>Linux shell脚本计算运行时间</h1><p>这个功能经常用但是，总是现用现查，很麻烦。</p>\n<a id=\"more\"></a>\n<p>代码</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># filename: msec_diff.sh</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">timediff</span></span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># time format:date +\"%s.%N\", such as 1502758855.907197692</span></span><br><span class=\"line\">    start_time=<span class=\"variable\">$1</span></span><br><span class=\"line\">    end_time=<span class=\"variable\">$2</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    start_s=<span class=\"variable\">$&#123;start_time%.*&#125;</span></span><br><span class=\"line\">    start_nanos=<span class=\"variable\">$&#123;start_time#*.&#125;</span></span><br><span class=\"line\">    end_s=<span class=\"variable\">$&#123;end_time%.*&#125;</span></span><br><span class=\"line\">    end_nanos=<span class=\"variable\">$&#123;end_time#*.&#125;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># end_nanos &gt; start_nanos? </span></span><br><span class=\"line\">    <span class=\"comment\"># Another way, the time part may start with 0, which means</span></span><br><span class=\"line\">    <span class=\"comment\"># it will be regarded as oct format, use \"10#\" to ensure</span></span><br><span class=\"line\">    <span class=\"comment\"># calculateing with decimal</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> [ <span class=\"string\">\"<span class=\"variable\">$end_nanos</span>\"</span> -lt <span class=\"string\">\"<span class=\"variable\">$start_nanos</span>\"</span> ];<span class=\"keyword\">then</span></span><br><span class=\"line\">        end_s=$(( 10<span class=\"comment\">#$end_s - 1 ))</span></span><br><span class=\"line\">        end_nanos=$(( 10<span class=\"comment\">#$end_nanos + 10**9 ))</span></span><br><span class=\"line\">    <span class=\"keyword\">fi</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\"># get timediff</span></span><br><span class=\"line\">    time=$(( 10<span class=\"comment\">#$end_s - 10#$start_s )).`printf \"%03d\\n\" $(( (10#$end_nanos - 10#$start_nanos)/10**6 ))`</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"variable\">$time</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#start=$(date +\"%s.%N\")</span></span><br><span class=\"line\"><span class=\"comment\"># Now exec some command</span></span><br><span class=\"line\"><span class=\"comment\">#end=$(date +\"%s.%N\")</span></span><br><span class=\"line\"><span class=\"comment\"># here give the values</span></span><br><span class=\"line\">start=1502758855.907197692</span><br><span class=\"line\">end=1502758865.066894173</span><br><span class=\"line\"></span><br><span class=\"line\">timediff <span class=\"variable\">$start</span> <span class=\"variable\">$end</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://www.cnblogs.com/f-ck-need-u/p/7426987.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/f-ck-need-u/p/7426987.html</a></p>\n","site":{"data":{}},"length":915,"excerpt":"<h1 id=\"Linux-shell脚本计算运行时间\"><a href=\"#Linux-shell脚本计算运行时间\" class=\"headerlink\" title=\"Linux shell脚本计算运行时间\"></a>Linux shell脚本计算运行时间</h1><p>这个功能经常用但是，总是现用现查，很麻烦。</p>","more":"<p>代码</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># filename: msec_diff.sh</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">timediff</span></span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># time format:date +\"%s.%N\", such as 1502758855.907197692</span></span><br><span class=\"line\">    start_time=<span class=\"variable\">$1</span></span><br><span class=\"line\">    end_time=<span class=\"variable\">$2</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    start_s=<span class=\"variable\">$&#123;start_time%.*&#125;</span></span><br><span class=\"line\">    start_nanos=<span class=\"variable\">$&#123;start_time#*.&#125;</span></span><br><span class=\"line\">    end_s=<span class=\"variable\">$&#123;end_time%.*&#125;</span></span><br><span class=\"line\">    end_nanos=<span class=\"variable\">$&#123;end_time#*.&#125;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># end_nanos &gt; start_nanos? </span></span><br><span class=\"line\">    <span class=\"comment\"># Another way, the time part may start with 0, which means</span></span><br><span class=\"line\">    <span class=\"comment\"># it will be regarded as oct format, use \"10#\" to ensure</span></span><br><span class=\"line\">    <span class=\"comment\"># calculateing with decimal</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> [ <span class=\"string\">\"<span class=\"variable\">$end_nanos</span>\"</span> -lt <span class=\"string\">\"<span class=\"variable\">$start_nanos</span>\"</span> ];<span class=\"keyword\">then</span></span><br><span class=\"line\">        end_s=$(( 10<span class=\"comment\">#$end_s - 1 ))</span></span><br><span class=\"line\">        end_nanos=$(( 10<span class=\"comment\">#$end_nanos + 10**9 ))</span></span><br><span class=\"line\">    <span class=\"keyword\">fi</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\"># get timediff</span></span><br><span class=\"line\">    time=$(( 10<span class=\"comment\">#$end_s - 10#$start_s )).`printf \"%03d\\n\" $(( (10#$end_nanos - 10#$start_nanos)/10**6 ))`</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"variable\">$time</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#start=$(date +\"%s.%N\")</span></span><br><span class=\"line\"><span class=\"comment\"># Now exec some command</span></span><br><span class=\"line\"><span class=\"comment\">#end=$(date +\"%s.%N\")</span></span><br><span class=\"line\"><span class=\"comment\"># here give the values</span></span><br><span class=\"line\">start=1502758855.907197692</span><br><span class=\"line\">end=1502758865.066894173</span><br><span class=\"line\"></span><br><span class=\"line\">timediff <span class=\"variable\">$start</span> <span class=\"variable\">$end</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://www.cnblogs.com/f-ck-need-u/p/7426987.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/f-ck-need-u/p/7426987.html</a></p>"},{"title":"数组中的第K大的数","date":"2019-09-19T13:06:01.000Z","copyright":true,"_content":"\n# 数组中的第K大的数\n\nleetcode#215题，给定一个数组，要求找出其第K大的个数。\n\n<!--more-->\n\n题目来源：\n\n<https://leetcode.com/problems/kth-largest-element-in-an-array/> \n\n## 解题思路\n\n简单：（1）通过对数组排序后可以直接对升序排序后的数组返回下标为len-k（降序就直接返回下标为k）。(2) 选择排序算法中时间复杂度比较低的快排进行排序，可以直接使用<algorithm>库中的sort()函数进行排序。\n\n优化： 仔细分析快排的思路：在分割的过程中每次返回一个主元pivot,主元左边的元素都小于pivot,右边的元素都大于piovt，然后再分别对两边递归排序。因为题目要求的只是返回一个第k大的数，所以不需要完整地对执行完所有递归。当寻找到的主元pivot的坐标刚好等于len-k时，就可以直接返回；如果pivot<len-k说明要找的数目在右边，则只用对右边进行快排；如果pivot>len-k，说明要寻找的数字在左边，则只用对左半边进行快排。\n\n## 代码\n\n```c++\n/*\nhttps://leetcode.com/problems/kth-largest-element-in-an-array/\n */\n#include <iostream>\n#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nclass Solution{\n\tprivate:\n\t\t\n\tpublic:\n\t\tint ans;\n\t\tvoid quicksort(vector<int>& vec, int lo, int hi, int k){\n\t\t\tif(lo>=hi) { //正常情况下退出时相等的情况，为了避免其他逻辑错误因此再加上lo大于hi的情况\n\t\t\t\tans = vec[hi]; // 递归到最后还没有找到说明就是最后的这个元素就是要找的第k大，不考虑k大len的情况。\n\t\t\t\treturn; // base case 递归必备，有个出口只有一个元素的时候不会再递归。\n\t\t\t}\n\t\t\tint piv = partition(vec, lo, hi);\n\t\t\tif(piv==k){\n\t\t\t\tans = vec[k];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse if(k<piv) quicksort(vec,lo,piv-1,k);//左边递归 piv不再参与两边的快排,因为已经找到它的位置了。\n\t\t\telse quicksort(vec,piv+1,hi,k);//右边递归\n\t\t}\n\n\t\tint partition(vector<int>&vec,int lo, int hi){\n\t\t\tint loNow = lo - 1;\n\t\t\tint piov = hi;\n\t\t\tfor(int i = lo; i<=hi-1; i++){ // 必须小于等于，因为hi是下标而不是数组长度，\n\t\t\t\t\t\t\t\t\t\t\t//如果是长度的话i<len-1,会访问到倒数第二个，下标的话就不会。\n\t\t\t\tif(vec[i]<=vec[piov]){\n\t\t\t\t\tloNow++;\n\t\t\t\t\tswap(vec, loNow, i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(vec, loNow+1, piov);\n\t\t\tpiov = loNow+1;\n\t\t\treturn piov;\n\t\t}\n\n\t\tvoid swap(vector<int>& vec, int a, int b){\n\t\t\tint tmp = vec[a];\n\t\t\tvec[a] = vec[b];\n\t\t\tvec[b] = tmp;\n\t\t}\n};\n\n\nint main()\n{\n\tint len, k;\n\tSolution Sol;\n\tvector<int> vec;\n\t//while(cin>>len>>k)\n\twhile(scanf(\"%d %d\", &len, &k)!=EOF)\n\t{\n\t\tint tmp_len = len ;\n\t\twhile(tmp_len--) {\n\t\t\tint element;\n\t\t\tscanf(\"%d\",&element);\n\t\t\tvec.push_back(element);\n\t\t}\n\t\tSol.quicksort(vec, 0, len-1, len-k);\n\t\tcout<<Sol.ans<<endl;\n\t}\n \treturn 0;\n}\n```\n\n","source":"_posts/2019-09-19-数组中的第K大的数.md","raw":"---\ntitle: 数组中的第K大的数\ndate: 2019-09-19 21:06:01\ncategories: 题解\ntags:\n- 快排\n- leetcode\ncopyright: true\n---\n\n# 数组中的第K大的数\n\nleetcode#215题，给定一个数组，要求找出其第K大的个数。\n\n<!--more-->\n\n题目来源：\n\n<https://leetcode.com/problems/kth-largest-element-in-an-array/> \n\n## 解题思路\n\n简单：（1）通过对数组排序后可以直接对升序排序后的数组返回下标为len-k（降序就直接返回下标为k）。(2) 选择排序算法中时间复杂度比较低的快排进行排序，可以直接使用<algorithm>库中的sort()函数进行排序。\n\n优化： 仔细分析快排的思路：在分割的过程中每次返回一个主元pivot,主元左边的元素都小于pivot,右边的元素都大于piovt，然后再分别对两边递归排序。因为题目要求的只是返回一个第k大的数，所以不需要完整地对执行完所有递归。当寻找到的主元pivot的坐标刚好等于len-k时，就可以直接返回；如果pivot<len-k说明要找的数目在右边，则只用对右边进行快排；如果pivot>len-k，说明要寻找的数字在左边，则只用对左半边进行快排。\n\n## 代码\n\n```c++\n/*\nhttps://leetcode.com/problems/kth-largest-element-in-an-array/\n */\n#include <iostream>\n#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nclass Solution{\n\tprivate:\n\t\t\n\tpublic:\n\t\tint ans;\n\t\tvoid quicksort(vector<int>& vec, int lo, int hi, int k){\n\t\t\tif(lo>=hi) { //正常情况下退出时相等的情况，为了避免其他逻辑错误因此再加上lo大于hi的情况\n\t\t\t\tans = vec[hi]; // 递归到最后还没有找到说明就是最后的这个元素就是要找的第k大，不考虑k大len的情况。\n\t\t\t\treturn; // base case 递归必备，有个出口只有一个元素的时候不会再递归。\n\t\t\t}\n\t\t\tint piv = partition(vec, lo, hi);\n\t\t\tif(piv==k){\n\t\t\t\tans = vec[k];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse if(k<piv) quicksort(vec,lo,piv-1,k);//左边递归 piv不再参与两边的快排,因为已经找到它的位置了。\n\t\t\telse quicksort(vec,piv+1,hi,k);//右边递归\n\t\t}\n\n\t\tint partition(vector<int>&vec,int lo, int hi){\n\t\t\tint loNow = lo - 1;\n\t\t\tint piov = hi;\n\t\t\tfor(int i = lo; i<=hi-1; i++){ // 必须小于等于，因为hi是下标而不是数组长度，\n\t\t\t\t\t\t\t\t\t\t\t//如果是长度的话i<len-1,会访问到倒数第二个，下标的话就不会。\n\t\t\t\tif(vec[i]<=vec[piov]){\n\t\t\t\t\tloNow++;\n\t\t\t\t\tswap(vec, loNow, i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(vec, loNow+1, piov);\n\t\t\tpiov = loNow+1;\n\t\t\treturn piov;\n\t\t}\n\n\t\tvoid swap(vector<int>& vec, int a, int b){\n\t\t\tint tmp = vec[a];\n\t\t\tvec[a] = vec[b];\n\t\t\tvec[b] = tmp;\n\t\t}\n};\n\n\nint main()\n{\n\tint len, k;\n\tSolution Sol;\n\tvector<int> vec;\n\t//while(cin>>len>>k)\n\twhile(scanf(\"%d %d\", &len, &k)!=EOF)\n\t{\n\t\tint tmp_len = len ;\n\t\twhile(tmp_len--) {\n\t\t\tint element;\n\t\t\tscanf(\"%d\",&element);\n\t\t\tvec.push_back(element);\n\t\t}\n\t\tSol.quicksort(vec, 0, len-1, len-k);\n\t\tcout<<Sol.ans<<endl;\n\t}\n \treturn 0;\n}\n```\n\n","slug":"2019-09-19-数组中的第K大的数","published":1,"updated":"2019-11-11T03:49:53.617Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6he13yi000rdstz754cjleh","content":"<h1 id=\"数组中的第K大的数\"><a href=\"#数组中的第K大的数\" class=\"headerlink\" title=\"数组中的第K大的数\"></a>数组中的第K大的数</h1><p>leetcode#215题，给定一个数组，要求找出其第K大的个数。</p>\n<a id=\"more\"></a>\n<p>题目来源：</p>\n<p><a href=\"https://leetcode.com/problems/kth-largest-element-in-an-array/\" target=\"_blank\" rel=\"noopener\">https://leetcode.com/problems/kth-largest-element-in-an-array/</a> </p>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>简单：（1）通过对数组排序后可以直接对升序排序后的数组返回下标为len-k（降序就直接返回下标为k）。(2) 选择排序算法中时间复杂度比较低的快排进行排序，可以直接使用<algorithm>库中的sort()函数进行排序。</algorithm></p>\n<p>优化： 仔细分析快排的思路：在分割的过程中每次返回一个主元pivot,主元左边的元素都小于pivot,右边的元素都大于piovt，然后再分别对两边递归排序。因为题目要求的只是返回一个第k大的数，所以不需要完整地对执行完所有递归。当寻找到的主元pivot的坐标刚好等于len-k时，就可以直接返回；如果pivot<len-k说明要找的数目在右边，则只用对右边进行快排；如果pivot>len-k，说明要寻找的数字在左边，则只用对左半边进行快排。</len-k说明要找的数目在右边，则只用对右边进行快排；如果pivot></p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">https://leetcode.com/problems/kth-largest-element-in-an-array/</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t<span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> ans;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">quicksort</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; vec, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi, <span class=\"keyword\">int</span> k)</span></span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(lo&gt;=hi) &#123; <span class=\"comment\">//正常情况下退出时相等的情况，为了避免其他逻辑错误因此再加上lo大于hi的情况</span></span><br><span class=\"line\">\t\t\t\tans = vec[hi]; <span class=\"comment\">// 递归到最后还没有找到说明就是最后的这个元素就是要找的第k大，不考虑k大len的情况。</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span>; <span class=\"comment\">// base case 递归必备，有个出口只有一个元素的时候不会再递归。</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> piv = partition(vec, lo, hi);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(piv==k)&#123;</span><br><span class=\"line\">\t\t\t\tans = vec[k];</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(k&lt;piv) quicksort(vec,lo,piv<span class=\"number\">-1</span>,k);<span class=\"comment\">//左边递归 piv不再参与两边的快排,因为已经找到它的位置了。</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> quicksort(vec,piv+<span class=\"number\">1</span>,hi,k);<span class=\"comment\">//右边递归</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">partition</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp;vec,<span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span></span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> loNow = lo - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> piov = hi;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = lo; i&lt;=hi<span class=\"number\">-1</span>; i++)&#123; <span class=\"comment\">// 必须小于等于，因为hi是下标而不是数组长度，</span></span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">//如果是长度的话i&lt;len-1,会访问到倒数第二个，下标的话就不会。</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(vec[i]&lt;=vec[piov])&#123;</span><br><span class=\"line\">\t\t\t\t\tloNow++;</span><br><span class=\"line\">\t\t\t\t\tswap(vec, loNow, i);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tswap(vec, loNow+<span class=\"number\">1</span>, piov);</span><br><span class=\"line\">\t\t\tpiov = loNow+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> piov;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; vec, <span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> tmp = vec[a];</span><br><span class=\"line\">\t\t\tvec[a] = vec[b];</span><br><span class=\"line\">\t\t\tvec[b] = tmp;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> len, k;</span><br><span class=\"line\">\tSolution Sol;</span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec;</span><br><span class=\"line\">\t<span class=\"comment\">//while(cin&gt;&gt;len&gt;&gt;k)</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;len, &amp;k)!=EOF)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> tmp_len = len ;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(tmp_len--) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> element;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;element);</span><br><span class=\"line\">\t\t\tvec.push_back(element);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tSol.quicksort(vec, <span class=\"number\">0</span>, len<span class=\"number\">-1</span>, len-k);</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;Sol.ans&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> \t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"length":1853,"excerpt":"<h1 id=\"数组中的第K大的数\"><a href=\"#数组中的第K大的数\" class=\"headerlink\" title=\"数组中的第K大的数\"></a>数组中的第K大的数</h1><p>leetcode#215题，给定一个数组，要求找出其第K大的个数。</p>","more":"<p>题目来源：</p>\n<p><a href=\"https://leetcode.com/problems/kth-largest-element-in-an-array/\" target=\"_blank\" rel=\"noopener\">https://leetcode.com/problems/kth-largest-element-in-an-array/</a> </p>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>简单：（1）通过对数组排序后可以直接对升序排序后的数组返回下标为len-k（降序就直接返回下标为k）。(2) 选择排序算法中时间复杂度比较低的快排进行排序，可以直接使用<algorithm>库中的sort()函数进行排序。</algorithm></p>\n<p>优化： 仔细分析快排的思路：在分割的过程中每次返回一个主元pivot,主元左边的元素都小于pivot,右边的元素都大于piovt，然后再分别对两边递归排序。因为题目要求的只是返回一个第k大的数，所以不需要完整地对执行完所有递归。当寻找到的主元pivot的坐标刚好等于len-k时，就可以直接返回；如果pivot<len-k说明要找的数目在右边，则只用对右边进行快排；如果pivot>len-k，说明要寻找的数字在左边，则只用对左半边进行快排。</len-k说明要找的数目在右边，则只用对右边进行快排；如果pivot></p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">https://leetcode.com/problems/kth-largest-element-in-an-array/</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t<span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> ans;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">quicksort</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; vec, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi, <span class=\"keyword\">int</span> k)</span></span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(lo&gt;=hi) &#123; <span class=\"comment\">//正常情况下退出时相等的情况，为了避免其他逻辑错误因此再加上lo大于hi的情况</span></span><br><span class=\"line\">\t\t\t\tans = vec[hi]; <span class=\"comment\">// 递归到最后还没有找到说明就是最后的这个元素就是要找的第k大，不考虑k大len的情况。</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span>; <span class=\"comment\">// base case 递归必备，有个出口只有一个元素的时候不会再递归。</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> piv = partition(vec, lo, hi);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(piv==k)&#123;</span><br><span class=\"line\">\t\t\t\tans = vec[k];</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(k&lt;piv) quicksort(vec,lo,piv<span class=\"number\">-1</span>,k);<span class=\"comment\">//左边递归 piv不再参与两边的快排,因为已经找到它的位置了。</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> quicksort(vec,piv+<span class=\"number\">1</span>,hi,k);<span class=\"comment\">//右边递归</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">partition</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp;vec,<span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span></span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> loNow = lo - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> piov = hi;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = lo; i&lt;=hi<span class=\"number\">-1</span>; i++)&#123; <span class=\"comment\">// 必须小于等于，因为hi是下标而不是数组长度，</span></span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">//如果是长度的话i&lt;len-1,会访问到倒数第二个，下标的话就不会。</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(vec[i]&lt;=vec[piov])&#123;</span><br><span class=\"line\">\t\t\t\t\tloNow++;</span><br><span class=\"line\">\t\t\t\t\tswap(vec, loNow, i);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tswap(vec, loNow+<span class=\"number\">1</span>, piov);</span><br><span class=\"line\">\t\t\tpiov = loNow+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> piov;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; vec, <span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> tmp = vec[a];</span><br><span class=\"line\">\t\t\tvec[a] = vec[b];</span><br><span class=\"line\">\t\t\tvec[b] = tmp;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> len, k;</span><br><span class=\"line\">\tSolution Sol;</span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec;</span><br><span class=\"line\">\t<span class=\"comment\">//while(cin&gt;&gt;len&gt;&gt;k)</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;len, &amp;k)!=EOF)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> tmp_len = len ;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(tmp_len--) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> element;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;element);</span><br><span class=\"line\">\t\t\tvec.push_back(element);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tSol.quicksort(vec, <span class=\"number\">0</span>, len<span class=\"number\">-1</span>, len-k);</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;Sol.ans&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> \t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Redis Makefile注解","date":"2019-04-26T07:57:19.000Z","copyright":true,"_content":"\n# Redis Makefile注解\n\nRedis的makefile是阅读源码的第一步，总共有292行，读起来也是头大，记录之。\n\n<!--more-->\n\n4.02版本源码为：\n\n```makefile\n# Redis Makefile\n# Copyright (C) 2009 Salvatore Sanfilippo <antirez at gmail dot com>\n# This file is released under the BSD license, see the COPYING file\n#\n# The Makefile composes the final FINAL_CFLAGS and FINAL_LDFLAGS using\n# what is needed for Redis plus the standard CFLAGS and LDFLAGS passed.\n# However when building the dependencies (Jemalloc, Lua, Hiredis, ...)\n# CFLAGS and LDFLAGS are propagated to the dependencies, so to pass\n# flags only to be used when compiling / linking Redis itself REDIS_CFLAGS\n# and REDIS_LDFLAGS are used instead (this is the case of 'make gcov').\n#\n# Dependencies are stored in the Makefile.dep file. To rebuild this file\n# Just use 'make dep', but this is only needed by developers.\n\nrelease_hdr := $(shell sh -c './mkreleasehdr.sh')\n# uname -s 获取操作系统的类型 Linux\nuname_S := $(shell sh -c 'uname -s 2>/dev/null || echo not')\n#uname -m 获取机子的架构 x86_64\nuname_M := $(shell sh -c 'uname -m 2>/dev/null || echo not')\n# 优化选项\nOPTIMIZATION?=-O2\n# 依赖目标\nDEPENDENCY_TARGETS=hiredis linenoise lua\nNODEPS:=clean distclean\n\n# Default settings\n# 使用c99标准编译，-pedantic 保证代码规范满足ISO C和ISO C++标准\nSTD=-std=c99 -pedantic -DREDIS_STATIC=''\n# 输出所有编译警告信息 ，Wno-missing-field-initializers 不输出missing-的警告信息\nWARN=-Wall -W -Wno-missing-field-initializers\nOPT=$(OPTIMIZATION)\n\n#默认目录\nPREFIX?=/usr/local\n#安装的默认目录\nINSTALL_BIN=$(PREFIX)/bin\nINSTALL=install\n\n# Default allocator defaults to Jemalloc if it's not an ARM\n#内存分配器的指定 默认libc，linux系统而且架构不是armv61和71的时候则是jemalloc，\nMALLOC=libc\nifneq ($(uname_M),armv6l)\nifneq ($(uname_M),armv7l)\nifeq ($(uname_S),Linux)\n\tMALLOC=jemalloc\nendif\nendif\nendif\n\n# To get ARM stack traces if Redis crashes we need a special C flag.\nifneq (,$(findstring armv,$(uname_M)))\n        CFLAGS+=-funwind-tables\nendif\n\n# Backwards compatibility for selecting an allocator\n#编译的时候指定内存分配器\nifeq ($(USE_TCMALLOC),yes)\n\tMALLOC=tcmalloc\nendif\n\nifeq ($(USE_TCMALLOC_MINIMAL),yes)\n\tMALLOC=tcmalloc_minimal\nendif\n\nifeq ($(USE_JEMALLOC),yes)\n\tMALLOC=jemalloc\nendif\n\nifeq ($(USE_JEMALLOC),no)\n\tMALLOC=libc\nendif\n\n# Override default settings if possible\n-include .make-settings\n# 最终的编译选项CFLAGS是-c的选项，LDFLAGS是链接的选项\nFINAL_CFLAGS=$(STD) $(WARN) $(OPT) $(DEBUG) $(CFLAGS) $(REDIS_CFLAGS)\nFINAL_LDFLAGS=$(LDFLAGS) $(REDIS_LDFLAGS) $(DEBUG)\n# m这个lib是libmath 也就是math的链接\nFINAL_LIBS=-lm\n# 调试信息\nDEBUG=-g -ggdb\n#根据操作系统继续指定编译选项\nifeq ($(uname_S),SunOS)\n\t# SunOS\n        ifneq ($(@@),32bit)\n\t\tCFLAGS+= -m64\n\t\tLDFLAGS+= -m64\n\tendif\n\tDEBUG=-g\n\tDEBUG_FLAGS=-g\n\texport CFLAGS LDFLAGS DEBUG DEBUG_FLAGS\n\tINSTALL=cp -pf\n\tFINAL_CFLAGS+= -D__EXTENSIONS__ -D_XPG6\n\tFINAL_LIBS+= -ldl -lnsl -lsocket -lresolv -lpthread -lrt\nelse\nifeq ($(uname_S),Darwin)\n\t# Darwin\n\tFINAL_LIBS+= -ldl\nelse\nifeq ($(uname_S),AIX)\n        # AIX\n        FINAL_LDFLAGS+= -Wl,-bexpall\n        FINAL_LIBS+=-ldl -pthread -lcrypt -lbsd\nelse\nifeq ($(uname_S),OpenBSD)\n\t# OpenBSD\n\tFINAL_LIBS+= -lpthread\nelse\nifeq ($(uname_S),FreeBSD)\n\t# FreeBSD\n\tFINAL_LIBS+= -lpthread\nelse\n\t# 特别是对Linux的指定\n\t# All the other OSes (notably Linux)\n\t# -rdynamic将链接器将所有符号添加到动态符号表\n\tFINAL_LDFLAGS+= -rdynamic\n\t#pthread库 用于多线程， dl是libdl 动态链接库\n\tFINAL_LIBS+=-ldl -pthread\nendif\nendif\nendif\nendif\nendif\n# Include paths to dependencies\n# -I 指定头文件的目录\nFINAL_CFLAGS+= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src\n\nifeq ($(MALLOC),tcmalloc)\n\tFINAL_CFLAGS+= -DUSE_TCMALLOC\n\tFINAL_LIBS+= -ltcmalloc\nendif\n\nifeq ($(MALLOC),tcmalloc_minimal)\n\tFINAL_CFLAGS+= -DUSE_TCMALLOC\n\tFINAL_LIBS+= -ltcmalloc_minimal\nendif\n#使用jemalloc的话 链接 libjemalloc.a -I指定jemalloc的头文件目录\nifeq ($(MALLOC),jemalloc)\n\tDEPENDENCY_TARGETS+= jemalloc\n\tFINAL_CFLAGS+= -DUSE_JEMALLOC -I../deps/jemalloc/include\n\tFINAL_LIBS+= ../deps/jemalloc/lib/libjemalloc.a\nendif\n#redis 的gcc -c 选项\nREDIS_CC=$(QUIET_CC)$(CC) $(FINAL_CFLAGS)\n#redis的gcc 链接选项\nREDIS_LD=$(QUIET_LINK)$(CC) $(FINAL_LDFLAGS)\n#redis的安装选项\nREDIS_INSTALL=$(QUIET_INSTALL)$(INSTALL)\n\nCCCOLOR=\"\\033[34m\"\nLINKCOLOR=\"\\033[34;1m\"\nSRCCOLOR=\"\\033[33m\"\nBINCOLOR=\"\\033[37;1m\"\nMAKECOLOR=\"\\033[32;1m\"\nENDCOLOR=\"\\033[0m\"\n\nifndef V\nQUIET_CC = @printf '    %b %b\\n' $(CCCOLOR)CC$(ENDCOLOR) $(SRCCOLOR)$@$(ENDCOLOR) 1>&2;\nQUIET_LINK = @printf '    %b %b\\n' $(LINKCOLOR)LINK$(ENDCOLOR) $(BINCOLOR)$@$(ENDCOLOR) 1>&2;\nQUIET_INSTALL = @printf '    %b %b\\n' $(LINKCOLOR)INSTALL$(ENDCOLOR) $(BINCOLOR)$@$(ENDCOLOR) 1>&2;\nendif\n\nREDIS_SERVER_NAME=redis-server\nREDIS_SENTINEL_NAME=redis-sentinel\n# redis-server的需要使用的对象文件，也就是各个模块\nREDIS_SERVER_OBJ=adlist.o quicklist.o ae.o anet.o dict.o server.o sds.o zmalloc.o lzf_c.o lzf_d.o pqsort.o zipmap.o sha1.o ziplist.o release.o networking.o util.o object.o db.o replication.o rdb.o t_string.o t_list.o t_set.o t_zset.o t_hash.o config.o aof.o pubsub.o multi.o debug.o sort.o intset.o syncio.o cluster.o crc16.o endianconv.o slowlog.o scripting.o bio.o rio.o rand.o memtest.o crc64.o bitops.o sentinel.o notify.o setproctitle.o blocked.o hyperloglog.o latency.o sparkline.o redis-check-rdb.o redis-check-aof.o geo.o lazyfree.o module.o evict.o expire.o geohash.o geohash_helper.o childinfo.o defrag.o siphash.o rax.o\nREDIS_CLI_NAME=redis-cli\n#redis-cli 需要使用的对象文件\nREDIS_CLI_OBJ=anet.o adlist.o redis-cli.o zmalloc.o release.o anet.o ae.o crc64.o\nREDIS_BENCHMARK_NAME=redis-benchmark\n#redis-benchmark需要使用的对象文件\nREDIS_BENCHMARK_OBJ=ae.o anet.o redis-benchmark.o adlist.o zmalloc.o redis-benchmark.o\nREDIS_CHECK_RDB_NAME=redis-check-rdb\nREDIS_CHECK_AOF_NAME=redis-check-aof\n#所有需要需要构建的对象，第一条规则也就是默认规则，不指定规则的话，从第一个规则执行\nall: $(REDIS_SERVER_NAME) $(REDIS_SENTINEL_NAME) $(REDIS_CLI_NAME) $(REDIS_BENCHMARK_NAME) $(REDIS_CHECK_RDB_NAME) $(REDIS_CHECK_AOF_NAME)\n\t@echo \"\"\n\t@echo \"Hint: It's a good idea to run 'make test' ;)\"\n\t@echo \"\"\n#Makefil.dep 的生成\nMakefile.dep:\n\t-$(REDIS_CC) -MM *.c > Makefile.dep 2> /dev/null || true\n\nifeq (0, $(words $(findstring $(MAKECMDGOALS), $(NODEPS))))\n-include Makefile.dep\nendif\n\n.PHONY: all\n#先清除所有编译的输出然后，  将所有设置持久化\npersist-settings: distclean\n\techo STD=$(STD) >> .make-settings\n\techo WARN=$(WARN) >> .make-settings\n\techo OPT=$(OPT) >> .make-settings\n\techo MALLOC=$(MALLOC) >> .make-settings\n\techo CFLAGS=$(CFLAGS) >> .make-settings\n\techo LDFLAGS=$(LDFLAGS) >> .make-settings\n\techo REDIS_CFLAGS=$(REDIS_CFLAGS) >> .make-settings\n\techo REDIS_LDFLAGS=$(REDIS_LDFLAGS) >> .make-settings\n\techo PREV_FINAL_CFLAGS=$(FINAL_CFLAGS) >> .make-settings\n\techo PREV_FINAL_LDFLAGS=$(FINAL_LDFLAGS) >> .make-settings\n\t-(cd ../deps && $(MAKE) $(DEPENDENCY_TARGETS))\n\n.PHONY: persist-settings\n \n# Prerequisites target\n.make-prerequisites:\n\t@touch $@\n\n# Clean everything, persist settings and build dependencies if anything changed\n#当设置有变化的时候清除并重新持久化设置\nifneq ($(strip $(PREV_FINAL_CFLAGS)), $(strip $(FINAL_CFLAGS)))\n.make-prerequisites: persist-settings\nendif\n\nifneq ($(strip $(PREV_FINAL_LDFLAGS)), $(strip $(FINAL_LDFLAGS)))\n.make-prerequisites: persist-settings\nendif\n\n# redis-server\n#redis-server可执行程序的链接，需要链接的静态链接文件包括hiredi和lua,还有final_libs\n$(REDIS_SERVER_NAME): $(REDIS_SERVER_OBJ)\n\t$(REDIS_LD) -o $@ $^ ../deps/hiredis/libhiredis.a ../deps/lua/src/liblua.a $(FINAL_LIBS)\n\n# redis-sentinel\n#redis-sentienl构建\n$(REDIS_SENTINEL_NAME): $(REDIS_SERVER_NAME)\n\t$(REDIS_INSTALL) $(REDIS_SERVER_NAME) $(REDIS_SENTINEL_NAME)\n\n# redis-check-rdb\n#redis-check-rdb的构建\n$(REDIS_CHECK_RDB_NAME): $(REDIS_SERVER_NAME)\n\t$(REDIS_INSTALL) $(REDIS_SERVER_NAME) $(REDIS_CHECK_RDB_NAME)\n\n# redis-check-aof\n#redis-check-aof的构建\n$(REDIS_CHECK_AOF_NAME): $(REDIS_SERVER_NAME)\n\t$(REDIS_INSTALL) $(REDIS_SERVER_NAME) $(REDIS_CHECK_AOF_NAME)\n\n# redis-cli\n#redis-cli的链接\n$(REDIS_CLI_NAME): $(REDIS_CLI_OBJ)\n\t$(REDIS_LD) -o $@ $^ ../deps/hiredis/libhiredis.a ../deps/linenoise/linenoise.o $(FINAL_LIBS)\n\n# redis-benchmark\n#redis-benchmark的链接\n$(REDIS_BENCHMARK_NAME): $(REDIS_BENCHMARK_OBJ)\n\t$(REDIS_LD) -o $@ $^ ../deps/hiredis/libhiredis.a $(FINAL_LIBS)\n\ndict-benchmark: dict.c zmalloc.c sds.c siphash.c\n\t$(REDIS_CC) $(FINAL_CFLAGS) $^ -D DICT_BENCHMARK_MAIN -o $@ $(FINAL_LIBS)\n\n# Because the jemalloc.h header is generated as a part of the jemalloc build,\n# building it should complete before building any other object. Instead of\n# depending on a single artifact, build all dependencies first.\n#将所有点c文件编译成.o文件 自动完成file.c 到file.o的对应\n%.o: %.c .make-prerequisites\n\t$(REDIS_CC) -c $<\n\nclean:\n\trm -rf $(REDIS_SERVER_NAME) $(REDIS_SENTINEL_NAME) $(REDIS_CLI_NAME) $(REDIS_BENCHMARK_NAME) $(REDIS_CHECK_RDB_NAME) $(REDIS_CHECK_AOF_NAME) *.o *.gcda *.gcno *.gcov redis.info lcov-html Makefile.dep dict-benchmark\n\n.PHONY: clean\n\ndistclean: clean\n\t-(cd ../deps && $(MAKE) distclean)\n\t-(rm -f .make-*)\n\n.PHONY: distclean\n\ntest: $(REDIS_SERVER_NAME) $(REDIS_CHECK_AOF_NAME)\n\t@(cd ..; ./runtest)\n\ntest-sentinel: $(REDIS_SENTINEL_NAME)\n\t@(cd ..; ./runtest-sentinel)\n\ncheck: test\n\nlcov:\n\t$(MAKE) gcov\n\t@(set -e; cd ..; ./runtest --clients 1)\n\t@geninfo -o redis.info .\n\t@genhtml --legend -o lcov-html redis.info\n\ntest-sds: sds.c sds.h\n\t$(REDIS_CC) sds.c zmalloc.c -DSDS_TEST_MAIN $(FINAL_LIBS) -o /tmp/sds_test\n\t/tmp/sds_test\n\n.PHONY: lcov\n\nbench: $(REDIS_BENCHMARK_NAME)\n\t./$(REDIS_BENCHMARK_NAME)\n\n32bit:\n\t@echo \"\"\n\t@echo \"WARNING: if it fails under Linux you probably need to install libc6-dev-i386\"\n\t@echo \"\"\n\t$(MAKE) CFLAGS=\"-m32\" LDFLAGS=\"-m32\"\n\ngcov:\n\t$(MAKE) REDIS_CFLAGS=\"-fprofile-arcs -ftest-coverage -DCOVERAGE_TEST\" REDIS_LDFLAGS=\"-fprofile-arcs -ftest-coverage\"\n\nnoopt:\n\t$(MAKE) OPTIMIZATION=\"-O0\"\n\nvalgrind:\n\t$(MAKE) OPTIMIZATION=\"-O0\" MALLOC=\"libc\"\n\nhelgrind:\n\t$(MAKE) OPTIMIZATION=\"-O0\" MALLOC=\"libc\" CFLAGS=\"-D__ATOMIC_VAR_FORCE_SYNC_MACROS\"\n\nsrc/help.h:\n\t@../utils/generate-command-help.rb > help.h\n#将构建完成的可执行程序安装到指定的目录，-p选项自行创建多层目录\ninstall: all\n\t@mkdir -p $(INSTALL_BIN)\n\t$(REDIS_INSTALL) $(REDIS_SERVER_NAME) $(INSTALL_BIN)\n\t$(REDIS_INSTALL) $(REDIS_BENCHMARK_NAME) $(INSTALL_BIN)\n\t$(REDIS_INSTALL) $(REDIS_CLI_NAME) $(INSTALL_BIN)\n\t$(REDIS_INSTALL) $(REDIS_CHECK_RDB_NAME) $(INSTALL_BIN)\n\t$(REDIS_INSTALL) $(REDIS_CHECK_AOF_NAME) $(INSTALL_BIN)\n\t@ln -sf $(REDIS_SERVER_NAME) $(INSTALL_BIN)/$(REDIS_SENTINEL_NAME)\n\n```\n\n`uname_S := $(shell sh -c 'uname -s 2>/dev/null || echo not') ` 这一句-c让后面的字符串命令当成一个完成的命令来执行，从而避免向文件中写入东西的时候权限不够的问题。就算加上sudo也不行，因为里面的命令有>,echo等很多个文件，所以只能用-c来当成一个整体来执行。[参考](https://blog.csdn.net/bobchill/article/details/84647575)\n\n## Makefile思路\n\n总结一下Redis Makefile的思路：\n\n1. 在默认规则也就是第一条规则之前，通过变量设置好编译的相关选项：LDFLAGS，相应的对应关系REDIS_SERVER_OBJ，将规则的target用变量表示好（方便all规则里面用作前置条件），比如REDIS_SERVER_NAME。\n2. 在第一条默认规则 all规则里面指定需要构建的东西\n3. 在第一规则后面先完成链接，再完成编译的规则\n4. 其他功能性规则如clean和distclean\n\n也就是从上到下的结构是总-分。显示整个项目 ，然后是各个模块如redis-server，redis-cli的链接，然后是从源文件到obj文件的编译。\n\n## 参考\n\n<https://blog.csdn.net/bobchill/article/details/84647575>","source":"_posts/2019-04-26-Redis-Makefile注解.md","raw":"---\ntitle: Redis Makefile注解\ndate: 2019-04-26 15:57:19\ncategories: 源码阅读\ntags:\n- redis\n- Makefile\ncopyright: true\n---\n\n# Redis Makefile注解\n\nRedis的makefile是阅读源码的第一步，总共有292行，读起来也是头大，记录之。\n\n<!--more-->\n\n4.02版本源码为：\n\n```makefile\n# Redis Makefile\n# Copyright (C) 2009 Salvatore Sanfilippo <antirez at gmail dot com>\n# This file is released under the BSD license, see the COPYING file\n#\n# The Makefile composes the final FINAL_CFLAGS and FINAL_LDFLAGS using\n# what is needed for Redis plus the standard CFLAGS and LDFLAGS passed.\n# However when building the dependencies (Jemalloc, Lua, Hiredis, ...)\n# CFLAGS and LDFLAGS are propagated to the dependencies, so to pass\n# flags only to be used when compiling / linking Redis itself REDIS_CFLAGS\n# and REDIS_LDFLAGS are used instead (this is the case of 'make gcov').\n#\n# Dependencies are stored in the Makefile.dep file. To rebuild this file\n# Just use 'make dep', but this is only needed by developers.\n\nrelease_hdr := $(shell sh -c './mkreleasehdr.sh')\n# uname -s 获取操作系统的类型 Linux\nuname_S := $(shell sh -c 'uname -s 2>/dev/null || echo not')\n#uname -m 获取机子的架构 x86_64\nuname_M := $(shell sh -c 'uname -m 2>/dev/null || echo not')\n# 优化选项\nOPTIMIZATION?=-O2\n# 依赖目标\nDEPENDENCY_TARGETS=hiredis linenoise lua\nNODEPS:=clean distclean\n\n# Default settings\n# 使用c99标准编译，-pedantic 保证代码规范满足ISO C和ISO C++标准\nSTD=-std=c99 -pedantic -DREDIS_STATIC=''\n# 输出所有编译警告信息 ，Wno-missing-field-initializers 不输出missing-的警告信息\nWARN=-Wall -W -Wno-missing-field-initializers\nOPT=$(OPTIMIZATION)\n\n#默认目录\nPREFIX?=/usr/local\n#安装的默认目录\nINSTALL_BIN=$(PREFIX)/bin\nINSTALL=install\n\n# Default allocator defaults to Jemalloc if it's not an ARM\n#内存分配器的指定 默认libc，linux系统而且架构不是armv61和71的时候则是jemalloc，\nMALLOC=libc\nifneq ($(uname_M),armv6l)\nifneq ($(uname_M),armv7l)\nifeq ($(uname_S),Linux)\n\tMALLOC=jemalloc\nendif\nendif\nendif\n\n# To get ARM stack traces if Redis crashes we need a special C flag.\nifneq (,$(findstring armv,$(uname_M)))\n        CFLAGS+=-funwind-tables\nendif\n\n# Backwards compatibility for selecting an allocator\n#编译的时候指定内存分配器\nifeq ($(USE_TCMALLOC),yes)\n\tMALLOC=tcmalloc\nendif\n\nifeq ($(USE_TCMALLOC_MINIMAL),yes)\n\tMALLOC=tcmalloc_minimal\nendif\n\nifeq ($(USE_JEMALLOC),yes)\n\tMALLOC=jemalloc\nendif\n\nifeq ($(USE_JEMALLOC),no)\n\tMALLOC=libc\nendif\n\n# Override default settings if possible\n-include .make-settings\n# 最终的编译选项CFLAGS是-c的选项，LDFLAGS是链接的选项\nFINAL_CFLAGS=$(STD) $(WARN) $(OPT) $(DEBUG) $(CFLAGS) $(REDIS_CFLAGS)\nFINAL_LDFLAGS=$(LDFLAGS) $(REDIS_LDFLAGS) $(DEBUG)\n# m这个lib是libmath 也就是math的链接\nFINAL_LIBS=-lm\n# 调试信息\nDEBUG=-g -ggdb\n#根据操作系统继续指定编译选项\nifeq ($(uname_S),SunOS)\n\t# SunOS\n        ifneq ($(@@),32bit)\n\t\tCFLAGS+= -m64\n\t\tLDFLAGS+= -m64\n\tendif\n\tDEBUG=-g\n\tDEBUG_FLAGS=-g\n\texport CFLAGS LDFLAGS DEBUG DEBUG_FLAGS\n\tINSTALL=cp -pf\n\tFINAL_CFLAGS+= -D__EXTENSIONS__ -D_XPG6\n\tFINAL_LIBS+= -ldl -lnsl -lsocket -lresolv -lpthread -lrt\nelse\nifeq ($(uname_S),Darwin)\n\t# Darwin\n\tFINAL_LIBS+= -ldl\nelse\nifeq ($(uname_S),AIX)\n        # AIX\n        FINAL_LDFLAGS+= -Wl,-bexpall\n        FINAL_LIBS+=-ldl -pthread -lcrypt -lbsd\nelse\nifeq ($(uname_S),OpenBSD)\n\t# OpenBSD\n\tFINAL_LIBS+= -lpthread\nelse\nifeq ($(uname_S),FreeBSD)\n\t# FreeBSD\n\tFINAL_LIBS+= -lpthread\nelse\n\t# 特别是对Linux的指定\n\t# All the other OSes (notably Linux)\n\t# -rdynamic将链接器将所有符号添加到动态符号表\n\tFINAL_LDFLAGS+= -rdynamic\n\t#pthread库 用于多线程， dl是libdl 动态链接库\n\tFINAL_LIBS+=-ldl -pthread\nendif\nendif\nendif\nendif\nendif\n# Include paths to dependencies\n# -I 指定头文件的目录\nFINAL_CFLAGS+= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src\n\nifeq ($(MALLOC),tcmalloc)\n\tFINAL_CFLAGS+= -DUSE_TCMALLOC\n\tFINAL_LIBS+= -ltcmalloc\nendif\n\nifeq ($(MALLOC),tcmalloc_minimal)\n\tFINAL_CFLAGS+= -DUSE_TCMALLOC\n\tFINAL_LIBS+= -ltcmalloc_minimal\nendif\n#使用jemalloc的话 链接 libjemalloc.a -I指定jemalloc的头文件目录\nifeq ($(MALLOC),jemalloc)\n\tDEPENDENCY_TARGETS+= jemalloc\n\tFINAL_CFLAGS+= -DUSE_JEMALLOC -I../deps/jemalloc/include\n\tFINAL_LIBS+= ../deps/jemalloc/lib/libjemalloc.a\nendif\n#redis 的gcc -c 选项\nREDIS_CC=$(QUIET_CC)$(CC) $(FINAL_CFLAGS)\n#redis的gcc 链接选项\nREDIS_LD=$(QUIET_LINK)$(CC) $(FINAL_LDFLAGS)\n#redis的安装选项\nREDIS_INSTALL=$(QUIET_INSTALL)$(INSTALL)\n\nCCCOLOR=\"\\033[34m\"\nLINKCOLOR=\"\\033[34;1m\"\nSRCCOLOR=\"\\033[33m\"\nBINCOLOR=\"\\033[37;1m\"\nMAKECOLOR=\"\\033[32;1m\"\nENDCOLOR=\"\\033[0m\"\n\nifndef V\nQUIET_CC = @printf '    %b %b\\n' $(CCCOLOR)CC$(ENDCOLOR) $(SRCCOLOR)$@$(ENDCOLOR) 1>&2;\nQUIET_LINK = @printf '    %b %b\\n' $(LINKCOLOR)LINK$(ENDCOLOR) $(BINCOLOR)$@$(ENDCOLOR) 1>&2;\nQUIET_INSTALL = @printf '    %b %b\\n' $(LINKCOLOR)INSTALL$(ENDCOLOR) $(BINCOLOR)$@$(ENDCOLOR) 1>&2;\nendif\n\nREDIS_SERVER_NAME=redis-server\nREDIS_SENTINEL_NAME=redis-sentinel\n# redis-server的需要使用的对象文件，也就是各个模块\nREDIS_SERVER_OBJ=adlist.o quicklist.o ae.o anet.o dict.o server.o sds.o zmalloc.o lzf_c.o lzf_d.o pqsort.o zipmap.o sha1.o ziplist.o release.o networking.o util.o object.o db.o replication.o rdb.o t_string.o t_list.o t_set.o t_zset.o t_hash.o config.o aof.o pubsub.o multi.o debug.o sort.o intset.o syncio.o cluster.o crc16.o endianconv.o slowlog.o scripting.o bio.o rio.o rand.o memtest.o crc64.o bitops.o sentinel.o notify.o setproctitle.o blocked.o hyperloglog.o latency.o sparkline.o redis-check-rdb.o redis-check-aof.o geo.o lazyfree.o module.o evict.o expire.o geohash.o geohash_helper.o childinfo.o defrag.o siphash.o rax.o\nREDIS_CLI_NAME=redis-cli\n#redis-cli 需要使用的对象文件\nREDIS_CLI_OBJ=anet.o adlist.o redis-cli.o zmalloc.o release.o anet.o ae.o crc64.o\nREDIS_BENCHMARK_NAME=redis-benchmark\n#redis-benchmark需要使用的对象文件\nREDIS_BENCHMARK_OBJ=ae.o anet.o redis-benchmark.o adlist.o zmalloc.o redis-benchmark.o\nREDIS_CHECK_RDB_NAME=redis-check-rdb\nREDIS_CHECK_AOF_NAME=redis-check-aof\n#所有需要需要构建的对象，第一条规则也就是默认规则，不指定规则的话，从第一个规则执行\nall: $(REDIS_SERVER_NAME) $(REDIS_SENTINEL_NAME) $(REDIS_CLI_NAME) $(REDIS_BENCHMARK_NAME) $(REDIS_CHECK_RDB_NAME) $(REDIS_CHECK_AOF_NAME)\n\t@echo \"\"\n\t@echo \"Hint: It's a good idea to run 'make test' ;)\"\n\t@echo \"\"\n#Makefil.dep 的生成\nMakefile.dep:\n\t-$(REDIS_CC) -MM *.c > Makefile.dep 2> /dev/null || true\n\nifeq (0, $(words $(findstring $(MAKECMDGOALS), $(NODEPS))))\n-include Makefile.dep\nendif\n\n.PHONY: all\n#先清除所有编译的输出然后，  将所有设置持久化\npersist-settings: distclean\n\techo STD=$(STD) >> .make-settings\n\techo WARN=$(WARN) >> .make-settings\n\techo OPT=$(OPT) >> .make-settings\n\techo MALLOC=$(MALLOC) >> .make-settings\n\techo CFLAGS=$(CFLAGS) >> .make-settings\n\techo LDFLAGS=$(LDFLAGS) >> .make-settings\n\techo REDIS_CFLAGS=$(REDIS_CFLAGS) >> .make-settings\n\techo REDIS_LDFLAGS=$(REDIS_LDFLAGS) >> .make-settings\n\techo PREV_FINAL_CFLAGS=$(FINAL_CFLAGS) >> .make-settings\n\techo PREV_FINAL_LDFLAGS=$(FINAL_LDFLAGS) >> .make-settings\n\t-(cd ../deps && $(MAKE) $(DEPENDENCY_TARGETS))\n\n.PHONY: persist-settings\n \n# Prerequisites target\n.make-prerequisites:\n\t@touch $@\n\n# Clean everything, persist settings and build dependencies if anything changed\n#当设置有变化的时候清除并重新持久化设置\nifneq ($(strip $(PREV_FINAL_CFLAGS)), $(strip $(FINAL_CFLAGS)))\n.make-prerequisites: persist-settings\nendif\n\nifneq ($(strip $(PREV_FINAL_LDFLAGS)), $(strip $(FINAL_LDFLAGS)))\n.make-prerequisites: persist-settings\nendif\n\n# redis-server\n#redis-server可执行程序的链接，需要链接的静态链接文件包括hiredi和lua,还有final_libs\n$(REDIS_SERVER_NAME): $(REDIS_SERVER_OBJ)\n\t$(REDIS_LD) -o $@ $^ ../deps/hiredis/libhiredis.a ../deps/lua/src/liblua.a $(FINAL_LIBS)\n\n# redis-sentinel\n#redis-sentienl构建\n$(REDIS_SENTINEL_NAME): $(REDIS_SERVER_NAME)\n\t$(REDIS_INSTALL) $(REDIS_SERVER_NAME) $(REDIS_SENTINEL_NAME)\n\n# redis-check-rdb\n#redis-check-rdb的构建\n$(REDIS_CHECK_RDB_NAME): $(REDIS_SERVER_NAME)\n\t$(REDIS_INSTALL) $(REDIS_SERVER_NAME) $(REDIS_CHECK_RDB_NAME)\n\n# redis-check-aof\n#redis-check-aof的构建\n$(REDIS_CHECK_AOF_NAME): $(REDIS_SERVER_NAME)\n\t$(REDIS_INSTALL) $(REDIS_SERVER_NAME) $(REDIS_CHECK_AOF_NAME)\n\n# redis-cli\n#redis-cli的链接\n$(REDIS_CLI_NAME): $(REDIS_CLI_OBJ)\n\t$(REDIS_LD) -o $@ $^ ../deps/hiredis/libhiredis.a ../deps/linenoise/linenoise.o $(FINAL_LIBS)\n\n# redis-benchmark\n#redis-benchmark的链接\n$(REDIS_BENCHMARK_NAME): $(REDIS_BENCHMARK_OBJ)\n\t$(REDIS_LD) -o $@ $^ ../deps/hiredis/libhiredis.a $(FINAL_LIBS)\n\ndict-benchmark: dict.c zmalloc.c sds.c siphash.c\n\t$(REDIS_CC) $(FINAL_CFLAGS) $^ -D DICT_BENCHMARK_MAIN -o $@ $(FINAL_LIBS)\n\n# Because the jemalloc.h header is generated as a part of the jemalloc build,\n# building it should complete before building any other object. Instead of\n# depending on a single artifact, build all dependencies first.\n#将所有点c文件编译成.o文件 自动完成file.c 到file.o的对应\n%.o: %.c .make-prerequisites\n\t$(REDIS_CC) -c $<\n\nclean:\n\trm -rf $(REDIS_SERVER_NAME) $(REDIS_SENTINEL_NAME) $(REDIS_CLI_NAME) $(REDIS_BENCHMARK_NAME) $(REDIS_CHECK_RDB_NAME) $(REDIS_CHECK_AOF_NAME) *.o *.gcda *.gcno *.gcov redis.info lcov-html Makefile.dep dict-benchmark\n\n.PHONY: clean\n\ndistclean: clean\n\t-(cd ../deps && $(MAKE) distclean)\n\t-(rm -f .make-*)\n\n.PHONY: distclean\n\ntest: $(REDIS_SERVER_NAME) $(REDIS_CHECK_AOF_NAME)\n\t@(cd ..; ./runtest)\n\ntest-sentinel: $(REDIS_SENTINEL_NAME)\n\t@(cd ..; ./runtest-sentinel)\n\ncheck: test\n\nlcov:\n\t$(MAKE) gcov\n\t@(set -e; cd ..; ./runtest --clients 1)\n\t@geninfo -o redis.info .\n\t@genhtml --legend -o lcov-html redis.info\n\ntest-sds: sds.c sds.h\n\t$(REDIS_CC) sds.c zmalloc.c -DSDS_TEST_MAIN $(FINAL_LIBS) -o /tmp/sds_test\n\t/tmp/sds_test\n\n.PHONY: lcov\n\nbench: $(REDIS_BENCHMARK_NAME)\n\t./$(REDIS_BENCHMARK_NAME)\n\n32bit:\n\t@echo \"\"\n\t@echo \"WARNING: if it fails under Linux you probably need to install libc6-dev-i386\"\n\t@echo \"\"\n\t$(MAKE) CFLAGS=\"-m32\" LDFLAGS=\"-m32\"\n\ngcov:\n\t$(MAKE) REDIS_CFLAGS=\"-fprofile-arcs -ftest-coverage -DCOVERAGE_TEST\" REDIS_LDFLAGS=\"-fprofile-arcs -ftest-coverage\"\n\nnoopt:\n\t$(MAKE) OPTIMIZATION=\"-O0\"\n\nvalgrind:\n\t$(MAKE) OPTIMIZATION=\"-O0\" MALLOC=\"libc\"\n\nhelgrind:\n\t$(MAKE) OPTIMIZATION=\"-O0\" MALLOC=\"libc\" CFLAGS=\"-D__ATOMIC_VAR_FORCE_SYNC_MACROS\"\n\nsrc/help.h:\n\t@../utils/generate-command-help.rb > help.h\n#将构建完成的可执行程序安装到指定的目录，-p选项自行创建多层目录\ninstall: all\n\t@mkdir -p $(INSTALL_BIN)\n\t$(REDIS_INSTALL) $(REDIS_SERVER_NAME) $(INSTALL_BIN)\n\t$(REDIS_INSTALL) $(REDIS_BENCHMARK_NAME) $(INSTALL_BIN)\n\t$(REDIS_INSTALL) $(REDIS_CLI_NAME) $(INSTALL_BIN)\n\t$(REDIS_INSTALL) $(REDIS_CHECK_RDB_NAME) $(INSTALL_BIN)\n\t$(REDIS_INSTALL) $(REDIS_CHECK_AOF_NAME) $(INSTALL_BIN)\n\t@ln -sf $(REDIS_SERVER_NAME) $(INSTALL_BIN)/$(REDIS_SENTINEL_NAME)\n\n```\n\n`uname_S := $(shell sh -c 'uname -s 2>/dev/null || echo not') ` 这一句-c让后面的字符串命令当成一个完成的命令来执行，从而避免向文件中写入东西的时候权限不够的问题。就算加上sudo也不行，因为里面的命令有>,echo等很多个文件，所以只能用-c来当成一个整体来执行。[参考](https://blog.csdn.net/bobchill/article/details/84647575)\n\n## Makefile思路\n\n总结一下Redis Makefile的思路：\n\n1. 在默认规则也就是第一条规则之前，通过变量设置好编译的相关选项：LDFLAGS，相应的对应关系REDIS_SERVER_OBJ，将规则的target用变量表示好（方便all规则里面用作前置条件），比如REDIS_SERVER_NAME。\n2. 在第一条默认规则 all规则里面指定需要构建的东西\n3. 在第一规则后面先完成链接，再完成编译的规则\n4. 其他功能性规则如clean和distclean\n\n也就是从上到下的结构是总-分。显示整个项目 ，然后是各个模块如redis-server，redis-cli的链接，然后是从源文件到obj文件的编译。\n\n## 参考\n\n<https://blog.csdn.net/bobchill/article/details/84647575>","slug":"2019-04-26-Redis-Makefile注解","published":1,"updated":"2019-11-08T13:13:23.742Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6he13yj000vdstz44zardas","content":"<h1 id=\"Redis-Makefile注解\"><a href=\"#Redis-Makefile注解\" class=\"headerlink\" title=\"Redis Makefile注解\"></a>Redis Makefile注解</h1><p>Redis的makefile是阅读源码的第一步，总共有292行，读起来也是头大，记录之。</p>\n<a id=\"more\"></a>\n<p>4.02版本源码为：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Redis Makefile</span></span><br><span class=\"line\"><span class=\"comment\"># Copyright (C) 2009 Salvatore Sanfilippo &lt;antirez at gmail dot com&gt;</span></span><br><span class=\"line\"><span class=\"comment\"># This file is released under the BSD license, see the COPYING file</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># The Makefile composes the final FINAL_CFLAGS and FINAL_LDFLAGS using</span></span><br><span class=\"line\"><span class=\"comment\"># what is needed for Redis plus the standard CFLAGS and LDFLAGS passed.</span></span><br><span class=\"line\"><span class=\"comment\"># However when building the dependencies (Jemalloc, Lua, Hiredis, ...)</span></span><br><span class=\"line\"><span class=\"comment\"># CFLAGS and LDFLAGS are propagated to the dependencies, so to pass</span></span><br><span class=\"line\"><span class=\"comment\"># flags only to be used when compiling / linking Redis itself REDIS_CFLAGS</span></span><br><span class=\"line\"><span class=\"comment\"># and REDIS_LDFLAGS are used instead (this is the case of 'make gcov').</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Dependencies are stored in the Makefile.dep file. To rebuild this file</span></span><br><span class=\"line\"><span class=\"comment\"># Just use 'make dep', but this is only needed by developers.</span></span><br><span class=\"line\"></span><br><span class=\"line\">release_hdr := <span class=\"variable\">$(<span class=\"built_in\">shell</span> sh -c './mkreleasehdr.sh')</span></span><br><span class=\"line\"><span class=\"comment\"># uname -s 获取操作系统的类型 Linux</span></span><br><span class=\"line\">uname_S := <span class=\"variable\">$(<span class=\"built_in\">shell</span> sh -c 'uname -s 2&gt;/dev/null || echo not')</span></span><br><span class=\"line\"><span class=\"comment\">#uname -m 获取机子的架构 x86_64</span></span><br><span class=\"line\">uname_M := <span class=\"variable\">$(<span class=\"built_in\">shell</span> sh -c 'uname -m 2&gt;/dev/null || echo not')</span></span><br><span class=\"line\"><span class=\"comment\"># 优化选项</span></span><br><span class=\"line\">OPTIMIZATION?=-O2</span><br><span class=\"line\"><span class=\"comment\"># 依赖目标</span></span><br><span class=\"line\">DEPENDENCY_TARGETS=hiredis linenoise lua</span><br><span class=\"line\">NODEPS:=clean distclean</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Default settings</span></span><br><span class=\"line\"><span class=\"comment\"># 使用c99标准编译，-pedantic 保证代码规范满足ISO C和ISO C++标准</span></span><br><span class=\"line\">STD=-std=c99 -pedantic -DREDIS_STATIC=''</span><br><span class=\"line\"><span class=\"comment\"># 输出所有编译警告信息 ，Wno-missing-field-initializers 不输出missing-的警告信息</span></span><br><span class=\"line\">WARN=-Wall -W -Wno-missing-field-initializers</span><br><span class=\"line\">OPT=<span class=\"variable\">$(OPTIMIZATION)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#默认目录</span></span><br><span class=\"line\">PREFIX?=/usr/local</span><br><span class=\"line\"><span class=\"comment\">#安装的默认目录</span></span><br><span class=\"line\">INSTALL_BIN=<span class=\"variable\">$(PREFIX)</span>/bin</span><br><span class=\"line\">INSTALL=install</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Default allocator defaults to Jemalloc if it's not an ARM</span></span><br><span class=\"line\"><span class=\"comment\">#内存分配器的指定 默认libc，linux系统而且架构不是armv61和71的时候则是jemalloc，</span></span><br><span class=\"line\">MALLOC=libc</span><br><span class=\"line\"><span class=\"keyword\">ifneq</span> (<span class=\"variable\">$(uname_M)</span>,armv6l)</span><br><span class=\"line\"><span class=\"keyword\">ifneq</span> (<span class=\"variable\">$(uname_M)</span>,armv7l)</span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(uname_S)</span>,Linux)</span><br><span class=\"line\">\tMALLOC=jemalloc</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># To get ARM stack traces if Redis crashes we need a special C flag.</span></span><br><span class=\"line\"><span class=\"keyword\">ifneq</span> (,<span class=\"variable\">$(<span class=\"built_in\">findstring</span> armv,<span class=\"variable\">$(uname_M)</span>)</span>)</span><br><span class=\"line\">        CFLAGS+=-funwind-tables</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Backwards compatibility for selecting an allocator</span></span><br><span class=\"line\"><span class=\"comment\">#编译的时候指定内存分配器</span></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(USE_TCMALLOC)</span>,yes)</span><br><span class=\"line\">\tMALLOC=tcmalloc</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(USE_TCMALLOC_MINIMAL)</span>,yes)</span><br><span class=\"line\">\tMALLOC=tcmalloc_minimal</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(USE_JEMALLOC)</span>,yes)</span><br><span class=\"line\">\tMALLOC=jemalloc</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(USE_JEMALLOC)</span>,no)</span><br><span class=\"line\">\tMALLOC=libc</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Override default settings if possible</span></span><br><span class=\"line\"><span class=\"keyword\">-include</span> .make-settings</span><br><span class=\"line\"><span class=\"comment\"># 最终的编译选项CFLAGS是-c的选项，LDFLAGS是链接的选项</span></span><br><span class=\"line\">FINAL_CFLAGS=<span class=\"variable\">$(STD)</span> <span class=\"variable\">$(WARN)</span> <span class=\"variable\">$(OPT)</span> <span class=\"variable\">$(DEBUG)</span> <span class=\"variable\">$(CFLAGS)</span> <span class=\"variable\">$(REDIS_CFLAGS)</span></span><br><span class=\"line\">FINAL_LDFLAGS=<span class=\"variable\">$(LDFLAGS)</span> <span class=\"variable\">$(REDIS_LDFLAGS)</span> <span class=\"variable\">$(DEBUG)</span></span><br><span class=\"line\"><span class=\"comment\"># m这个lib是libmath 也就是math的链接</span></span><br><span class=\"line\">FINAL_LIBS=-lm</span><br><span class=\"line\"><span class=\"comment\"># 调试信息</span></span><br><span class=\"line\">DEBUG=-g -ggdb</span><br><span class=\"line\"><span class=\"comment\">#根据操作系统继续指定编译选项</span></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(uname_S)</span>,SunOS)</span><br><span class=\"line\">\t<span class=\"comment\"># SunOS</span></span><br><span class=\"line\">        <span class=\"keyword\">ifneq</span> ($(@@),32bit)</span><br><span class=\"line\">\t\tCFLAGS+= -m64</span><br><span class=\"line\">\t\tLDFLAGS+= -m64</span><br><span class=\"line\">\t<span class=\"keyword\">endif</span></span><br><span class=\"line\">\tDEBUG=-g</span><br><span class=\"line\">\tDEBUG_FLAGS=-g</span><br><span class=\"line\">\t<span class=\"keyword\">export</span> CFLAGS LDFLAGS DEBUG DEBUG_FLAGS</span><br><span class=\"line\">\tINSTALL=cp -pf</span><br><span class=\"line\">\tFINAL_CFLAGS+= -D__EXTENSIONS__ -D_XPG6</span><br><span class=\"line\">\tFINAL_LIBS+= -ldl -lnsl -lsocket -lresolv -lpthread -lrt</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(uname_S)</span>,Darwin)</span><br><span class=\"line\">\t<span class=\"comment\"># Darwin</span></span><br><span class=\"line\">\tFINAL_LIBS+= -ldl</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(uname_S)</span>,AIX)</span><br><span class=\"line\">        <span class=\"comment\"># AIX</span></span><br><span class=\"line\">        FINAL_LDFLAGS+= -Wl,-bexpall</span><br><span class=\"line\">        FINAL_LIBS+=-ldl -pthread -lcrypt -lbsd</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(uname_S)</span>,OpenBSD)</span><br><span class=\"line\">\t<span class=\"comment\"># OpenBSD</span></span><br><span class=\"line\">\tFINAL_LIBS+= -lpthread</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(uname_S)</span>,FreeBSD)</span><br><span class=\"line\">\t<span class=\"comment\"># FreeBSD</span></span><br><span class=\"line\">\tFINAL_LIBS+= -lpthread</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">\t<span class=\"comment\"># 特别是对Linux的指定</span></span><br><span class=\"line\">\t<span class=\"comment\"># All the other OSes (notably Linux)</span></span><br><span class=\"line\">\t<span class=\"comment\"># -rdynamic将链接器将所有符号添加到动态符号表</span></span><br><span class=\"line\">\tFINAL_LDFLAGS+= -rdynamic</span><br><span class=\"line\">\t<span class=\"comment\">#pthread库 用于多线程， dl是libdl 动态链接库</span></span><br><span class=\"line\">\tFINAL_LIBS+=-ldl -pthread</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"><span class=\"comment\"># Include paths to dependencies</span></span><br><span class=\"line\"><span class=\"comment\"># -I 指定头文件的目录</span></span><br><span class=\"line\">FINAL_CFLAGS+= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(MALLOC)</span>,tcmalloc)</span><br><span class=\"line\">\tFINAL_CFLAGS+= -DUSE_TCMALLOC</span><br><span class=\"line\">\tFINAL_LIBS+= -ltcmalloc</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(MALLOC)</span>,tcmalloc_minimal)</span><br><span class=\"line\">\tFINAL_CFLAGS+= -DUSE_TCMALLOC</span><br><span class=\"line\">\tFINAL_LIBS+= -ltcmalloc_minimal</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"><span class=\"comment\">#使用jemalloc的话 链接 libjemalloc.a -I指定jemalloc的头文件目录</span></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(MALLOC)</span>,jemalloc)</span><br><span class=\"line\">\tDEPENDENCY_TARGETS+= jemalloc</span><br><span class=\"line\">\tFINAL_CFLAGS+= -DUSE_JEMALLOC -I../deps/jemalloc/<span class=\"keyword\">include</span></span><br><span class=\"line\">\tFINAL_LIBS+= ../deps/jemalloc/lib/libjemalloc.a</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"><span class=\"comment\">#redis 的gcc -c 选项</span></span><br><span class=\"line\">REDIS_CC=<span class=\"variable\">$(QUIET_CC)</span><span class=\"variable\">$(CC)</span> <span class=\"variable\">$(FINAL_CFLAGS)</span></span><br><span class=\"line\"><span class=\"comment\">#redis的gcc 链接选项</span></span><br><span class=\"line\">REDIS_LD=<span class=\"variable\">$(QUIET_LINK)</span><span class=\"variable\">$(CC)</span> <span class=\"variable\">$(FINAL_LDFLAGS)</span></span><br><span class=\"line\"><span class=\"comment\">#redis的安装选项</span></span><br><span class=\"line\">REDIS_INSTALL=<span class=\"variable\">$(QUIET_INSTALL)</span><span class=\"variable\">$(INSTALL)</span></span><br><span class=\"line\"></span><br><span class=\"line\">CCCOLOR=<span class=\"string\">\"\\033[34m\"</span></span><br><span class=\"line\">LINKCOLOR=<span class=\"string\">\"\\033[34;1m\"</span></span><br><span class=\"line\">SRCCOLOR=<span class=\"string\">\"\\033[33m\"</span></span><br><span class=\"line\">BINCOLOR=<span class=\"string\">\"\\033[37;1m\"</span></span><br><span class=\"line\">MAKECOLOR=<span class=\"string\">\"\\033[32;1m\"</span></span><br><span class=\"line\">ENDCOLOR=<span class=\"string\">\"\\033[0m\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ifndef</span> V</span><br><span class=\"line\">QUIET_CC = @printf '    %b %b\\n' <span class=\"variable\">$(CCCOLOR)</span>CC<span class=\"variable\">$(ENDCOLOR)</span> <span class=\"variable\">$(SRCCOLOR)</span><span class=\"variable\">$@</span><span class=\"variable\">$(ENDCOLOR)</span> 1&gt;&amp;2;</span><br><span class=\"line\">QUIET_LINK = @printf '    %b %b\\n' <span class=\"variable\">$(LINKCOLOR)</span>LINK<span class=\"variable\">$(ENDCOLOR)</span> <span class=\"variable\">$(BINCOLOR)</span><span class=\"variable\">$@</span><span class=\"variable\">$(ENDCOLOR)</span> 1&gt;&amp;2;</span><br><span class=\"line\">QUIET_INSTALL = @printf '    %b %b\\n' <span class=\"variable\">$(LINKCOLOR)</span>INSTALL<span class=\"variable\">$(ENDCOLOR)</span> <span class=\"variable\">$(BINCOLOR)</span><span class=\"variable\">$@</span><span class=\"variable\">$(ENDCOLOR)</span> 1&gt;&amp;2;</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"></span><br><span class=\"line\">REDIS_SERVER_NAME=redis-server</span><br><span class=\"line\">REDIS_SENTINEL_NAME=redis-sentinel</span><br><span class=\"line\"><span class=\"comment\"># redis-server的需要使用的对象文件，也就是各个模块</span></span><br><span class=\"line\">REDIS_SERVER_OBJ=adlist.o quicklist.o ae.o anet.o dict.o server.o sds.o zmalloc.o lzf_c.o lzf_d.o pqsort.o zipmap.o sha1.o ziplist.o release.o networking.o util.o object.o db.o replication.o rdb.o t_string.o t_list.o t_set.o t_zset.o t_hash.o config.o aof.o pubsub.o multi.o debug.o sort.o intset.o syncio.o cluster.o crc16.o endianconv.o slowlog.o scripting.o bio.o rio.o rand.o memtest.o crc64.o bitops.o sentinel.o notify.o setproctitle.o blocked.o hyperloglog.o latency.o sparkline.o redis-check-rdb.o redis-check-aof.o geo.o lazyfree.o module.o evict.o expire.o geohash.o geohash_helper.o childinfo.o defrag.o siphash.o rax.o</span><br><span class=\"line\">REDIS_CLI_NAME=redis-cli</span><br><span class=\"line\"><span class=\"comment\">#redis-cli 需要使用的对象文件</span></span><br><span class=\"line\">REDIS_CLI_OBJ=anet.o adlist.o redis-cli.o zmalloc.o release.o anet.o ae.o crc64.o</span><br><span class=\"line\">REDIS_BENCHMARK_NAME=redis-benchmark</span><br><span class=\"line\"><span class=\"comment\">#redis-benchmark需要使用的对象文件</span></span><br><span class=\"line\">REDIS_BENCHMARK_OBJ=ae.o anet.o redis-benchmark.o adlist.o zmalloc.o redis-benchmark.o</span><br><span class=\"line\">REDIS_CHECK_RDB_NAME=redis-check-rdb</span><br><span class=\"line\">REDIS_CHECK_AOF_NAME=redis-check-aof</span><br><span class=\"line\"><span class=\"comment\">#所有需要需要构建的对象，第一条规则也就是默认规则，不指定规则的话，从第一个规则执行</span></span><br><span class=\"line\"><span class=\"section\">all: <span class=\"variable\">$(REDIS_SERVER_NAME)</span> <span class=\"variable\">$(REDIS_SENTINEL_NAME)</span> <span class=\"variable\">$(REDIS_CLI_NAME)</span> <span class=\"variable\">$(REDIS_BENCHMARK_NAME)</span> <span class=\"variable\">$(REDIS_CHECK_RDB_NAME)</span> <span class=\"variable\">$(REDIS_CHECK_AOF_NAME)</span></span></span><br><span class=\"line\">\t@echo <span class=\"string\">\"\"</span></span><br><span class=\"line\">\t@echo <span class=\"string\">\"Hint: It's a good idea to run 'make test' ;)\"</span></span><br><span class=\"line\">\t@echo <span class=\"string\">\"\"</span></span><br><span class=\"line\"><span class=\"comment\">#Makefil.dep 的生成</span></span><br><span class=\"line\"><span class=\"section\">Makefile.dep:</span></span><br><span class=\"line\">\t-<span class=\"variable\">$(REDIS_CC)</span> -MM *.c &gt; Makefile.dep 2&gt; /dev/null || true</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (0, <span class=\"variable\">$(words $(<span class=\"built_in\">findstring</span> <span class=\"variable\">$(MAKECMDGOALS)</span>, <span class=\"variable\">$(NODEPS)</span>)</span>))</span><br><span class=\"line\"><span class=\"keyword\">-include</span> Makefile.dep</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"><span class=\"meta-keyword\">.PHONY</span>: all</span></span><br><span class=\"line\"><span class=\"comment\">#先清除所有编译的输出然后，  将所有设置持久化</span></span><br><span class=\"line\"><span class=\"section\">persist-settings: distclean</span></span><br><span class=\"line\">\techo STD=<span class=\"variable\">$(STD)</span> &gt;&gt; .make-settings</span><br><span class=\"line\">\techo WARN=<span class=\"variable\">$(WARN)</span> &gt;&gt; .make-settings</span><br><span class=\"line\">\techo OPT=<span class=\"variable\">$(OPT)</span> &gt;&gt; .make-settings</span><br><span class=\"line\">\techo MALLOC=<span class=\"variable\">$(MALLOC)</span> &gt;&gt; .make-settings</span><br><span class=\"line\">\techo CFLAGS=<span class=\"variable\">$(CFLAGS)</span> &gt;&gt; .make-settings</span><br><span class=\"line\">\techo LDFLAGS=<span class=\"variable\">$(LDFLAGS)</span> &gt;&gt; .make-settings</span><br><span class=\"line\">\techo REDIS_CFLAGS=<span class=\"variable\">$(REDIS_CFLAGS)</span> &gt;&gt; .make-settings</span><br><span class=\"line\">\techo REDIS_LDFLAGS=<span class=\"variable\">$(REDIS_LDFLAGS)</span> &gt;&gt; .make-settings</span><br><span class=\"line\">\techo PREV_FINAL_CFLAGS=<span class=\"variable\">$(FINAL_CFLAGS)</span> &gt;&gt; .make-settings</span><br><span class=\"line\">\techo PREV_FINAL_LDFLAGS=<span class=\"variable\">$(FINAL_LDFLAGS)</span> &gt;&gt; .make-settings</span><br><span class=\"line\">\t-(cd ../deps &amp;&amp; <span class=\"variable\">$(MAKE)</span> <span class=\"variable\">$(DEPENDENCY_TARGETS)</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"><span class=\"meta-keyword\">.PHONY</span>: persist-settings</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># Prerequisites target</span></span><br><span class=\"line\"><span class=\"section\">.make-prerequisites:</span></span><br><span class=\"line\">\t@touch <span class=\"variable\">$@</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Clean everything, persist settings and build dependencies if anything changed</span></span><br><span class=\"line\"><span class=\"comment\">#当设置有变化的时候清除并重新持久化设置</span></span><br><span class=\"line\"><span class=\"keyword\">ifneq</span> (<span class=\"variable\">$(<span class=\"built_in\">strip</span> <span class=\"variable\">$(PREV_FINAL_CFLAGS)</span>)</span>, <span class=\"variable\">$(<span class=\"built_in\">strip</span> <span class=\"variable\">$(FINAL_CFLAGS)</span>)</span>)</span><br><span class=\"line\"><span class=\"section\">.make-prerequisites: persist-settings</span></span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ifneq</span> (<span class=\"variable\">$(<span class=\"built_in\">strip</span> <span class=\"variable\">$(PREV_FINAL_LDFLAGS)</span>)</span>, <span class=\"variable\">$(<span class=\"built_in\">strip</span> <span class=\"variable\">$(FINAL_LDFLAGS)</span>)</span>)</span><br><span class=\"line\"><span class=\"section\">.make-prerequisites: persist-settings</span></span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># redis-server</span></span><br><span class=\"line\"><span class=\"comment\">#redis-server可执行程序的链接，需要链接的静态链接文件包括hiredi和lua,还有final_libs</span></span><br><span class=\"line\"><span class=\"variable\">$(REDIS_SERVER_NAME)</span>: <span class=\"variable\">$(REDIS_SERVER_OBJ)</span></span><br><span class=\"line\">\t<span class=\"variable\">$(REDIS_LD)</span> -o <span class=\"variable\">$@</span> <span class=\"variable\">$^</span> ../deps/hiredis/libhiredis.a ../deps/lua/src/liblua.a <span class=\"variable\">$(FINAL_LIBS)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># redis-sentinel</span></span><br><span class=\"line\"><span class=\"comment\">#redis-sentienl构建</span></span><br><span class=\"line\"><span class=\"variable\">$(REDIS_SENTINEL_NAME)</span>: <span class=\"variable\">$(REDIS_SERVER_NAME)</span></span><br><span class=\"line\">\t<span class=\"variable\">$(REDIS_INSTALL)</span> <span class=\"variable\">$(REDIS_SERVER_NAME)</span> <span class=\"variable\">$(REDIS_SENTINEL_NAME)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># redis-check-rdb</span></span><br><span class=\"line\"><span class=\"comment\">#redis-check-rdb的构建</span></span><br><span class=\"line\"><span class=\"variable\">$(REDIS_CHECK_RDB_NAME)</span>: <span class=\"variable\">$(REDIS_SERVER_NAME)</span></span><br><span class=\"line\">\t<span class=\"variable\">$(REDIS_INSTALL)</span> <span class=\"variable\">$(REDIS_SERVER_NAME)</span> <span class=\"variable\">$(REDIS_CHECK_RDB_NAME)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># redis-check-aof</span></span><br><span class=\"line\"><span class=\"comment\">#redis-check-aof的构建</span></span><br><span class=\"line\"><span class=\"variable\">$(REDIS_CHECK_AOF_NAME)</span>: <span class=\"variable\">$(REDIS_SERVER_NAME)</span></span><br><span class=\"line\">\t<span class=\"variable\">$(REDIS_INSTALL)</span> <span class=\"variable\">$(REDIS_SERVER_NAME)</span> <span class=\"variable\">$(REDIS_CHECK_AOF_NAME)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># redis-cli</span></span><br><span class=\"line\"><span class=\"comment\">#redis-cli的链接</span></span><br><span class=\"line\"><span class=\"variable\">$(REDIS_CLI_NAME)</span>: <span class=\"variable\">$(REDIS_CLI_OBJ)</span></span><br><span class=\"line\">\t<span class=\"variable\">$(REDIS_LD)</span> -o <span class=\"variable\">$@</span> <span class=\"variable\">$^</span> ../deps/hiredis/libhiredis.a ../deps/linenoise/linenoise.o <span class=\"variable\">$(FINAL_LIBS)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># redis-benchmark</span></span><br><span class=\"line\"><span class=\"comment\">#redis-benchmark的链接</span></span><br><span class=\"line\"><span class=\"variable\">$(REDIS_BENCHMARK_NAME)</span>: <span class=\"variable\">$(REDIS_BENCHMARK_OBJ)</span></span><br><span class=\"line\">\t<span class=\"variable\">$(REDIS_LD)</span> -o <span class=\"variable\">$@</span> <span class=\"variable\">$^</span> ../deps/hiredis/libhiredis.a <span class=\"variable\">$(FINAL_LIBS)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">dict-benchmark: dict.c zmalloc.c sds.c siphash.c</span></span><br><span class=\"line\">\t<span class=\"variable\">$(REDIS_CC)</span> <span class=\"variable\">$(FINAL_CFLAGS)</span> <span class=\"variable\">$^</span> -D DICT_BENCHMARK_MAIN -o <span class=\"variable\">$@</span> <span class=\"variable\">$(FINAL_LIBS)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Because the jemalloc.h header is generated as a part of the jemalloc build,</span></span><br><span class=\"line\"><span class=\"comment\"># building it should complete before building any other object. Instead of</span></span><br><span class=\"line\"><span class=\"comment\"># depending on a single artifact, build all dependencies first.</span></span><br><span class=\"line\"><span class=\"comment\">#将所有点c文件编译成.o文件 自动完成file.c 到file.o的对应</span></span><br><span class=\"line\"><span class=\"section\">%.o: %.c .make-prerequisites</span></span><br><span class=\"line\">\t<span class=\"variable\">$(REDIS_CC)</span> -c <span class=\"variable\">$&lt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">clean:</span></span><br><span class=\"line\">\trm -rf <span class=\"variable\">$(REDIS_SERVER_NAME)</span> <span class=\"variable\">$(REDIS_SENTINEL_NAME)</span> <span class=\"variable\">$(REDIS_CLI_NAME)</span> <span class=\"variable\">$(REDIS_BENCHMARK_NAME)</span> <span class=\"variable\">$(REDIS_CHECK_RDB_NAME)</span> <span class=\"variable\">$(REDIS_CHECK_AOF_NAME)</span> *.o *.gcda *.gcno *.gcov redis.info lcov-html Makefile.dep dict-benchmark</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"><span class=\"meta-keyword\">.PHONY</span>: clean</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">distclean: clean</span></span><br><span class=\"line\">\t-(cd ../deps &amp;&amp; <span class=\"variable\">$(MAKE)</span> distclean)</span><br><span class=\"line\">\t-(rm -f .make-*)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"><span class=\"meta-keyword\">.PHONY</span>: distclean</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">test: <span class=\"variable\">$(REDIS_SERVER_NAME)</span> <span class=\"variable\">$(REDIS_CHECK_AOF_NAME)</span></span></span><br><span class=\"line\">\t@(cd ..; ./runtest)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">test-sentinel: <span class=\"variable\">$(REDIS_SENTINEL_NAME)</span></span></span><br><span class=\"line\">\t@(cd ..; ./runtest-sentinel)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">check: test</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">lcov:</span></span><br><span class=\"line\">\t<span class=\"variable\">$(MAKE)</span> gcov</span><br><span class=\"line\">\t@(set -e; cd ..; ./runtest --clients 1)</span><br><span class=\"line\">\t@geninfo -o redis.info .</span><br><span class=\"line\">\t@genhtml --legend -o lcov-html redis.info</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">test-sds: sds.c sds.h</span></span><br><span class=\"line\">\t<span class=\"variable\">$(REDIS_CC)</span> sds.c zmalloc.c -DSDS_TEST_MAIN <span class=\"variable\">$(FINAL_LIBS)</span> -o /tmp/sds_test</span><br><span class=\"line\">\t/tmp/sds_test</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"><span class=\"meta-keyword\">.PHONY</span>: lcov</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">bench: <span class=\"variable\">$(REDIS_BENCHMARK_NAME)</span></span></span><br><span class=\"line\">\t./<span class=\"variable\">$(REDIS_BENCHMARK_NAME)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">32bit:</span></span><br><span class=\"line\">\t@echo <span class=\"string\">\"\"</span></span><br><span class=\"line\">\t@echo <span class=\"string\">\"WARNING: if it fails under Linux you probably need to install libc6-dev-i386\"</span></span><br><span class=\"line\">\t@echo <span class=\"string\">\"\"</span></span><br><span class=\"line\">\t<span class=\"variable\">$(MAKE)</span> CFLAGS=<span class=\"string\">\"-m32\"</span> LDFLAGS=<span class=\"string\">\"-m32\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">gcov:</span></span><br><span class=\"line\">\t<span class=\"variable\">$(MAKE)</span> REDIS_CFLAGS=<span class=\"string\">\"-fprofile-arcs -ftest-coverage -DCOVERAGE_TEST\"</span> REDIS_LDFLAGS=<span class=\"string\">\"-fprofile-arcs -ftest-coverage\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">noopt:</span></span><br><span class=\"line\">\t<span class=\"variable\">$(MAKE)</span> OPTIMIZATION=<span class=\"string\">\"-O0\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">valgrind:</span></span><br><span class=\"line\">\t<span class=\"variable\">$(MAKE)</span> OPTIMIZATION=<span class=\"string\">\"-O0\"</span> MALLOC=<span class=\"string\">\"libc\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">helgrind:</span></span><br><span class=\"line\">\t<span class=\"variable\">$(MAKE)</span> OPTIMIZATION=<span class=\"string\">\"-O0\"</span> MALLOC=<span class=\"string\">\"libc\"</span> CFLAGS=<span class=\"string\">\"-D__ATOMIC_VAR_FORCE_SYNC_MACROS\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">src/help.h:</span></span><br><span class=\"line\">\t@../utils/generate-command-help.rb &gt; help.h</span><br><span class=\"line\"><span class=\"comment\">#将构建完成的可执行程序安装到指定的目录，-p选项自行创建多层目录</span></span><br><span class=\"line\"><span class=\"section\">install: all</span></span><br><span class=\"line\">\t@mkdir -p <span class=\"variable\">$(INSTALL_BIN)</span></span><br><span class=\"line\">\t<span class=\"variable\">$(REDIS_INSTALL)</span> <span class=\"variable\">$(REDIS_SERVER_NAME)</span> <span class=\"variable\">$(INSTALL_BIN)</span></span><br><span class=\"line\">\t<span class=\"variable\">$(REDIS_INSTALL)</span> <span class=\"variable\">$(REDIS_BENCHMARK_NAME)</span> <span class=\"variable\">$(INSTALL_BIN)</span></span><br><span class=\"line\">\t<span class=\"variable\">$(REDIS_INSTALL)</span> <span class=\"variable\">$(REDIS_CLI_NAME)</span> <span class=\"variable\">$(INSTALL_BIN)</span></span><br><span class=\"line\">\t<span class=\"variable\">$(REDIS_INSTALL)</span> <span class=\"variable\">$(REDIS_CHECK_RDB_NAME)</span> <span class=\"variable\">$(INSTALL_BIN)</span></span><br><span class=\"line\">\t<span class=\"variable\">$(REDIS_INSTALL)</span> <span class=\"variable\">$(REDIS_CHECK_AOF_NAME)</span> <span class=\"variable\">$(INSTALL_BIN)</span></span><br><span class=\"line\">\t@ln -sf <span class=\"variable\">$(REDIS_SERVER_NAME)</span> <span class=\"variable\">$(INSTALL_BIN)</span>/<span class=\"variable\">$(REDIS_SENTINEL_NAME)</span></span><br></pre></td></tr></table></figure>\n<p><code>uname_S := $(shell sh -c &#39;uname -s 2&gt;/dev/null || echo not&#39;)</code> 这一句-c让后面的字符串命令当成一个完成的命令来执行，从而避免向文件中写入东西的时候权限不够的问题。就算加上sudo也不行，因为里面的命令有&gt;,echo等很多个文件，所以只能用-c来当成一个整体来执行。<a href=\"https://blog.csdn.net/bobchill/article/details/84647575\" target=\"_blank\" rel=\"noopener\">参考</a></p>\n<h2 id=\"Makefile思路\"><a href=\"#Makefile思路\" class=\"headerlink\" title=\"Makefile思路\"></a>Makefile思路</h2><p>总结一下Redis Makefile的思路：</p>\n<ol>\n<li>在默认规则也就是第一条规则之前，通过变量设置好编译的相关选项：LDFLAGS，相应的对应关系REDIS_SERVER_OBJ，将规则的target用变量表示好（方便all规则里面用作前置条件），比如REDIS_SERVER_NAME。</li>\n<li>在第一条默认规则 all规则里面指定需要构建的东西</li>\n<li>在第一规则后面先完成链接，再完成编译的规则</li>\n<li>其他功能性规则如clean和distclean</li>\n</ol>\n<p>也就是从上到下的结构是总-分。显示整个项目 ，然后是各个模块如redis-server，redis-cli的链接，然后是从源文件到obj文件的编译。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://blog.csdn.net/bobchill/article/details/84647575\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/bobchill/article/details/84647575</a></p>\n","site":{"data":{}},"length":10300,"excerpt":"<h1 id=\"Redis-Makefile注解\"><a href=\"#Redis-Makefile注解\" class=\"headerlink\" title=\"Redis Makefile注解\"></a>Redis Makefile注解</h1><p>Redis的makefile是阅读源码的第一步，总共有292行，读起来也是头大，记录之。</p>","more":"<p>4.02版本源码为：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Redis Makefile</span></span><br><span class=\"line\"><span class=\"comment\"># Copyright (C) 2009 Salvatore Sanfilippo &lt;antirez at gmail dot com&gt;</span></span><br><span class=\"line\"><span class=\"comment\"># This file is released under the BSD license, see the COPYING file</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># The Makefile composes the final FINAL_CFLAGS and FINAL_LDFLAGS using</span></span><br><span class=\"line\"><span class=\"comment\"># what is needed for Redis plus the standard CFLAGS and LDFLAGS passed.</span></span><br><span class=\"line\"><span class=\"comment\"># However when building the dependencies (Jemalloc, Lua, Hiredis, ...)</span></span><br><span class=\"line\"><span class=\"comment\"># CFLAGS and LDFLAGS are propagated to the dependencies, so to pass</span></span><br><span class=\"line\"><span class=\"comment\"># flags only to be used when compiling / linking Redis itself REDIS_CFLAGS</span></span><br><span class=\"line\"><span class=\"comment\"># and REDIS_LDFLAGS are used instead (this is the case of 'make gcov').</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Dependencies are stored in the Makefile.dep file. To rebuild this file</span></span><br><span class=\"line\"><span class=\"comment\"># Just use 'make dep', but this is only needed by developers.</span></span><br><span class=\"line\"></span><br><span class=\"line\">release_hdr := <span class=\"variable\">$(<span class=\"built_in\">shell</span> sh -c './mkreleasehdr.sh')</span></span><br><span class=\"line\"><span class=\"comment\"># uname -s 获取操作系统的类型 Linux</span></span><br><span class=\"line\">uname_S := <span class=\"variable\">$(<span class=\"built_in\">shell</span> sh -c 'uname -s 2&gt;/dev/null || echo not')</span></span><br><span class=\"line\"><span class=\"comment\">#uname -m 获取机子的架构 x86_64</span></span><br><span class=\"line\">uname_M := <span class=\"variable\">$(<span class=\"built_in\">shell</span> sh -c 'uname -m 2&gt;/dev/null || echo not')</span></span><br><span class=\"line\"><span class=\"comment\"># 优化选项</span></span><br><span class=\"line\">OPTIMIZATION?=-O2</span><br><span class=\"line\"><span class=\"comment\"># 依赖目标</span></span><br><span class=\"line\">DEPENDENCY_TARGETS=hiredis linenoise lua</span><br><span class=\"line\">NODEPS:=clean distclean</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Default settings</span></span><br><span class=\"line\"><span class=\"comment\"># 使用c99标准编译，-pedantic 保证代码规范满足ISO C和ISO C++标准</span></span><br><span class=\"line\">STD=-std=c99 -pedantic -DREDIS_STATIC=''</span><br><span class=\"line\"><span class=\"comment\"># 输出所有编译警告信息 ，Wno-missing-field-initializers 不输出missing-的警告信息</span></span><br><span class=\"line\">WARN=-Wall -W -Wno-missing-field-initializers</span><br><span class=\"line\">OPT=<span class=\"variable\">$(OPTIMIZATION)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#默认目录</span></span><br><span class=\"line\">PREFIX?=/usr/local</span><br><span class=\"line\"><span class=\"comment\">#安装的默认目录</span></span><br><span class=\"line\">INSTALL_BIN=<span class=\"variable\">$(PREFIX)</span>/bin</span><br><span class=\"line\">INSTALL=install</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Default allocator defaults to Jemalloc if it's not an ARM</span></span><br><span class=\"line\"><span class=\"comment\">#内存分配器的指定 默认libc，linux系统而且架构不是armv61和71的时候则是jemalloc，</span></span><br><span class=\"line\">MALLOC=libc</span><br><span class=\"line\"><span class=\"keyword\">ifneq</span> (<span class=\"variable\">$(uname_M)</span>,armv6l)</span><br><span class=\"line\"><span class=\"keyword\">ifneq</span> (<span class=\"variable\">$(uname_M)</span>,armv7l)</span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(uname_S)</span>,Linux)</span><br><span class=\"line\">\tMALLOC=jemalloc</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># To get ARM stack traces if Redis crashes we need a special C flag.</span></span><br><span class=\"line\"><span class=\"keyword\">ifneq</span> (,<span class=\"variable\">$(<span class=\"built_in\">findstring</span> armv,<span class=\"variable\">$(uname_M)</span>)</span>)</span><br><span class=\"line\">        CFLAGS+=-funwind-tables</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Backwards compatibility for selecting an allocator</span></span><br><span class=\"line\"><span class=\"comment\">#编译的时候指定内存分配器</span></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(USE_TCMALLOC)</span>,yes)</span><br><span class=\"line\">\tMALLOC=tcmalloc</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(USE_TCMALLOC_MINIMAL)</span>,yes)</span><br><span class=\"line\">\tMALLOC=tcmalloc_minimal</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(USE_JEMALLOC)</span>,yes)</span><br><span class=\"line\">\tMALLOC=jemalloc</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(USE_JEMALLOC)</span>,no)</span><br><span class=\"line\">\tMALLOC=libc</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Override default settings if possible</span></span><br><span class=\"line\"><span class=\"keyword\">-include</span> .make-settings</span><br><span class=\"line\"><span class=\"comment\"># 最终的编译选项CFLAGS是-c的选项，LDFLAGS是链接的选项</span></span><br><span class=\"line\">FINAL_CFLAGS=<span class=\"variable\">$(STD)</span> <span class=\"variable\">$(WARN)</span> <span class=\"variable\">$(OPT)</span> <span class=\"variable\">$(DEBUG)</span> <span class=\"variable\">$(CFLAGS)</span> <span class=\"variable\">$(REDIS_CFLAGS)</span></span><br><span class=\"line\">FINAL_LDFLAGS=<span class=\"variable\">$(LDFLAGS)</span> <span class=\"variable\">$(REDIS_LDFLAGS)</span> <span class=\"variable\">$(DEBUG)</span></span><br><span class=\"line\"><span class=\"comment\"># m这个lib是libmath 也就是math的链接</span></span><br><span class=\"line\">FINAL_LIBS=-lm</span><br><span class=\"line\"><span class=\"comment\"># 调试信息</span></span><br><span class=\"line\">DEBUG=-g -ggdb</span><br><span class=\"line\"><span class=\"comment\">#根据操作系统继续指定编译选项</span></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(uname_S)</span>,SunOS)</span><br><span class=\"line\">\t<span class=\"comment\"># SunOS</span></span><br><span class=\"line\">        <span class=\"keyword\">ifneq</span> ($(@@),32bit)</span><br><span class=\"line\">\t\tCFLAGS+= -m64</span><br><span class=\"line\">\t\tLDFLAGS+= -m64</span><br><span class=\"line\">\t<span class=\"keyword\">endif</span></span><br><span class=\"line\">\tDEBUG=-g</span><br><span class=\"line\">\tDEBUG_FLAGS=-g</span><br><span class=\"line\">\t<span class=\"keyword\">export</span> CFLAGS LDFLAGS DEBUG DEBUG_FLAGS</span><br><span class=\"line\">\tINSTALL=cp -pf</span><br><span class=\"line\">\tFINAL_CFLAGS+= -D__EXTENSIONS__ -D_XPG6</span><br><span class=\"line\">\tFINAL_LIBS+= -ldl -lnsl -lsocket -lresolv -lpthread -lrt</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(uname_S)</span>,Darwin)</span><br><span class=\"line\">\t<span class=\"comment\"># Darwin</span></span><br><span class=\"line\">\tFINAL_LIBS+= -ldl</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(uname_S)</span>,AIX)</span><br><span class=\"line\">        <span class=\"comment\"># AIX</span></span><br><span class=\"line\">        FINAL_LDFLAGS+= -Wl,-bexpall</span><br><span class=\"line\">        FINAL_LIBS+=-ldl -pthread -lcrypt -lbsd</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(uname_S)</span>,OpenBSD)</span><br><span class=\"line\">\t<span class=\"comment\"># OpenBSD</span></span><br><span class=\"line\">\tFINAL_LIBS+= -lpthread</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(uname_S)</span>,FreeBSD)</span><br><span class=\"line\">\t<span class=\"comment\"># FreeBSD</span></span><br><span class=\"line\">\tFINAL_LIBS+= -lpthread</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">\t<span class=\"comment\"># 特别是对Linux的指定</span></span><br><span class=\"line\">\t<span class=\"comment\"># All the other OSes (notably Linux)</span></span><br><span class=\"line\">\t<span class=\"comment\"># -rdynamic将链接器将所有符号添加到动态符号表</span></span><br><span class=\"line\">\tFINAL_LDFLAGS+= -rdynamic</span><br><span class=\"line\">\t<span class=\"comment\">#pthread库 用于多线程， dl是libdl 动态链接库</span></span><br><span class=\"line\">\tFINAL_LIBS+=-ldl -pthread</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"><span class=\"comment\"># Include paths to dependencies</span></span><br><span class=\"line\"><span class=\"comment\"># -I 指定头文件的目录</span></span><br><span class=\"line\">FINAL_CFLAGS+= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(MALLOC)</span>,tcmalloc)</span><br><span class=\"line\">\tFINAL_CFLAGS+= -DUSE_TCMALLOC</span><br><span class=\"line\">\tFINAL_LIBS+= -ltcmalloc</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(MALLOC)</span>,tcmalloc_minimal)</span><br><span class=\"line\">\tFINAL_CFLAGS+= -DUSE_TCMALLOC</span><br><span class=\"line\">\tFINAL_LIBS+= -ltcmalloc_minimal</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"><span class=\"comment\">#使用jemalloc的话 链接 libjemalloc.a -I指定jemalloc的头文件目录</span></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(MALLOC)</span>,jemalloc)</span><br><span class=\"line\">\tDEPENDENCY_TARGETS+= jemalloc</span><br><span class=\"line\">\tFINAL_CFLAGS+= -DUSE_JEMALLOC -I../deps/jemalloc/<span class=\"keyword\">include</span></span><br><span class=\"line\">\tFINAL_LIBS+= ../deps/jemalloc/lib/libjemalloc.a</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"><span class=\"comment\">#redis 的gcc -c 选项</span></span><br><span class=\"line\">REDIS_CC=<span class=\"variable\">$(QUIET_CC)</span><span class=\"variable\">$(CC)</span> <span class=\"variable\">$(FINAL_CFLAGS)</span></span><br><span class=\"line\"><span class=\"comment\">#redis的gcc 链接选项</span></span><br><span class=\"line\">REDIS_LD=<span class=\"variable\">$(QUIET_LINK)</span><span class=\"variable\">$(CC)</span> <span class=\"variable\">$(FINAL_LDFLAGS)</span></span><br><span class=\"line\"><span class=\"comment\">#redis的安装选项</span></span><br><span class=\"line\">REDIS_INSTALL=<span class=\"variable\">$(QUIET_INSTALL)</span><span class=\"variable\">$(INSTALL)</span></span><br><span class=\"line\"></span><br><span class=\"line\">CCCOLOR=<span class=\"string\">\"\\033[34m\"</span></span><br><span class=\"line\">LINKCOLOR=<span class=\"string\">\"\\033[34;1m\"</span></span><br><span class=\"line\">SRCCOLOR=<span class=\"string\">\"\\033[33m\"</span></span><br><span class=\"line\">BINCOLOR=<span class=\"string\">\"\\033[37;1m\"</span></span><br><span class=\"line\">MAKECOLOR=<span class=\"string\">\"\\033[32;1m\"</span></span><br><span class=\"line\">ENDCOLOR=<span class=\"string\">\"\\033[0m\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ifndef</span> V</span><br><span class=\"line\">QUIET_CC = @printf '    %b %b\\n' <span class=\"variable\">$(CCCOLOR)</span>CC<span class=\"variable\">$(ENDCOLOR)</span> <span class=\"variable\">$(SRCCOLOR)</span><span class=\"variable\">$@</span><span class=\"variable\">$(ENDCOLOR)</span> 1&gt;&amp;2;</span><br><span class=\"line\">QUIET_LINK = @printf '    %b %b\\n' <span class=\"variable\">$(LINKCOLOR)</span>LINK<span class=\"variable\">$(ENDCOLOR)</span> <span class=\"variable\">$(BINCOLOR)</span><span class=\"variable\">$@</span><span class=\"variable\">$(ENDCOLOR)</span> 1&gt;&amp;2;</span><br><span class=\"line\">QUIET_INSTALL = @printf '    %b %b\\n' <span class=\"variable\">$(LINKCOLOR)</span>INSTALL<span class=\"variable\">$(ENDCOLOR)</span> <span class=\"variable\">$(BINCOLOR)</span><span class=\"variable\">$@</span><span class=\"variable\">$(ENDCOLOR)</span> 1&gt;&amp;2;</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"></span><br><span class=\"line\">REDIS_SERVER_NAME=redis-server</span><br><span class=\"line\">REDIS_SENTINEL_NAME=redis-sentinel</span><br><span class=\"line\"><span class=\"comment\"># redis-server的需要使用的对象文件，也就是各个模块</span></span><br><span class=\"line\">REDIS_SERVER_OBJ=adlist.o quicklist.o ae.o anet.o dict.o server.o sds.o zmalloc.o lzf_c.o lzf_d.o pqsort.o zipmap.o sha1.o ziplist.o release.o networking.o util.o object.o db.o replication.o rdb.o t_string.o t_list.o t_set.o t_zset.o t_hash.o config.o aof.o pubsub.o multi.o debug.o sort.o intset.o syncio.o cluster.o crc16.o endianconv.o slowlog.o scripting.o bio.o rio.o rand.o memtest.o crc64.o bitops.o sentinel.o notify.o setproctitle.o blocked.o hyperloglog.o latency.o sparkline.o redis-check-rdb.o redis-check-aof.o geo.o lazyfree.o module.o evict.o expire.o geohash.o geohash_helper.o childinfo.o defrag.o siphash.o rax.o</span><br><span class=\"line\">REDIS_CLI_NAME=redis-cli</span><br><span class=\"line\"><span class=\"comment\">#redis-cli 需要使用的对象文件</span></span><br><span class=\"line\">REDIS_CLI_OBJ=anet.o adlist.o redis-cli.o zmalloc.o release.o anet.o ae.o crc64.o</span><br><span class=\"line\">REDIS_BENCHMARK_NAME=redis-benchmark</span><br><span class=\"line\"><span class=\"comment\">#redis-benchmark需要使用的对象文件</span></span><br><span class=\"line\">REDIS_BENCHMARK_OBJ=ae.o anet.o redis-benchmark.o adlist.o zmalloc.o redis-benchmark.o</span><br><span class=\"line\">REDIS_CHECK_RDB_NAME=redis-check-rdb</span><br><span class=\"line\">REDIS_CHECK_AOF_NAME=redis-check-aof</span><br><span class=\"line\"><span class=\"comment\">#所有需要需要构建的对象，第一条规则也就是默认规则，不指定规则的话，从第一个规则执行</span></span><br><span class=\"line\"><span class=\"section\">all: <span class=\"variable\">$(REDIS_SERVER_NAME)</span> <span class=\"variable\">$(REDIS_SENTINEL_NAME)</span> <span class=\"variable\">$(REDIS_CLI_NAME)</span> <span class=\"variable\">$(REDIS_BENCHMARK_NAME)</span> <span class=\"variable\">$(REDIS_CHECK_RDB_NAME)</span> <span class=\"variable\">$(REDIS_CHECK_AOF_NAME)</span></span></span><br><span class=\"line\">\t@echo <span class=\"string\">\"\"</span></span><br><span class=\"line\">\t@echo <span class=\"string\">\"Hint: It's a good idea to run 'make test' ;)\"</span></span><br><span class=\"line\">\t@echo <span class=\"string\">\"\"</span></span><br><span class=\"line\"><span class=\"comment\">#Makefil.dep 的生成</span></span><br><span class=\"line\"><span class=\"section\">Makefile.dep:</span></span><br><span class=\"line\">\t-<span class=\"variable\">$(REDIS_CC)</span> -MM *.c &gt; Makefile.dep 2&gt; /dev/null || true</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (0, <span class=\"variable\">$(words $(<span class=\"built_in\">findstring</span> <span class=\"variable\">$(MAKECMDGOALS)</span>, <span class=\"variable\">$(NODEPS)</span>)</span>))</span><br><span class=\"line\"><span class=\"keyword\">-include</span> Makefile.dep</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"><span class=\"meta-keyword\">.PHONY</span>: all</span></span><br><span class=\"line\"><span class=\"comment\">#先清除所有编译的输出然后，  将所有设置持久化</span></span><br><span class=\"line\"><span class=\"section\">persist-settings: distclean</span></span><br><span class=\"line\">\techo STD=<span class=\"variable\">$(STD)</span> &gt;&gt; .make-settings</span><br><span class=\"line\">\techo WARN=<span class=\"variable\">$(WARN)</span> &gt;&gt; .make-settings</span><br><span class=\"line\">\techo OPT=<span class=\"variable\">$(OPT)</span> &gt;&gt; .make-settings</span><br><span class=\"line\">\techo MALLOC=<span class=\"variable\">$(MALLOC)</span> &gt;&gt; .make-settings</span><br><span class=\"line\">\techo CFLAGS=<span class=\"variable\">$(CFLAGS)</span> &gt;&gt; .make-settings</span><br><span class=\"line\">\techo LDFLAGS=<span class=\"variable\">$(LDFLAGS)</span> &gt;&gt; .make-settings</span><br><span class=\"line\">\techo REDIS_CFLAGS=<span class=\"variable\">$(REDIS_CFLAGS)</span> &gt;&gt; .make-settings</span><br><span class=\"line\">\techo REDIS_LDFLAGS=<span class=\"variable\">$(REDIS_LDFLAGS)</span> &gt;&gt; .make-settings</span><br><span class=\"line\">\techo PREV_FINAL_CFLAGS=<span class=\"variable\">$(FINAL_CFLAGS)</span> &gt;&gt; .make-settings</span><br><span class=\"line\">\techo PREV_FINAL_LDFLAGS=<span class=\"variable\">$(FINAL_LDFLAGS)</span> &gt;&gt; .make-settings</span><br><span class=\"line\">\t-(cd ../deps &amp;&amp; <span class=\"variable\">$(MAKE)</span> <span class=\"variable\">$(DEPENDENCY_TARGETS)</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"><span class=\"meta-keyword\">.PHONY</span>: persist-settings</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># Prerequisites target</span></span><br><span class=\"line\"><span class=\"section\">.make-prerequisites:</span></span><br><span class=\"line\">\t@touch <span class=\"variable\">$@</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Clean everything, persist settings and build dependencies if anything changed</span></span><br><span class=\"line\"><span class=\"comment\">#当设置有变化的时候清除并重新持久化设置</span></span><br><span class=\"line\"><span class=\"keyword\">ifneq</span> (<span class=\"variable\">$(<span class=\"built_in\">strip</span> <span class=\"variable\">$(PREV_FINAL_CFLAGS)</span>)</span>, <span class=\"variable\">$(<span class=\"built_in\">strip</span> <span class=\"variable\">$(FINAL_CFLAGS)</span>)</span>)</span><br><span class=\"line\"><span class=\"section\">.make-prerequisites: persist-settings</span></span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ifneq</span> (<span class=\"variable\">$(<span class=\"built_in\">strip</span> <span class=\"variable\">$(PREV_FINAL_LDFLAGS)</span>)</span>, <span class=\"variable\">$(<span class=\"built_in\">strip</span> <span class=\"variable\">$(FINAL_LDFLAGS)</span>)</span>)</span><br><span class=\"line\"><span class=\"section\">.make-prerequisites: persist-settings</span></span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># redis-server</span></span><br><span class=\"line\"><span class=\"comment\">#redis-server可执行程序的链接，需要链接的静态链接文件包括hiredi和lua,还有final_libs</span></span><br><span class=\"line\"><span class=\"variable\">$(REDIS_SERVER_NAME)</span>: <span class=\"variable\">$(REDIS_SERVER_OBJ)</span></span><br><span class=\"line\">\t<span class=\"variable\">$(REDIS_LD)</span> -o <span class=\"variable\">$@</span> <span class=\"variable\">$^</span> ../deps/hiredis/libhiredis.a ../deps/lua/src/liblua.a <span class=\"variable\">$(FINAL_LIBS)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># redis-sentinel</span></span><br><span class=\"line\"><span class=\"comment\">#redis-sentienl构建</span></span><br><span class=\"line\"><span class=\"variable\">$(REDIS_SENTINEL_NAME)</span>: <span class=\"variable\">$(REDIS_SERVER_NAME)</span></span><br><span class=\"line\">\t<span class=\"variable\">$(REDIS_INSTALL)</span> <span class=\"variable\">$(REDIS_SERVER_NAME)</span> <span class=\"variable\">$(REDIS_SENTINEL_NAME)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># redis-check-rdb</span></span><br><span class=\"line\"><span class=\"comment\">#redis-check-rdb的构建</span></span><br><span class=\"line\"><span class=\"variable\">$(REDIS_CHECK_RDB_NAME)</span>: <span class=\"variable\">$(REDIS_SERVER_NAME)</span></span><br><span class=\"line\">\t<span class=\"variable\">$(REDIS_INSTALL)</span> <span class=\"variable\">$(REDIS_SERVER_NAME)</span> <span class=\"variable\">$(REDIS_CHECK_RDB_NAME)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># redis-check-aof</span></span><br><span class=\"line\"><span class=\"comment\">#redis-check-aof的构建</span></span><br><span class=\"line\"><span class=\"variable\">$(REDIS_CHECK_AOF_NAME)</span>: <span class=\"variable\">$(REDIS_SERVER_NAME)</span></span><br><span class=\"line\">\t<span class=\"variable\">$(REDIS_INSTALL)</span> <span class=\"variable\">$(REDIS_SERVER_NAME)</span> <span class=\"variable\">$(REDIS_CHECK_AOF_NAME)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># redis-cli</span></span><br><span class=\"line\"><span class=\"comment\">#redis-cli的链接</span></span><br><span class=\"line\"><span class=\"variable\">$(REDIS_CLI_NAME)</span>: <span class=\"variable\">$(REDIS_CLI_OBJ)</span></span><br><span class=\"line\">\t<span class=\"variable\">$(REDIS_LD)</span> -o <span class=\"variable\">$@</span> <span class=\"variable\">$^</span> ../deps/hiredis/libhiredis.a ../deps/linenoise/linenoise.o <span class=\"variable\">$(FINAL_LIBS)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># redis-benchmark</span></span><br><span class=\"line\"><span class=\"comment\">#redis-benchmark的链接</span></span><br><span class=\"line\"><span class=\"variable\">$(REDIS_BENCHMARK_NAME)</span>: <span class=\"variable\">$(REDIS_BENCHMARK_OBJ)</span></span><br><span class=\"line\">\t<span class=\"variable\">$(REDIS_LD)</span> -o <span class=\"variable\">$@</span> <span class=\"variable\">$^</span> ../deps/hiredis/libhiredis.a <span class=\"variable\">$(FINAL_LIBS)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">dict-benchmark: dict.c zmalloc.c sds.c siphash.c</span></span><br><span class=\"line\">\t<span class=\"variable\">$(REDIS_CC)</span> <span class=\"variable\">$(FINAL_CFLAGS)</span> <span class=\"variable\">$^</span> -D DICT_BENCHMARK_MAIN -o <span class=\"variable\">$@</span> <span class=\"variable\">$(FINAL_LIBS)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Because the jemalloc.h header is generated as a part of the jemalloc build,</span></span><br><span class=\"line\"><span class=\"comment\"># building it should complete before building any other object. Instead of</span></span><br><span class=\"line\"><span class=\"comment\"># depending on a single artifact, build all dependencies first.</span></span><br><span class=\"line\"><span class=\"comment\">#将所有点c文件编译成.o文件 自动完成file.c 到file.o的对应</span></span><br><span class=\"line\"><span class=\"section\">%.o: %.c .make-prerequisites</span></span><br><span class=\"line\">\t<span class=\"variable\">$(REDIS_CC)</span> -c <span class=\"variable\">$&lt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">clean:</span></span><br><span class=\"line\">\trm -rf <span class=\"variable\">$(REDIS_SERVER_NAME)</span> <span class=\"variable\">$(REDIS_SENTINEL_NAME)</span> <span class=\"variable\">$(REDIS_CLI_NAME)</span> <span class=\"variable\">$(REDIS_BENCHMARK_NAME)</span> <span class=\"variable\">$(REDIS_CHECK_RDB_NAME)</span> <span class=\"variable\">$(REDIS_CHECK_AOF_NAME)</span> *.o *.gcda *.gcno *.gcov redis.info lcov-html Makefile.dep dict-benchmark</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"><span class=\"meta-keyword\">.PHONY</span>: clean</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">distclean: clean</span></span><br><span class=\"line\">\t-(cd ../deps &amp;&amp; <span class=\"variable\">$(MAKE)</span> distclean)</span><br><span class=\"line\">\t-(rm -f .make-*)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"><span class=\"meta-keyword\">.PHONY</span>: distclean</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">test: <span class=\"variable\">$(REDIS_SERVER_NAME)</span> <span class=\"variable\">$(REDIS_CHECK_AOF_NAME)</span></span></span><br><span class=\"line\">\t@(cd ..; ./runtest)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">test-sentinel: <span class=\"variable\">$(REDIS_SENTINEL_NAME)</span></span></span><br><span class=\"line\">\t@(cd ..; ./runtest-sentinel)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">check: test</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">lcov:</span></span><br><span class=\"line\">\t<span class=\"variable\">$(MAKE)</span> gcov</span><br><span class=\"line\">\t@(set -e; cd ..; ./runtest --clients 1)</span><br><span class=\"line\">\t@geninfo -o redis.info .</span><br><span class=\"line\">\t@genhtml --legend -o lcov-html redis.info</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">test-sds: sds.c sds.h</span></span><br><span class=\"line\">\t<span class=\"variable\">$(REDIS_CC)</span> sds.c zmalloc.c -DSDS_TEST_MAIN <span class=\"variable\">$(FINAL_LIBS)</span> -o /tmp/sds_test</span><br><span class=\"line\">\t/tmp/sds_test</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"><span class=\"meta-keyword\">.PHONY</span>: lcov</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">bench: <span class=\"variable\">$(REDIS_BENCHMARK_NAME)</span></span></span><br><span class=\"line\">\t./<span class=\"variable\">$(REDIS_BENCHMARK_NAME)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">32bit:</span></span><br><span class=\"line\">\t@echo <span class=\"string\">\"\"</span></span><br><span class=\"line\">\t@echo <span class=\"string\">\"WARNING: if it fails under Linux you probably need to install libc6-dev-i386\"</span></span><br><span class=\"line\">\t@echo <span class=\"string\">\"\"</span></span><br><span class=\"line\">\t<span class=\"variable\">$(MAKE)</span> CFLAGS=<span class=\"string\">\"-m32\"</span> LDFLAGS=<span class=\"string\">\"-m32\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">gcov:</span></span><br><span class=\"line\">\t<span class=\"variable\">$(MAKE)</span> REDIS_CFLAGS=<span class=\"string\">\"-fprofile-arcs -ftest-coverage -DCOVERAGE_TEST\"</span> REDIS_LDFLAGS=<span class=\"string\">\"-fprofile-arcs -ftest-coverage\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">noopt:</span></span><br><span class=\"line\">\t<span class=\"variable\">$(MAKE)</span> OPTIMIZATION=<span class=\"string\">\"-O0\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">valgrind:</span></span><br><span class=\"line\">\t<span class=\"variable\">$(MAKE)</span> OPTIMIZATION=<span class=\"string\">\"-O0\"</span> MALLOC=<span class=\"string\">\"libc\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">helgrind:</span></span><br><span class=\"line\">\t<span class=\"variable\">$(MAKE)</span> OPTIMIZATION=<span class=\"string\">\"-O0\"</span> MALLOC=<span class=\"string\">\"libc\"</span> CFLAGS=<span class=\"string\">\"-D__ATOMIC_VAR_FORCE_SYNC_MACROS\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">src/help.h:</span></span><br><span class=\"line\">\t@../utils/generate-command-help.rb &gt; help.h</span><br><span class=\"line\"><span class=\"comment\">#将构建完成的可执行程序安装到指定的目录，-p选项自行创建多层目录</span></span><br><span class=\"line\"><span class=\"section\">install: all</span></span><br><span class=\"line\">\t@mkdir -p <span class=\"variable\">$(INSTALL_BIN)</span></span><br><span class=\"line\">\t<span class=\"variable\">$(REDIS_INSTALL)</span> <span class=\"variable\">$(REDIS_SERVER_NAME)</span> <span class=\"variable\">$(INSTALL_BIN)</span></span><br><span class=\"line\">\t<span class=\"variable\">$(REDIS_INSTALL)</span> <span class=\"variable\">$(REDIS_BENCHMARK_NAME)</span> <span class=\"variable\">$(INSTALL_BIN)</span></span><br><span class=\"line\">\t<span class=\"variable\">$(REDIS_INSTALL)</span> <span class=\"variable\">$(REDIS_CLI_NAME)</span> <span class=\"variable\">$(INSTALL_BIN)</span></span><br><span class=\"line\">\t<span class=\"variable\">$(REDIS_INSTALL)</span> <span class=\"variable\">$(REDIS_CHECK_RDB_NAME)</span> <span class=\"variable\">$(INSTALL_BIN)</span></span><br><span class=\"line\">\t<span class=\"variable\">$(REDIS_INSTALL)</span> <span class=\"variable\">$(REDIS_CHECK_AOF_NAME)</span> <span class=\"variable\">$(INSTALL_BIN)</span></span><br><span class=\"line\">\t@ln -sf <span class=\"variable\">$(REDIS_SERVER_NAME)</span> <span class=\"variable\">$(INSTALL_BIN)</span>/<span class=\"variable\">$(REDIS_SENTINEL_NAME)</span></span><br></pre></td></tr></table></figure>\n<p><code>uname_S := $(shell sh -c &#39;uname -s 2&gt;/dev/null || echo not&#39;)</code> 这一句-c让后面的字符串命令当成一个完成的命令来执行，从而避免向文件中写入东西的时候权限不够的问题。就算加上sudo也不行，因为里面的命令有&gt;,echo等很多个文件，所以只能用-c来当成一个整体来执行。<a href=\"https://blog.csdn.net/bobchill/article/details/84647575\" target=\"_blank\" rel=\"noopener\">参考</a></p>\n<h2 id=\"Makefile思路\"><a href=\"#Makefile思路\" class=\"headerlink\" title=\"Makefile思路\"></a>Makefile思路</h2><p>总结一下Redis Makefile的思路：</p>\n<ol>\n<li>在默认规则也就是第一条规则之前，通过变量设置好编译的相关选项：LDFLAGS，相应的对应关系REDIS_SERVER_OBJ，将规则的target用变量表示好（方便all规则里面用作前置条件），比如REDIS_SERVER_NAME。</li>\n<li>在第一条默认规则 all规则里面指定需要构建的东西</li>\n<li>在第一规则后面先完成链接，再完成编译的规则</li>\n<li>其他功能性规则如clean和distclean</li>\n</ol>\n<p>也就是从上到下的结构是总-分。显示整个项目 ，然后是各个模块如redis-server，redis-cli的链接，然后是从源文件到obj文件的编译。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://blog.csdn.net/bobchill/article/details/84647575\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/bobchill/article/details/84647575</a></p>"},{"title":"GCC的编译选项","date":"2019-04-25T06:18:49.000Z","copyright":true,"_content":"\n# GCC的编译选项\n\nMakefile 中的gcc的编译选项有很多，因此学习记录下。\n\n<!--more-->\n\n这些选项在Makefile文件中常用CFLAGS（gcc 用在c语言的编译），CXXFLAGS（g++用在c++的编译）来表示。\n\n## 程序编译的过程\n\ngcc 与 g++ 分别是 gnu 的 c & c++ 编译器 gcc/g++ 在执行编译工作的时候，总共需要4步：\n\n- 1、预处理,生成 .i 的文件[预处理器cpp]\n- 2、将预处理后的文件转换成汇编语言, 生成文件 .s [编译器egcs]\n- 3、将汇编代码变为目标代码(机器代码)生成 .o 的obj文件[汇编器as]\n- 4、连接目标代码, 生成可执行程序 [链接器ld]\n\n## 选项\n\n| 选项          | 释义                                                         |\n| ------------- | ------------------------------------------------------------ |\n| -c            | 只激活预处理,编译,和汇编。只把程序做成obj文件，不是可执行文件（因为没有链接,有的程序中也没有main入口） |\n| -S            | 只激活预处理和编译，就是只把文件编译成为汇编代码。生成.s的汇编代码 |\n| -E            | 只激活预处理,不生成文件,你需要把它重定向到一个输出文件里面 例子：gcc -E hello.c > pianoapan.txt |\n| -o            | 指定输出，缺省的时候,gcc 编译出来的文件是a.out               |\n| -Wall         | 显示所有警告信息                                             |\n| -w            | 不生成任何警告信息。                                         |\n| -Wextra       | 打印出更多的警告信息，比开启 -Wall 打印的还多                |\n| -ansi         | 关闭gnu c中与ansi c不兼容的特性,激活ansi c的专有特性(包括禁止一些asm inline typeof关键字,以及UNIX,vax等预处理宏 |\n| -include file | 包含某个代码,简单来说,就是便于某个文件需要另一个文件的时候,就可以用它设<br/>定,功能就相当于在代码中使用#include<filename> |\n| -Idir         | 添加dir目录为头文件搜索路径，如-I./ 在当前目录查找头文件     |\n| -I-           | 取消前一个参数的功能,所以一般在-Idir之后使用                 |\n| -llib         | 指定编译的时候使用的库，gcc -lcurses hello.c 使用库curses进行编译 |\n| -std=         | 编译的标准,包括GNU99，c++11,c99,等等                         |\n| -O2           | 编译器的优化选项的4个级别，-O0表示没有优化,-O1为缺省值，-O3优化级别最高 |\n| -Ldir         | 链接的时候，搜索库的路径 -L./ 在当前目录搜说                 |\n| -g            | 产生调试信息，可以使用gdb调试可执行文件                      |\n| -ggdb         | 此选项将尽可能的生成gdb的可以使用的调试信息.                 |\n| -static       | 禁止使用动态库，所以，编译出来的东西，一般都很大，也不需要什么 |\n| -share        | 此选项将尽量使用动态库，所以生成文件比较小，但是需要系统由动态库. |\n| -shared       | 创建一个动态链接库（不指定的话输出的是obj文件）gcc -fPIC -shared func.c -o libfunc.s |\n| -rdynamic     | 动态连接符号信息，用于动态连接功能。所有符号添加到动态符号表中（目的是能够通过使用 dlopen 来实现向后跟踪） |\n| -pedantic     | 用于保证代码规范满足ISO C和ISO C++标准, 不允许使用任何扩展以及不满足ISO C和C++的代码, 遵守 -std 选项指定的标准 |\n| -pthread      | 支持多线程, 使用pthread库                                    |\n| -fPIC         | PIC 是 position-independent code的意思, 此选项去除独立位置代码, 适合于动态链接 |\n\nar -r libhello.a hello.o  #这里的ar相当于tar的作用，将多个目标打包。 makefile中用于创建静态链接库（就是把多个目标文件打包成一个）\n\n## 参考\n\n<https://blog.csdn.net/navyhu/article/details/46788559>\n\nhttps://blog.csdn.net/woshinia/article/details/11060797>\n\n<https://gcc.gnu.org/onlinedocs/>","source":"_posts/2019-04-25-GCC的编译选项.md","raw":"---\ntitle: GCC的编译选项\ndate: 2019-04-25 14:18:49\ncategories: Linux\ntags: \n- gcc\n- make\ncopyright: true\n---\n\n# GCC的编译选项\n\nMakefile 中的gcc的编译选项有很多，因此学习记录下。\n\n<!--more-->\n\n这些选项在Makefile文件中常用CFLAGS（gcc 用在c语言的编译），CXXFLAGS（g++用在c++的编译）来表示。\n\n## 程序编译的过程\n\ngcc 与 g++ 分别是 gnu 的 c & c++ 编译器 gcc/g++ 在执行编译工作的时候，总共需要4步：\n\n- 1、预处理,生成 .i 的文件[预处理器cpp]\n- 2、将预处理后的文件转换成汇编语言, 生成文件 .s [编译器egcs]\n- 3、将汇编代码变为目标代码(机器代码)生成 .o 的obj文件[汇编器as]\n- 4、连接目标代码, 生成可执行程序 [链接器ld]\n\n## 选项\n\n| 选项          | 释义                                                         |\n| ------------- | ------------------------------------------------------------ |\n| -c            | 只激活预处理,编译,和汇编。只把程序做成obj文件，不是可执行文件（因为没有链接,有的程序中也没有main入口） |\n| -S            | 只激活预处理和编译，就是只把文件编译成为汇编代码。生成.s的汇编代码 |\n| -E            | 只激活预处理,不生成文件,你需要把它重定向到一个输出文件里面 例子：gcc -E hello.c > pianoapan.txt |\n| -o            | 指定输出，缺省的时候,gcc 编译出来的文件是a.out               |\n| -Wall         | 显示所有警告信息                                             |\n| -w            | 不生成任何警告信息。                                         |\n| -Wextra       | 打印出更多的警告信息，比开启 -Wall 打印的还多                |\n| -ansi         | 关闭gnu c中与ansi c不兼容的特性,激活ansi c的专有特性(包括禁止一些asm inline typeof关键字,以及UNIX,vax等预处理宏 |\n| -include file | 包含某个代码,简单来说,就是便于某个文件需要另一个文件的时候,就可以用它设<br/>定,功能就相当于在代码中使用#include<filename> |\n| -Idir         | 添加dir目录为头文件搜索路径，如-I./ 在当前目录查找头文件     |\n| -I-           | 取消前一个参数的功能,所以一般在-Idir之后使用                 |\n| -llib         | 指定编译的时候使用的库，gcc -lcurses hello.c 使用库curses进行编译 |\n| -std=         | 编译的标准,包括GNU99，c++11,c99,等等                         |\n| -O2           | 编译器的优化选项的4个级别，-O0表示没有优化,-O1为缺省值，-O3优化级别最高 |\n| -Ldir         | 链接的时候，搜索库的路径 -L./ 在当前目录搜说                 |\n| -g            | 产生调试信息，可以使用gdb调试可执行文件                      |\n| -ggdb         | 此选项将尽可能的生成gdb的可以使用的调试信息.                 |\n| -static       | 禁止使用动态库，所以，编译出来的东西，一般都很大，也不需要什么 |\n| -share        | 此选项将尽量使用动态库，所以生成文件比较小，但是需要系统由动态库. |\n| -shared       | 创建一个动态链接库（不指定的话输出的是obj文件）gcc -fPIC -shared func.c -o libfunc.s |\n| -rdynamic     | 动态连接符号信息，用于动态连接功能。所有符号添加到动态符号表中（目的是能够通过使用 dlopen 来实现向后跟踪） |\n| -pedantic     | 用于保证代码规范满足ISO C和ISO C++标准, 不允许使用任何扩展以及不满足ISO C和C++的代码, 遵守 -std 选项指定的标准 |\n| -pthread      | 支持多线程, 使用pthread库                                    |\n| -fPIC         | PIC 是 position-independent code的意思, 此选项去除独立位置代码, 适合于动态链接 |\n\nar -r libhello.a hello.o  #这里的ar相当于tar的作用，将多个目标打包。 makefile中用于创建静态链接库（就是把多个目标文件打包成一个）\n\n## 参考\n\n<https://blog.csdn.net/navyhu/article/details/46788559>\n\nhttps://blog.csdn.net/woshinia/article/details/11060797>\n\n<https://gcc.gnu.org/onlinedocs/>","slug":"2019-04-25-GCC的编译选项","published":1,"updated":"2019-11-08T13:13:31.703Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6he13yl000ydstz8zz1phca","content":"<h1 id=\"GCC的编译选项\"><a href=\"#GCC的编译选项\" class=\"headerlink\" title=\"GCC的编译选项\"></a>GCC的编译选项</h1><p>Makefile 中的gcc的编译选项有很多，因此学习记录下。</p>\n<a id=\"more\"></a>\n<p>这些选项在Makefile文件中常用CFLAGS（gcc 用在c语言的编译），CXXFLAGS（g++用在c++的编译）来表示。</p>\n<h2 id=\"程序编译的过程\"><a href=\"#程序编译的过程\" class=\"headerlink\" title=\"程序编译的过程\"></a>程序编译的过程</h2><p>gcc 与 g++ 分别是 gnu 的 c &amp; c++ 编译器 gcc/g++ 在执行编译工作的时候，总共需要4步：</p>\n<ul>\n<li>1、预处理,生成 .i 的文件[预处理器cpp]</li>\n<li>2、将预处理后的文件转换成汇编语言, 生成文件 .s [编译器egcs]</li>\n<li>3、将汇编代码变为目标代码(机器代码)生成 .o 的obj文件[汇编器as]</li>\n<li>4、连接目标代码, 生成可执行程序 [链接器ld]</li>\n</ul>\n<h2 id=\"选项\"><a href=\"#选项\" class=\"headerlink\" title=\"选项\"></a>选项</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>释义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-c</td>\n<td>只激活预处理,编译,和汇编。只把程序做成obj文件，不是可执行文件（因为没有链接,有的程序中也没有main入口）</td>\n</tr>\n<tr>\n<td>-S</td>\n<td>只激活预处理和编译，就是只把文件编译成为汇编代码。生成.s的汇编代码</td>\n</tr>\n<tr>\n<td>-E</td>\n<td>只激活预处理,不生成文件,你需要把它重定向到一个输出文件里面 例子：gcc -E hello.c &gt; pianoapan.txt</td>\n</tr>\n<tr>\n<td>-o</td>\n<td>指定输出，缺省的时候,gcc 编译出来的文件是a.out</td>\n</tr>\n<tr>\n<td>-Wall</td>\n<td>显示所有警告信息</td>\n</tr>\n<tr>\n<td>-w</td>\n<td>不生成任何警告信息。</td>\n</tr>\n<tr>\n<td>-Wextra</td>\n<td>打印出更多的警告信息，比开启 -Wall 打印的还多</td>\n</tr>\n<tr>\n<td>-ansi</td>\n<td>关闭gnu c中与ansi c不兼容的特性,激活ansi c的专有特性(包括禁止一些asm inline typeof关键字,以及UNIX,vax等预处理宏</td>\n</tr>\n<tr>\n<td>-include file</td>\n<td>包含某个代码,简单来说,就是便于某个文件需要另一个文件的时候,就可以用它设<br>定,功能就相当于在代码中使用#include<filename></filename></td>\n</tr>\n<tr>\n<td>-Idir</td>\n<td>添加dir目录为头文件搜索路径，如-I./ 在当前目录查找头文件</td>\n</tr>\n<tr>\n<td>-I-</td>\n<td>取消前一个参数的功能,所以一般在-Idir之后使用</td>\n</tr>\n<tr>\n<td>-llib</td>\n<td>指定编译的时候使用的库，gcc -lcurses hello.c 使用库curses进行编译</td>\n</tr>\n<tr>\n<td>-std=</td>\n<td>编译的标准,包括GNU99，c++11,c99,等等</td>\n</tr>\n<tr>\n<td>-O2</td>\n<td>编译器的优化选项的4个级别，-O0表示没有优化,-O1为缺省值，-O3优化级别最高</td>\n</tr>\n<tr>\n<td>-Ldir</td>\n<td>链接的时候，搜索库的路径 -L./ 在当前目录搜说</td>\n</tr>\n<tr>\n<td>-g</td>\n<td>产生调试信息，可以使用gdb调试可执行文件</td>\n</tr>\n<tr>\n<td>-ggdb</td>\n<td>此选项将尽可能的生成gdb的可以使用的调试信息.</td>\n</tr>\n<tr>\n<td>-static</td>\n<td>禁止使用动态库，所以，编译出来的东西，一般都很大，也不需要什么</td>\n</tr>\n<tr>\n<td>-share</td>\n<td>此选项将尽量使用动态库，所以生成文件比较小，但是需要系统由动态库.</td>\n</tr>\n<tr>\n<td>-shared</td>\n<td>创建一个动态链接库（不指定的话输出的是obj文件）gcc -fPIC -shared func.c -o libfunc.s</td>\n</tr>\n<tr>\n<td>-rdynamic</td>\n<td>动态连接符号信息，用于动态连接功能。所有符号添加到动态符号表中（目的是能够通过使用 dlopen 来实现向后跟踪）</td>\n</tr>\n<tr>\n<td>-pedantic</td>\n<td>用于保证代码规范满足ISO C和ISO C++标准, 不允许使用任何扩展以及不满足ISO C和C++的代码, 遵守 -std 选项指定的标准</td>\n</tr>\n<tr>\n<td>-pthread</td>\n<td>支持多线程, 使用pthread库</td>\n</tr>\n<tr>\n<td>-fPIC</td>\n<td>PIC 是 position-independent code的意思, 此选项去除独立位置代码, 适合于动态链接</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>ar -r libhello.a hello.o  #这里的ar相当于tar的作用，将多个目标打包。 makefile中用于创建静态链接库（就是把多个目标文件打包成一个）</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://blog.csdn.net/navyhu/article/details/46788559\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/navyhu/article/details/46788559</a></p>\n<p><a href=\"https://blog.csdn.net/woshinia/article/details/11060797&gt;\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/woshinia/article/details/11060797&gt;</a></p>\n<p><a href=\"https://gcc.gnu.org/onlinedocs/\" target=\"_blank\" rel=\"noopener\">https://gcc.gnu.org/onlinedocs/</a></p>\n","site":{"data":{}},"length":1519,"excerpt":"<h1 id=\"GCC的编译选项\"><a href=\"#GCC的编译选项\" class=\"headerlink\" title=\"GCC的编译选项\"></a>GCC的编译选项</h1><p>Makefile 中的gcc的编译选项有很多，因此学习记录下。</p>","more":"<p>这些选项在Makefile文件中常用CFLAGS（gcc 用在c语言的编译），CXXFLAGS（g++用在c++的编译）来表示。</p>\n<h2 id=\"程序编译的过程\"><a href=\"#程序编译的过程\" class=\"headerlink\" title=\"程序编译的过程\"></a>程序编译的过程</h2><p>gcc 与 g++ 分别是 gnu 的 c &amp; c++ 编译器 gcc/g++ 在执行编译工作的时候，总共需要4步：</p>\n<ul>\n<li>1、预处理,生成 .i 的文件[预处理器cpp]</li>\n<li>2、将预处理后的文件转换成汇编语言, 生成文件 .s [编译器egcs]</li>\n<li>3、将汇编代码变为目标代码(机器代码)生成 .o 的obj文件[汇编器as]</li>\n<li>4、连接目标代码, 生成可执行程序 [链接器ld]</li>\n</ul>\n<h2 id=\"选项\"><a href=\"#选项\" class=\"headerlink\" title=\"选项\"></a>选项</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>释义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-c</td>\n<td>只激活预处理,编译,和汇编。只把程序做成obj文件，不是可执行文件（因为没有链接,有的程序中也没有main入口）</td>\n</tr>\n<tr>\n<td>-S</td>\n<td>只激活预处理和编译，就是只把文件编译成为汇编代码。生成.s的汇编代码</td>\n</tr>\n<tr>\n<td>-E</td>\n<td>只激活预处理,不生成文件,你需要把它重定向到一个输出文件里面 例子：gcc -E hello.c &gt; pianoapan.txt</td>\n</tr>\n<tr>\n<td>-o</td>\n<td>指定输出，缺省的时候,gcc 编译出来的文件是a.out</td>\n</tr>\n<tr>\n<td>-Wall</td>\n<td>显示所有警告信息</td>\n</tr>\n<tr>\n<td>-w</td>\n<td>不生成任何警告信息。</td>\n</tr>\n<tr>\n<td>-Wextra</td>\n<td>打印出更多的警告信息，比开启 -Wall 打印的还多</td>\n</tr>\n<tr>\n<td>-ansi</td>\n<td>关闭gnu c中与ansi c不兼容的特性,激活ansi c的专有特性(包括禁止一些asm inline typeof关键字,以及UNIX,vax等预处理宏</td>\n</tr>\n<tr>\n<td>-include file</td>\n<td>包含某个代码,简单来说,就是便于某个文件需要另一个文件的时候,就可以用它设<br>定,功能就相当于在代码中使用#include<filename></filename></td>\n</tr>\n<tr>\n<td>-Idir</td>\n<td>添加dir目录为头文件搜索路径，如-I./ 在当前目录查找头文件</td>\n</tr>\n<tr>\n<td>-I-</td>\n<td>取消前一个参数的功能,所以一般在-Idir之后使用</td>\n</tr>\n<tr>\n<td>-llib</td>\n<td>指定编译的时候使用的库，gcc -lcurses hello.c 使用库curses进行编译</td>\n</tr>\n<tr>\n<td>-std=</td>\n<td>编译的标准,包括GNU99，c++11,c99,等等</td>\n</tr>\n<tr>\n<td>-O2</td>\n<td>编译器的优化选项的4个级别，-O0表示没有优化,-O1为缺省值，-O3优化级别最高</td>\n</tr>\n<tr>\n<td>-Ldir</td>\n<td>链接的时候，搜索库的路径 -L./ 在当前目录搜说</td>\n</tr>\n<tr>\n<td>-g</td>\n<td>产生调试信息，可以使用gdb调试可执行文件</td>\n</tr>\n<tr>\n<td>-ggdb</td>\n<td>此选项将尽可能的生成gdb的可以使用的调试信息.</td>\n</tr>\n<tr>\n<td>-static</td>\n<td>禁止使用动态库，所以，编译出来的东西，一般都很大，也不需要什么</td>\n</tr>\n<tr>\n<td>-share</td>\n<td>此选项将尽量使用动态库，所以生成文件比较小，但是需要系统由动态库.</td>\n</tr>\n<tr>\n<td>-shared</td>\n<td>创建一个动态链接库（不指定的话输出的是obj文件）gcc -fPIC -shared func.c -o libfunc.s</td>\n</tr>\n<tr>\n<td>-rdynamic</td>\n<td>动态连接符号信息，用于动态连接功能。所有符号添加到动态符号表中（目的是能够通过使用 dlopen 来实现向后跟踪）</td>\n</tr>\n<tr>\n<td>-pedantic</td>\n<td>用于保证代码规范满足ISO C和ISO C++标准, 不允许使用任何扩展以及不满足ISO C和C++的代码, 遵守 -std 选项指定的标准</td>\n</tr>\n<tr>\n<td>-pthread</td>\n<td>支持多线程, 使用pthread库</td>\n</tr>\n<tr>\n<td>-fPIC</td>\n<td>PIC 是 position-independent code的意思, 此选项去除独立位置代码, 适合于动态链接</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>ar -r libhello.a hello.o  #这里的ar相当于tar的作用，将多个目标打包。 makefile中用于创建静态链接库（就是把多个目标文件打包成一个）</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://blog.csdn.net/navyhu/article/details/46788559\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/navyhu/article/details/46788559</a></p>\n<p><a href=\"https://blog.csdn.net/woshinia/article/details/11060797&gt;\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/woshinia/article/details/11060797&gt;</a></p>\n<p><a href=\"https://gcc.gnu.org/onlinedocs/\" target=\"_blank\" rel=\"noopener\">https://gcc.gnu.org/onlinedocs/</a></p>"},{"title":"shadowsocks的部署","date":"2019-08-24T04:59:32.000Z","copyright":true,"_content":"\n# shadowsocks 的部署\n\n部署shadowsocks主要有两个作用：\n\n1. 可以翻墙 \n2. 可以白嫖校园网的ipv6 \n\n<!--more-->\n\n## 1. 购买VPS服务器\n\n目前使用vultr的VPS服务器，5刀一个月，使用的CENTOS 8发行版。貌似日本的服务器网速最快，而且支持IPV6。在部署服务器的时候就需要开启IPV6。\n\n## 2. 服务器设置\n\n### 安装\n\n在/root/目录下创建文件夹\n\n```shell\nmkdir shadowsocks\ncd shadowsocks/\n```\n\n安装python和pip工具以及git\n\n```shell\n#centos 8 服务器自带有python3 和 pip3 所以无需再安装python\n#yum install python-setuptools && easy_install pip \nyum -y install git \n```\n\n使用pip3通过git安装shadowsocks\n\n```shell\n#pip install git+https://github.com/shadowsocks/shadowsocks.git@master\npip3 install git+https://github.com/shadowsocks/shadowsocks.git@master\nssserver\n```\n\nssserver 命令用来查看是否安装成功\n\n### 脚本\n\n```\n vi shadowsocks.json\n```\n\n脚本内容为：\n\n多端口账户脚本如下\n\n```json\n{\n    \"server\":\"::\",\n    \"local_address\": \"127.0.0.1\",\n    \"local_port\":1080,\n    \"port_password\":{\n    \"8388\":\"frankfurt123\",\n \t\"2343\":\"password\"\n},\n    \"timeout\":300,\n    \"method\":\"aes-256-cfb\",\n    \"fast_open\": false\n}\n```\n\n其中server:\"::\" 用两个:: 冒号来表示可以同时使用ipv4和ipv6来访问服务器，如果就只有ipv4的地址的话，只能使用ipv4来翻墙。\n\n通过脚本来启动shadowsocks\n\n```shell\n ssserver -c /root/shadowsocks/shadowsocks.json -d start\n ssserver -c /root/shadowsocks/shadowsocks.json -d status\n ssserver -c /root/shadowsocks/shadowsocks.json -d stop\n```\n\n至此通过添加服务器配置就应该可以使用shadowsocks+switchomega客户端了，如果还不可以的话，多半是因为防火墙的问题。\n\n### 防火墙设置\n\n将8388添加到防火墙白名单。\n\n```\nfirewall-cmd --zone=public --add-port=8388/tcp --permanent\nfirewall-cmd --reload\nfirewall-cmd --list-ports\n```\n\n## 客户端设置\n\n我使用的是win10 可以从：<https://github.com/shadowsocks/shadowsocks-windows> 下载\n\nMacOS：<https://github.com/shadowsocks/ShadowsocksX-NG/releases> \n\n在服务器设置界面依次添加IPV6的地址、端口、密码、加密方式就可以使用IPV6进行白嫖了。\n\n## 参考\n\n<https://github.com/shadowsocks/shadowsocks/tree/master> ","source":"_posts/2019-08-24-shadowsocks的部署.md","raw":"---\ntitle: shadowsocks的部署\ndate: 2019-08-24 12:59:32\ncategories: deploy\ntags:\n- shadowsocks\n- 翻墙\n- ipv6\ncopyright: true\n---\n\n# shadowsocks 的部署\n\n部署shadowsocks主要有两个作用：\n\n1. 可以翻墙 \n2. 可以白嫖校园网的ipv6 \n\n<!--more-->\n\n## 1. 购买VPS服务器\n\n目前使用vultr的VPS服务器，5刀一个月，使用的CENTOS 8发行版。貌似日本的服务器网速最快，而且支持IPV6。在部署服务器的时候就需要开启IPV6。\n\n## 2. 服务器设置\n\n### 安装\n\n在/root/目录下创建文件夹\n\n```shell\nmkdir shadowsocks\ncd shadowsocks/\n```\n\n安装python和pip工具以及git\n\n```shell\n#centos 8 服务器自带有python3 和 pip3 所以无需再安装python\n#yum install python-setuptools && easy_install pip \nyum -y install git \n```\n\n使用pip3通过git安装shadowsocks\n\n```shell\n#pip install git+https://github.com/shadowsocks/shadowsocks.git@master\npip3 install git+https://github.com/shadowsocks/shadowsocks.git@master\nssserver\n```\n\nssserver 命令用来查看是否安装成功\n\n### 脚本\n\n```\n vi shadowsocks.json\n```\n\n脚本内容为：\n\n多端口账户脚本如下\n\n```json\n{\n    \"server\":\"::\",\n    \"local_address\": \"127.0.0.1\",\n    \"local_port\":1080,\n    \"port_password\":{\n    \"8388\":\"frankfurt123\",\n \t\"2343\":\"password\"\n},\n    \"timeout\":300,\n    \"method\":\"aes-256-cfb\",\n    \"fast_open\": false\n}\n```\n\n其中server:\"::\" 用两个:: 冒号来表示可以同时使用ipv4和ipv6来访问服务器，如果就只有ipv4的地址的话，只能使用ipv4来翻墙。\n\n通过脚本来启动shadowsocks\n\n```shell\n ssserver -c /root/shadowsocks/shadowsocks.json -d start\n ssserver -c /root/shadowsocks/shadowsocks.json -d status\n ssserver -c /root/shadowsocks/shadowsocks.json -d stop\n```\n\n至此通过添加服务器配置就应该可以使用shadowsocks+switchomega客户端了，如果还不可以的话，多半是因为防火墙的问题。\n\n### 防火墙设置\n\n将8388添加到防火墙白名单。\n\n```\nfirewall-cmd --zone=public --add-port=8388/tcp --permanent\nfirewall-cmd --reload\nfirewall-cmd --list-ports\n```\n\n## 客户端设置\n\n我使用的是win10 可以从：<https://github.com/shadowsocks/shadowsocks-windows> 下载\n\nMacOS：<https://github.com/shadowsocks/ShadowsocksX-NG/releases> \n\n在服务器设置界面依次添加IPV6的地址、端口、密码、加密方式就可以使用IPV6进行白嫖了。\n\n## 参考\n\n<https://github.com/shadowsocks/shadowsocks/tree/master> ","slug":"2019-08-24-shadowsocks的部署","published":1,"updated":"2020-02-07T03:20:32.398Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6he13yn0012dstzq9dcgwxi","content":"<h1 id=\"shadowsocks-的部署\"><a href=\"#shadowsocks-的部署\" class=\"headerlink\" title=\"shadowsocks 的部署\"></a>shadowsocks 的部署</h1><p>部署shadowsocks主要有两个作用：</p>\n<ol>\n<li>可以翻墙 </li>\n<li>可以白嫖校园网的ipv6 </li>\n</ol>\n<a id=\"more\"></a>\n<h2 id=\"1-购买VPS服务器\"><a href=\"#1-购买VPS服务器\" class=\"headerlink\" title=\"1. 购买VPS服务器\"></a>1. 购买VPS服务器</h2><p>目前使用vultr的VPS服务器，5刀一个月，使用的CENTOS 8发行版。貌似日本的服务器网速最快，而且支持IPV6。在部署服务器的时候就需要开启IPV6。</p>\n<h2 id=\"2-服务器设置\"><a href=\"#2-服务器设置\" class=\"headerlink\" title=\"2. 服务器设置\"></a>2. 服务器设置</h2><h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>在/root/目录下创建文件夹</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir shadowsocks</span><br><span class=\"line\">cd shadowsocks/</span><br></pre></td></tr></table></figure>\n<p>安装python和pip工具以及git</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">centos 8 服务器自带有python3 和 pip3 所以无需再安装python</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">yum install python-setuptools &amp;&amp; easy_install pip </span></span><br><span class=\"line\">yum -y install git</span><br></pre></td></tr></table></figure>\n<p>使用pip3通过git安装shadowsocks</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">pip install git+https://github.com/shadowsocks/shadowsocks.git@master</span></span><br><span class=\"line\">pip3 install git+https://github.com/shadowsocks/shadowsocks.git@master</span><br><span class=\"line\">ssserver</span><br></pre></td></tr></table></figure>\n<p>ssserver 命令用来查看是否安装成功</p>\n<h3 id=\"脚本\"><a href=\"#脚本\" class=\"headerlink\" title=\"脚本\"></a>脚本</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi shadowsocks.json</span><br></pre></td></tr></table></figure>\n<p>脚本内容为：</p>\n<p>多端口账户脚本如下</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"server\"</span>:<span class=\"string\">\"::\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"local_address\"</span>: <span class=\"string\">\"127.0.0.1\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"local_port\"</span>:<span class=\"number\">1080</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"port_password\"</span>:&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"8388\"</span>:<span class=\"string\">\"frankfurt123\"</span>,</span><br><span class=\"line\"> \t<span class=\"attr\">\"2343\"</span>:<span class=\"string\">\"password\"</span></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">    <span class=\"attr\">\"timeout\"</span>:<span class=\"number\">300</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"method\"</span>:<span class=\"string\">\"aes-256-cfb\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"fast_open\"</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中server:”::” 用两个:: 冒号来表示可以同时使用ipv4和ipv6来访问服务器，如果就只有ipv4的地址的话，只能使用ipv4来翻墙。</p>\n<p>通过脚本来启动shadowsocks</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssserver -c /root/shadowsocks/shadowsocks.json -d start</span><br><span class=\"line\">ssserver -c /root/shadowsocks/shadowsocks.json -d status</span><br><span class=\"line\">ssserver -c /root/shadowsocks/shadowsocks.json -d stop</span><br></pre></td></tr></table></figure>\n<p>至此通过添加服务器配置就应该可以使用shadowsocks+switchomega客户端了，如果还不可以的话，多半是因为防火墙的问题。</p>\n<h3 id=\"防火墙设置\"><a href=\"#防火墙设置\" class=\"headerlink\" title=\"防火墙设置\"></a>防火墙设置</h3><p>将8388添加到防火墙白名单。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">firewall-cmd --zone=public --add-port=8388/tcp --permanent</span><br><span class=\"line\">firewall-cmd --reload</span><br><span class=\"line\">firewall-cmd --list-ports</span><br></pre></td></tr></table></figure>\n<h2 id=\"客户端设置\"><a href=\"#客户端设置\" class=\"headerlink\" title=\"客户端设置\"></a>客户端设置</h2><p>我使用的是win10 可以从：<a href=\"https://github.com/shadowsocks/shadowsocks-windows\" target=\"_blank\" rel=\"noopener\">https://github.com/shadowsocks/shadowsocks-windows</a> 下载</p>\n<p>MacOS：<a href=\"https://github.com/shadowsocks/ShadowsocksX-NG/releases\" target=\"_blank\" rel=\"noopener\">https://github.com/shadowsocks/ShadowsocksX-NG/releases</a> </p>\n<p>在服务器设置界面依次添加IPV6的地址、端口、密码、加密方式就可以使用IPV6进行白嫖了。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://github.com/shadowsocks/shadowsocks/tree/master\" target=\"_blank\" rel=\"noopener\">https://github.com/shadowsocks/shadowsocks/tree/master</a> </p>\n","site":{"data":{}},"length":1428,"excerpt":"<h1 id=\"shadowsocks-的部署\"><a href=\"#shadowsocks-的部署\" class=\"headerlink\" title=\"shadowsocks 的部署\"></a>shadowsocks 的部署</h1><p>部署shadowsocks主要有两个作用：</p>\n<ol>\n<li>可以翻墙 </li>\n<li>可以白嫖校园网的ipv6 </li>\n</ol>","more":"<h2 id=\"1-购买VPS服务器\"><a href=\"#1-购买VPS服务器\" class=\"headerlink\" title=\"1. 购买VPS服务器\"></a>1. 购买VPS服务器</h2><p>目前使用vultr的VPS服务器，5刀一个月，使用的CENTOS 8发行版。貌似日本的服务器网速最快，而且支持IPV6。在部署服务器的时候就需要开启IPV6。</p>\n<h2 id=\"2-服务器设置\"><a href=\"#2-服务器设置\" class=\"headerlink\" title=\"2. 服务器设置\"></a>2. 服务器设置</h2><h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>在/root/目录下创建文件夹</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir shadowsocks</span><br><span class=\"line\">cd shadowsocks/</span><br></pre></td></tr></table></figure>\n<p>安装python和pip工具以及git</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">centos 8 服务器自带有python3 和 pip3 所以无需再安装python</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">yum install python-setuptools &amp;&amp; easy_install pip </span></span><br><span class=\"line\">yum -y install git</span><br></pre></td></tr></table></figure>\n<p>使用pip3通过git安装shadowsocks</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">pip install git+https://github.com/shadowsocks/shadowsocks.git@master</span></span><br><span class=\"line\">pip3 install git+https://github.com/shadowsocks/shadowsocks.git@master</span><br><span class=\"line\">ssserver</span><br></pre></td></tr></table></figure>\n<p>ssserver 命令用来查看是否安装成功</p>\n<h3 id=\"脚本\"><a href=\"#脚本\" class=\"headerlink\" title=\"脚本\"></a>脚本</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi shadowsocks.json</span><br></pre></td></tr></table></figure>\n<p>脚本内容为：</p>\n<p>多端口账户脚本如下</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"server\"</span>:<span class=\"string\">\"::\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"local_address\"</span>: <span class=\"string\">\"127.0.0.1\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"local_port\"</span>:<span class=\"number\">1080</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"port_password\"</span>:&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"8388\"</span>:<span class=\"string\">\"frankfurt123\"</span>,</span><br><span class=\"line\"> \t<span class=\"attr\">\"2343\"</span>:<span class=\"string\">\"password\"</span></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">    <span class=\"attr\">\"timeout\"</span>:<span class=\"number\">300</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"method\"</span>:<span class=\"string\">\"aes-256-cfb\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"fast_open\"</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中server:”::” 用两个:: 冒号来表示可以同时使用ipv4和ipv6来访问服务器，如果就只有ipv4的地址的话，只能使用ipv4来翻墙。</p>\n<p>通过脚本来启动shadowsocks</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssserver -c /root/shadowsocks/shadowsocks.json -d start</span><br><span class=\"line\">ssserver -c /root/shadowsocks/shadowsocks.json -d status</span><br><span class=\"line\">ssserver -c /root/shadowsocks/shadowsocks.json -d stop</span><br></pre></td></tr></table></figure>\n<p>至此通过添加服务器配置就应该可以使用shadowsocks+switchomega客户端了，如果还不可以的话，多半是因为防火墙的问题。</p>\n<h3 id=\"防火墙设置\"><a href=\"#防火墙设置\" class=\"headerlink\" title=\"防火墙设置\"></a>防火墙设置</h3><p>将8388添加到防火墙白名单。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">firewall-cmd --zone=public --add-port=8388/tcp --permanent</span><br><span class=\"line\">firewall-cmd --reload</span><br><span class=\"line\">firewall-cmd --list-ports</span><br></pre></td></tr></table></figure>\n<h2 id=\"客户端设置\"><a href=\"#客户端设置\" class=\"headerlink\" title=\"客户端设置\"></a>客户端设置</h2><p>我使用的是win10 可以从：<a href=\"https://github.com/shadowsocks/shadowsocks-windows\" target=\"_blank\" rel=\"noopener\">https://github.com/shadowsocks/shadowsocks-windows</a> 下载</p>\n<p>MacOS：<a href=\"https://github.com/shadowsocks/ShadowsocksX-NG/releases\" target=\"_blank\" rel=\"noopener\">https://github.com/shadowsocks/ShadowsocksX-NG/releases</a> </p>\n<p>在服务器设置界面依次添加IPV6的地址、端口、密码、加密方式就可以使用IPV6进行白嫖了。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://github.com/shadowsocks/shadowsocks/tree/master\" target=\"_blank\" rel=\"noopener\">https://github.com/shadowsocks/shadowsocks/tree/master</a> </p>"},{"title":"数组中的主要元素","date":"2019-10-14T02:46:11.000Z","copyright":true,"mathjax":true,"_content":"\n# 数组中的主要元素\n\nleetcode#169题，找出一个数组中出现次数超过$\\lfloor \\dfrac{n}{2}\\rfloor$ 次数的元素，也就是过半的主要元素。题目来源：\n\n<https://leetcode.com/problems/majority-element/> \n\n<!--more-->\n\n## 解题思路\n\n### 哈希表\n\n遍历一次数组然后将每个元素出现的次数放在哈希表中，key是元素，value是出现的次数。然后输出哈希表中值大于$\\lfloor \\dfrac{n}{2}\\rfloor$ 的元素。\n\n#### 复杂度\n\n遍历数组的时间复杂度为O(n)，新建一个哈希表造成的空间复杂度为O(n)。\n\n#### 代码\n\n第一个是自己写的,输入是为了自己调试和算法课程作业的UOJ，这个OJ有个卡内存的坑后面讲。\n\n```c++\n#include<iostream>\n#include<vector>\n#include<map>\n#include <stdio.h>\n\nusing namespace std;\nclass Solution {\npublic:\n    int majorityElement(vector<int>& nums) {\n        map<int, int> m;\n        for(int i=0; i<nums.size(); i++){\n            m[nums[i]]++;\n        }\n        int major = 0;\n        int max = 0;\n        for(map<int, int>::iterator it= m.begin(); it!=m.end(); it++){\n            if(it->second>=max){\n                max = it->second;\n                major = it->first;\n            }\n        }\n        return major;\n    }\n};\n\nint main(int argc, char const *argv[])\n{\n    // Solution sol;\n    // std::vector<int> vec={3,2,3};\n    // int ans = sol.majorityElement(vec);\n    // cout<<ans<<endl;\n    // cin>>ans;\n    ios::sync_with_stdio(false);\n    int len;\n    Solution Sol;\n    int ans;\n    while(cin>>len){\n        vector<int> vec(len);\n        for(int i = 0; i < len; i++) {\n            cin>>vec[i];\n        }\n        ans = Sol.majorityElement(vec);\n        cout<<ans<<endl;\n    }\n    return 0;\n}\n```\n\n然后再来看看花花大神写的：\n\n```c++\n// Author: Huahua\n// Runtime : 23 ms\nclass Solution {\npublic:\n    int majorityElement(vector<int>& nums) {\n        unordered_map<int, int> count;\n        const int n = nums.size();\n        for (const int num : nums)\n            if (++count[num] > n / 2) return num;\n        return -1;\n    }\n};\n```\n\n我自己写的代码多了一步冗余操作，就是完整的把count哈希表给建立完毕之后又多次一举的进行遍历寻找最大值。实际上在对原来的数组进行遍历的同时一定会出现主要元素的计数大于$\\lfloor \\dfrac{n}{2}\\rfloor$，这个时候直接返回就可以了。\n\n### 分治\n\n首先考虑最简单的情况，当n=1的时候，这个唯一的元素就是主要元素，这是一个最简单的子问题。那么是否所有自问都能正确返回主要元素呢？很明显当n=2的时候，如果A[0]!=A[1]，这个时候A是没有主要元素的。因为如果使用分治的话，子问题一定要有一个解得，所以当出现两个子问题的主要元素不一致的时候，如何来得到原问题的解呢？这时只能通过遍历，统计两个子问题对应的主要元素在更大的局部中出现的次数来解决。如果左边的主要元素在原问题的数组中出现的次数大于右边的主要元素那么答案就是左边的主要元素，否则的话就是右边的元素（需要注意的是返回右边的时候是包含右边的主要元素次数等于左边的情况，不过无所谓，因为后面的上一层还是要遍历统计的）。总结一下：\n\n**Divide** 将输入数组A划分为左边A[0, n/2] 与右边A[n/2+1, n-1]两个数组\n\n**Conquer** 左边的主要元素与右边的主要元素分别再各自递归的调用函数求解。\n\n**Merge** 如果左边与右边的主要元素相等，那么就直接返回这个主要元素。如果不等那就统计这两个主要元素在A中的出现次数，然后返回较大的那个，次数相等的话左右两个主要元素随便返回其中一个。\n\n#### 复杂度\n\n根据上面的思路可以写出递推式：首先是考虑最好的情况:就是每次都有左右两个子数组的主要元素相同，不需要判别，此时有递推公式：\n$$\n\\begin{equation}\\nonumber\n\\begin{split}\nT(n)&=2T[{\\lfloor\\frac{n}{2}\\rfloor]+Cn}\\\\\\\\\n&=2^2T[{\\lfloor\\frac{n}{2^2}\\rfloor]+C+2C}\\\\\\\\\n&=2^3T[{\\lfloor\\frac{n}{2^3}\\rfloor]+C+2C+2C}\\\\\\\\\n\\dots\\\\\\\\\n&=2^kT[{\\lfloor\\frac{n}{2^k}\\rfloor]+(2k-1)C}\\\\\\\\\n\\end{split} \n\\end{equation}\n$$\n每次分解后规模变为左右两个子树，因此下降到$\\lfloor\\frac{n}{2}\\rfloor$,而每次比较左右两个子树最大深度与更新最大路径长度所需的时间为常数C。设当第k次的时候下降到规模为1的叶子节点，因此有$\\frac{n}{2^k}=1$推出$k=\\log_2n$所以有$T(n)=n+(2\\log_2n-1)C=O(n)$,所以时间复杂度为O(n)。\n\n考虑最坏的情况：每次都需要重新遍历来确定主要元素，也就是递归树中的每一层都需要遍历数组也就是O(n)的成本。所以有递推公式\n$$\nT(n)=2T[{\\lfloor\\frac{n}{2}\\rfloor]+Cn}\n$$\n根据主定理可以得出算法的最坏时间复杂度为$O(nlogn)$\n\n空间复杂度因为可以使用左右的索引来进行划分，不需要额外的空间所以是O(1)。\n\n#### 代码\n\n```c++\n#include<iostream>\n#include<vector>\n#include<map>\n#include <stdio.h>\n\nusing namespace std;\nclass Solution {\nprivate:\n    int dc_majority(std::vector<int>&vec, int lo, int hi){\n        if(lo>=hi) return vec[lo];\n        int mid = lo + (hi-lo)/2;\n        int l_ans = dc_majority(vec, lo, mid);\n        int r_ans = dc_majority(vec, mid+1, hi);\n        if(l_ans==r_ans) return l_ans;\n        int l_ans_nums=0, r_ans_nums = 0;\n        for(int i=lo; i<=hi; i++){\n            if(vec[i]==l_ans) l_ans_nums++;\n            if(vec[i]==r_ans) r_ans_nums++;\n        }\n        return l_ans_nums>r_ans_nums ? l_ans : r_ans;\n    }\npublic:\n    int majorityElement(vector<int>& nums) {\n        int major=dc_majority(nums, 0, nums.size()-1);\n        return major;\n    }\n};\n\nint main(int argc, char const *argv[])\n{\n    // Solution sol;\n    // std::vector<int> vec={3,2,3};\n    // int ans = sol.majorityElement(vec);\n    // cout<<ans<<endl;\n    // cin>>ans;\n    ios::sync_with_stdio(false);\n    int len;\n    Solution Sol;\n    int ans;\n    while(cin>>len){\n        vector<int> vec(len);\n        for(int i = 0; i < len; i++) {\n            cin>>vec[i];\n        }\n        ans = Sol.majorityElement(vec);\n        cout<<ans<<endl;\n    }\n    return 0;\n}\t\n```\n\n### 摩尔投票\n\n每次从数组中删除一对不同的元素，按照题意到最后一定会剩下至少一个元素（假设每次不同的元素都是由一个主要元素和非主要元素组成的，这样的话最终仍然剩下主要元素，假设每次不同的元素都是非主要元素构成，最后肯定也会剩下多余的主要元素。也可以理解成捉对厮杀，因为主要元素的占比超过一半，其他非主要元素小于一半，所以最后一相减一定有主要元素剩下。）\n\n#### 代码\n\n直接用的花花大神的：\n\n```c++\nclass Solution {\npublic:\n    int majorityElement(vector<int>& nums) {\n        int majority = nums.front();\n        int count = 0;\n        \n        for (const int num : nums) {\n            if (num == majority) ++count;\n            else if (--count == 0) {\n                count = 1;\n                majority = num;\n            }\n        }\n        \n        return majority;\n    }\n};\n```\n\n#### 复杂度\n\n根据代码分析很容易得出时间复杂度为O(n), 空间复杂度为O(1)。\n\n\n\n## OJ的输入\n\n这道题最开始是在UOJ上面的课程作业，我最开始做的时候不管怎么调，用什么方法，包括摩尔投票都会爆内存超过限制，后面分析出来的原因是：\n\n```c++\nint main(){\n\tSolution Sol;\n\tvector<int> vec;\n\tint n ;\n\twhile(cin>>n){\n\t\t//int tmp = n;\n\t\tint element;\n\t\twhile(n--){\n\t\t\tcin>>element;\n\t\t\tvec.push_back(element);\n\t\t}\n\t\tcout<<Sol.majorityElement(vec)<<endl;\n\t}\n\t\n}\n```\n\n我的输入是用push_back()来输入进vector中的，而vector的内存是动态申请的，不足的话会申请原来的两倍，所以造成了内存超过限制的原因，比如只需要11m的，假设上一次的vector申请到的是10m，所以下次就申请了20m造成了内存超过限制。\n\n## 参考\n\n<http://zxi.mytechroad.com/blog/divide-and-conquer/leetcode-169-majority-element/> ","source":"_posts/2019-10-14-数组中的主要元素.md","raw":"---\ntitle: 数组中的主要元素\ndate: 2019-10-14 10:46:11\ncategories: 题解\ntags:\n- 分治\n- 哈希\n- 摩尔投票\n- leetcode\ncopyright: true\nmathjax: true\n---\n\n# 数组中的主要元素\n\nleetcode#169题，找出一个数组中出现次数超过$\\lfloor \\dfrac{n}{2}\\rfloor$ 次数的元素，也就是过半的主要元素。题目来源：\n\n<https://leetcode.com/problems/majority-element/> \n\n<!--more-->\n\n## 解题思路\n\n### 哈希表\n\n遍历一次数组然后将每个元素出现的次数放在哈希表中，key是元素，value是出现的次数。然后输出哈希表中值大于$\\lfloor \\dfrac{n}{2}\\rfloor$ 的元素。\n\n#### 复杂度\n\n遍历数组的时间复杂度为O(n)，新建一个哈希表造成的空间复杂度为O(n)。\n\n#### 代码\n\n第一个是自己写的,输入是为了自己调试和算法课程作业的UOJ，这个OJ有个卡内存的坑后面讲。\n\n```c++\n#include<iostream>\n#include<vector>\n#include<map>\n#include <stdio.h>\n\nusing namespace std;\nclass Solution {\npublic:\n    int majorityElement(vector<int>& nums) {\n        map<int, int> m;\n        for(int i=0; i<nums.size(); i++){\n            m[nums[i]]++;\n        }\n        int major = 0;\n        int max = 0;\n        for(map<int, int>::iterator it= m.begin(); it!=m.end(); it++){\n            if(it->second>=max){\n                max = it->second;\n                major = it->first;\n            }\n        }\n        return major;\n    }\n};\n\nint main(int argc, char const *argv[])\n{\n    // Solution sol;\n    // std::vector<int> vec={3,2,3};\n    // int ans = sol.majorityElement(vec);\n    // cout<<ans<<endl;\n    // cin>>ans;\n    ios::sync_with_stdio(false);\n    int len;\n    Solution Sol;\n    int ans;\n    while(cin>>len){\n        vector<int> vec(len);\n        for(int i = 0; i < len; i++) {\n            cin>>vec[i];\n        }\n        ans = Sol.majorityElement(vec);\n        cout<<ans<<endl;\n    }\n    return 0;\n}\n```\n\n然后再来看看花花大神写的：\n\n```c++\n// Author: Huahua\n// Runtime : 23 ms\nclass Solution {\npublic:\n    int majorityElement(vector<int>& nums) {\n        unordered_map<int, int> count;\n        const int n = nums.size();\n        for (const int num : nums)\n            if (++count[num] > n / 2) return num;\n        return -1;\n    }\n};\n```\n\n我自己写的代码多了一步冗余操作，就是完整的把count哈希表给建立完毕之后又多次一举的进行遍历寻找最大值。实际上在对原来的数组进行遍历的同时一定会出现主要元素的计数大于$\\lfloor \\dfrac{n}{2}\\rfloor$，这个时候直接返回就可以了。\n\n### 分治\n\n首先考虑最简单的情况，当n=1的时候，这个唯一的元素就是主要元素，这是一个最简单的子问题。那么是否所有自问都能正确返回主要元素呢？很明显当n=2的时候，如果A[0]!=A[1]，这个时候A是没有主要元素的。因为如果使用分治的话，子问题一定要有一个解得，所以当出现两个子问题的主要元素不一致的时候，如何来得到原问题的解呢？这时只能通过遍历，统计两个子问题对应的主要元素在更大的局部中出现的次数来解决。如果左边的主要元素在原问题的数组中出现的次数大于右边的主要元素那么答案就是左边的主要元素，否则的话就是右边的元素（需要注意的是返回右边的时候是包含右边的主要元素次数等于左边的情况，不过无所谓，因为后面的上一层还是要遍历统计的）。总结一下：\n\n**Divide** 将输入数组A划分为左边A[0, n/2] 与右边A[n/2+1, n-1]两个数组\n\n**Conquer** 左边的主要元素与右边的主要元素分别再各自递归的调用函数求解。\n\n**Merge** 如果左边与右边的主要元素相等，那么就直接返回这个主要元素。如果不等那就统计这两个主要元素在A中的出现次数，然后返回较大的那个，次数相等的话左右两个主要元素随便返回其中一个。\n\n#### 复杂度\n\n根据上面的思路可以写出递推式：首先是考虑最好的情况:就是每次都有左右两个子数组的主要元素相同，不需要判别，此时有递推公式：\n$$\n\\begin{equation}\\nonumber\n\\begin{split}\nT(n)&=2T[{\\lfloor\\frac{n}{2}\\rfloor]+Cn}\\\\\\\\\n&=2^2T[{\\lfloor\\frac{n}{2^2}\\rfloor]+C+2C}\\\\\\\\\n&=2^3T[{\\lfloor\\frac{n}{2^3}\\rfloor]+C+2C+2C}\\\\\\\\\n\\dots\\\\\\\\\n&=2^kT[{\\lfloor\\frac{n}{2^k}\\rfloor]+(2k-1)C}\\\\\\\\\n\\end{split} \n\\end{equation}\n$$\n每次分解后规模变为左右两个子树，因此下降到$\\lfloor\\frac{n}{2}\\rfloor$,而每次比较左右两个子树最大深度与更新最大路径长度所需的时间为常数C。设当第k次的时候下降到规模为1的叶子节点，因此有$\\frac{n}{2^k}=1$推出$k=\\log_2n$所以有$T(n)=n+(2\\log_2n-1)C=O(n)$,所以时间复杂度为O(n)。\n\n考虑最坏的情况：每次都需要重新遍历来确定主要元素，也就是递归树中的每一层都需要遍历数组也就是O(n)的成本。所以有递推公式\n$$\nT(n)=2T[{\\lfloor\\frac{n}{2}\\rfloor]+Cn}\n$$\n根据主定理可以得出算法的最坏时间复杂度为$O(nlogn)$\n\n空间复杂度因为可以使用左右的索引来进行划分，不需要额外的空间所以是O(1)。\n\n#### 代码\n\n```c++\n#include<iostream>\n#include<vector>\n#include<map>\n#include <stdio.h>\n\nusing namespace std;\nclass Solution {\nprivate:\n    int dc_majority(std::vector<int>&vec, int lo, int hi){\n        if(lo>=hi) return vec[lo];\n        int mid = lo + (hi-lo)/2;\n        int l_ans = dc_majority(vec, lo, mid);\n        int r_ans = dc_majority(vec, mid+1, hi);\n        if(l_ans==r_ans) return l_ans;\n        int l_ans_nums=0, r_ans_nums = 0;\n        for(int i=lo; i<=hi; i++){\n            if(vec[i]==l_ans) l_ans_nums++;\n            if(vec[i]==r_ans) r_ans_nums++;\n        }\n        return l_ans_nums>r_ans_nums ? l_ans : r_ans;\n    }\npublic:\n    int majorityElement(vector<int>& nums) {\n        int major=dc_majority(nums, 0, nums.size()-1);\n        return major;\n    }\n};\n\nint main(int argc, char const *argv[])\n{\n    // Solution sol;\n    // std::vector<int> vec={3,2,3};\n    // int ans = sol.majorityElement(vec);\n    // cout<<ans<<endl;\n    // cin>>ans;\n    ios::sync_with_stdio(false);\n    int len;\n    Solution Sol;\n    int ans;\n    while(cin>>len){\n        vector<int> vec(len);\n        for(int i = 0; i < len; i++) {\n            cin>>vec[i];\n        }\n        ans = Sol.majorityElement(vec);\n        cout<<ans<<endl;\n    }\n    return 0;\n}\t\n```\n\n### 摩尔投票\n\n每次从数组中删除一对不同的元素，按照题意到最后一定会剩下至少一个元素（假设每次不同的元素都是由一个主要元素和非主要元素组成的，这样的话最终仍然剩下主要元素，假设每次不同的元素都是非主要元素构成，最后肯定也会剩下多余的主要元素。也可以理解成捉对厮杀，因为主要元素的占比超过一半，其他非主要元素小于一半，所以最后一相减一定有主要元素剩下。）\n\n#### 代码\n\n直接用的花花大神的：\n\n```c++\nclass Solution {\npublic:\n    int majorityElement(vector<int>& nums) {\n        int majority = nums.front();\n        int count = 0;\n        \n        for (const int num : nums) {\n            if (num == majority) ++count;\n            else if (--count == 0) {\n                count = 1;\n                majority = num;\n            }\n        }\n        \n        return majority;\n    }\n};\n```\n\n#### 复杂度\n\n根据代码分析很容易得出时间复杂度为O(n), 空间复杂度为O(1)。\n\n\n\n## OJ的输入\n\n这道题最开始是在UOJ上面的课程作业，我最开始做的时候不管怎么调，用什么方法，包括摩尔投票都会爆内存超过限制，后面分析出来的原因是：\n\n```c++\nint main(){\n\tSolution Sol;\n\tvector<int> vec;\n\tint n ;\n\twhile(cin>>n){\n\t\t//int tmp = n;\n\t\tint element;\n\t\twhile(n--){\n\t\t\tcin>>element;\n\t\t\tvec.push_back(element);\n\t\t}\n\t\tcout<<Sol.majorityElement(vec)<<endl;\n\t}\n\t\n}\n```\n\n我的输入是用push_back()来输入进vector中的，而vector的内存是动态申请的，不足的话会申请原来的两倍，所以造成了内存超过限制的原因，比如只需要11m的，假设上一次的vector申请到的是10m，所以下次就申请了20m造成了内存超过限制。\n\n## 参考\n\n<http://zxi.mytechroad.com/blog/divide-and-conquer/leetcode-169-majority-element/> ","slug":"2019-10-14-数组中的主要元素","published":1,"updated":"2019-11-13T16:46:17.188Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6he13yo0015dstzsf46b7b5","content":"<h1 id=\"数组中的主要元素\"><a href=\"#数组中的主要元素\" class=\"headerlink\" title=\"数组中的主要元素\"></a>数组中的主要元素</h1><p>leetcode#169题，找出一个数组中出现次数超过$\\lfloor \\dfrac{n}{2}\\rfloor$ 次数的元素，也就是过半的主要元素。题目来源：</p>\n<p><a href=\"https://leetcode.com/problems/majority-element/\" target=\"_blank\" rel=\"noopener\">https://leetcode.com/problems/majority-element/</a> </p>\n<a id=\"more\"></a>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><h3 id=\"哈希表\"><a href=\"#哈希表\" class=\"headerlink\" title=\"哈希表\"></a>哈希表</h3><p>遍历一次数组然后将每个元素出现的次数放在哈希表中，key是元素，value是出现的次数。然后输出哈希表中值大于$\\lfloor \\dfrac{n}{2}\\rfloor$ 的元素。</p>\n<h4 id=\"复杂度\"><a href=\"#复杂度\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h4><p>遍历数组的时间复杂度为O(n)，新建一个哈希表造成的空间复杂度为O(n)。</p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p>第一个是自己写的,输入是为了自己调试和算法课程作业的UOJ，这个OJ有个卡内存的坑后面讲。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">majorityElement</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">map</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; m;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class=\"line\">            m[nums[i]]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> major = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> max = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"built_in\">map</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt;::iterator it= m.begin(); it!=m.end(); it++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(it-&gt;second&gt;=max)&#123;</span><br><span class=\"line\">                max = it-&gt;second;</span><br><span class=\"line\">                major = it-&gt;first;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> major;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Solution sol;</span></span><br><span class=\"line\">    <span class=\"comment\">// std::vector&lt;int&gt; vec=&#123;3,2,3&#125;;</span></span><br><span class=\"line\">    <span class=\"comment\">// int ans = sol.majorityElement(vec);</span></span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class=\"line\">    <span class=\"comment\">// cin&gt;&gt;ans;</span></span><br><span class=\"line\">    ios::sync_with_stdio(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len;</span><br><span class=\"line\">    Solution Sol;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;len)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec(len);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span>&gt;&gt;vec[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans = Sol.majorityElement(vec);</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;ans&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后再来看看花花大神写的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Author: Huahua</span></span><br><span class=\"line\"><span class=\"comment\">// Runtime : 23 ms</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">majorityElement</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; count;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> n = nums.size();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> num : nums)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (++count[num] &gt; n / <span class=\"number\">2</span>) <span class=\"keyword\">return</span> num;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>我自己写的代码多了一步冗余操作，就是完整的把count哈希表给建立完毕之后又多次一举的进行遍历寻找最大值。实际上在对原来的数组进行遍历的同时一定会出现主要元素的计数大于$\\lfloor \\dfrac{n}{2}\\rfloor$，这个时候直接返回就可以了。</p>\n<h3 id=\"分治\"><a href=\"#分治\" class=\"headerlink\" title=\"分治\"></a>分治</h3><p>首先考虑最简单的情况，当n=1的时候，这个唯一的元素就是主要元素，这是一个最简单的子问题。那么是否所有自问都能正确返回主要元素呢？很明显当n=2的时候，如果A[0]!=A[1]，这个时候A是没有主要元素的。因为如果使用分治的话，子问题一定要有一个解得，所以当出现两个子问题的主要元素不一致的时候，如何来得到原问题的解呢？这时只能通过遍历，统计两个子问题对应的主要元素在更大的局部中出现的次数来解决。如果左边的主要元素在原问题的数组中出现的次数大于右边的主要元素那么答案就是左边的主要元素，否则的话就是右边的元素（需要注意的是返回右边的时候是包含右边的主要元素次数等于左边的情况，不过无所谓，因为后面的上一层还是要遍历统计的）。总结一下：</p>\n<p><strong>Divide</strong> 将输入数组A划分为左边A[0, n/2] 与右边A[n/2+1, n-1]两个数组</p>\n<p><strong>Conquer</strong> 左边的主要元素与右边的主要元素分别再各自递归的调用函数求解。</p>\n<p><strong>Merge</strong> 如果左边与右边的主要元素相等，那么就直接返回这个主要元素。如果不等那就统计这两个主要元素在A中的出现次数，然后返回较大的那个，次数相等的话左右两个主要元素随便返回其中一个。</p>\n<h4 id=\"复杂度-1\"><a href=\"#复杂度-1\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h4><p>根据上面的思路可以写出递推式：首先是考虑最好的情况:就是每次都有左右两个子数组的主要元素相同，不需要判别，此时有递推公式：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\\nonumber\n\\begin{split}\nT(n)&=2T[{\\lfloor\\frac{n}{2}\\rfloor]+Cn}\\\\\\\\\n&=2^2T[{\\lfloor\\frac{n}{2^2}\\rfloor]+C+2C}\\\\\\\\\n&=2^3T[{\\lfloor\\frac{n}{2^3}\\rfloor]+C+2C+2C}\\\\\\\\\n\\dots\\\\\\\\\n&=2^kT[{\\lfloor\\frac{n}{2^k}\\rfloor]+(2k-1)C}\\\\\\\\\n\\end{split} \n\\end{equation}</script><p>每次分解后规模变为左右两个子树，因此下降到$\\lfloor\\frac{n}{2}\\rfloor$,而每次比较左右两个子树最大深度与更新最大路径长度所需的时间为常数C。设当第k次的时候下降到规模为1的叶子节点，因此有$\\frac{n}{2^k}=1$推出$k=\\log_2n$所以有$T(n)=n+(2\\log_2n-1)C=O(n)$,所以时间复杂度为O(n)。</p>\n<p>考虑最坏的情况：每次都需要重新遍历来确定主要元素，也就是递归树中的每一层都需要遍历数组也就是O(n)的成本。所以有递推公式</p>\n<script type=\"math/tex; mode=display\">\nT(n)=2T[{\\lfloor\\frac{n}{2}\\rfloor]+Cn}</script><p>根据主定理可以得出算法的最坏时间复杂度为$O(nlogn)$</p>\n<p>空间复杂度因为可以使用左右的索引来进行划分，不需要额外的空间所以是O(1)。</p>\n<h4 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dc_majority</span><span class=\"params\">(<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp;vec, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(lo&gt;=hi) <span class=\"keyword\">return</span> vec[lo];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = lo + (hi-lo)/<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> l_ans = dc_majority(vec, lo, mid);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> r_ans = dc_majority(vec, mid+<span class=\"number\">1</span>, hi);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l_ans==r_ans) <span class=\"keyword\">return</span> l_ans;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> l_ans_nums=<span class=\"number\">0</span>, r_ans_nums = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=lo; i&lt;=hi; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(vec[i]==l_ans) l_ans_nums++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(vec[i]==r_ans) r_ans_nums++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> l_ans_nums&gt;r_ans_nums ? l_ans : r_ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">majorityElement</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> major=dc_majority(nums, <span class=\"number\">0</span>, nums.size()<span class=\"number\">-1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> major;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Solution sol;</span></span><br><span class=\"line\">    <span class=\"comment\">// std::vector&lt;int&gt; vec=&#123;3,2,3&#125;;</span></span><br><span class=\"line\">    <span class=\"comment\">// int ans = sol.majorityElement(vec);</span></span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class=\"line\">    <span class=\"comment\">// cin&gt;&gt;ans;</span></span><br><span class=\"line\">    ios::sync_with_stdio(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len;</span><br><span class=\"line\">    Solution Sol;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;len)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec(len);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span>&gt;&gt;vec[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans = Sol.majorityElement(vec);</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;ans&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"摩尔投票\"><a href=\"#摩尔投票\" class=\"headerlink\" title=\"摩尔投票\"></a>摩尔投票</h3><p>每次从数组中删除一对不同的元素，按照题意到最后一定会剩下至少一个元素（假设每次不同的元素都是由一个主要元素和非主要元素组成的，这样的话最终仍然剩下主要元素，假设每次不同的元素都是非主要元素构成，最后肯定也会剩下多余的主要元素。也可以理解成捉对厮杀，因为主要元素的占比超过一半，其他非主要元素小于一半，所以最后一相减一定有主要元素剩下。）</p>\n<h4 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p>直接用的花花大神的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">majorityElement</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> majority = nums.front();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> num : nums) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (num == majority) ++count;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (--count == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                count = <span class=\"number\">1</span>;</span><br><span class=\"line\">                majority = num;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> majority;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"复杂度-2\"><a href=\"#复杂度-2\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h4><p>根据代码分析很容易得出时间复杂度为O(n), 空间复杂度为O(1)。</p>\n<h2 id=\"OJ的输入\"><a href=\"#OJ的输入\" class=\"headerlink\" title=\"OJ的输入\"></a>OJ的输入</h2><p>这道题最开始是在UOJ上面的课程作业，我最开始做的时候不管怎么调，用什么方法，包括摩尔投票都会爆内存超过限制，后面分析出来的原因是：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tSolution Sol;</span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n ;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;n)&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//int tmp = n;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> element;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(n--)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">cin</span>&gt;&gt;element;</span><br><span class=\"line\">\t\t\tvec.push_back(element);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;Sol.majorityElement(vec)&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我的输入是用push_back()来输入进vector中的，而vector的内存是动态申请的，不足的话会申请原来的两倍，所以造成了内存超过限制的原因，比如只需要11m的，假设上一次的vector申请到的是10m，所以下次就申请了20m造成了内存超过限制。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://zxi.mytechroad.com/blog/divide-and-conquer/leetcode-169-majority-element/\" target=\"_blank\" rel=\"noopener\">http://zxi.mytechroad.com/blog/divide-and-conquer/leetcode-169-majority-element/</a> </p>\n","site":{"data":{}},"length":4999,"excerpt":"<h1 id=\"数组中的主要元素\"><a href=\"#数组中的主要元素\" class=\"headerlink\" title=\"数组中的主要元素\"></a>数组中的主要元素</h1><p>leetcode#169题，找出一个数组中出现次数超过$\\lfloor \\dfrac{n}{2}\\rfloor$ 次数的元素，也就是过半的主要元素。题目来源：</p>\n<p><a href=\"https://leetcode.com/problems/majority-element/\" target=\"_blank\" rel=\"noopener\">https://leetcode.com/problems/majority-element/</a> </p>","more":"<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><h3 id=\"哈希表\"><a href=\"#哈希表\" class=\"headerlink\" title=\"哈希表\"></a>哈希表</h3><p>遍历一次数组然后将每个元素出现的次数放在哈希表中，key是元素，value是出现的次数。然后输出哈希表中值大于$\\lfloor \\dfrac{n}{2}\\rfloor$ 的元素。</p>\n<h4 id=\"复杂度\"><a href=\"#复杂度\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h4><p>遍历数组的时间复杂度为O(n)，新建一个哈希表造成的空间复杂度为O(n)。</p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p>第一个是自己写的,输入是为了自己调试和算法课程作业的UOJ，这个OJ有个卡内存的坑后面讲。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">majorityElement</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">map</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; m;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class=\"line\">            m[nums[i]]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> major = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> max = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"built_in\">map</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt;::iterator it= m.begin(); it!=m.end(); it++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(it-&gt;second&gt;=max)&#123;</span><br><span class=\"line\">                max = it-&gt;second;</span><br><span class=\"line\">                major = it-&gt;first;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> major;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Solution sol;</span></span><br><span class=\"line\">    <span class=\"comment\">// std::vector&lt;int&gt; vec=&#123;3,2,3&#125;;</span></span><br><span class=\"line\">    <span class=\"comment\">// int ans = sol.majorityElement(vec);</span></span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class=\"line\">    <span class=\"comment\">// cin&gt;&gt;ans;</span></span><br><span class=\"line\">    ios::sync_with_stdio(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len;</span><br><span class=\"line\">    Solution Sol;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;len)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec(len);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span>&gt;&gt;vec[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans = Sol.majorityElement(vec);</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;ans&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后再来看看花花大神写的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Author: Huahua</span></span><br><span class=\"line\"><span class=\"comment\">// Runtime : 23 ms</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">majorityElement</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; count;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> n = nums.size();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> num : nums)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (++count[num] &gt; n / <span class=\"number\">2</span>) <span class=\"keyword\">return</span> num;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>我自己写的代码多了一步冗余操作，就是完整的把count哈希表给建立完毕之后又多次一举的进行遍历寻找最大值。实际上在对原来的数组进行遍历的同时一定会出现主要元素的计数大于$\\lfloor \\dfrac{n}{2}\\rfloor$，这个时候直接返回就可以了。</p>\n<h3 id=\"分治\"><a href=\"#分治\" class=\"headerlink\" title=\"分治\"></a>分治</h3><p>首先考虑最简单的情况，当n=1的时候，这个唯一的元素就是主要元素，这是一个最简单的子问题。那么是否所有自问都能正确返回主要元素呢？很明显当n=2的时候，如果A[0]!=A[1]，这个时候A是没有主要元素的。因为如果使用分治的话，子问题一定要有一个解得，所以当出现两个子问题的主要元素不一致的时候，如何来得到原问题的解呢？这时只能通过遍历，统计两个子问题对应的主要元素在更大的局部中出现的次数来解决。如果左边的主要元素在原问题的数组中出现的次数大于右边的主要元素那么答案就是左边的主要元素，否则的话就是右边的元素（需要注意的是返回右边的时候是包含右边的主要元素次数等于左边的情况，不过无所谓，因为后面的上一层还是要遍历统计的）。总结一下：</p>\n<p><strong>Divide</strong> 将输入数组A划分为左边A[0, n/2] 与右边A[n/2+1, n-1]两个数组</p>\n<p><strong>Conquer</strong> 左边的主要元素与右边的主要元素分别再各自递归的调用函数求解。</p>\n<p><strong>Merge</strong> 如果左边与右边的主要元素相等，那么就直接返回这个主要元素。如果不等那就统计这两个主要元素在A中的出现次数，然后返回较大的那个，次数相等的话左右两个主要元素随便返回其中一个。</p>\n<h4 id=\"复杂度-1\"><a href=\"#复杂度-1\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h4><p>根据上面的思路可以写出递推式：首先是考虑最好的情况:就是每次都有左右两个子数组的主要元素相同，不需要判别，此时有递推公式：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\\nonumber\n\\begin{split}\nT(n)&=2T[{\\lfloor\\frac{n}{2}\\rfloor]+Cn}\\\\\\\\\n&=2^2T[{\\lfloor\\frac{n}{2^2}\\rfloor]+C+2C}\\\\\\\\\n&=2^3T[{\\lfloor\\frac{n}{2^3}\\rfloor]+C+2C+2C}\\\\\\\\\n\\dots\\\\\\\\\n&=2^kT[{\\lfloor\\frac{n}{2^k}\\rfloor]+(2k-1)C}\\\\\\\\\n\\end{split} \n\\end{equation}</script><p>每次分解后规模变为左右两个子树，因此下降到$\\lfloor\\frac{n}{2}\\rfloor$,而每次比较左右两个子树最大深度与更新最大路径长度所需的时间为常数C。设当第k次的时候下降到规模为1的叶子节点，因此有$\\frac{n}{2^k}=1$推出$k=\\log_2n$所以有$T(n)=n+(2\\log_2n-1)C=O(n)$,所以时间复杂度为O(n)。</p>\n<p>考虑最坏的情况：每次都需要重新遍历来确定主要元素，也就是递归树中的每一层都需要遍历数组也就是O(n)的成本。所以有递推公式</p>\n<script type=\"math/tex; mode=display\">\nT(n)=2T[{\\lfloor\\frac{n}{2}\\rfloor]+Cn}</script><p>根据主定理可以得出算法的最坏时间复杂度为$O(nlogn)$</p>\n<p>空间复杂度因为可以使用左右的索引来进行划分，不需要额外的空间所以是O(1)。</p>\n<h4 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dc_majority</span><span class=\"params\">(<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp;vec, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(lo&gt;=hi) <span class=\"keyword\">return</span> vec[lo];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = lo + (hi-lo)/<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> l_ans = dc_majority(vec, lo, mid);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> r_ans = dc_majority(vec, mid+<span class=\"number\">1</span>, hi);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l_ans==r_ans) <span class=\"keyword\">return</span> l_ans;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> l_ans_nums=<span class=\"number\">0</span>, r_ans_nums = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=lo; i&lt;=hi; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(vec[i]==l_ans) l_ans_nums++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(vec[i]==r_ans) r_ans_nums++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> l_ans_nums&gt;r_ans_nums ? l_ans : r_ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">majorityElement</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> major=dc_majority(nums, <span class=\"number\">0</span>, nums.size()<span class=\"number\">-1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> major;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Solution sol;</span></span><br><span class=\"line\">    <span class=\"comment\">// std::vector&lt;int&gt; vec=&#123;3,2,3&#125;;</span></span><br><span class=\"line\">    <span class=\"comment\">// int ans = sol.majorityElement(vec);</span></span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class=\"line\">    <span class=\"comment\">// cin&gt;&gt;ans;</span></span><br><span class=\"line\">    ios::sync_with_stdio(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len;</span><br><span class=\"line\">    Solution Sol;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;len)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec(len);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span>&gt;&gt;vec[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans = Sol.majorityElement(vec);</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;ans&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"摩尔投票\"><a href=\"#摩尔投票\" class=\"headerlink\" title=\"摩尔投票\"></a>摩尔投票</h3><p>每次从数组中删除一对不同的元素，按照题意到最后一定会剩下至少一个元素（假设每次不同的元素都是由一个主要元素和非主要元素组成的，这样的话最终仍然剩下主要元素，假设每次不同的元素都是非主要元素构成，最后肯定也会剩下多余的主要元素。也可以理解成捉对厮杀，因为主要元素的占比超过一半，其他非主要元素小于一半，所以最后一相减一定有主要元素剩下。）</p>\n<h4 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p>直接用的花花大神的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">majorityElement</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> majority = nums.front();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> num : nums) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (num == majority) ++count;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (--count == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                count = <span class=\"number\">1</span>;</span><br><span class=\"line\">                majority = num;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> majority;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"复杂度-2\"><a href=\"#复杂度-2\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h4><p>根据代码分析很容易得出时间复杂度为O(n), 空间复杂度为O(1)。</p>\n<h2 id=\"OJ的输入\"><a href=\"#OJ的输入\" class=\"headerlink\" title=\"OJ的输入\"></a>OJ的输入</h2><p>这道题最开始是在UOJ上面的课程作业，我最开始做的时候不管怎么调，用什么方法，包括摩尔投票都会爆内存超过限制，后面分析出来的原因是：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tSolution Sol;</span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n ;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;n)&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//int tmp = n;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> element;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(n--)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">cin</span>&gt;&gt;element;</span><br><span class=\"line\">\t\t\tvec.push_back(element);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;Sol.majorityElement(vec)&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我的输入是用push_back()来输入进vector中的，而vector的内存是动态申请的，不足的话会申请原来的两倍，所以造成了内存超过限制的原因，比如只需要11m的，假设上一次的vector申请到的是10m，所以下次就申请了20m造成了内存超过限制。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://zxi.mytechroad.com/blog/divide-and-conquer/leetcode-169-majority-element/\" target=\"_blank\" rel=\"noopener\">http://zxi.mytechroad.com/blog/divide-and-conquer/leetcode-169-majority-element/</a> </p>"},{"title":"OJ输入输出","date":"2019-09-08T14:16:11.000Z","copyright":true,"_content":"\n# OJ输入输出\n\n算法课要求打UOJ，实际操作后发现与leetcode，牛客这些只用写解决类不一样，OJ要求自己编写输入输出。所以对于输入输出还是很头痛，在此总结下。\n\n<!--more-->\n\n## C++输入输出\n\n输入输出不是对文件进行操作的，可以理解成是在命令行中进行输入与输出。所以主要使用标准输入流cin进行数据的输入，标准输出流cout进行输出。因为有多组测试样例，所以一般需要放在while循环中来读取数据并进行操作。总思路是输入一组输入对应的输出一组输出，边输入边输出。\n\n需要注意的是cin 会自动跳过空格、tab、换行符等不可见的符号，所以可以在同一行中输入a,b两个值，而不用自己去分割空格。\n\n### 只有一组输入输出 \t\n\n直接从键盘获取一组输入，随后输出，以计算a+b为例。\n\n```c++\n#include < iostream >   \nusing namespace std; \nint main() \n{\n     int a,b; \n     cin >> a >> b;\n     cout << a+b << endl; \n     return 0; \n}\n```\n\n## **有多组测试数据，直到读至输入文件结尾为止** \n\n有多组测试数据，需要在while循环中读取数据并进行处理。当输入\n\n````c++\n#include < iostream >    \nusing namespace std;\nint main()\n{\n       int a,b;\n       while(cin >> a >> b)\n            cout << a+b << endl;\n       return 0;\n}\n````\n\n## **在开始的时候输入一个N，接下来是N组数据** \n\n在while循环中进行数据读入，需要注意的是如果后面需要用到n这个参数，需要使用临时变量来存储n，否则n在循环后会变成0.\n\n```c++\n#include <iostream>\nusing namespace std;\nint main() {\n    int a, b, n;\n    cin >> n;\n    while (n--) {\n        cin>>a>>b;\n        cout << a + b << endl;\n    }\n    return 0;\n}\n```\n\n## 未知输入数据量，但以某个特殊输入为结束标志\n\n当a或者b为0的时候结束输入，否则读入一组a，b并输出二者之和。\n\n```c++\n#include<iostream>\nusing namespace std;\nint main()\n{\n    int a ,b;\n    while(cin>>a>>b&&(a||b)){\n        cout<<a+b<<endl;\n    }\n    return 0;\n}\n```\n\n## 重定向输入\n\n将输入从控制台重定向到文件，从文件进行输入。\n\n```c++\n#include<iostream>  \n#include<cstdio>  \nusing namespace std;  \nint main()  \n{  \n    freopen(\"input.txt\",\"r\",stdin);  //输入将被重定向到文件\n    int a,b;  \n    cin>>a>>b;  \n    cout<<a+b<<endl;  \n    return 0;  \n} \n```\n\n## 字符串输入\n\n使用` cin.getline()`函数，其原型为：\n\n```c++\nistream& getline(char line[], int size, char endchar = '\\n');\nchar line[]： 就是一个字符数组，用户输入的内容将存入在该数组内。\nint size : 最多接受几个字符，用户超过size的输入都将不被接受。\nchar endchar :当用户输入endchar指定的字符时，自动结束，默认是回车符。\n```\n\n所以输入指定数目的字符串可以写成：\n\n```c++\n#include<iostream>\nusing namespace std;\nint main()\n{\n    char buf[ 255 ];\n    while(cin.getline( buf, 255 ));\n\n}\n```\n\n也可以使用string类型来进行输入，如下程序循环输入pair组字符串，每组字符串有两个字符串用空格分开。\n\n```c++\n#include<iostream>\n#include<string>\nusing namespace std;\nint main(int argc, char const *argv[])\n{\n\tint pair;\n    string str1, str2;\n\twhile(cin>>pair){\n\t\twhile(pair--){\n\t\t\tcin>>str1;\n\t\t\tcin>>str2;\n\t\t\tcout<<str1<<str2<<endl;\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n上面的输入样式为：\n\n```\n2\nABCD AEFC\nSCFEZ BNI\n3\nABCD AEFC\nSCFEZ BNI\nABCD XVC\n```\n\n即第一次输入2组字符串，第一组字符串为：`ABCD 与 AEFC`这两个字符串，cin会跳过空格即自动把空格前的ABCD这个字符串作为str1的输入而把空格后面的`AEFC`作为str2的输入。第二组字符串为：`SCFEZ BNI` ,与前面同理不赘述。\n\n第二次输入为3组字符串，与第一次同理。\n\n## 参考\n\n<https://blog.csdn.net/qiao1245/article/details/53020326> \n\n<https://www.cnblogs.com/emerson027/articles/9319135.html> ","source":"_posts/2019-09-08-OJ输入输出.md","raw":"---\ntitle: OJ输入输出\ndate: 2019-09-08 22:16:11\ncategories: 题解\ntags:\n- OJ\n- 编程\ncopyright: true\n---\n\n# OJ输入输出\n\n算法课要求打UOJ，实际操作后发现与leetcode，牛客这些只用写解决类不一样，OJ要求自己编写输入输出。所以对于输入输出还是很头痛，在此总结下。\n\n<!--more-->\n\n## C++输入输出\n\n输入输出不是对文件进行操作的，可以理解成是在命令行中进行输入与输出。所以主要使用标准输入流cin进行数据的输入，标准输出流cout进行输出。因为有多组测试样例，所以一般需要放在while循环中来读取数据并进行操作。总思路是输入一组输入对应的输出一组输出，边输入边输出。\n\n需要注意的是cin 会自动跳过空格、tab、换行符等不可见的符号，所以可以在同一行中输入a,b两个值，而不用自己去分割空格。\n\n### 只有一组输入输出 \t\n\n直接从键盘获取一组输入，随后输出，以计算a+b为例。\n\n```c++\n#include < iostream >   \nusing namespace std; \nint main() \n{\n     int a,b; \n     cin >> a >> b;\n     cout << a+b << endl; \n     return 0; \n}\n```\n\n## **有多组测试数据，直到读至输入文件结尾为止** \n\n有多组测试数据，需要在while循环中读取数据并进行处理。当输入\n\n````c++\n#include < iostream >    \nusing namespace std;\nint main()\n{\n       int a,b;\n       while(cin >> a >> b)\n            cout << a+b << endl;\n       return 0;\n}\n````\n\n## **在开始的时候输入一个N，接下来是N组数据** \n\n在while循环中进行数据读入，需要注意的是如果后面需要用到n这个参数，需要使用临时变量来存储n，否则n在循环后会变成0.\n\n```c++\n#include <iostream>\nusing namespace std;\nint main() {\n    int a, b, n;\n    cin >> n;\n    while (n--) {\n        cin>>a>>b;\n        cout << a + b << endl;\n    }\n    return 0;\n}\n```\n\n## 未知输入数据量，但以某个特殊输入为结束标志\n\n当a或者b为0的时候结束输入，否则读入一组a，b并输出二者之和。\n\n```c++\n#include<iostream>\nusing namespace std;\nint main()\n{\n    int a ,b;\n    while(cin>>a>>b&&(a||b)){\n        cout<<a+b<<endl;\n    }\n    return 0;\n}\n```\n\n## 重定向输入\n\n将输入从控制台重定向到文件，从文件进行输入。\n\n```c++\n#include<iostream>  \n#include<cstdio>  \nusing namespace std;  \nint main()  \n{  \n    freopen(\"input.txt\",\"r\",stdin);  //输入将被重定向到文件\n    int a,b;  \n    cin>>a>>b;  \n    cout<<a+b<<endl;  \n    return 0;  \n} \n```\n\n## 字符串输入\n\n使用` cin.getline()`函数，其原型为：\n\n```c++\nistream& getline(char line[], int size, char endchar = '\\n');\nchar line[]： 就是一个字符数组，用户输入的内容将存入在该数组内。\nint size : 最多接受几个字符，用户超过size的输入都将不被接受。\nchar endchar :当用户输入endchar指定的字符时，自动结束，默认是回车符。\n```\n\n所以输入指定数目的字符串可以写成：\n\n```c++\n#include<iostream>\nusing namespace std;\nint main()\n{\n    char buf[ 255 ];\n    while(cin.getline( buf, 255 ));\n\n}\n```\n\n也可以使用string类型来进行输入，如下程序循环输入pair组字符串，每组字符串有两个字符串用空格分开。\n\n```c++\n#include<iostream>\n#include<string>\nusing namespace std;\nint main(int argc, char const *argv[])\n{\n\tint pair;\n    string str1, str2;\n\twhile(cin>>pair){\n\t\twhile(pair--){\n\t\t\tcin>>str1;\n\t\t\tcin>>str2;\n\t\t\tcout<<str1<<str2<<endl;\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n上面的输入样式为：\n\n```\n2\nABCD AEFC\nSCFEZ BNI\n3\nABCD AEFC\nSCFEZ BNI\nABCD XVC\n```\n\n即第一次输入2组字符串，第一组字符串为：`ABCD 与 AEFC`这两个字符串，cin会跳过空格即自动把空格前的ABCD这个字符串作为str1的输入而把空格后面的`AEFC`作为str2的输入。第二组字符串为：`SCFEZ BNI` ,与前面同理不赘述。\n\n第二次输入为3组字符串，与第一次同理。\n\n## 参考\n\n<https://blog.csdn.net/qiao1245/article/details/53020326> \n\n<https://www.cnblogs.com/emerson027/articles/9319135.html> ","slug":"2019-09-08-OJ输入输出","published":1,"updated":"2019-11-11T03:34:45.463Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6he13yq0018dstzeupnptsd","content":"<h1 id=\"OJ输入输出\"><a href=\"#OJ输入输出\" class=\"headerlink\" title=\"OJ输入输出\"></a>OJ输入输出</h1><p>算法课要求打UOJ，实际操作后发现与leetcode，牛客这些只用写解决类不一样，OJ要求自己编写输入输出。所以对于输入输出还是很头痛，在此总结下。</p>\n<a id=\"more\"></a>\n<h2 id=\"C-输入输出\"><a href=\"#C-输入输出\" class=\"headerlink\" title=\"C++输入输出\"></a>C++输入输出</h2><p>输入输出不是对文件进行操作的，可以理解成是在命令行中进行输入与输出。所以主要使用标准输入流cin进行数据的输入，标准输出流cout进行输出。因为有多组测试样例，所以一般需要放在while循环中来读取数据并进行操作。总思路是输入一组输入对应的输出一组输出，边输入边输出。</p>\n<p>需要注意的是cin 会自动跳过空格、tab、换行符等不可见的符号，所以可以在同一行中输入a,b两个值，而不用自己去分割空格。</p>\n<h3 id=\"只有一组输入输出\"><a href=\"#只有一组输入输出\" class=\"headerlink\" title=\"只有一组输入输出\"></a>只有一组输入输出</h3><p>直接从键盘获取一组输入，随后输出，以计算a+b为例。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt; iostream &gt;   </span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>; </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">int</span> a,b; </span><br><span class=\"line\">     <span class=\"built_in\">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class=\"line\">     <span class=\"built_in\">cout</span> &lt;&lt; a+b &lt;&lt; <span class=\"built_in\">endl</span>; </span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"number\">0</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"有多组测试数据，直到读至输入文件结尾为止\"><a href=\"#有多组测试数据，直到读至输入文件结尾为止\" class=\"headerlink\" title=\"有多组测试数据，直到读至输入文件结尾为止\"></a><strong>有多组测试数据，直到读至输入文件结尾为止</strong></h2><p>有多组测试数据，需要在while循环中读取数据并进行处理。当输入</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt; iostream &gt;    </span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">int</span> a,b;</span><br><span class=\"line\">       <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span> &gt;&gt; a &gt;&gt; b)</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; a+b &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"在开始的时候输入一个N，接下来是N组数据\"><a href=\"#在开始的时候输入一个N，接下来是N组数据\" class=\"headerlink\" title=\"在开始的时候输入一个N，接下来是N组数据\"></a><strong>在开始的时候输入一个N，接下来是N组数据</strong></h2><p>在while循环中进行数据读入，需要注意的是如果后面需要用到n这个参数，需要使用临时变量来存储n，否则n在循环后会变成0.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a, b, n;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (n--) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; a + b &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"未知输入数据量，但以某个特殊输入为结束标志\"><a href=\"#未知输入数据量，但以某个特殊输入为结束标志\" class=\"headerlink\" title=\"未知输入数据量，但以某个特殊输入为结束标志\"></a>未知输入数据量，但以某个特殊输入为结束标志</h2><p>当a或者b为0的时候结束输入，否则读入一组a，b并输出二者之和。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a ,b;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;a&gt;&gt;b&amp;&amp;(a||b))&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;a+b&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"重定向输入\"><a href=\"#重定向输入\" class=\"headerlink\" title=\"重定向输入\"></a>重定向输入</h2><p>将输入从控制台重定向到文件，从文件进行输入。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;  </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstdio&gt;  </span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span>  </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;  </span><br><span class=\"line\">    freopen(<span class=\"string\">\"input.txt\"</span>,<span class=\"string\">\"r\"</span>,<span class=\"built_in\">stdin</span>);  <span class=\"comment\">//输入将被重定向到文件</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a,b;  </span><br><span class=\"line\">    <span class=\"built_in\">cin</span>&gt;&gt;a&gt;&gt;b;  </span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;a+b&lt;&lt;<span class=\"built_in\">endl</span>;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"字符串输入\"><a href=\"#字符串输入\" class=\"headerlink\" title=\"字符串输入\"></a>字符串输入</h2><p>使用<code>cin.getline()</code>函数，其原型为：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">istream&amp; <span class=\"title\">getline</span><span class=\"params\">(<span class=\"keyword\">char</span> line[], <span class=\"keyword\">int</span> size, <span class=\"keyword\">char</span> endchar = <span class=\"string\">'\\n'</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> line[]： 就是一个字符数组，用户输入的内容将存入在该数组内。</span><br><span class=\"line\"><span class=\"keyword\">int</span> size : 最多接受几个字符，用户超过size的输入都将不被接受。</span><br><span class=\"line\"><span class=\"keyword\">char</span> endchar :当用户输入endchar指定的字符时，自动结束，默认是回车符。</span><br></pre></td></tr></table></figure>\n<p>所以输入指定数目的字符串可以写成：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[ <span class=\"number\">255</span> ];</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>.getline( buf, <span class=\"number\">255</span> ));</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>也可以使用string类型来进行输入，如下程序循环输入pair组字符串，每组字符串有两个字符串用空格分开。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> pair;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> str1, str2;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;pair)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(pair--)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">cin</span>&gt;&gt;str1;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">cin</span>&gt;&gt;str2;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">cout</span>&lt;&lt;str1&lt;&lt;str2&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的输入样式为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2</span><br><span class=\"line\">ABCD AEFC</span><br><span class=\"line\">SCFEZ BNI</span><br><span class=\"line\">3</span><br><span class=\"line\">ABCD AEFC</span><br><span class=\"line\">SCFEZ BNI</span><br><span class=\"line\">ABCD XVC</span><br></pre></td></tr></table></figure>\n<p>即第一次输入2组字符串，第一组字符串为：<code>ABCD 与 AEFC</code>这两个字符串，cin会跳过空格即自动把空格前的ABCD这个字符串作为str1的输入而把空格后面的<code>AEFC</code>作为str2的输入。第二组字符串为：<code>SCFEZ BNI</code> ,与前面同理不赘述。</p>\n<p>第二次输入为3组字符串，与第一次同理。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://blog.csdn.net/qiao1245/article/details/53020326\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qiao1245/article/details/53020326</a> </p>\n<p><a href=\"https://www.cnblogs.com/emerson027/articles/9319135.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/emerson027/articles/9319135.html</a> </p>\n","site":{"data":{}},"length":2353,"excerpt":"<h1 id=\"OJ输入输出\"><a href=\"#OJ输入输出\" class=\"headerlink\" title=\"OJ输入输出\"></a>OJ输入输出</h1><p>算法课要求打UOJ，实际操作后发现与leetcode，牛客这些只用写解决类不一样，OJ要求自己编写输入输出。所以对于输入输出还是很头痛，在此总结下。</p>","more":"<h2 id=\"C-输入输出\"><a href=\"#C-输入输出\" class=\"headerlink\" title=\"C++输入输出\"></a>C++输入输出</h2><p>输入输出不是对文件进行操作的，可以理解成是在命令行中进行输入与输出。所以主要使用标准输入流cin进行数据的输入，标准输出流cout进行输出。因为有多组测试样例，所以一般需要放在while循环中来读取数据并进行操作。总思路是输入一组输入对应的输出一组输出，边输入边输出。</p>\n<p>需要注意的是cin 会自动跳过空格、tab、换行符等不可见的符号，所以可以在同一行中输入a,b两个值，而不用自己去分割空格。</p>\n<h3 id=\"只有一组输入输出\"><a href=\"#只有一组输入输出\" class=\"headerlink\" title=\"只有一组输入输出\"></a>只有一组输入输出</h3><p>直接从键盘获取一组输入，随后输出，以计算a+b为例。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt; iostream &gt;   </span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>; </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">int</span> a,b; </span><br><span class=\"line\">     <span class=\"built_in\">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class=\"line\">     <span class=\"built_in\">cout</span> &lt;&lt; a+b &lt;&lt; <span class=\"built_in\">endl</span>; </span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"number\">0</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"有多组测试数据，直到读至输入文件结尾为止\"><a href=\"#有多组测试数据，直到读至输入文件结尾为止\" class=\"headerlink\" title=\"有多组测试数据，直到读至输入文件结尾为止\"></a><strong>有多组测试数据，直到读至输入文件结尾为止</strong></h2><p>有多组测试数据，需要在while循环中读取数据并进行处理。当输入</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt; iostream &gt;    </span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">int</span> a,b;</span><br><span class=\"line\">       <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span> &gt;&gt; a &gt;&gt; b)</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; a+b &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"在开始的时候输入一个N，接下来是N组数据\"><a href=\"#在开始的时候输入一个N，接下来是N组数据\" class=\"headerlink\" title=\"在开始的时候输入一个N，接下来是N组数据\"></a><strong>在开始的时候输入一个N，接下来是N组数据</strong></h2><p>在while循环中进行数据读入，需要注意的是如果后面需要用到n这个参数，需要使用临时变量来存储n，否则n在循环后会变成0.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a, b, n;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (n--) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; a + b &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"未知输入数据量，但以某个特殊输入为结束标志\"><a href=\"#未知输入数据量，但以某个特殊输入为结束标志\" class=\"headerlink\" title=\"未知输入数据量，但以某个特殊输入为结束标志\"></a>未知输入数据量，但以某个特殊输入为结束标志</h2><p>当a或者b为0的时候结束输入，否则读入一组a，b并输出二者之和。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a ,b;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;a&gt;&gt;b&amp;&amp;(a||b))&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;a+b&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"重定向输入\"><a href=\"#重定向输入\" class=\"headerlink\" title=\"重定向输入\"></a>重定向输入</h2><p>将输入从控制台重定向到文件，从文件进行输入。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;  </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstdio&gt;  </span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span>  </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;  </span><br><span class=\"line\">    freopen(<span class=\"string\">\"input.txt\"</span>,<span class=\"string\">\"r\"</span>,<span class=\"built_in\">stdin</span>);  <span class=\"comment\">//输入将被重定向到文件</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a,b;  </span><br><span class=\"line\">    <span class=\"built_in\">cin</span>&gt;&gt;a&gt;&gt;b;  </span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;a+b&lt;&lt;<span class=\"built_in\">endl</span>;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"字符串输入\"><a href=\"#字符串输入\" class=\"headerlink\" title=\"字符串输入\"></a>字符串输入</h2><p>使用<code>cin.getline()</code>函数，其原型为：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">istream&amp; <span class=\"title\">getline</span><span class=\"params\">(<span class=\"keyword\">char</span> line[], <span class=\"keyword\">int</span> size, <span class=\"keyword\">char</span> endchar = <span class=\"string\">'\\n'</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> line[]： 就是一个字符数组，用户输入的内容将存入在该数组内。</span><br><span class=\"line\"><span class=\"keyword\">int</span> size : 最多接受几个字符，用户超过size的输入都将不被接受。</span><br><span class=\"line\"><span class=\"keyword\">char</span> endchar :当用户输入endchar指定的字符时，自动结束，默认是回车符。</span><br></pre></td></tr></table></figure>\n<p>所以输入指定数目的字符串可以写成：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[ <span class=\"number\">255</span> ];</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>.getline( buf, <span class=\"number\">255</span> ));</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>也可以使用string类型来进行输入，如下程序循环输入pair组字符串，每组字符串有两个字符串用空格分开。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> pair;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> str1, str2;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;pair)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(pair--)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">cin</span>&gt;&gt;str1;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">cin</span>&gt;&gt;str2;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">cout</span>&lt;&lt;str1&lt;&lt;str2&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的输入样式为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2</span><br><span class=\"line\">ABCD AEFC</span><br><span class=\"line\">SCFEZ BNI</span><br><span class=\"line\">3</span><br><span class=\"line\">ABCD AEFC</span><br><span class=\"line\">SCFEZ BNI</span><br><span class=\"line\">ABCD XVC</span><br></pre></td></tr></table></figure>\n<p>即第一次输入2组字符串，第一组字符串为：<code>ABCD 与 AEFC</code>这两个字符串，cin会跳过空格即自动把空格前的ABCD这个字符串作为str1的输入而把空格后面的<code>AEFC</code>作为str2的输入。第二组字符串为：<code>SCFEZ BNI</code> ,与前面同理不赘述。</p>\n<p>第二次输入为3组字符串，与第一次同理。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://blog.csdn.net/qiao1245/article/details/53020326\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qiao1245/article/details/53020326</a> </p>\n<p><a href=\"https://www.cnblogs.com/emerson027/articles/9319135.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/emerson027/articles/9319135.html</a> </p>"},{"title":"逆序对的计数","date":"2019-10-07T03:07:35.000Z","copyright":true,"mathjax":true,"_content":"\n# 逆序对的计数\n\nleetcode#493题，给定一个数组A，寻找i<j，但是有A[i]>A[j]的数目。变种为重要逆序对的寻找即寻找A[i]>kA[j]的数目。\n\n题目来源：https://leetcode.com/problems/reverse-pairs/\n\n<!--more-->\n\n## 解题思路\n\n基本的逆序对与重要逆序对思路一致，因此只对逆序对进行讲解。\n\n### 暴力枚举\n\n从前往后遍历数组，枚举出所有(A[i],A[j])，然后统计符合条件的重要逆序对的数目，很明显所需要的时间复杂度为\n\n$O(n^2)$\n\n### 分治\n\n#### 分析\n\n先考虑最简单的情况：\n\n如果input的数组长度为n=1，则输出为0，不存在逆序对。会做\n\nn=2的时候，可以分解成两个n=1的情况。因为左右两边都是一个元素自然都不存在逆序对，考虑一个元素在左边，一个在右边的情况可以得出(8,4)一个逆序对的情况，所以输出为1。会做\n\nn=4的时候：同样的可以分解成两个n=2的情况，因为我们已经解决了n=2的问题。这时候左边数组存在一个(8,4)的逆序对，右边数组存在一个(3,2)的逆序对。这时候主要考虑的是交叉的情况，如果左右两个数组都是没有结构的，那么只能用两个指针来挨个遍历左右两边的数组了时间复杂度为$O(n^2)$ 。如果左右两边数组都是有序的情况下，就可以减少很多冗余的比较操作了，当$L_i>R_j$ 时，左边数组位于$L_i$ 后面的元素肯定都会大于$R_j$ ，因此就不用在比较$L_i$ 后面的元素了,将右边数组指针+1寻找更大的元素来进行比较。当$L_i<R_j$时，需要将左边的指针+1，寻找一个更大的左边元素进行比较。因为左右指针总共的移动次数不超过数组长度，所以这时的复杂度为$O(n)$。以图中的例子来说明，当有4大于3的时候，就不需要比较8是否大于3了。\n\n一个形象的比喻是两个人打牌，一个人L拿的是左边的数组，另一个人R是右边的数组，牌已经从小到大整理好了。如果L最小的牌比R的最小的牌都大，那么L手中所有的牌都比R的最小的牌大。R要找到比L当前牌更大的牌只能向后寻找，如果找不到说明，L所有的牌都比R大，如果找到了是$R_j$那么L就向后面再找一个新的比$R_j$的牌大的新牌$L_i$ 。规则就是从左到右出牌，牌小的先出，最后谁的牌出完那么游戏结束，结束逆序对的统计。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1570434502/blog/reversepairs.jpg)\n\n#### 归纳\n\n可以看到，在上述分析过程中我们可以将输入为n的数组不断划分为原来的一半直至最后n=1的情况，从n=1的情况再向上合并得到上层问题的答案，也就是归并排序的过程中加上了逆序对的统计，这是一个很典型的分治策略。\n\n**Divide** 将输入数组A划分为左边A[0, n/2] 与右边A[n/2+1, n-1]两个数组\n\n**Conquer** 左边的逆序对数目与右边的逆序对数目分别再各自递归的调用函数求解，同时对其排序。\n\n**Merge** 统计逆序对元素交叉在左右两边的情况，并将两个排好序的子数组合并成一个新的有序数组\n\n#### 复杂度\n\n将规模为n的问题分解成两个两个$\\frac{n}{2}$ 的子问题问题，同时对两个子问题进行合并的复杂度为O(n)，所以有递推公式：\n\n\n$$\nT(n)=\\left\\{\n  \\begin{array}{**lr**}  \n             1 &  n=1\\\\\\\\  \n             2T(\\frac{n}{2})+O(n)\n             \\end{array}  \n\\right.\n$$\n根据主定理有最后的复杂度为$O(n\\log(n))$\n\n### 代码\n\n```c++\n/*\nhttps://leetcode.com/problems/reverse-pairs/\n */\n#include <iostream>\n#include <vector>\nusing namespace std;\nclass Solution {\n\tvector<int> tmp_vec;//把tmp_vec设置成共有变量，而不在函数中设置为临时变量可以减少多次对其创建与销毁，提高效率\npublic:\n    int reversePairs(vector<int>& nums) {\n    \tint size = nums.size();\n    \ttmp_vec.resize(nums.size());\n        return MergeSort(nums, 0, size-1); // 不用全局变量否则，多线程的时候会被修改。\n    }\n\nprivate:\n\tint MergeSort(vector<int>& vec, int lo, int hi){\n\t\tif(lo>=hi) return 0;// base case 递归必备\n\t\tint mid = lo + (hi -lo)/2; //防止两个超级大的int相加后造成溢出\n\t\tint ans = 0;\n\t\tans += MergeSort(vec, lo, mid); //左边merge的计数\n\t\tans += MergeSort(vec, mid+1, hi); //右边merge的计数\n\t\tans += Merge(vec, lo, hi, mid);// 返回什么？ 本次merge的技术 也就是split 的情况\n\t\treturn ans;\n\t}\n\n\tint Merge(vector<int>& vec, int lo, int hi, int mid){ //采用双指针来一次把左右两边的小值冒泡出来放到合并后的数组中，同时完成对逆序数目的统计\n\t\tint p = lo;\n\t\tint q = mid + 1;\n\t\tint count = 0;//记录逆序数目\n\t\tint index = lo;\n\t\twhile(p<=mid&&q<=hi){\n\t\t\tif((long)vec[p] > (long)vec[q]*3){\n\t\t\t\tcount += mid-p+1;\n\t\t\t\tq++;\n\t\t\t}else{\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\t//正常的merge操作\n\t\tp = lo ;\n\t\tq = mid + 1;\n\t\twhile(p<=mid&&q<=hi){\n\t\t\tif(vec[p]>=vec[q]) tmp_vec[index++]=vec[q++];\n\t\t\telse tmp_vec[index++]=vec[p++];\n\t\t}\n\t\twhile(p<=mid) tmp_vec[index++]=vec[p++];\n\t\twhile(q<=hi) tmp_vec[index++]=vec[q++];\n\t\tfor(int i=lo; i<=hi; i++){\n\t\t\tvec[i] = tmp_vec[i];\n\t\t}\n\t\treturn count;\n\t}    \n};\n\nint main(){\n\tSolution Sol;\n\tvector<int> vec;\n\tint n ;\n\twhile(cin>>n){\n\t\t//int tmp = n;\n\t\tint element;\n\t\twhile(n--){\n\t\t\tcin>>element;\n\t\t\tvec.push_back(element);\n\t\t}\n\t\tcout<<Sol.reversePairs(vec)<<endl;\n\t}\n\t\n}\n```\n\n","source":"_posts/2019-10-07-逆序对的计数.md","raw":"---\ntitle: 逆序对的计数\ndate: 2019-10-07 11:07:35\ncategories: 题解\ntags:\n- leetcode\n- 归并排序\n- 分治\ncopyright: true\nmathjax: true\n---\n\n# 逆序对的计数\n\nleetcode#493题，给定一个数组A，寻找i<j，但是有A[i]>A[j]的数目。变种为重要逆序对的寻找即寻找A[i]>kA[j]的数目。\n\n题目来源：https://leetcode.com/problems/reverse-pairs/\n\n<!--more-->\n\n## 解题思路\n\n基本的逆序对与重要逆序对思路一致，因此只对逆序对进行讲解。\n\n### 暴力枚举\n\n从前往后遍历数组，枚举出所有(A[i],A[j])，然后统计符合条件的重要逆序对的数目，很明显所需要的时间复杂度为\n\n$O(n^2)$\n\n### 分治\n\n#### 分析\n\n先考虑最简单的情况：\n\n如果input的数组长度为n=1，则输出为0，不存在逆序对。会做\n\nn=2的时候，可以分解成两个n=1的情况。因为左右两边都是一个元素自然都不存在逆序对，考虑一个元素在左边，一个在右边的情况可以得出(8,4)一个逆序对的情况，所以输出为1。会做\n\nn=4的时候：同样的可以分解成两个n=2的情况，因为我们已经解决了n=2的问题。这时候左边数组存在一个(8,4)的逆序对，右边数组存在一个(3,2)的逆序对。这时候主要考虑的是交叉的情况，如果左右两个数组都是没有结构的，那么只能用两个指针来挨个遍历左右两边的数组了时间复杂度为$O(n^2)$ 。如果左右两边数组都是有序的情况下，就可以减少很多冗余的比较操作了，当$L_i>R_j$ 时，左边数组位于$L_i$ 后面的元素肯定都会大于$R_j$ ，因此就不用在比较$L_i$ 后面的元素了,将右边数组指针+1寻找更大的元素来进行比较。当$L_i<R_j$时，需要将左边的指针+1，寻找一个更大的左边元素进行比较。因为左右指针总共的移动次数不超过数组长度，所以这时的复杂度为$O(n)$。以图中的例子来说明，当有4大于3的时候，就不需要比较8是否大于3了。\n\n一个形象的比喻是两个人打牌，一个人L拿的是左边的数组，另一个人R是右边的数组，牌已经从小到大整理好了。如果L最小的牌比R的最小的牌都大，那么L手中所有的牌都比R的最小的牌大。R要找到比L当前牌更大的牌只能向后寻找，如果找不到说明，L所有的牌都比R大，如果找到了是$R_j$那么L就向后面再找一个新的比$R_j$的牌大的新牌$L_i$ 。规则就是从左到右出牌，牌小的先出，最后谁的牌出完那么游戏结束，结束逆序对的统计。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1570434502/blog/reversepairs.jpg)\n\n#### 归纳\n\n可以看到，在上述分析过程中我们可以将输入为n的数组不断划分为原来的一半直至最后n=1的情况，从n=1的情况再向上合并得到上层问题的答案，也就是归并排序的过程中加上了逆序对的统计，这是一个很典型的分治策略。\n\n**Divide** 将输入数组A划分为左边A[0, n/2] 与右边A[n/2+1, n-1]两个数组\n\n**Conquer** 左边的逆序对数目与右边的逆序对数目分别再各自递归的调用函数求解，同时对其排序。\n\n**Merge** 统计逆序对元素交叉在左右两边的情况，并将两个排好序的子数组合并成一个新的有序数组\n\n#### 复杂度\n\n将规模为n的问题分解成两个两个$\\frac{n}{2}$ 的子问题问题，同时对两个子问题进行合并的复杂度为O(n)，所以有递推公式：\n\n\n$$\nT(n)=\\left\\{\n  \\begin{array}{**lr**}  \n             1 &  n=1\\\\\\\\  \n             2T(\\frac{n}{2})+O(n)\n             \\end{array}  \n\\right.\n$$\n根据主定理有最后的复杂度为$O(n\\log(n))$\n\n### 代码\n\n```c++\n/*\nhttps://leetcode.com/problems/reverse-pairs/\n */\n#include <iostream>\n#include <vector>\nusing namespace std;\nclass Solution {\n\tvector<int> tmp_vec;//把tmp_vec设置成共有变量，而不在函数中设置为临时变量可以减少多次对其创建与销毁，提高效率\npublic:\n    int reversePairs(vector<int>& nums) {\n    \tint size = nums.size();\n    \ttmp_vec.resize(nums.size());\n        return MergeSort(nums, 0, size-1); // 不用全局变量否则，多线程的时候会被修改。\n    }\n\nprivate:\n\tint MergeSort(vector<int>& vec, int lo, int hi){\n\t\tif(lo>=hi) return 0;// base case 递归必备\n\t\tint mid = lo + (hi -lo)/2; //防止两个超级大的int相加后造成溢出\n\t\tint ans = 0;\n\t\tans += MergeSort(vec, lo, mid); //左边merge的计数\n\t\tans += MergeSort(vec, mid+1, hi); //右边merge的计数\n\t\tans += Merge(vec, lo, hi, mid);// 返回什么？ 本次merge的技术 也就是split 的情况\n\t\treturn ans;\n\t}\n\n\tint Merge(vector<int>& vec, int lo, int hi, int mid){ //采用双指针来一次把左右两边的小值冒泡出来放到合并后的数组中，同时完成对逆序数目的统计\n\t\tint p = lo;\n\t\tint q = mid + 1;\n\t\tint count = 0;//记录逆序数目\n\t\tint index = lo;\n\t\twhile(p<=mid&&q<=hi){\n\t\t\tif((long)vec[p] > (long)vec[q]*3){\n\t\t\t\tcount += mid-p+1;\n\t\t\t\tq++;\n\t\t\t}else{\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\t//正常的merge操作\n\t\tp = lo ;\n\t\tq = mid + 1;\n\t\twhile(p<=mid&&q<=hi){\n\t\t\tif(vec[p]>=vec[q]) tmp_vec[index++]=vec[q++];\n\t\t\telse tmp_vec[index++]=vec[p++];\n\t\t}\n\t\twhile(p<=mid) tmp_vec[index++]=vec[p++];\n\t\twhile(q<=hi) tmp_vec[index++]=vec[q++];\n\t\tfor(int i=lo; i<=hi; i++){\n\t\t\tvec[i] = tmp_vec[i];\n\t\t}\n\t\treturn count;\n\t}    \n};\n\nint main(){\n\tSolution Sol;\n\tvector<int> vec;\n\tint n ;\n\twhile(cin>>n){\n\t\t//int tmp = n;\n\t\tint element;\n\t\twhile(n--){\n\t\t\tcin>>element;\n\t\t\tvec.push_back(element);\n\t\t}\n\t\tcout<<Sol.reversePairs(vec)<<endl;\n\t}\n\t\n}\n```\n\n","slug":"2019-10-07-逆序对的计数","published":1,"updated":"2019-11-13T16:47:53.243Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6he13ys001bdstzyc6asrzb","content":"<h1 id=\"逆序对的计数\"><a href=\"#逆序对的计数\" class=\"headerlink\" title=\"逆序对的计数\"></a>逆序对的计数</h1><p>leetcode#493题，给定一个数组A，寻找i<j，但是有a[i]>A[j]的数目。变种为重要逆序对的寻找即寻找A[i]&gt;kA[j]的数目。</j，但是有a[i]></p>\n<p>题目来源：<a href=\"https://leetcode.com/problems/reverse-pairs/\" target=\"_blank\" rel=\"noopener\">https://leetcode.com/problems/reverse-pairs/</a></p>\n<a id=\"more\"></a>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>基本的逆序对与重要逆序对思路一致，因此只对逆序对进行讲解。</p>\n<h3 id=\"暴力枚举\"><a href=\"#暴力枚举\" class=\"headerlink\" title=\"暴力枚举\"></a>暴力枚举</h3><p>从前往后遍历数组，枚举出所有(A[i],A[j])，然后统计符合条件的重要逆序对的数目，很明显所需要的时间复杂度为</p>\n<p>$O(n^2)$</p>\n<h3 id=\"分治\"><a href=\"#分治\" class=\"headerlink\" title=\"分治\"></a>分治</h3><h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><p>先考虑最简单的情况：</p>\n<p>如果input的数组长度为n=1，则输出为0，不存在逆序对。会做</p>\n<p>n=2的时候，可以分解成两个n=1的情况。因为左右两边都是一个元素自然都不存在逆序对，考虑一个元素在左边，一个在右边的情况可以得出(8,4)一个逆序对的情况，所以输出为1。会做</p>\n<p>n=4的时候：同样的可以分解成两个n=2的情况，因为我们已经解决了n=2的问题。这时候左边数组存在一个(8,4)的逆序对，右边数组存在一个(3,2)的逆序对。这时候主要考虑的是交叉的情况，如果左右两个数组都是没有结构的，那么只能用两个指针来挨个遍历左右两边的数组了时间复杂度为$O(n^2)$ 。如果左右两边数组都是有序的情况下，就可以减少很多冗余的比较操作了，当$L_i&gt;R_j$ 时，左边数组位于$L_i$ 后面的元素肯定都会大于$R_j$ ，因此就不用在比较$L_i$ 后面的元素了,将右边数组指针+1寻找更大的元素来进行比较。当$L_i&lt;R_j$时，需要将左边的指针+1，寻找一个更大的左边元素进行比较。因为左右指针总共的移动次数不超过数组长度，所以这时的复杂度为$O(n)$。以图中的例子来说明，当有4大于3的时候，就不需要比较8是否大于3了。</p>\n<p>一个形象的比喻是两个人打牌，一个人L拿的是左边的数组，另一个人R是右边的数组，牌已经从小到大整理好了。如果L最小的牌比R的最小的牌都大，那么L手中所有的牌都比R的最小的牌大。R要找到比L当前牌更大的牌只能向后寻找，如果找不到说明，L所有的牌都比R大，如果找到了是$R_j$那么L就向后面再找一个新的比$R_j$的牌大的新牌$L_i$ 。规则就是从左到右出牌，牌小的先出，最后谁的牌出完那么游戏结束，结束逆序对的统计。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1570434502/blog/reversepairs.jpg\" alt=\"\"></p>\n<h4 id=\"归纳\"><a href=\"#归纳\" class=\"headerlink\" title=\"归纳\"></a>归纳</h4><p>可以看到，在上述分析过程中我们可以将输入为n的数组不断划分为原来的一半直至最后n=1的情况，从n=1的情况再向上合并得到上层问题的答案，也就是归并排序的过程中加上了逆序对的统计，这是一个很典型的分治策略。</p>\n<p><strong>Divide</strong> 将输入数组A划分为左边A[0, n/2] 与右边A[n/2+1, n-1]两个数组</p>\n<p><strong>Conquer</strong> 左边的逆序对数目与右边的逆序对数目分别再各自递归的调用函数求解，同时对其排序。</p>\n<p><strong>Merge</strong> 统计逆序对元素交叉在左右两边的情况，并将两个排好序的子数组合并成一个新的有序数组</p>\n<h4 id=\"复杂度\"><a href=\"#复杂度\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h4><p>将规模为n的问题分解成两个两个$\\frac{n}{2}$ 的子问题问题，同时对两个子问题进行合并的复杂度为O(n)，所以有递推公式：</p>\n<script type=\"math/tex; mode=display\">\nT(n)=\\left\\{\n  \\begin{array}{**lr**}  \n             1 &  n=1\\\\\\\\  \n             2T(\\frac{n}{2})+O(n)\n             \\end{array}  \n\\right.</script><p>根据主定理有最后的复杂度为$O(n\\log(n))$</p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">https://leetcode.com/problems/reverse-pairs/</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; tmp_vec;<span class=\"comment\">//把tmp_vec设置成共有变量，而不在函数中设置为临时变量可以减少多次对其创建与销毁，提高效率</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">reversePairs</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">int</span> size = nums.size();</span><br><span class=\"line\">    \ttmp_vec.resize(nums.size());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> MergeSort(nums, <span class=\"number\">0</span>, size<span class=\"number\">-1</span>); <span class=\"comment\">// 不用全局变量否则，多线程的时候会被修改。</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">MergeSort</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; vec, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(lo&gt;=hi) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;<span class=\"comment\">// base case 递归必备</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> mid = lo + (hi -lo)/<span class=\"number\">2</span>; <span class=\"comment\">//防止两个超级大的int相加后造成溢出</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tans += MergeSort(vec, lo, mid); <span class=\"comment\">//左边merge的计数</span></span><br><span class=\"line\">\t\tans += MergeSort(vec, mid+<span class=\"number\">1</span>, hi); <span class=\"comment\">//右边merge的计数</span></span><br><span class=\"line\">\t\tans += Merge(vec, lo, hi, mid);<span class=\"comment\">// 返回什么？ 本次merge的技术 也就是split 的情况</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Merge</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; vec, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi, <span class=\"keyword\">int</span> mid)</span></span>&#123; <span class=\"comment\">//采用双指针来一次把左右两边的小值冒泡出来放到合并后的数组中，同时完成对逆序数目的统计</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> p = lo;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> q = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;<span class=\"comment\">//记录逆序数目</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> index = lo;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(p&lt;=mid&amp;&amp;q&lt;=hi)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>((<span class=\"keyword\">long</span>)vec[p] &gt; (<span class=\"keyword\">long</span>)vec[q]*<span class=\"number\">3</span>)&#123;</span><br><span class=\"line\">\t\t\t\tcount += mid-p+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\tq++;</span><br><span class=\"line\">\t\t\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\tp++;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//正常的merge操作</span></span><br><span class=\"line\">\t\tp = lo ;</span><br><span class=\"line\">\t\tq = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(p&lt;=mid&amp;&amp;q&lt;=hi)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(vec[p]&gt;=vec[q]) tmp_vec[index++]=vec[q++];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> tmp_vec[index++]=vec[p++];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(p&lt;=mid) tmp_vec[index++]=vec[p++];</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(q&lt;=hi) tmp_vec[index++]=vec[q++];</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=lo; i&lt;=hi; i++)&#123;</span><br><span class=\"line\">\t\t\tvec[i] = tmp_vec[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> count;</span><br><span class=\"line\">\t&#125;    </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tSolution Sol;</span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n ;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;n)&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//int tmp = n;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> element;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(n--)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">cin</span>&gt;&gt;element;</span><br><span class=\"line\">\t\t\tvec.push_back(element);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;Sol.reversePairs(vec)&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"length":2971,"excerpt":"<h1 id=\"逆序对的计数\"><a href=\"#逆序对的计数\" class=\"headerlink\" title=\"逆序对的计数\"></a>逆序对的计数</h1><p>leetcode#493题，给定一个数组A，寻找i<j，但是有a[i]>A[j]的数目。变种为重要逆序对的寻找即寻找A[i]&gt;kA[j]的数目。</j，但是有a[i]></p>\n<p>题目来源：<a href=\"https://leetcode.com/problems/reverse-pairs/\" target=\"_blank\" rel=\"noopener\">https://leetcode.com/problems/reverse-pairs/</a></p>","more":"<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>基本的逆序对与重要逆序对思路一致，因此只对逆序对进行讲解。</p>\n<h3 id=\"暴力枚举\"><a href=\"#暴力枚举\" class=\"headerlink\" title=\"暴力枚举\"></a>暴力枚举</h3><p>从前往后遍历数组，枚举出所有(A[i],A[j])，然后统计符合条件的重要逆序对的数目，很明显所需要的时间复杂度为</p>\n<p>$O(n^2)$</p>\n<h3 id=\"分治\"><a href=\"#分治\" class=\"headerlink\" title=\"分治\"></a>分治</h3><h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><p>先考虑最简单的情况：</p>\n<p>如果input的数组长度为n=1，则输出为0，不存在逆序对。会做</p>\n<p>n=2的时候，可以分解成两个n=1的情况。因为左右两边都是一个元素自然都不存在逆序对，考虑一个元素在左边，一个在右边的情况可以得出(8,4)一个逆序对的情况，所以输出为1。会做</p>\n<p>n=4的时候：同样的可以分解成两个n=2的情况，因为我们已经解决了n=2的问题。这时候左边数组存在一个(8,4)的逆序对，右边数组存在一个(3,2)的逆序对。这时候主要考虑的是交叉的情况，如果左右两个数组都是没有结构的，那么只能用两个指针来挨个遍历左右两边的数组了时间复杂度为$O(n^2)$ 。如果左右两边数组都是有序的情况下，就可以减少很多冗余的比较操作了，当$L_i&gt;R_j$ 时，左边数组位于$L_i$ 后面的元素肯定都会大于$R_j$ ，因此就不用在比较$L_i$ 后面的元素了,将右边数组指针+1寻找更大的元素来进行比较。当$L_i&lt;R_j$时，需要将左边的指针+1，寻找一个更大的左边元素进行比较。因为左右指针总共的移动次数不超过数组长度，所以这时的复杂度为$O(n)$。以图中的例子来说明，当有4大于3的时候，就不需要比较8是否大于3了。</p>\n<p>一个形象的比喻是两个人打牌，一个人L拿的是左边的数组，另一个人R是右边的数组，牌已经从小到大整理好了。如果L最小的牌比R的最小的牌都大，那么L手中所有的牌都比R的最小的牌大。R要找到比L当前牌更大的牌只能向后寻找，如果找不到说明，L所有的牌都比R大，如果找到了是$R_j$那么L就向后面再找一个新的比$R_j$的牌大的新牌$L_i$ 。规则就是从左到右出牌，牌小的先出，最后谁的牌出完那么游戏结束，结束逆序对的统计。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1570434502/blog/reversepairs.jpg\" alt=\"\"></p>\n<h4 id=\"归纳\"><a href=\"#归纳\" class=\"headerlink\" title=\"归纳\"></a>归纳</h4><p>可以看到，在上述分析过程中我们可以将输入为n的数组不断划分为原来的一半直至最后n=1的情况，从n=1的情况再向上合并得到上层问题的答案，也就是归并排序的过程中加上了逆序对的统计，这是一个很典型的分治策略。</p>\n<p><strong>Divide</strong> 将输入数组A划分为左边A[0, n/2] 与右边A[n/2+1, n-1]两个数组</p>\n<p><strong>Conquer</strong> 左边的逆序对数目与右边的逆序对数目分别再各自递归的调用函数求解，同时对其排序。</p>\n<p><strong>Merge</strong> 统计逆序对元素交叉在左右两边的情况，并将两个排好序的子数组合并成一个新的有序数组</p>\n<h4 id=\"复杂度\"><a href=\"#复杂度\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h4><p>将规模为n的问题分解成两个两个$\\frac{n}{2}$ 的子问题问题，同时对两个子问题进行合并的复杂度为O(n)，所以有递推公式：</p>\n<script type=\"math/tex; mode=display\">\nT(n)=\\left\\{\n  \\begin{array}{**lr**}  \n             1 &  n=1\\\\\\\\  \n             2T(\\frac{n}{2})+O(n)\n             \\end{array}  \n\\right.</script><p>根据主定理有最后的复杂度为$O(n\\log(n))$</p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">https://leetcode.com/problems/reverse-pairs/</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; tmp_vec;<span class=\"comment\">//把tmp_vec设置成共有变量，而不在函数中设置为临时变量可以减少多次对其创建与销毁，提高效率</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">reversePairs</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">int</span> size = nums.size();</span><br><span class=\"line\">    \ttmp_vec.resize(nums.size());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> MergeSort(nums, <span class=\"number\">0</span>, size<span class=\"number\">-1</span>); <span class=\"comment\">// 不用全局变量否则，多线程的时候会被修改。</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">MergeSort</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; vec, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(lo&gt;=hi) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;<span class=\"comment\">// base case 递归必备</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> mid = lo + (hi -lo)/<span class=\"number\">2</span>; <span class=\"comment\">//防止两个超级大的int相加后造成溢出</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tans += MergeSort(vec, lo, mid); <span class=\"comment\">//左边merge的计数</span></span><br><span class=\"line\">\t\tans += MergeSort(vec, mid+<span class=\"number\">1</span>, hi); <span class=\"comment\">//右边merge的计数</span></span><br><span class=\"line\">\t\tans += Merge(vec, lo, hi, mid);<span class=\"comment\">// 返回什么？ 本次merge的技术 也就是split 的情况</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Merge</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; vec, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi, <span class=\"keyword\">int</span> mid)</span></span>&#123; <span class=\"comment\">//采用双指针来一次把左右两边的小值冒泡出来放到合并后的数组中，同时完成对逆序数目的统计</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> p = lo;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> q = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;<span class=\"comment\">//记录逆序数目</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> index = lo;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(p&lt;=mid&amp;&amp;q&lt;=hi)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>((<span class=\"keyword\">long</span>)vec[p] &gt; (<span class=\"keyword\">long</span>)vec[q]*<span class=\"number\">3</span>)&#123;</span><br><span class=\"line\">\t\t\t\tcount += mid-p+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\tq++;</span><br><span class=\"line\">\t\t\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\tp++;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//正常的merge操作</span></span><br><span class=\"line\">\t\tp = lo ;</span><br><span class=\"line\">\t\tq = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(p&lt;=mid&amp;&amp;q&lt;=hi)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(vec[p]&gt;=vec[q]) tmp_vec[index++]=vec[q++];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> tmp_vec[index++]=vec[p++];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(p&lt;=mid) tmp_vec[index++]=vec[p++];</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(q&lt;=hi) tmp_vec[index++]=vec[q++];</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=lo; i&lt;=hi; i++)&#123;</span><br><span class=\"line\">\t\t\tvec[i] = tmp_vec[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> count;</span><br><span class=\"line\">\t&#125;    </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tSolution Sol;</span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n ;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;n)&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//int tmp = n;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> element;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(n--)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">cin</span>&gt;&gt;element;</span><br><span class=\"line\">\t\t\tvec.push_back(element);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;Sol.reversePairs(vec)&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"实模式寻址方式","date":"2019-09-08T02:12:44.000Z","copyright":true,"_content":"\n# 实模式寻址方式\n\n在上《操作系统高级教程》课时有BIOS启动时的实模式，讲到 CS与IP这两个寄存器，但是始终不能理解为什么说CS:IP可以表示一个物理地址，查询后才理解到与实模式的寻址方式有关。\n\n<!--more-->\n\n## 8086的寻址方式\n\n为了理解实模式，首先需要理解Intel 8086这个16位CPU的寻址模式。\n\n8086的CPU是16位，即它的所有寄存器和寄存器之间的数据总线都是16位的，而其外部数据总线却是20位的。那么如何才能访问到20位也就是1MB的地址空间呢？显然一个寄存器是不够的所以就用两个寄存器来存储，这也就是段式寻址（内存分段）。段式寻址需要使用一个寄存器作为段寄存器比如CS代码段寄存器，使用另外一个寄存器比如IP指令指针寄存器作为偏移寄存器。计算物理地址的时候首先将段寄存器的16位地址向左移动4位（也就是最开始段寄存器的地址x16），然后将左移4位后的段地址与偏移地址相加就可以得到一个20位的物理地址了。也可以理解成最开始的段寄存器的地址默认后面还有4位，只是都省略成0，这样就可以放在16位寄存器中了。\n\n## 实模式寻址方式\n\n实模式（Real mode） 是Intel 80286和之后的80x86兼容CPU的操作模式，所有的80x86CPU的开机状态都是实模式。实模式的特性是一个20位的存储器地址空间（即1MB的存储器）可以被寻址。为了兼容，也为了解决最开始的启动问题，Intel将所有80x86系列的CPU（包括最新型号的64位CPU）的硬件都设计为加电即进入16位实模式状态运行。在实模式状态下寄存器是16位的，地址总线是20位的，也就是说实模式下寻址空间为1MB。因此与8086这个16位机器一样，为了实现20位寻址依然采取段式寻址方式。\n\n开机时的第一个操作就是执行BIOS程序，CPU的硬件逻辑被设计为加电瞬间强行将CS的值设置为0XF000,IP的值设置为0XFFF0，这样CS:IP 的地址就是CS值左移四位变成0xF0000后加上IP的偏移地址也就是0xF0000+0XFFF0 也就是0xFFFF0，而0xFFFF0这个地址也就是BIOS程序的地址，CPU将开始执行这个地址的BIOS代码，从而开始BIOS的启动。\n\n## 参考\n\n《Linux内核设计的艺术》第二版\n\n<https://zh.wikipedia.org/wiki/X86#%E7%9C%9F%E5%AF%A6%E6%A8%A1%E5%BC%8F> \n\n<https://zh.wikipedia.org/wiki/Intel_8086#%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5> \n\n<https://zhuanlan.zhihu.com/p/69504370> \n\n<https://blog.csdn.net/unix21/article/details/8450214> \n\n","source":"_posts/2019-09-08-实模式寻址方式.md","raw":"---\ntitle: 实模式寻址方式\ndate: 2019-09-08 10:12:44\ncategories: 计算机基础\ntags:\n- 内存寻址\n- 寄存器\n- BIOS\ncopyright: true\n---\n\n# 实模式寻址方式\n\n在上《操作系统高级教程》课时有BIOS启动时的实模式，讲到 CS与IP这两个寄存器，但是始终不能理解为什么说CS:IP可以表示一个物理地址，查询后才理解到与实模式的寻址方式有关。\n\n<!--more-->\n\n## 8086的寻址方式\n\n为了理解实模式，首先需要理解Intel 8086这个16位CPU的寻址模式。\n\n8086的CPU是16位，即它的所有寄存器和寄存器之间的数据总线都是16位的，而其外部数据总线却是20位的。那么如何才能访问到20位也就是1MB的地址空间呢？显然一个寄存器是不够的所以就用两个寄存器来存储，这也就是段式寻址（内存分段）。段式寻址需要使用一个寄存器作为段寄存器比如CS代码段寄存器，使用另外一个寄存器比如IP指令指针寄存器作为偏移寄存器。计算物理地址的时候首先将段寄存器的16位地址向左移动4位（也就是最开始段寄存器的地址x16），然后将左移4位后的段地址与偏移地址相加就可以得到一个20位的物理地址了。也可以理解成最开始的段寄存器的地址默认后面还有4位，只是都省略成0，这样就可以放在16位寄存器中了。\n\n## 实模式寻址方式\n\n实模式（Real mode） 是Intel 80286和之后的80x86兼容CPU的操作模式，所有的80x86CPU的开机状态都是实模式。实模式的特性是一个20位的存储器地址空间（即1MB的存储器）可以被寻址。为了兼容，也为了解决最开始的启动问题，Intel将所有80x86系列的CPU（包括最新型号的64位CPU）的硬件都设计为加电即进入16位实模式状态运行。在实模式状态下寄存器是16位的，地址总线是20位的，也就是说实模式下寻址空间为1MB。因此与8086这个16位机器一样，为了实现20位寻址依然采取段式寻址方式。\n\n开机时的第一个操作就是执行BIOS程序，CPU的硬件逻辑被设计为加电瞬间强行将CS的值设置为0XF000,IP的值设置为0XFFF0，这样CS:IP 的地址就是CS值左移四位变成0xF0000后加上IP的偏移地址也就是0xF0000+0XFFF0 也就是0xFFFF0，而0xFFFF0这个地址也就是BIOS程序的地址，CPU将开始执行这个地址的BIOS代码，从而开始BIOS的启动。\n\n## 参考\n\n《Linux内核设计的艺术》第二版\n\n<https://zh.wikipedia.org/wiki/X86#%E7%9C%9F%E5%AF%A6%E6%A8%A1%E5%BC%8F> \n\n<https://zh.wikipedia.org/wiki/Intel_8086#%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5> \n\n<https://zhuanlan.zhihu.com/p/69504370> \n\n<https://blog.csdn.net/unix21/article/details/8450214> \n\n","slug":"2019-09-08-实模式寻址方式","published":1,"updated":"2019-11-08T13:12:18.272Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6he13yt001fdstzvonxo8p4","content":"<h1 id=\"实模式寻址方式\"><a href=\"#实模式寻址方式\" class=\"headerlink\" title=\"实模式寻址方式\"></a>实模式寻址方式</h1><p>在上《操作系统高级教程》课时有BIOS启动时的实模式，讲到 CS与IP这两个寄存器，但是始终不能理解为什么说CS:IP可以表示一个物理地址，查询后才理解到与实模式的寻址方式有关。</p>\n<a id=\"more\"></a>\n<h2 id=\"8086的寻址方式\"><a href=\"#8086的寻址方式\" class=\"headerlink\" title=\"8086的寻址方式\"></a>8086的寻址方式</h2><p>为了理解实模式，首先需要理解Intel 8086这个16位CPU的寻址模式。</p>\n<p>8086的CPU是16位，即它的所有寄存器和寄存器之间的数据总线都是16位的，而其外部数据总线却是20位的。那么如何才能访问到20位也就是1MB的地址空间呢？显然一个寄存器是不够的所以就用两个寄存器来存储，这也就是段式寻址（内存分段）。段式寻址需要使用一个寄存器作为段寄存器比如CS代码段寄存器，使用另外一个寄存器比如IP指令指针寄存器作为偏移寄存器。计算物理地址的时候首先将段寄存器的16位地址向左移动4位（也就是最开始段寄存器的地址x16），然后将左移4位后的段地址与偏移地址相加就可以得到一个20位的物理地址了。也可以理解成最开始的段寄存器的地址默认后面还有4位，只是都省略成0，这样就可以放在16位寄存器中了。</p>\n<h2 id=\"实模式寻址方式-1\"><a href=\"#实模式寻址方式-1\" class=\"headerlink\" title=\"实模式寻址方式\"></a>实模式寻址方式</h2><p>实模式（Real mode） 是Intel 80286和之后的80x86兼容CPU的操作模式，所有的80x86CPU的开机状态都是实模式。实模式的特性是一个20位的存储器地址空间（即1MB的存储器）可以被寻址。为了兼容，也为了解决最开始的启动问题，Intel将所有80x86系列的CPU（包括最新型号的64位CPU）的硬件都设计为加电即进入16位实模式状态运行。在实模式状态下寄存器是16位的，地址总线是20位的，也就是说实模式下寻址空间为1MB。因此与8086这个16位机器一样，为了实现20位寻址依然采取段式寻址方式。</p>\n<p>开机时的第一个操作就是执行BIOS程序，CPU的硬件逻辑被设计为加电瞬间强行将CS的值设置为0XF000,IP的值设置为0XFFF0，这样CS:IP 的地址就是CS值左移四位变成0xF0000后加上IP的偏移地址也就是0xF0000+0XFFF0 也就是0xFFFF0，而0xFFFF0这个地址也就是BIOS程序的地址，CPU将开始执行这个地址的BIOS代码，从而开始BIOS的启动。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>《Linux内核设计的艺术》第二版</p>\n<p><a href=\"https://zh.wikipedia.org/wiki/X86#%E7%9C%9F%E5%AF%A6%E6%A8%A1%E5%BC%8F\" target=\"_blank\" rel=\"noopener\">https://zh.wikipedia.org/wiki/X86#%E7%9C%9F%E5%AF%A6%E6%A8%A1%E5%BC%8F</a> </p>\n<p><a href=\"https://zh.wikipedia.org/wiki/Intel_8086#%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5\" target=\"_blank\" rel=\"noopener\">https://zh.wikipedia.org/wiki/Intel_8086#%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5</a> </p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/69504370\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/69504370</a> </p>\n<p><a href=\"https://blog.csdn.net/unix21/article/details/8450214\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/unix21/article/details/8450214</a> </p>\n","site":{"data":{}},"length":1160,"excerpt":"<h1 id=\"实模式寻址方式\"><a href=\"#实模式寻址方式\" class=\"headerlink\" title=\"实模式寻址方式\"></a>实模式寻址方式</h1><p>在上《操作系统高级教程》课时有BIOS启动时的实模式，讲到 CS与IP这两个寄存器，但是始终不能理解为什么说CS:IP可以表示一个物理地址，查询后才理解到与实模式的寻址方式有关。</p>","more":"<h2 id=\"8086的寻址方式\"><a href=\"#8086的寻址方式\" class=\"headerlink\" title=\"8086的寻址方式\"></a>8086的寻址方式</h2><p>为了理解实模式，首先需要理解Intel 8086这个16位CPU的寻址模式。</p>\n<p>8086的CPU是16位，即它的所有寄存器和寄存器之间的数据总线都是16位的，而其外部数据总线却是20位的。那么如何才能访问到20位也就是1MB的地址空间呢？显然一个寄存器是不够的所以就用两个寄存器来存储，这也就是段式寻址（内存分段）。段式寻址需要使用一个寄存器作为段寄存器比如CS代码段寄存器，使用另外一个寄存器比如IP指令指针寄存器作为偏移寄存器。计算物理地址的时候首先将段寄存器的16位地址向左移动4位（也就是最开始段寄存器的地址x16），然后将左移4位后的段地址与偏移地址相加就可以得到一个20位的物理地址了。也可以理解成最开始的段寄存器的地址默认后面还有4位，只是都省略成0，这样就可以放在16位寄存器中了。</p>\n<h2 id=\"实模式寻址方式-1\"><a href=\"#实模式寻址方式-1\" class=\"headerlink\" title=\"实模式寻址方式\"></a>实模式寻址方式</h2><p>实模式（Real mode） 是Intel 80286和之后的80x86兼容CPU的操作模式，所有的80x86CPU的开机状态都是实模式。实模式的特性是一个20位的存储器地址空间（即1MB的存储器）可以被寻址。为了兼容，也为了解决最开始的启动问题，Intel将所有80x86系列的CPU（包括最新型号的64位CPU）的硬件都设计为加电即进入16位实模式状态运行。在实模式状态下寄存器是16位的，地址总线是20位的，也就是说实模式下寻址空间为1MB。因此与8086这个16位机器一样，为了实现20位寻址依然采取段式寻址方式。</p>\n<p>开机时的第一个操作就是执行BIOS程序，CPU的硬件逻辑被设计为加电瞬间强行将CS的值设置为0XF000,IP的值设置为0XFFF0，这样CS:IP 的地址就是CS值左移四位变成0xF0000后加上IP的偏移地址也就是0xF0000+0XFFF0 也就是0xFFFF0，而0xFFFF0这个地址也就是BIOS程序的地址，CPU将开始执行这个地址的BIOS代码，从而开始BIOS的启动。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>《Linux内核设计的艺术》第二版</p>\n<p><a href=\"https://zh.wikipedia.org/wiki/X86#%E7%9C%9F%E5%AF%A6%E6%A8%A1%E5%BC%8F\" target=\"_blank\" rel=\"noopener\">https://zh.wikipedia.org/wiki/X86#%E7%9C%9F%E5%AF%A6%E6%A8%A1%E5%BC%8F</a> </p>\n<p><a href=\"https://zh.wikipedia.org/wiki/Intel_8086#%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5\" target=\"_blank\" rel=\"noopener\">https://zh.wikipedia.org/wiki/Intel_8086#%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5</a> </p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/69504370\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/69504370</a> </p>\n<p><a href=\"https://blog.csdn.net/unix21/article/details/8450214\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/unix21/article/details/8450214</a> </p>"},{"title":"Clementine教程","date":"2019-11-07T02:42:24.000Z","copyright":true,"_content":"\n# Clementine教程\n\n数据挖掘课程要求使用这个软件Clementine来进行实验，之前完全没听说过这个软件。网上搜到的资料也比较少，特别是CSDN上面有个博客名字叫做Clementine完整教程，然后内容也是Clementine教程这几个字，把我给惊呆了，这也能写博客？现在实验都已经做完了因此记录下使用方法，希望对其他人能有帮助。\n\n<!--more-->\n\n## 简介\n\n### 页面\n\n在Clementine软件中只需要简单的像画图一样，把整个数据挖掘的操作流程对应的节点给连接起来就可以使用了。先对页面简单的介绍下，页面如下。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1573095648/blog/clementine.jpg)\n\n在最下面的一栏是相对应的各个节点：Favorites中是常用的节点，Sources中是输入的数据节点，Field中是数据的属性设置节点，Modeling中是一些数据挖掘模型节点比如决策树神经网络等模型，Output中是输出节点用来查看数据。\n\n在右上角中的Streams显示整个工作台中的所有Stream，Outputs中是每次运行后得到输出结果，Models中是流程所用到的模型。\n\n数据挖掘的过程可以简单的分为两步：第一步对模型进行训练 第二步对训练好的模型进行使用。而一个完整的数据挖掘流程Stream中在Clementine中需要包含：数据输入节点->输入属性设置节点->模型节点->输出节点。在第一步模型训练中可以不使用输出节点。\n\n## 数据导入\n\n在下方节点栏中的Sources中选择Var.file节点，拖到中间的画布。然后双击设置输入数据的文件导入，如下所示：\n![](https://res.cloudinary.com/bravey/image/upload/v1573097265/blog/varfile1.jpg )\n\n在导入数据后选择分隔符我的数据是用tab分割的)，之后点击Apply完成设置。\n\n## 数据显示\n\n在导入了数据后可以使用输出节点来输出数据，选择Outputs中的Table节点来输出数据。如下所示：\n\n![](C:\\Users\\BraveY\\AppData\\Local\\Temp\\1573097747688.png)\n\n对输入节点训练集.txt邮件有个connect可以进行连接。或者使用快捷键F2来连接。连接好后右键execute就可以得到上图显示了。\n\n## 模型训练\n\n以使用决策树模型为例子，给定的输入数据集是一个在线测试系统中学生做的各项测试的数据，final是期末考试是否及格。也就是通过学生在测试系统的数据，来预测学生期末考试是否会及格。在选择模型前，需要在Fidel Ops中选择一个type节点来设置输入数据中各个属性。如下所示：\n\n![](https://res.cloudinary.com/bravey/image/upload/v1573098328/blog/type.jpg )\n\n第一个PersonId设置为Typeless不进行输入，决策树输出的是final，并设置为flag类型。其他数据都设置为range。\n\n接下来选择模型，在Modeling中选择C5.0这个决策树模型。并与前面的type节点连接。如下所示：\n\n![](https://res.cloudinary.com/bravey/image/upload/v1573098962/blog/train_tree.jpg)\n\n可以选择专家模式自定义剪枝率等参数。设置好后执行就可以得到训练好的模型了，将会显示在右上角的model中，这样就完成模型训练这个Stream了。\n\n在右上角的models中选择训练好的final模型，右键browse，然后选择viewer就可以查看训练好的决策树模型了。如下所示。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1573099406/blog/model.jpg)\n![](https://res.cloudinary.com/bravey/image/upload/v1573099392/blog/viewer.jpg)\n\n## 模型使用\n\n同样导入数据节点验证集.txt，设置好type节点(测试集的flag属性也设置为输入了)，再把训练好的模型从右上角给拖进来，最后设置输出节点。整个流程与前述相同，得到的验证流程如下：\n![](https://res.cloudinary.com/bravey/image/upload/v1573099826/blog/test_stream.jpg)\n输出节点使用混淆矩阵来查看模型的准确性，具体设置为：\n![](https://res.cloudinary.com/bravey/image/upload/v1573099827/blog/confuse_matrix.jpg)\n最后执行就可以得到最终的显示了如下：\n![](https://res.cloudinary.com/bravey/image/upload/v1573099826/blog/matrix_out.jpg)\n\n## 总结\n\n其他模型比如神经网络等的使用流程大同小异，如果需要数据集与测试集以及英文教程可以联系我。","source":"_posts/2019-11-07-Clementine教程.md","raw":"---\ntitle: Clementine教程\ndate: 2019-11-07 10:42:24\ncategories: 数据挖掘\ntags:\n- Clementine\ncopyright: true\n---\n\n# Clementine教程\n\n数据挖掘课程要求使用这个软件Clementine来进行实验，之前完全没听说过这个软件。网上搜到的资料也比较少，特别是CSDN上面有个博客名字叫做Clementine完整教程，然后内容也是Clementine教程这几个字，把我给惊呆了，这也能写博客？现在实验都已经做完了因此记录下使用方法，希望对其他人能有帮助。\n\n<!--more-->\n\n## 简介\n\n### 页面\n\n在Clementine软件中只需要简单的像画图一样，把整个数据挖掘的操作流程对应的节点给连接起来就可以使用了。先对页面简单的介绍下，页面如下。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1573095648/blog/clementine.jpg)\n\n在最下面的一栏是相对应的各个节点：Favorites中是常用的节点，Sources中是输入的数据节点，Field中是数据的属性设置节点，Modeling中是一些数据挖掘模型节点比如决策树神经网络等模型，Output中是输出节点用来查看数据。\n\n在右上角中的Streams显示整个工作台中的所有Stream，Outputs中是每次运行后得到输出结果，Models中是流程所用到的模型。\n\n数据挖掘的过程可以简单的分为两步：第一步对模型进行训练 第二步对训练好的模型进行使用。而一个完整的数据挖掘流程Stream中在Clementine中需要包含：数据输入节点->输入属性设置节点->模型节点->输出节点。在第一步模型训练中可以不使用输出节点。\n\n## 数据导入\n\n在下方节点栏中的Sources中选择Var.file节点，拖到中间的画布。然后双击设置输入数据的文件导入，如下所示：\n![](https://res.cloudinary.com/bravey/image/upload/v1573097265/blog/varfile1.jpg )\n\n在导入数据后选择分隔符我的数据是用tab分割的)，之后点击Apply完成设置。\n\n## 数据显示\n\n在导入了数据后可以使用输出节点来输出数据，选择Outputs中的Table节点来输出数据。如下所示：\n\n![](C:\\Users\\BraveY\\AppData\\Local\\Temp\\1573097747688.png)\n\n对输入节点训练集.txt邮件有个connect可以进行连接。或者使用快捷键F2来连接。连接好后右键execute就可以得到上图显示了。\n\n## 模型训练\n\n以使用决策树模型为例子，给定的输入数据集是一个在线测试系统中学生做的各项测试的数据，final是期末考试是否及格。也就是通过学生在测试系统的数据，来预测学生期末考试是否会及格。在选择模型前，需要在Fidel Ops中选择一个type节点来设置输入数据中各个属性。如下所示：\n\n![](https://res.cloudinary.com/bravey/image/upload/v1573098328/blog/type.jpg )\n\n第一个PersonId设置为Typeless不进行输入，决策树输出的是final，并设置为flag类型。其他数据都设置为range。\n\n接下来选择模型，在Modeling中选择C5.0这个决策树模型。并与前面的type节点连接。如下所示：\n\n![](https://res.cloudinary.com/bravey/image/upload/v1573098962/blog/train_tree.jpg)\n\n可以选择专家模式自定义剪枝率等参数。设置好后执行就可以得到训练好的模型了，将会显示在右上角的model中，这样就完成模型训练这个Stream了。\n\n在右上角的models中选择训练好的final模型，右键browse，然后选择viewer就可以查看训练好的决策树模型了。如下所示。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1573099406/blog/model.jpg)\n![](https://res.cloudinary.com/bravey/image/upload/v1573099392/blog/viewer.jpg)\n\n## 模型使用\n\n同样导入数据节点验证集.txt，设置好type节点(测试集的flag属性也设置为输入了)，再把训练好的模型从右上角给拖进来，最后设置输出节点。整个流程与前述相同，得到的验证流程如下：\n![](https://res.cloudinary.com/bravey/image/upload/v1573099826/blog/test_stream.jpg)\n输出节点使用混淆矩阵来查看模型的准确性，具体设置为：\n![](https://res.cloudinary.com/bravey/image/upload/v1573099827/blog/confuse_matrix.jpg)\n最后执行就可以得到最终的显示了如下：\n![](https://res.cloudinary.com/bravey/image/upload/v1573099826/blog/matrix_out.jpg)\n\n## 总结\n\n其他模型比如神经网络等的使用流程大同小异，如果需要数据集与测试集以及英文教程可以联系我。","slug":"2019-11-07-Clementine教程","published":1,"updated":"2019-11-11T11:51:14.326Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6he13yv001jdstzm0rhgu3b","content":"<h1 id=\"Clementine教程\"><a href=\"#Clementine教程\" class=\"headerlink\" title=\"Clementine教程\"></a>Clementine教程</h1><p>数据挖掘课程要求使用这个软件Clementine来进行实验，之前完全没听说过这个软件。网上搜到的资料也比较少，特别是CSDN上面有个博客名字叫做Clementine完整教程，然后内容也是Clementine教程这几个字，把我给惊呆了，这也能写博客？现在实验都已经做完了因此记录下使用方法，希望对其他人能有帮助。</p>\n<a id=\"more\"></a>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><h3 id=\"页面\"><a href=\"#页面\" class=\"headerlink\" title=\"页面\"></a>页面</h3><p>在Clementine软件中只需要简单的像画图一样，把整个数据挖掘的操作流程对应的节点给连接起来就可以使用了。先对页面简单的介绍下，页面如下。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573095648/blog/clementine.jpg\" alt=\"\"></p>\n<p>在最下面的一栏是相对应的各个节点：Favorites中是常用的节点，Sources中是输入的数据节点，Field中是数据的属性设置节点，Modeling中是一些数据挖掘模型节点比如决策树神经网络等模型，Output中是输出节点用来查看数据。</p>\n<p>在右上角中的Streams显示整个工作台中的所有Stream，Outputs中是每次运行后得到输出结果，Models中是流程所用到的模型。</p>\n<p>数据挖掘的过程可以简单的分为两步：第一步对模型进行训练 第二步对训练好的模型进行使用。而一个完整的数据挖掘流程Stream中在Clementine中需要包含：数据输入节点-&gt;输入属性设置节点-&gt;模型节点-&gt;输出节点。在第一步模型训练中可以不使用输出节点。</p>\n<h2 id=\"数据导入\"><a href=\"#数据导入\" class=\"headerlink\" title=\"数据导入\"></a>数据导入</h2><p>在下方节点栏中的Sources中选择Var.file节点，拖到中间的画布。然后双击设置输入数据的文件导入，如下所示：<br><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573097265/blog/varfile1.jpg\" alt=\"\"></p>\n<p>在导入数据后选择分隔符我的数据是用tab分割的)，之后点击Apply完成设置。</p>\n<h2 id=\"数据显示\"><a href=\"#数据显示\" class=\"headerlink\" title=\"数据显示\"></a>数据显示</h2><p>在导入了数据后可以使用输出节点来输出数据，选择Outputs中的Table节点来输出数据。如下所示：</p>\n<p><img src=\"C:\\Users\\BraveY\\AppData\\Local\\Temp\\1573097747688.png\" alt=\"\"></p>\n<p>对输入节点训练集.txt邮件有个connect可以进行连接。或者使用快捷键F2来连接。连接好后右键execute就可以得到上图显示了。</p>\n<h2 id=\"模型训练\"><a href=\"#模型训练\" class=\"headerlink\" title=\"模型训练\"></a>模型训练</h2><p>以使用决策树模型为例子，给定的输入数据集是一个在线测试系统中学生做的各项测试的数据，final是期末考试是否及格。也就是通过学生在测试系统的数据，来预测学生期末考试是否会及格。在选择模型前，需要在Fidel Ops中选择一个type节点来设置输入数据中各个属性。如下所示：</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573098328/blog/type.jpg\" alt=\"\"></p>\n<p>第一个PersonId设置为Typeless不进行输入，决策树输出的是final，并设置为flag类型。其他数据都设置为range。</p>\n<p>接下来选择模型，在Modeling中选择C5.0这个决策树模型。并与前面的type节点连接。如下所示：</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573098962/blog/train_tree.jpg\" alt=\"\"></p>\n<p>可以选择专家模式自定义剪枝率等参数。设置好后执行就可以得到训练好的模型了，将会显示在右上角的model中，这样就完成模型训练这个Stream了。</p>\n<p>在右上角的models中选择训练好的final模型，右键browse，然后选择viewer就可以查看训练好的决策树模型了。如下所示。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573099406/blog/model.jpg\" alt=\"\"><br><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573099392/blog/viewer.jpg\" alt=\"\"></p>\n<h2 id=\"模型使用\"><a href=\"#模型使用\" class=\"headerlink\" title=\"模型使用\"></a>模型使用</h2><p>同样导入数据节点验证集.txt，设置好type节点(测试集的flag属性也设置为输入了)，再把训练好的模型从右上角给拖进来，最后设置输出节点。整个流程与前述相同，得到的验证流程如下：<br><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573099826/blog/test_stream.jpg\" alt=\"\"><br>输出节点使用混淆矩阵来查看模型的准确性，具体设置为：<br><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573099827/blog/confuse_matrix.jpg\" alt=\"\"><br>最后执行就可以得到最终的显示了如下：<br><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573099826/blog/matrix_out.jpg\" alt=\"\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>其他模型比如神经网络等的使用流程大同小异，如果需要数据集与测试集以及英文教程可以联系我。</p>\n","site":{"data":{}},"length":1367,"excerpt":"<h1 id=\"Clementine教程\"><a href=\"#Clementine教程\" class=\"headerlink\" title=\"Clementine教程\"></a>Clementine教程</h1><p>数据挖掘课程要求使用这个软件Clementine来进行实验，之前完全没听说过这个软件。网上搜到的资料也比较少，特别是CSDN上面有个博客名字叫做Clementine完整教程，然后内容也是Clementine教程这几个字，把我给惊呆了，这也能写博客？现在实验都已经做完了因此记录下使用方法，希望对其他人能有帮助。</p>","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><h3 id=\"页面\"><a href=\"#页面\" class=\"headerlink\" title=\"页面\"></a>页面</h3><p>在Clementine软件中只需要简单的像画图一样，把整个数据挖掘的操作流程对应的节点给连接起来就可以使用了。先对页面简单的介绍下，页面如下。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573095648/blog/clementine.jpg\" alt=\"\"></p>\n<p>在最下面的一栏是相对应的各个节点：Favorites中是常用的节点，Sources中是输入的数据节点，Field中是数据的属性设置节点，Modeling中是一些数据挖掘模型节点比如决策树神经网络等模型，Output中是输出节点用来查看数据。</p>\n<p>在右上角中的Streams显示整个工作台中的所有Stream，Outputs中是每次运行后得到输出结果，Models中是流程所用到的模型。</p>\n<p>数据挖掘的过程可以简单的分为两步：第一步对模型进行训练 第二步对训练好的模型进行使用。而一个完整的数据挖掘流程Stream中在Clementine中需要包含：数据输入节点-&gt;输入属性设置节点-&gt;模型节点-&gt;输出节点。在第一步模型训练中可以不使用输出节点。</p>\n<h2 id=\"数据导入\"><a href=\"#数据导入\" class=\"headerlink\" title=\"数据导入\"></a>数据导入</h2><p>在下方节点栏中的Sources中选择Var.file节点，拖到中间的画布。然后双击设置输入数据的文件导入，如下所示：<br><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573097265/blog/varfile1.jpg\" alt=\"\"></p>\n<p>在导入数据后选择分隔符我的数据是用tab分割的)，之后点击Apply完成设置。</p>\n<h2 id=\"数据显示\"><a href=\"#数据显示\" class=\"headerlink\" title=\"数据显示\"></a>数据显示</h2><p>在导入了数据后可以使用输出节点来输出数据，选择Outputs中的Table节点来输出数据。如下所示：</p>\n<p><img src=\"C:\\Users\\BraveY\\AppData\\Local\\Temp\\1573097747688.png\" alt=\"\"></p>\n<p>对输入节点训练集.txt邮件有个connect可以进行连接。或者使用快捷键F2来连接。连接好后右键execute就可以得到上图显示了。</p>\n<h2 id=\"模型训练\"><a href=\"#模型训练\" class=\"headerlink\" title=\"模型训练\"></a>模型训练</h2><p>以使用决策树模型为例子，给定的输入数据集是一个在线测试系统中学生做的各项测试的数据，final是期末考试是否及格。也就是通过学生在测试系统的数据，来预测学生期末考试是否会及格。在选择模型前，需要在Fidel Ops中选择一个type节点来设置输入数据中各个属性。如下所示：</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573098328/blog/type.jpg\" alt=\"\"></p>\n<p>第一个PersonId设置为Typeless不进行输入，决策树输出的是final，并设置为flag类型。其他数据都设置为range。</p>\n<p>接下来选择模型，在Modeling中选择C5.0这个决策树模型。并与前面的type节点连接。如下所示：</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573098962/blog/train_tree.jpg\" alt=\"\"></p>\n<p>可以选择专家模式自定义剪枝率等参数。设置好后执行就可以得到训练好的模型了，将会显示在右上角的model中，这样就完成模型训练这个Stream了。</p>\n<p>在右上角的models中选择训练好的final模型，右键browse，然后选择viewer就可以查看训练好的决策树模型了。如下所示。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573099406/blog/model.jpg\" alt=\"\"><br><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573099392/blog/viewer.jpg\" alt=\"\"></p>\n<h2 id=\"模型使用\"><a href=\"#模型使用\" class=\"headerlink\" title=\"模型使用\"></a>模型使用</h2><p>同样导入数据节点验证集.txt，设置好type节点(测试集的flag属性也设置为输入了)，再把训练好的模型从右上角给拖进来，最后设置输出节点。整个流程与前述相同，得到的验证流程如下：<br><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573099826/blog/test_stream.jpg\" alt=\"\"><br>输出节点使用混淆矩阵来查看模型的准确性，具体设置为：<br><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573099827/blog/confuse_matrix.jpg\" alt=\"\"><br>最后执行就可以得到最终的显示了如下：<br><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573099826/blog/matrix_out.jpg\" alt=\"\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>其他模型比如神经网络等的使用流程大同小异，如果需要数据集与测试集以及英文教程可以联系我。</p>"},{"title":"数据仓库","date":"2019-11-15T12:13:46.000Z","copyright":true,"mathjax":true,"_content":"\n# 数据仓库\n\n## 什么是数据仓库\n\n有多种定义，按照一位数据仓库系统构造方面的领衔设计师William H. Inmon的说法：数据仓库是一个面向主题的、集成的、时变的、非易失的数据集合，支持管理者的决策过程。\n\n一句话总结：通过数据仓库来完成对一个项目的相关需求的快速分析，是一个联机分析处理（Online Analytical Processing System）系统，具体的定义见[百度百科](<https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93> )。\n\n<!--more-->\n\n### 特征\n\n- **面向主题的**：数据仓库围绕一些主题，如顾客、供应商、产品和销售组织。数据仓库关注决策者的数据建模与分析，而不是构造组织机构的日常操作和事务处理。\n- **集成的：**通常，构造数据仓库是将多个异种数据源，如关系数据库、一般文件和联机事务处理记录，集成在一起。\n- **时变的**：数据存储从历史的角度（例如，过去5-10 年）提供信息。\n- **非易失的：**数据仓库总是。物理地分离存放数据；这些数据源于操作环境下的应用数据\n\n### 操作数据库系统与数据仓库的区别\n\n我们常见的关系数据库就是联机操作数据库，联机操作数据库系统的主要任务是执行联机事务和查询处理。这种系统称为联机事务处理（OLTP）系统。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1573875850/blog/OLTP_OLAP.jpg)\n\n## 数据立方体\n\n数据仓库基于**多维数据模型**，这种模型将数据看做数据立方体形式。\n\n数据立方体的定义：在一个多维的平台上面对数据建模和观察，由**维和事实**定义。\n\n每个维都可以有一个与之相关联的表，称作维表，在表中进一步的描述维更具体的属性（比如名字、类型等）。\n\n多维数据模型围绕一个具体的主题（比如销售）这样的中心主题来组织。主题用事实表表示。事实是数值度量的，事实表包括事实的**名称或度量**。\n\n一个具体的例子如下所示，表示的是关于销售这个事实的数据立方体。其中左边是一个二维的数据立方体，右边是一个三维的数据立方体。可以扩展到n维。以3d这个数据立方体，讲解下682这个值的含义，表示Toronto市，security项目在Q2季度的销售量。![](https://res.cloudinary.com/bravey/image/upload/v1573875852/blog/data_cube.jpg)\n\n## 数据仓库建模\n\n数据仓库最流行的数据模型是多维数据模型，这种模型有三种形式：星形模式（Star schema）、雪花模式（snowflake schema）、事实星座（fact constellation）\n\n### 星形模式\n\n最常见的模式，在这种模式下，数据仓库包括：\n\n- 一个大的事实表，里面又包含\n  - 事实的维度\n  - 事实的度量\n- 多组小的维表，详细记录一个维度的属性\n\n例子如下，展开了很像星光四射，因而得名。![](https://res.cloudinary.com/bravey/image/upload/v1573875853/blog/start_schema.jpg)\n\n最中间的是销售事实表，总共有4个维度：时间、商品、部门（branch）、地点，3个度量：销售数量、销售金额、平均销售量。\n\n### 雪花模式\n\n雪花模式是星形模式的变种，其中某些维表被规范化，因而把数据进一步分解到附加的表中。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1573875852/blog/snowfake_schema.jpg)\n\n星形模式是只有一层的，而雪花模式可以延伸。图中在item维度又延伸出了供应商这个维度，在地点维度又延伸出了城市这个维度。\n\n### 事实星座\n\n对于一些复杂的应用可能需要多个事实表共享维表，这种模式可以看成星形模式的汇集，所以称做事实星座。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1573875852/blog/fact_schema.jpg)\n\n上面总共有两个事实表：销售与运输(Shipping)。因为两个事实表有些维度是共享的，所以同时指向相同的维度就可以了。\n\n### 概念分层\n\n概念分层(Concept Hierarchy)，对一个维度在概念上进行分层。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1573875852/blog/location_hierarchy.jpg)\n\n比如在地点上可以从办公室上升到城市上升到国家一直到最后的最高层所有。每个维度的最高层都是all所有这个级别。上图地点的分层是基于全序的层次结构，也可以组织成基于偏序的格结构，如下对时间的分层。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1573875851/blog/time_hierarchy.jpg)\n\n对于连续的属性值或或者维度，通过将其离散化来定义概念分层。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1573875851/blog/numeric_hierarchy.jpg)\n\n### OLAP操作\n\n进行实际分析的时候需要执行OLAP操作，典型的有下面四种。\n\n#### 上卷（roll-up）\n\n上卷操作沿着一个维度的概念分层向上攀升。如下图所示的第1个操作，对location维度从城市上卷到国家，则原来的立方体的location维度从原来有4个城市变成只有两个国家。\n\n#### 下钻（drill-down）\n\n下钻是上卷的逆操作，它由不太详细的数据到更详细的数据。\n\n比如从第1个上卷的操作得到的数据立方体做从国家到城市的逆操作就回到了原来的数据立方体。第二个操作就是下钻操作，在time维度上从季度下钻到了月。\n\n#### 切片（slice）和切块（dice）\n\n切片操作在给定的立方体上一个维度上面进行选择，形成一个新的子立方体。比如第3个操作，切边选择了time=Q1，因而得到的子立方体都是在Q1季度上的数据。\n\n切块操作则是在多个维度上进行选择。比如第4个操作就是在location维度选择多伦多与温哥华，而在time维度上选择Q1与Q2季度，而在item维度上选择家庭娱乐与计算机。\n\n#### 转轴（pivot）\n\n转轴又称作旋转(rotate)，是一种目视操作，移动了数据的视角。比如第5个操作，将原来的item维度在下，location维度在上。旋转后变成了item维度在上，而location维度在下。类似于矩阵的转置。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1573875851/blog/olap_operation.jpg)\n\n#### 操作实例\n\n Starting with the base cuboid [day, doctor, patient],what OLAP operations should be performed in order\nto list the total fee collected by each doctor in 1999?\n\n首先要求所有的费用，因此对patient维度做上卷操作，上卷到all所有这个层次。然后时间限定在了1999年，因此对day维度做上卷操作，上卷到年这个层次。最后进行切边操作，选择1999年这个年份。\n\n## 数据仓库实现\n\n### 数据立方体的有效计算\n\n前述的OLAP操作依赖于对数据立方体的计算操作，既是针对不同维度上面的聚合，SQL的术语是分组（group-by）。对于n个维度的数据立方体，不考虑每个维度的概念分层，则总共可以构成的分组（不同维度组合的集合）有$2^n$种。如下所示，一个（city，item，year）的三维数据立方体可以有8种分组方式。\n\n其实不考虑概念分层意味着每个维度可以有最高层all和最低层两个分层。因此如果考虑概念分层，假设有n个维度\n\n，每个维度都有m个分层，则这样来说可有$m^n$个方体。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1573875850/blog/cube_group_by.jpg)\n\n为了实现快速返回OLAP的操作，需要提前将这些分组的结果存储下来，这样当指定OLAP操作，直接去访问这些分组就可以了。这种提前计算方体结果的方法，称作**物化（materialization）**但是考虑到概念分层，存储所有的分组结果是不现实的。采用**部分物化（partial materaialiaztion）**预先计算一部分适当的常用的子集。\n\n### OLAP索引\n\n#### 位图索引（bitmap indexing）\n\n在给定属性的位图索引中，属性域中的每个值v，有一个不同的位向量bit vector(即一列值)Bv。如果给定的属性域包含n 个值，则位图索引中每项需要n 位（即，n 位向量）。如果数据表中给定行的属性值为v，则在位图索引的对应行，表示该值的位为1，该行的其它位均为0。可以理解成one hot 编码。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1573875851/blog/index_map.jpg)\n\nRegion有3种取值，所以3个位向量，也就是对应3列值；Type有2种取值，所以对应2列值。\n\n##### 优缺点\n\n优点：与散列和树索引相比，位图索引有优势。对于基数较小的域它特别有用，因为比较、连接、和聚集操作都变成了位算术运算，大大减少了运行时间。由于字符串可以用单个位表示，位图索引大大降低了空间和I/O 开销。对于基数较高的域，使用压缩技术，这种方法可以接受。但是不是很适合。\n\n缺点：因为值域中的每一个可能的值都需要一个位向量来记录，所以当基数较大时，会需要开辟很大的存储空间，因为每一个记录其实只使用到了一位，因此造成了很大的浪费。同时当可取的值连续时无法使用位图来记录。\n\n#### 连接索引\n\n如果两个关系R(RID,A)和S(B,SID)在属性A和B 上连接，则连接索引记录包含(RID,SID)对，其中RID 和SID 分别为来自R 和S 的记录标识符。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1573875850/blog/join_index.jpg)\n\n在左边的销售事实表中有同location和item两个维度的链接，那么就可以有右边3中连接索引。\n\n## 参考\n\n《数据挖掘概念与技术》第3版 第四章数据仓库与联机分析处理\n\n","source":"_posts/2019-11-15-数据仓库.md","raw":"---\ntitle: 数据仓库\ndate: 2019-11-15 20:13:46\ncategories: 数据挖掘\ntags:\n- 数据仓库\n- OLAPS\n- 课程\n- 国科大\ncopyright: true\nmathjax: true\n---\n\n# 数据仓库\n\n## 什么是数据仓库\n\n有多种定义，按照一位数据仓库系统构造方面的领衔设计师William H. Inmon的说法：数据仓库是一个面向主题的、集成的、时变的、非易失的数据集合，支持管理者的决策过程。\n\n一句话总结：通过数据仓库来完成对一个项目的相关需求的快速分析，是一个联机分析处理（Online Analytical Processing System）系统，具体的定义见[百度百科](<https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93> )。\n\n<!--more-->\n\n### 特征\n\n- **面向主题的**：数据仓库围绕一些主题，如顾客、供应商、产品和销售组织。数据仓库关注决策者的数据建模与分析，而不是构造组织机构的日常操作和事务处理。\n- **集成的：**通常，构造数据仓库是将多个异种数据源，如关系数据库、一般文件和联机事务处理记录，集成在一起。\n- **时变的**：数据存储从历史的角度（例如，过去5-10 年）提供信息。\n- **非易失的：**数据仓库总是。物理地分离存放数据；这些数据源于操作环境下的应用数据\n\n### 操作数据库系统与数据仓库的区别\n\n我们常见的关系数据库就是联机操作数据库，联机操作数据库系统的主要任务是执行联机事务和查询处理。这种系统称为联机事务处理（OLTP）系统。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1573875850/blog/OLTP_OLAP.jpg)\n\n## 数据立方体\n\n数据仓库基于**多维数据模型**，这种模型将数据看做数据立方体形式。\n\n数据立方体的定义：在一个多维的平台上面对数据建模和观察，由**维和事实**定义。\n\n每个维都可以有一个与之相关联的表，称作维表，在表中进一步的描述维更具体的属性（比如名字、类型等）。\n\n多维数据模型围绕一个具体的主题（比如销售）这样的中心主题来组织。主题用事实表表示。事实是数值度量的，事实表包括事实的**名称或度量**。\n\n一个具体的例子如下所示，表示的是关于销售这个事实的数据立方体。其中左边是一个二维的数据立方体，右边是一个三维的数据立方体。可以扩展到n维。以3d这个数据立方体，讲解下682这个值的含义，表示Toronto市，security项目在Q2季度的销售量。![](https://res.cloudinary.com/bravey/image/upload/v1573875852/blog/data_cube.jpg)\n\n## 数据仓库建模\n\n数据仓库最流行的数据模型是多维数据模型，这种模型有三种形式：星形模式（Star schema）、雪花模式（snowflake schema）、事实星座（fact constellation）\n\n### 星形模式\n\n最常见的模式，在这种模式下，数据仓库包括：\n\n- 一个大的事实表，里面又包含\n  - 事实的维度\n  - 事实的度量\n- 多组小的维表，详细记录一个维度的属性\n\n例子如下，展开了很像星光四射，因而得名。![](https://res.cloudinary.com/bravey/image/upload/v1573875853/blog/start_schema.jpg)\n\n最中间的是销售事实表，总共有4个维度：时间、商品、部门（branch）、地点，3个度量：销售数量、销售金额、平均销售量。\n\n### 雪花模式\n\n雪花模式是星形模式的变种，其中某些维表被规范化，因而把数据进一步分解到附加的表中。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1573875852/blog/snowfake_schema.jpg)\n\n星形模式是只有一层的，而雪花模式可以延伸。图中在item维度又延伸出了供应商这个维度，在地点维度又延伸出了城市这个维度。\n\n### 事实星座\n\n对于一些复杂的应用可能需要多个事实表共享维表，这种模式可以看成星形模式的汇集，所以称做事实星座。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1573875852/blog/fact_schema.jpg)\n\n上面总共有两个事实表：销售与运输(Shipping)。因为两个事实表有些维度是共享的，所以同时指向相同的维度就可以了。\n\n### 概念分层\n\n概念分层(Concept Hierarchy)，对一个维度在概念上进行分层。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1573875852/blog/location_hierarchy.jpg)\n\n比如在地点上可以从办公室上升到城市上升到国家一直到最后的最高层所有。每个维度的最高层都是all所有这个级别。上图地点的分层是基于全序的层次结构，也可以组织成基于偏序的格结构，如下对时间的分层。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1573875851/blog/time_hierarchy.jpg)\n\n对于连续的属性值或或者维度，通过将其离散化来定义概念分层。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1573875851/blog/numeric_hierarchy.jpg)\n\n### OLAP操作\n\n进行实际分析的时候需要执行OLAP操作，典型的有下面四种。\n\n#### 上卷（roll-up）\n\n上卷操作沿着一个维度的概念分层向上攀升。如下图所示的第1个操作，对location维度从城市上卷到国家，则原来的立方体的location维度从原来有4个城市变成只有两个国家。\n\n#### 下钻（drill-down）\n\n下钻是上卷的逆操作，它由不太详细的数据到更详细的数据。\n\n比如从第1个上卷的操作得到的数据立方体做从国家到城市的逆操作就回到了原来的数据立方体。第二个操作就是下钻操作，在time维度上从季度下钻到了月。\n\n#### 切片（slice）和切块（dice）\n\n切片操作在给定的立方体上一个维度上面进行选择，形成一个新的子立方体。比如第3个操作，切边选择了time=Q1，因而得到的子立方体都是在Q1季度上的数据。\n\n切块操作则是在多个维度上进行选择。比如第4个操作就是在location维度选择多伦多与温哥华，而在time维度上选择Q1与Q2季度，而在item维度上选择家庭娱乐与计算机。\n\n#### 转轴（pivot）\n\n转轴又称作旋转(rotate)，是一种目视操作，移动了数据的视角。比如第5个操作，将原来的item维度在下，location维度在上。旋转后变成了item维度在上，而location维度在下。类似于矩阵的转置。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1573875851/blog/olap_operation.jpg)\n\n#### 操作实例\n\n Starting with the base cuboid [day, doctor, patient],what OLAP operations should be performed in order\nto list the total fee collected by each doctor in 1999?\n\n首先要求所有的费用，因此对patient维度做上卷操作，上卷到all所有这个层次。然后时间限定在了1999年，因此对day维度做上卷操作，上卷到年这个层次。最后进行切边操作，选择1999年这个年份。\n\n## 数据仓库实现\n\n### 数据立方体的有效计算\n\n前述的OLAP操作依赖于对数据立方体的计算操作，既是针对不同维度上面的聚合，SQL的术语是分组（group-by）。对于n个维度的数据立方体，不考虑每个维度的概念分层，则总共可以构成的分组（不同维度组合的集合）有$2^n$种。如下所示，一个（city，item，year）的三维数据立方体可以有8种分组方式。\n\n其实不考虑概念分层意味着每个维度可以有最高层all和最低层两个分层。因此如果考虑概念分层，假设有n个维度\n\n，每个维度都有m个分层，则这样来说可有$m^n$个方体。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1573875850/blog/cube_group_by.jpg)\n\n为了实现快速返回OLAP的操作，需要提前将这些分组的结果存储下来，这样当指定OLAP操作，直接去访问这些分组就可以了。这种提前计算方体结果的方法，称作**物化（materialization）**但是考虑到概念分层，存储所有的分组结果是不现实的。采用**部分物化（partial materaialiaztion）**预先计算一部分适当的常用的子集。\n\n### OLAP索引\n\n#### 位图索引（bitmap indexing）\n\n在给定属性的位图索引中，属性域中的每个值v，有一个不同的位向量bit vector(即一列值)Bv。如果给定的属性域包含n 个值，则位图索引中每项需要n 位（即，n 位向量）。如果数据表中给定行的属性值为v，则在位图索引的对应行，表示该值的位为1，该行的其它位均为0。可以理解成one hot 编码。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1573875851/blog/index_map.jpg)\n\nRegion有3种取值，所以3个位向量，也就是对应3列值；Type有2种取值，所以对应2列值。\n\n##### 优缺点\n\n优点：与散列和树索引相比，位图索引有优势。对于基数较小的域它特别有用，因为比较、连接、和聚集操作都变成了位算术运算，大大减少了运行时间。由于字符串可以用单个位表示，位图索引大大降低了空间和I/O 开销。对于基数较高的域，使用压缩技术，这种方法可以接受。但是不是很适合。\n\n缺点：因为值域中的每一个可能的值都需要一个位向量来记录，所以当基数较大时，会需要开辟很大的存储空间，因为每一个记录其实只使用到了一位，因此造成了很大的浪费。同时当可取的值连续时无法使用位图来记录。\n\n#### 连接索引\n\n如果两个关系R(RID,A)和S(B,SID)在属性A和B 上连接，则连接索引记录包含(RID,SID)对，其中RID 和SID 分别为来自R 和S 的记录标识符。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1573875850/blog/join_index.jpg)\n\n在左边的销售事实表中有同location和item两个维度的链接，那么就可以有右边3中连接索引。\n\n## 参考\n\n《数据挖掘概念与技术》第3版 第四章数据仓库与联机分析处理\n\n","slug":"2019-11-15-数据仓库","published":1,"updated":"2019-11-16T13:00:19.536Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6he13yx001mdstz2cc9f0j7","content":"<h1 id=\"数据仓库\"><a href=\"#数据仓库\" class=\"headerlink\" title=\"数据仓库\"></a>数据仓库</h1><h2 id=\"什么是数据仓库\"><a href=\"#什么是数据仓库\" class=\"headerlink\" title=\"什么是数据仓库\"></a>什么是数据仓库</h2><p>有多种定义，按照一位数据仓库系统构造方面的领衔设计师William H. Inmon的说法：数据仓库是一个面向主题的、集成的、时变的、非易失的数据集合，支持管理者的决策过程。</p>\n<p>一句话总结：通过数据仓库来完成对一个项目的相关需求的快速分析，是一个联机分析处理（Online Analytical Processing System）系统，具体的定义见<a href=\"https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93\" target=\"_blank\" rel=\"noopener\">百度百科</a>。</p>\n<a id=\"more\"></a>\n<h3 id=\"特征\"><a href=\"#特征\" class=\"headerlink\" title=\"特征\"></a>特征</h3><ul>\n<li><strong>面向主题的</strong>：数据仓库围绕一些主题，如顾客、供应商、产品和销售组织。数据仓库关注决策者的数据建模与分析，而不是构造组织机构的日常操作和事务处理。</li>\n<li><strong>集成的：</strong>通常，构造数据仓库是将多个异种数据源，如关系数据库、一般文件和联机事务处理记录，集成在一起。</li>\n<li><strong>时变的</strong>：数据存储从历史的角度（例如，过去5-10 年）提供信息。</li>\n<li><strong>非易失的：</strong>数据仓库总是。物理地分离存放数据；这些数据源于操作环境下的应用数据</li>\n</ul>\n<h3 id=\"操作数据库系统与数据仓库的区别\"><a href=\"#操作数据库系统与数据仓库的区别\" class=\"headerlink\" title=\"操作数据库系统与数据仓库的区别\"></a>操作数据库系统与数据仓库的区别</h3><p>我们常见的关系数据库就是联机操作数据库，联机操作数据库系统的主要任务是执行联机事务和查询处理。这种系统称为联机事务处理（OLTP）系统。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573875850/blog/OLTP_OLAP.jpg\" alt=\"\"></p>\n<h2 id=\"数据立方体\"><a href=\"#数据立方体\" class=\"headerlink\" title=\"数据立方体\"></a>数据立方体</h2><p>数据仓库基于<strong>多维数据模型</strong>，这种模型将数据看做数据立方体形式。</p>\n<p>数据立方体的定义：在一个多维的平台上面对数据建模和观察，由<strong>维和事实</strong>定义。</p>\n<p>每个维都可以有一个与之相关联的表，称作维表，在表中进一步的描述维更具体的属性（比如名字、类型等）。</p>\n<p>多维数据模型围绕一个具体的主题（比如销售）这样的中心主题来组织。主题用事实表表示。事实是数值度量的，事实表包括事实的<strong>名称或度量</strong>。</p>\n<p>一个具体的例子如下所示，表示的是关于销售这个事实的数据立方体。其中左边是一个二维的数据立方体，右边是一个三维的数据立方体。可以扩展到n维。以3d这个数据立方体，讲解下682这个值的含义，表示Toronto市，security项目在Q2季度的销售量。<img src=\"https://res.cloudinary.com/bravey/image/upload/v1573875852/blog/data_cube.jpg\" alt=\"\"></p>\n<h2 id=\"数据仓库建模\"><a href=\"#数据仓库建模\" class=\"headerlink\" title=\"数据仓库建模\"></a>数据仓库建模</h2><p>数据仓库最流行的数据模型是多维数据模型，这种模型有三种形式：星形模式（Star schema）、雪花模式（snowflake schema）、事实星座（fact constellation）</p>\n<h3 id=\"星形模式\"><a href=\"#星形模式\" class=\"headerlink\" title=\"星形模式\"></a>星形模式</h3><p>最常见的模式，在这种模式下，数据仓库包括：</p>\n<ul>\n<li>一个大的事实表，里面又包含<ul>\n<li>事实的维度</li>\n<li>事实的度量</li>\n</ul>\n</li>\n<li>多组小的维表，详细记录一个维度的属性</li>\n</ul>\n<p>例子如下，展开了很像星光四射，因而得名。<img src=\"https://res.cloudinary.com/bravey/image/upload/v1573875853/blog/start_schema.jpg\" alt=\"\"></p>\n<p>最中间的是销售事实表，总共有4个维度：时间、商品、部门（branch）、地点，3个度量：销售数量、销售金额、平均销售量。</p>\n<h3 id=\"雪花模式\"><a href=\"#雪花模式\" class=\"headerlink\" title=\"雪花模式\"></a>雪花模式</h3><p>雪花模式是星形模式的变种，其中某些维表被规范化，因而把数据进一步分解到附加的表中。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573875852/blog/snowfake_schema.jpg\" alt=\"\"></p>\n<p>星形模式是只有一层的，而雪花模式可以延伸。图中在item维度又延伸出了供应商这个维度，在地点维度又延伸出了城市这个维度。</p>\n<h3 id=\"事实星座\"><a href=\"#事实星座\" class=\"headerlink\" title=\"事实星座\"></a>事实星座</h3><p>对于一些复杂的应用可能需要多个事实表共享维表，这种模式可以看成星形模式的汇集，所以称做事实星座。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573875852/blog/fact_schema.jpg\" alt=\"\"></p>\n<p>上面总共有两个事实表：销售与运输(Shipping)。因为两个事实表有些维度是共享的，所以同时指向相同的维度就可以了。</p>\n<h3 id=\"概念分层\"><a href=\"#概念分层\" class=\"headerlink\" title=\"概念分层\"></a>概念分层</h3><p>概念分层(Concept Hierarchy)，对一个维度在概念上进行分层。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573875852/blog/location_hierarchy.jpg\" alt=\"\"></p>\n<p>比如在地点上可以从办公室上升到城市上升到国家一直到最后的最高层所有。每个维度的最高层都是all所有这个级别。上图地点的分层是基于全序的层次结构，也可以组织成基于偏序的格结构，如下对时间的分层。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573875851/blog/time_hierarchy.jpg\" alt=\"\"></p>\n<p>对于连续的属性值或或者维度，通过将其离散化来定义概念分层。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573875851/blog/numeric_hierarchy.jpg\" alt=\"\"></p>\n<h3 id=\"OLAP操作\"><a href=\"#OLAP操作\" class=\"headerlink\" title=\"OLAP操作\"></a>OLAP操作</h3><p>进行实际分析的时候需要执行OLAP操作，典型的有下面四种。</p>\n<h4 id=\"上卷（roll-up）\"><a href=\"#上卷（roll-up）\" class=\"headerlink\" title=\"上卷（roll-up）\"></a>上卷（roll-up）</h4><p>上卷操作沿着一个维度的概念分层向上攀升。如下图所示的第1个操作，对location维度从城市上卷到国家，则原来的立方体的location维度从原来有4个城市变成只有两个国家。</p>\n<h4 id=\"下钻（drill-down）\"><a href=\"#下钻（drill-down）\" class=\"headerlink\" title=\"下钻（drill-down）\"></a>下钻（drill-down）</h4><p>下钻是上卷的逆操作，它由不太详细的数据到更详细的数据。</p>\n<p>比如从第1个上卷的操作得到的数据立方体做从国家到城市的逆操作就回到了原来的数据立方体。第二个操作就是下钻操作，在time维度上从季度下钻到了月。</p>\n<h4 id=\"切片（slice）和切块（dice）\"><a href=\"#切片（slice）和切块（dice）\" class=\"headerlink\" title=\"切片（slice）和切块（dice）\"></a>切片（slice）和切块（dice）</h4><p>切片操作在给定的立方体上一个维度上面进行选择，形成一个新的子立方体。比如第3个操作，切边选择了time=Q1，因而得到的子立方体都是在Q1季度上的数据。</p>\n<p>切块操作则是在多个维度上进行选择。比如第4个操作就是在location维度选择多伦多与温哥华，而在time维度上选择Q1与Q2季度，而在item维度上选择家庭娱乐与计算机。</p>\n<h4 id=\"转轴（pivot）\"><a href=\"#转轴（pivot）\" class=\"headerlink\" title=\"转轴（pivot）\"></a>转轴（pivot）</h4><p>转轴又称作旋转(rotate)，是一种目视操作，移动了数据的视角。比如第5个操作，将原来的item维度在下，location维度在上。旋转后变成了item维度在上，而location维度在下。类似于矩阵的转置。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573875851/blog/olap_operation.jpg\" alt=\"\"></p>\n<h4 id=\"操作实例\"><a href=\"#操作实例\" class=\"headerlink\" title=\"操作实例\"></a>操作实例</h4><p> Starting with the base cuboid [day, doctor, patient],what OLAP operations should be performed in order<br>to list the total fee collected by each doctor in 1999?</p>\n<p>首先要求所有的费用，因此对patient维度做上卷操作，上卷到all所有这个层次。然后时间限定在了1999年，因此对day维度做上卷操作，上卷到年这个层次。最后进行切边操作，选择1999年这个年份。</p>\n<h2 id=\"数据仓库实现\"><a href=\"#数据仓库实现\" class=\"headerlink\" title=\"数据仓库实现\"></a>数据仓库实现</h2><h3 id=\"数据立方体的有效计算\"><a href=\"#数据立方体的有效计算\" class=\"headerlink\" title=\"数据立方体的有效计算\"></a>数据立方体的有效计算</h3><p>前述的OLAP操作依赖于对数据立方体的计算操作，既是针对不同维度上面的聚合，SQL的术语是分组（group-by）。对于n个维度的数据立方体，不考虑每个维度的概念分层，则总共可以构成的分组（不同维度组合的集合）有$2^n$种。如下所示，一个（city，item，year）的三维数据立方体可以有8种分组方式。</p>\n<p>其实不考虑概念分层意味着每个维度可以有最高层all和最低层两个分层。因此如果考虑概念分层，假设有n个维度</p>\n<p>，每个维度都有m个分层，则这样来说可有$m^n$个方体。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573875850/blog/cube_group_by.jpg\" alt=\"\"></p>\n<p>为了实现快速返回OLAP的操作，需要提前将这些分组的结果存储下来，这样当指定OLAP操作，直接去访问这些分组就可以了。这种提前计算方体结果的方法，称作<strong>物化（materialization）</strong>但是考虑到概念分层，存储所有的分组结果是不现实的。采用<strong>部分物化（partial materaialiaztion）</strong>预先计算一部分适当的常用的子集。</p>\n<h3 id=\"OLAP索引\"><a href=\"#OLAP索引\" class=\"headerlink\" title=\"OLAP索引\"></a>OLAP索引</h3><h4 id=\"位图索引（bitmap-indexing）\"><a href=\"#位图索引（bitmap-indexing）\" class=\"headerlink\" title=\"位图索引（bitmap indexing）\"></a>位图索引（bitmap indexing）</h4><p>在给定属性的位图索引中，属性域中的每个值v，有一个不同的位向量bit vector(即一列值)Bv。如果给定的属性域包含n 个值，则位图索引中每项需要n 位（即，n 位向量）。如果数据表中给定行的属性值为v，则在位图索引的对应行，表示该值的位为1，该行的其它位均为0。可以理解成one hot 编码。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573875851/blog/index_map.jpg\" alt=\"\"></p>\n<p>Region有3种取值，所以3个位向量，也就是对应3列值；Type有2种取值，所以对应2列值。</p>\n<h5 id=\"优缺点\"><a href=\"#优缺点\" class=\"headerlink\" title=\"优缺点\"></a>优缺点</h5><p>优点：与散列和树索引相比，位图索引有优势。对于基数较小的域它特别有用，因为比较、连接、和聚集操作都变成了位算术运算，大大减少了运行时间。由于字符串可以用单个位表示，位图索引大大降低了空间和I/O 开销。对于基数较高的域，使用压缩技术，这种方法可以接受。但是不是很适合。</p>\n<p>缺点：因为值域中的每一个可能的值都需要一个位向量来记录，所以当基数较大时，会需要开辟很大的存储空间，因为每一个记录其实只使用到了一位，因此造成了很大的浪费。同时当可取的值连续时无法使用位图来记录。</p>\n<h4 id=\"连接索引\"><a href=\"#连接索引\" class=\"headerlink\" title=\"连接索引\"></a>连接索引</h4><p>如果两个关系R(RID,A)和S(B,SID)在属性A和B 上连接，则连接索引记录包含(RID,SID)对，其中RID 和SID 分别为来自R 和S 的记录标识符。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573875850/blog/join_index.jpg\" alt=\"\"></p>\n<p>在左边的销售事实表中有同location和item两个维度的链接，那么就可以有右边3中连接索引。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>《数据挖掘概念与技术》第3版 第四章数据仓库与联机分析处理</p>\n","site":{"data":{}},"length":3195,"excerpt":"<h1 id=\"数据仓库\"><a href=\"#数据仓库\" class=\"headerlink\" title=\"数据仓库\"></a>数据仓库</h1><h2 id=\"什么是数据仓库\"><a href=\"#什么是数据仓库\" class=\"headerlink\" title=\"什么是数据仓库\"></a>什么是数据仓库</h2><p>有多种定义，按照一位数据仓库系统构造方面的领衔设计师William H. Inmon的说法：数据仓库是一个面向主题的、集成的、时变的、非易失的数据集合，支持管理者的决策过程。</p>\n<p>一句话总结：通过数据仓库来完成对一个项目的相关需求的快速分析，是一个联机分析处理（Online Analytical Processing System）系统，具体的定义见<a href=\"https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93\" target=\"_blank\" rel=\"noopener\">百度百科</a>。</p>","more":"<h3 id=\"特征\"><a href=\"#特征\" class=\"headerlink\" title=\"特征\"></a>特征</h3><ul>\n<li><strong>面向主题的</strong>：数据仓库围绕一些主题，如顾客、供应商、产品和销售组织。数据仓库关注决策者的数据建模与分析，而不是构造组织机构的日常操作和事务处理。</li>\n<li><strong>集成的：</strong>通常，构造数据仓库是将多个异种数据源，如关系数据库、一般文件和联机事务处理记录，集成在一起。</li>\n<li><strong>时变的</strong>：数据存储从历史的角度（例如，过去5-10 年）提供信息。</li>\n<li><strong>非易失的：</strong>数据仓库总是。物理地分离存放数据；这些数据源于操作环境下的应用数据</li>\n</ul>\n<h3 id=\"操作数据库系统与数据仓库的区别\"><a href=\"#操作数据库系统与数据仓库的区别\" class=\"headerlink\" title=\"操作数据库系统与数据仓库的区别\"></a>操作数据库系统与数据仓库的区别</h3><p>我们常见的关系数据库就是联机操作数据库，联机操作数据库系统的主要任务是执行联机事务和查询处理。这种系统称为联机事务处理（OLTP）系统。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573875850/blog/OLTP_OLAP.jpg\" alt=\"\"></p>\n<h2 id=\"数据立方体\"><a href=\"#数据立方体\" class=\"headerlink\" title=\"数据立方体\"></a>数据立方体</h2><p>数据仓库基于<strong>多维数据模型</strong>，这种模型将数据看做数据立方体形式。</p>\n<p>数据立方体的定义：在一个多维的平台上面对数据建模和观察，由<strong>维和事实</strong>定义。</p>\n<p>每个维都可以有一个与之相关联的表，称作维表，在表中进一步的描述维更具体的属性（比如名字、类型等）。</p>\n<p>多维数据模型围绕一个具体的主题（比如销售）这样的中心主题来组织。主题用事实表表示。事实是数值度量的，事实表包括事实的<strong>名称或度量</strong>。</p>\n<p>一个具体的例子如下所示，表示的是关于销售这个事实的数据立方体。其中左边是一个二维的数据立方体，右边是一个三维的数据立方体。可以扩展到n维。以3d这个数据立方体，讲解下682这个值的含义，表示Toronto市，security项目在Q2季度的销售量。<img src=\"https://res.cloudinary.com/bravey/image/upload/v1573875852/blog/data_cube.jpg\" alt=\"\"></p>\n<h2 id=\"数据仓库建模\"><a href=\"#数据仓库建模\" class=\"headerlink\" title=\"数据仓库建模\"></a>数据仓库建模</h2><p>数据仓库最流行的数据模型是多维数据模型，这种模型有三种形式：星形模式（Star schema）、雪花模式（snowflake schema）、事实星座（fact constellation）</p>\n<h3 id=\"星形模式\"><a href=\"#星形模式\" class=\"headerlink\" title=\"星形模式\"></a>星形模式</h3><p>最常见的模式，在这种模式下，数据仓库包括：</p>\n<ul>\n<li>一个大的事实表，里面又包含<ul>\n<li>事实的维度</li>\n<li>事实的度量</li>\n</ul>\n</li>\n<li>多组小的维表，详细记录一个维度的属性</li>\n</ul>\n<p>例子如下，展开了很像星光四射，因而得名。<img src=\"https://res.cloudinary.com/bravey/image/upload/v1573875853/blog/start_schema.jpg\" alt=\"\"></p>\n<p>最中间的是销售事实表，总共有4个维度：时间、商品、部门（branch）、地点，3个度量：销售数量、销售金额、平均销售量。</p>\n<h3 id=\"雪花模式\"><a href=\"#雪花模式\" class=\"headerlink\" title=\"雪花模式\"></a>雪花模式</h3><p>雪花模式是星形模式的变种，其中某些维表被规范化，因而把数据进一步分解到附加的表中。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573875852/blog/snowfake_schema.jpg\" alt=\"\"></p>\n<p>星形模式是只有一层的，而雪花模式可以延伸。图中在item维度又延伸出了供应商这个维度，在地点维度又延伸出了城市这个维度。</p>\n<h3 id=\"事实星座\"><a href=\"#事实星座\" class=\"headerlink\" title=\"事实星座\"></a>事实星座</h3><p>对于一些复杂的应用可能需要多个事实表共享维表，这种模式可以看成星形模式的汇集，所以称做事实星座。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573875852/blog/fact_schema.jpg\" alt=\"\"></p>\n<p>上面总共有两个事实表：销售与运输(Shipping)。因为两个事实表有些维度是共享的，所以同时指向相同的维度就可以了。</p>\n<h3 id=\"概念分层\"><a href=\"#概念分层\" class=\"headerlink\" title=\"概念分层\"></a>概念分层</h3><p>概念分层(Concept Hierarchy)，对一个维度在概念上进行分层。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573875852/blog/location_hierarchy.jpg\" alt=\"\"></p>\n<p>比如在地点上可以从办公室上升到城市上升到国家一直到最后的最高层所有。每个维度的最高层都是all所有这个级别。上图地点的分层是基于全序的层次结构，也可以组织成基于偏序的格结构，如下对时间的分层。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573875851/blog/time_hierarchy.jpg\" alt=\"\"></p>\n<p>对于连续的属性值或或者维度，通过将其离散化来定义概念分层。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573875851/blog/numeric_hierarchy.jpg\" alt=\"\"></p>\n<h3 id=\"OLAP操作\"><a href=\"#OLAP操作\" class=\"headerlink\" title=\"OLAP操作\"></a>OLAP操作</h3><p>进行实际分析的时候需要执行OLAP操作，典型的有下面四种。</p>\n<h4 id=\"上卷（roll-up）\"><a href=\"#上卷（roll-up）\" class=\"headerlink\" title=\"上卷（roll-up）\"></a>上卷（roll-up）</h4><p>上卷操作沿着一个维度的概念分层向上攀升。如下图所示的第1个操作，对location维度从城市上卷到国家，则原来的立方体的location维度从原来有4个城市变成只有两个国家。</p>\n<h4 id=\"下钻（drill-down）\"><a href=\"#下钻（drill-down）\" class=\"headerlink\" title=\"下钻（drill-down）\"></a>下钻（drill-down）</h4><p>下钻是上卷的逆操作，它由不太详细的数据到更详细的数据。</p>\n<p>比如从第1个上卷的操作得到的数据立方体做从国家到城市的逆操作就回到了原来的数据立方体。第二个操作就是下钻操作，在time维度上从季度下钻到了月。</p>\n<h4 id=\"切片（slice）和切块（dice）\"><a href=\"#切片（slice）和切块（dice）\" class=\"headerlink\" title=\"切片（slice）和切块（dice）\"></a>切片（slice）和切块（dice）</h4><p>切片操作在给定的立方体上一个维度上面进行选择，形成一个新的子立方体。比如第3个操作，切边选择了time=Q1，因而得到的子立方体都是在Q1季度上的数据。</p>\n<p>切块操作则是在多个维度上进行选择。比如第4个操作就是在location维度选择多伦多与温哥华，而在time维度上选择Q1与Q2季度，而在item维度上选择家庭娱乐与计算机。</p>\n<h4 id=\"转轴（pivot）\"><a href=\"#转轴（pivot）\" class=\"headerlink\" title=\"转轴（pivot）\"></a>转轴（pivot）</h4><p>转轴又称作旋转(rotate)，是一种目视操作，移动了数据的视角。比如第5个操作，将原来的item维度在下，location维度在上。旋转后变成了item维度在上，而location维度在下。类似于矩阵的转置。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573875851/blog/olap_operation.jpg\" alt=\"\"></p>\n<h4 id=\"操作实例\"><a href=\"#操作实例\" class=\"headerlink\" title=\"操作实例\"></a>操作实例</h4><p> Starting with the base cuboid [day, doctor, patient],what OLAP operations should be performed in order<br>to list the total fee collected by each doctor in 1999?</p>\n<p>首先要求所有的费用，因此对patient维度做上卷操作，上卷到all所有这个层次。然后时间限定在了1999年，因此对day维度做上卷操作，上卷到年这个层次。最后进行切边操作，选择1999年这个年份。</p>\n<h2 id=\"数据仓库实现\"><a href=\"#数据仓库实现\" class=\"headerlink\" title=\"数据仓库实现\"></a>数据仓库实现</h2><h3 id=\"数据立方体的有效计算\"><a href=\"#数据立方体的有效计算\" class=\"headerlink\" title=\"数据立方体的有效计算\"></a>数据立方体的有效计算</h3><p>前述的OLAP操作依赖于对数据立方体的计算操作，既是针对不同维度上面的聚合，SQL的术语是分组（group-by）。对于n个维度的数据立方体，不考虑每个维度的概念分层，则总共可以构成的分组（不同维度组合的集合）有$2^n$种。如下所示，一个（city，item，year）的三维数据立方体可以有8种分组方式。</p>\n<p>其实不考虑概念分层意味着每个维度可以有最高层all和最低层两个分层。因此如果考虑概念分层，假设有n个维度</p>\n<p>，每个维度都有m个分层，则这样来说可有$m^n$个方体。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573875850/blog/cube_group_by.jpg\" alt=\"\"></p>\n<p>为了实现快速返回OLAP的操作，需要提前将这些分组的结果存储下来，这样当指定OLAP操作，直接去访问这些分组就可以了。这种提前计算方体结果的方法，称作<strong>物化（materialization）</strong>但是考虑到概念分层，存储所有的分组结果是不现实的。采用<strong>部分物化（partial materaialiaztion）</strong>预先计算一部分适当的常用的子集。</p>\n<h3 id=\"OLAP索引\"><a href=\"#OLAP索引\" class=\"headerlink\" title=\"OLAP索引\"></a>OLAP索引</h3><h4 id=\"位图索引（bitmap-indexing）\"><a href=\"#位图索引（bitmap-indexing）\" class=\"headerlink\" title=\"位图索引（bitmap indexing）\"></a>位图索引（bitmap indexing）</h4><p>在给定属性的位图索引中，属性域中的每个值v，有一个不同的位向量bit vector(即一列值)Bv。如果给定的属性域包含n 个值，则位图索引中每项需要n 位（即，n 位向量）。如果数据表中给定行的属性值为v，则在位图索引的对应行，表示该值的位为1，该行的其它位均为0。可以理解成one hot 编码。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573875851/blog/index_map.jpg\" alt=\"\"></p>\n<p>Region有3种取值，所以3个位向量，也就是对应3列值；Type有2种取值，所以对应2列值。</p>\n<h5 id=\"优缺点\"><a href=\"#优缺点\" class=\"headerlink\" title=\"优缺点\"></a>优缺点</h5><p>优点：与散列和树索引相比，位图索引有优势。对于基数较小的域它特别有用，因为比较、连接、和聚集操作都变成了位算术运算，大大减少了运行时间。由于字符串可以用单个位表示，位图索引大大降低了空间和I/O 开销。对于基数较高的域，使用压缩技术，这种方法可以接受。但是不是很适合。</p>\n<p>缺点：因为值域中的每一个可能的值都需要一个位向量来记录，所以当基数较大时，会需要开辟很大的存储空间，因为每一个记录其实只使用到了一位，因此造成了很大的浪费。同时当可取的值连续时无法使用位图来记录。</p>\n<h4 id=\"连接索引\"><a href=\"#连接索引\" class=\"headerlink\" title=\"连接索引\"></a>连接索引</h4><p>如果两个关系R(RID,A)和S(B,SID)在属性A和B 上连接，则连接索引记录包含(RID,SID)对，其中RID 和SID 分别为来自R 和S 的记录标识符。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573875850/blog/join_index.jpg\" alt=\"\"></p>\n<p>在左边的销售事实表中有同location和item两个维度的链接，那么就可以有右边3中连接索引。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>《数据挖掘概念与技术》第3版 第四章数据仓库与联机分析处理</p>"},{"title":"分类与预测","date":"2019-11-17T12:41:23.000Z","copyright":true,"mathjax":true,"_content":"\n# 分类与预测\n\n## 分类与预测的差别\n\n分类对给定的数据集一般是离散的，确定这些数据对应类别。而预测是对连续的数据，根据历史数据来预测未知的数据或者缺失值等。\n\n分类的过程分为两步：\n\n- 模型构建\n\n  使用训练数据集对模型进行训练，模型可以被表示为一些分类的规则集合，决策树或者是数学公式。\n\n- 模型使用\n\n  先使用模型来对测试数据进行分类，如果准确率能够接受则使用模型去对没有标注过的数据进行分类。\n\n分类属于有监督学习，训练的数据是经过标注的。聚类属于无监督学习训练数据未经过标注不知道样本的标签。\n\n<!--more-->\n\n在进行分类和预测之前需要对数据进行预处理包括数据清洗来处理噪声和缺失值，相关性分析来进行特征提取，数据转换比如归一化等。\n\n对于分类方法的评测指标有：准确性，速度，鲁棒性，可规模性（硬盘数据），可解释性等\n\n## 决策树\n\n决策树是一个类似于流程图的树结构；其中，每个内部结点表示在一个属性上的测试，每个分枝代表一个测试输出，而每个树叶结点代表类或类分布。树的最顶层结点是根结点。给定数据经过决策树不同节点的决策最终走到叶子节点，从而完成了对数据的分类。决策树不需要任何领域知识也不需要参数，适合探测式知识发现。\n\n决策数的构建分为两步：\n\n- 树的构建 从根节点开始递归的选择属性进行建树\n- 剪枝 ：减去反映噪声或者离群点的分枝\n\n### 构建决策树\n\n算法伪代码为：\n\n![](https://res.cloudinary.com/bravey/image/upload/v1574086256/blog/Data%20Mining/decision_tree_code.jpg)\n\n三个参数D是输入的数据集,attribute_list是输入数据中的属性集合和Atrribute_selection_method是指定选择属性的启发式过程，可以选择信息增益或者是基尼指数Gini index。\n\n步骤为：\n\n1. 首先从根节点N开始，根节点中的数据是原始的需要分类的原始数据集。\n\n2. 如果D中的数据都属于同一类，那么根节点N变成叶子节点，标记为这一类。\n\n3. 否则，调用Atrribute_selection_method来选择最佳的分裂属性，并给出分裂子集。理想情况下希望分裂子集尽可能的纯，也就是希望分裂自己尽可能的都属于同一类。\n\n4. 用选出来的分裂属性在节点N上进行划分，并输出划分的数据子集。并把分裂属性从属性列表中删除。\n\n   1. 选出来的属性是离散值的话，有多少个取值就产生多少个分支\n   2. 连续值的话选择一个分裂值，大于这个分裂值为一个分支，小于等于为另外一个分支\n   3. 离散值而且必须是二叉树的话：属于这个值为一个分支，否则为另外一个分支\n\n   ![](https://res.cloudinary.com/bravey/image/upload/v1574086256/blog/Data%20Mining/split_choice.jpg)\n\n5. 对于每一个删除了最佳分裂属性的输出的子集$D_j$ 递归的调用算法。\n\n6. 递归的终止条件：\n\n   1. 数据集D都属于同一类\n   2. 属性列表为空，使用数据集中的多数类来标记节点。**（多数投票）**\n   3. 如果一个分支的数据$D_j$为空，则新增加一个叶子节点，用父节点数据集D中的多数类来标记它。\n\n7. 返回决策数的节点N\n\n### 属性选择度量\n\n很明显，决策树的关键点是怎么选择分裂的属性。有如下三种方式。\n\n#### 信息增益\n\nID3这种决策树方法使用。\n\n先计算数据集D的熵：\n$$\nInfo(D)=-\\sum_{i=1}^{m}p_ilog_2(p_i)\n$$\n假设数据集中D有m个类别${C_1,C_2\\dots C_m}$，那么每一类的概率可以用所占的比例$p_i=\\dfrac{count(C_i)}{count(D)}$来估计。\n\n假设属性A 具有v 个不同值${a_1 ,..., a_v}$。可以用属性A 将S 划分为v 个子集${S_1 ,..., S_v}$；其中，\n$S_j$ 包含S 中这样一些样本，它们在A 上具有值$a_j$。如果A 选作测试属性,则获得的信息增益,也就是划分成了子集后的熵为：\n$$\nInfo_A(D)=\\sum_{j=1}^{v}\\dfrac{|D_j|}{|D|}\\times Info(D_j)\n$$\n信息增益定义为原来的的信息需求（近基于类比例）与新的信息需求（对A划分后）之间的差：\n$$\nGain(A)=Info(D)-Info_A(D)\n$$\n具有最高信息增益的属性是最佳分裂属性。可以这样理解，划分后越纯那么整个状态越不混乱，也就是熵越低。所以选择划分后熵最低而信息增益最高的属性。\n\n#### 信息增益率\n\n信息增益偏向有许多输出的测试，它倾向于选择具有大量值的属性。比如按照唯一的标识符id来划分，每个划分出来的都只包含一个数据都是纯的，但是这样的划分显然没有作用。\n\nC4.5使用增益率来进行选择分裂属性。增益率用分裂信息值将信息增益归一化。\n$$\nSplitInfo_A(D)=-\\sum_{j=1}^{v}\\dfrac{|D_j|}{|D|}\\times log_2(\\dfrac{|D_j|}{D})\n$$\n分裂信息值代表由训练数据集D根据属性A划分v个分区后，这v个分区的熵。前面的$Info_A(D)$是对每个分区还计算了一下分区里面的熵然后进行加权，而这里是全局地看待这v个分局而进行的计算。\n\n增益率定义为：\n$$\nGainRate(A)=\\dfrac{Gain(A)}{SplitInfo_A(D)}\n$$\n选择具有最大增益率的属性作为分裂属性。\n\n#### 基尼指数\n\n基尼指数在CART中使用，基尼指数度量数据集的不纯度，定义为：\n$$\nGini(D)=1-\\sum_{i=1}^{m}p_i^2\n$$\n$p_i=\\dfrac{|C_i|}{|D|}$依然用每一类的比例来估计。基尼指数考虑每个属性的二元划分，根据属性A划分成两个两个子集$D_1,D_2$在这种划分下的基尼指数为：\n$$\nGini_A(D)=\\dfrac{|D_1|}{|D|}Gini(D_1)+\\dfrac{|D_2|}{|D|}Gini(D_2)\n$$\n选择具有最低的基尼指数作为分裂属性。  \n\n### 决策树决策规则\n\n构建好了决策树后，决策规则使用IF-THEN的语句来表示。![](https://res.cloudinary.com/bravey/image/upload/v1574086256/blog/Data%20Mining/decision_tree_rules.jpg)\n\n比如上图的决策规则是：\n\n```\nIF age is Middle_aged THEN buys_computer = yes\nIF age is youth AND student = no THEN buys_computer = no\nIF age is youth AND student = yes THEN buys_computer = yes\nIF age is senior AND credit_rating=excellent THEN buys_computer = no\nIF age is senior AND credit_rating=fair THEN buys_computer = yes\n```\n\n有多少个叶子节点相应的有多少决策规则，在到达叶子节点的路径上有多少个节点就有多少个并列的条件。\n\n### 过拟合与树剪枝\n\n在创建决策树时，由于数据中的噪声和离群点，许多分支反映的是训练数据中的异常。使用剪枝的方法来处理这种过拟合的问题。\n\n#### 先剪枝\n\n先剪枝prepruning方法提前停止树的创建。比如设定一个阈值当信息增益等度量超过阈值则分裂，不超过就停止分裂，用投票的方法确定标签。但是阈值的设置比较困难，所以不常用。\n\n#### 后剪枝\n\n后剪枝postpruning方法从完全创建好了的决策树进行剪枝。剪去后也依然使用投票的方法来确定标签。\n\nCART使用**代价复杂度**剪枝算法，C4.5使用**悲观剪枝**的方法。二者都是根据错误率，简单说就是如果减去这个分支后错误率提升不大就可以减去。\n\n### 决策树评价\n\n比其他的分类方法有着相对更快的学习速度，能够转换成容易理解的决策规则，准确率也能接受，而且也可以适用于大规模的数据。\n\n## 贝叶斯分类\n\n朴素贝叶斯分类发假定一个属性值在给定类上的影响独立于其他属性的值，这个假定称为类条件独立性。做这个假定是为了简化计算，因而称之为朴素的。\n\n### 贝叶斯定理\n\n贝叶斯定理用来求解后验概率。公式为：\n$$\nP(H|X)=\\dfrac{P(H)P(X|H)}{P(X)}\n$$\nX是数据样本，分类未知。H是对X的分类的假设，比如X属于C类。P(H)是猜测的类的概率，P(X)是观察到的样本X的概率，而P(H|X)是在给定H的假设下，观察到X样本的概率。\n\n### 朴素贝叶斯分类\n\n#### 工作过程\n\n1. 训练数据集D中一个样本X向量用一个n维的列向量$[x_1,x_2\\dots x_n]^T$来表示它对应的n个属性$[A_1,A_2\\dots A_n]$的测量值。\n\n2. 假定有m个类$C_1,C_2\\dots C_n$,将X预测为拥有最高后验概率的类。\n   $$\n   max(P(C_i|X))=max(\\dfrac{P(X|C_i)P(C_i)}{P(X)})\n   $$\n\n3. 因为$P(X)$是常数，所以只用最大化$P(X|C_i)P(C_i)$ $P(C_i)$用类的频率来估计\n\n4. 在类条件独立的假定下有：\n   $$\n   P(X|C_i)=\\prod_{k=1}^nP(x_k|C_i)=P(x_1|C_i)P(x_2|C_i)\\dots P(x_n|C_i)\n   $$\n   $x_k$表示样本X向量对应的第k个属性$A_k$的值。\n\n   1. 如果$A_k$是分类属性，那么$P(x_k|C_i)$是D中属性$A_k$的值为$x_k$的$C_i$类的元组数除以D中$C_i$的数目 \n\n   2. 如果$A_k$是连续值，则假定连续值服从均值为$\\mu$,标准差为$\\sigma$的高斯分布。\n      $$\n      g(x,\\mu,\\sigma)=\\dfrac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\dfrac{(x-\\mu)^2}{2\\sigma^2}}\n      $$\n      所以可以得到：\n   $$\n   P(x_k|C_i)=g(x_k,\\mu_{C_i},\\sigma_{C_i})\n   $$\n\n5. 对每一类都分别计算$P(X|C_i)P(C_i)$ 最后选择最大的作为这个样本的分类。\n\n#### 零概率值的解决\n\n在做连乘的时候如果有一个的概率为0，那么整个计算结果都为0。可以假设训练数据集很大，将每个取值的计数都加1而造成的概率估计可以忽略不计。这样就可以避免出现零概率的情况，称之为**拉普拉斯估计或这拉普拉斯校准法**\n\n### 评价\n\n朴素贝叶斯的优势：比较容易实现，在大多数情况可以取得好结果。缺点是：因为做了属性互相独立的假设，因此会降低准确率。而且实际上，大部分属性之间并不互相独立。\n\n可以使用贝叶斯信念网络来处理。\n\n## BP神经网络\n\n### 多层前馈神经网络\n\n后向传播算法Back propagation在多层前馈神经网络上学习。由输入层、一个或多个隐藏层和一个输出层组成。\n\n![](C:\\Users\\BraveY\\Documents\\BraveY\\blog\\images\\data mining\\multi_layer_feed_forward_network.jpg)\n\n输入层的单元称作输入单元，隐藏层和输出层单元称作输出单元或者神经节点。输入向量输入进输入单元，然后加权同时地提供给隐藏层的输出单元。在全连接的情况下每一层单元与前后层单元都会有相应的权重，因为权重不会回馈到输入节点，所以称为前馈的。因此一次输入就完成输出。\n\n### 网络拓扑的定义\n\n应该设计多少层隐藏层，每一层有多少单元，输入层单元应该有多少，是否全连接等都是网络拓扑需要考虑的。\n\n需要先对输入值进行归一化，将值落入[0,1]之间。离散值的属性可以进行重新编码，让每一个域值都有一个输入单元。如果属性A有3个可能的值${a_0, a_1, a_2}$那么就需要设计3个输入单元$I_0, I_1,I_2$，输入单元$I_1$为1对应属性$A=a_1$。\n\n如果进行分类的话如果只有两类那么输出单元只用一个就可以了，多于2类的情况每一类都有一个输出单元。\n\n隐藏层单元数目的设计，没有明确的规定，通过反复实验的过程，来确定。一般选择一个隐藏层就可以了，权重的初始值也会影响结果的准确率。\n\n## 后向传播\n\n### 步骤\n\n后向传播通过迭代地处理训练数据，把每个样本的网络预测值与实际已知的目标值相比较。对每个训练样本，修改网络的权重使得网络预测和实际目标值之间的均方误差最小。修改后向进行，从输出层一直传递到输入层的，因此叫做后向传播。\n\n算法伪代码为：\n\n![](https://res.cloudinary.com/bravey/image/upload/v1574086256/blog/Data%20Mining/bp_code.jpg)\n\n步骤为：\n\n**初始化权重：**权重被初始化为小随机数（比如-1到1，或者-0.5到0.5），偏倚bias也初始化为小随机数。\n\n**向前传播输入**：输入单元的输出就是输入值。隐藏层和输出层单元的净输入用上一层输入的线性组合计算。输出单元的输出用激活函数计算，激活函数是logistic或这S型sigmoid函数,激活函数将较大的输入值域映射到区间[0,1]\n\n![](https://res.cloudinary.com/bravey/image/upload/v1574086256/blog/Data%20Mining/bpnn_io.jpg)\n\n隐藏层或者输出层单元j其输入为如下，其中$w_{ij}$是上层单元i到单元j的权重，$O_i$是上一层单元的输出，$\\theta_j$是单元j的偏倚。偏倚用来充当阈值，改变单元的活性\n$$\nI_j=\\sum_{i}w_{ij}O_i+\\theta_j\n$$\n单元j的输出$O_j$为：\n$$\nO_j=\\dfrac{1}{1+e^{I_j}}\n$$\n**向后传播误差**：通过更新权重和反映网络预测误差的偏倚，向后传播误差。对于输出层单元j，误差如下，其中$O_j$ 是单元j的实际输出， $T_j$ 是j给定训练样本的实际目标值，$O_j(1-O_j)$是逻辑斯提函数的导数。\n$$\nErr_j=O_j(1-O_j)(T_j-O_j)\n$$\n隐藏层单元j的误差，考虑下一层中j连接的单元的误差加权和。误差如下：\n$$\nErr_j=O_j(1-O_j)\\sum_kErr_kw_{jk}\n$$\n其中$w_{jk}$是下一层单元k与单元j的连接权重，而$Err_k$是单元k的误差。\n\n更新权重和偏倚，以反映误差的传播。权重更新公式如下，其中$\\Delta w_{ij}$是权重的改变量。\n$$\n\\begin{split}\n\\Delta w_{ij}&=l\\times Err_jO_i\\\\\nw_{ij}&=w_{ij}+\\Delta w_{ij}\n\\end{split}\n$$\n变量l是**学习率**，通常去[0,1]之间的常数值。学习率帮助避免陷入决策空间的局部极小，并有助于找到全局最小。学习率太低的话，学习将进行的很慢。学习率太高的话，可能出现在不适当的解之间的摆动。一种调整规则是将学习率设置为迭代次数的倒数。\n\n偏倚的更新公式为：其中$\\Delta \\theta_{ij}$是偏倚的改变量。\n$$\n\\begin{split}\n\\Delta \\theta_{ij}&=l\\times Err_j\\\\\n\\theta_{ij}&=\\theta_{ij}+\\Delta \\theta_{ij}\n\\end{split}\n$$\n更新的策略有实例更新：每处理一个样本就更新权重和偏倚。周期更新为处理玩所有样本后再更新。实例更新通常产生更准确的结果。\n\n**终止条件：**\n\n- 前一周期所有的$\\Delta w_{ij}$都太小，小于某个阈值\n- 前一周其误分类的数据百分比小于某个阈值\n- 超过预先指定的周期数。实践中权重收敛可能需要数十万个周期。\n\n和决策树一样，神经网络也可以剪枝，去除那些影响很小的连接。\n\n### 优缺点\n\n优点：\n\n- 对噪声的高容忍\n- 对连续值的良好适配\n- 对真实数据的良好处理\n- 效果很好\n\n缺点：\n\n- 很长的训练时间\n- 要求大量的参数\n- 解释性很差\n\n## 其他分类方法\n\n包括KNN、集成学习比如（Baggin、Boosting）\n\n## 预测\n\n线性回归模型、多项式回归模型、广义线性模型、对数线性模型（针对分类数据）\n\n## 准确率和误差的衡量\n\n使用混淆矩阵confusion matrix来表示分类的情况。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1574086256/blog/Data%20Mining/confusion_matrix.jpg)\n\n准确率和错误率表示为：\n$$\n\\begin{split}\nAccuracy&=\\dfrac{(true\\_pos+true\\_neg)}{pos+neg}\\\\\nError rate&=1-Accuracy\n\\end{split}\n$$\n还有其他几个指标\n$$\n\\begin{split}\nsensitivity&=\\dfrac{true\\_pos}{pos} /* 真阳的识别率*/\\\\\nspecificity&=\\dfrac{true\\_neg}{neg} /* 真阴的识别率*/\\\\\nprecision&=\\dfrac{true\\_pos}{true\\_pos+true\\_neg} /* 预测的精度*/\\\\\n\\end{split}\n$$\n\n## 参考\n\n《数据挖掘概念与技术》第3版 第八章分类：基本概念 第九章 分类高级方法","source":"_posts/2019-11-17-分类与预测.md","raw":"---\ntitle: 分类与预测\ndate: 2019-11-17 20:41:23\ncategories: 数据挖掘\ntags:\n- 分类\n- 课程\n- 国科大\n- 贝叶斯\n- 神经网络\n- 决策树\ncopyright: true\nmathjax: true\n---\n\n# 分类与预测\n\n## 分类与预测的差别\n\n分类对给定的数据集一般是离散的，确定这些数据对应类别。而预测是对连续的数据，根据历史数据来预测未知的数据或者缺失值等。\n\n分类的过程分为两步：\n\n- 模型构建\n\n  使用训练数据集对模型进行训练，模型可以被表示为一些分类的规则集合，决策树或者是数学公式。\n\n- 模型使用\n\n  先使用模型来对测试数据进行分类，如果准确率能够接受则使用模型去对没有标注过的数据进行分类。\n\n分类属于有监督学习，训练的数据是经过标注的。聚类属于无监督学习训练数据未经过标注不知道样本的标签。\n\n<!--more-->\n\n在进行分类和预测之前需要对数据进行预处理包括数据清洗来处理噪声和缺失值，相关性分析来进行特征提取，数据转换比如归一化等。\n\n对于分类方法的评测指标有：准确性，速度，鲁棒性，可规模性（硬盘数据），可解释性等\n\n## 决策树\n\n决策树是一个类似于流程图的树结构；其中，每个内部结点表示在一个属性上的测试，每个分枝代表一个测试输出，而每个树叶结点代表类或类分布。树的最顶层结点是根结点。给定数据经过决策树不同节点的决策最终走到叶子节点，从而完成了对数据的分类。决策树不需要任何领域知识也不需要参数，适合探测式知识发现。\n\n决策数的构建分为两步：\n\n- 树的构建 从根节点开始递归的选择属性进行建树\n- 剪枝 ：减去反映噪声或者离群点的分枝\n\n### 构建决策树\n\n算法伪代码为：\n\n![](https://res.cloudinary.com/bravey/image/upload/v1574086256/blog/Data%20Mining/decision_tree_code.jpg)\n\n三个参数D是输入的数据集,attribute_list是输入数据中的属性集合和Atrribute_selection_method是指定选择属性的启发式过程，可以选择信息增益或者是基尼指数Gini index。\n\n步骤为：\n\n1. 首先从根节点N开始，根节点中的数据是原始的需要分类的原始数据集。\n\n2. 如果D中的数据都属于同一类，那么根节点N变成叶子节点，标记为这一类。\n\n3. 否则，调用Atrribute_selection_method来选择最佳的分裂属性，并给出分裂子集。理想情况下希望分裂子集尽可能的纯，也就是希望分裂自己尽可能的都属于同一类。\n\n4. 用选出来的分裂属性在节点N上进行划分，并输出划分的数据子集。并把分裂属性从属性列表中删除。\n\n   1. 选出来的属性是离散值的话，有多少个取值就产生多少个分支\n   2. 连续值的话选择一个分裂值，大于这个分裂值为一个分支，小于等于为另外一个分支\n   3. 离散值而且必须是二叉树的话：属于这个值为一个分支，否则为另外一个分支\n\n   ![](https://res.cloudinary.com/bravey/image/upload/v1574086256/blog/Data%20Mining/split_choice.jpg)\n\n5. 对于每一个删除了最佳分裂属性的输出的子集$D_j$ 递归的调用算法。\n\n6. 递归的终止条件：\n\n   1. 数据集D都属于同一类\n   2. 属性列表为空，使用数据集中的多数类来标记节点。**（多数投票）**\n   3. 如果一个分支的数据$D_j$为空，则新增加一个叶子节点，用父节点数据集D中的多数类来标记它。\n\n7. 返回决策数的节点N\n\n### 属性选择度量\n\n很明显，决策树的关键点是怎么选择分裂的属性。有如下三种方式。\n\n#### 信息增益\n\nID3这种决策树方法使用。\n\n先计算数据集D的熵：\n$$\nInfo(D)=-\\sum_{i=1}^{m}p_ilog_2(p_i)\n$$\n假设数据集中D有m个类别${C_1,C_2\\dots C_m}$，那么每一类的概率可以用所占的比例$p_i=\\dfrac{count(C_i)}{count(D)}$来估计。\n\n假设属性A 具有v 个不同值${a_1 ,..., a_v}$。可以用属性A 将S 划分为v 个子集${S_1 ,..., S_v}$；其中，\n$S_j$ 包含S 中这样一些样本，它们在A 上具有值$a_j$。如果A 选作测试属性,则获得的信息增益,也就是划分成了子集后的熵为：\n$$\nInfo_A(D)=\\sum_{j=1}^{v}\\dfrac{|D_j|}{|D|}\\times Info(D_j)\n$$\n信息增益定义为原来的的信息需求（近基于类比例）与新的信息需求（对A划分后）之间的差：\n$$\nGain(A)=Info(D)-Info_A(D)\n$$\n具有最高信息增益的属性是最佳分裂属性。可以这样理解，划分后越纯那么整个状态越不混乱，也就是熵越低。所以选择划分后熵最低而信息增益最高的属性。\n\n#### 信息增益率\n\n信息增益偏向有许多输出的测试，它倾向于选择具有大量值的属性。比如按照唯一的标识符id来划分，每个划分出来的都只包含一个数据都是纯的，但是这样的划分显然没有作用。\n\nC4.5使用增益率来进行选择分裂属性。增益率用分裂信息值将信息增益归一化。\n$$\nSplitInfo_A(D)=-\\sum_{j=1}^{v}\\dfrac{|D_j|}{|D|}\\times log_2(\\dfrac{|D_j|}{D})\n$$\n分裂信息值代表由训练数据集D根据属性A划分v个分区后，这v个分区的熵。前面的$Info_A(D)$是对每个分区还计算了一下分区里面的熵然后进行加权，而这里是全局地看待这v个分局而进行的计算。\n\n增益率定义为：\n$$\nGainRate(A)=\\dfrac{Gain(A)}{SplitInfo_A(D)}\n$$\n选择具有最大增益率的属性作为分裂属性。\n\n#### 基尼指数\n\n基尼指数在CART中使用，基尼指数度量数据集的不纯度，定义为：\n$$\nGini(D)=1-\\sum_{i=1}^{m}p_i^2\n$$\n$p_i=\\dfrac{|C_i|}{|D|}$依然用每一类的比例来估计。基尼指数考虑每个属性的二元划分，根据属性A划分成两个两个子集$D_1,D_2$在这种划分下的基尼指数为：\n$$\nGini_A(D)=\\dfrac{|D_1|}{|D|}Gini(D_1)+\\dfrac{|D_2|}{|D|}Gini(D_2)\n$$\n选择具有最低的基尼指数作为分裂属性。  \n\n### 决策树决策规则\n\n构建好了决策树后，决策规则使用IF-THEN的语句来表示。![](https://res.cloudinary.com/bravey/image/upload/v1574086256/blog/Data%20Mining/decision_tree_rules.jpg)\n\n比如上图的决策规则是：\n\n```\nIF age is Middle_aged THEN buys_computer = yes\nIF age is youth AND student = no THEN buys_computer = no\nIF age is youth AND student = yes THEN buys_computer = yes\nIF age is senior AND credit_rating=excellent THEN buys_computer = no\nIF age is senior AND credit_rating=fair THEN buys_computer = yes\n```\n\n有多少个叶子节点相应的有多少决策规则，在到达叶子节点的路径上有多少个节点就有多少个并列的条件。\n\n### 过拟合与树剪枝\n\n在创建决策树时，由于数据中的噪声和离群点，许多分支反映的是训练数据中的异常。使用剪枝的方法来处理这种过拟合的问题。\n\n#### 先剪枝\n\n先剪枝prepruning方法提前停止树的创建。比如设定一个阈值当信息增益等度量超过阈值则分裂，不超过就停止分裂，用投票的方法确定标签。但是阈值的设置比较困难，所以不常用。\n\n#### 后剪枝\n\n后剪枝postpruning方法从完全创建好了的决策树进行剪枝。剪去后也依然使用投票的方法来确定标签。\n\nCART使用**代价复杂度**剪枝算法，C4.5使用**悲观剪枝**的方法。二者都是根据错误率，简单说就是如果减去这个分支后错误率提升不大就可以减去。\n\n### 决策树评价\n\n比其他的分类方法有着相对更快的学习速度，能够转换成容易理解的决策规则，准确率也能接受，而且也可以适用于大规模的数据。\n\n## 贝叶斯分类\n\n朴素贝叶斯分类发假定一个属性值在给定类上的影响独立于其他属性的值，这个假定称为类条件独立性。做这个假定是为了简化计算，因而称之为朴素的。\n\n### 贝叶斯定理\n\n贝叶斯定理用来求解后验概率。公式为：\n$$\nP(H|X)=\\dfrac{P(H)P(X|H)}{P(X)}\n$$\nX是数据样本，分类未知。H是对X的分类的假设，比如X属于C类。P(H)是猜测的类的概率，P(X)是观察到的样本X的概率，而P(H|X)是在给定H的假设下，观察到X样本的概率。\n\n### 朴素贝叶斯分类\n\n#### 工作过程\n\n1. 训练数据集D中一个样本X向量用一个n维的列向量$[x_1,x_2\\dots x_n]^T$来表示它对应的n个属性$[A_1,A_2\\dots A_n]$的测量值。\n\n2. 假定有m个类$C_1,C_2\\dots C_n$,将X预测为拥有最高后验概率的类。\n   $$\n   max(P(C_i|X))=max(\\dfrac{P(X|C_i)P(C_i)}{P(X)})\n   $$\n\n3. 因为$P(X)$是常数，所以只用最大化$P(X|C_i)P(C_i)$ $P(C_i)$用类的频率来估计\n\n4. 在类条件独立的假定下有：\n   $$\n   P(X|C_i)=\\prod_{k=1}^nP(x_k|C_i)=P(x_1|C_i)P(x_2|C_i)\\dots P(x_n|C_i)\n   $$\n   $x_k$表示样本X向量对应的第k个属性$A_k$的值。\n\n   1. 如果$A_k$是分类属性，那么$P(x_k|C_i)$是D中属性$A_k$的值为$x_k$的$C_i$类的元组数除以D中$C_i$的数目 \n\n   2. 如果$A_k$是连续值，则假定连续值服从均值为$\\mu$,标准差为$\\sigma$的高斯分布。\n      $$\n      g(x,\\mu,\\sigma)=\\dfrac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\dfrac{(x-\\mu)^2}{2\\sigma^2}}\n      $$\n      所以可以得到：\n   $$\n   P(x_k|C_i)=g(x_k,\\mu_{C_i},\\sigma_{C_i})\n   $$\n\n5. 对每一类都分别计算$P(X|C_i)P(C_i)$ 最后选择最大的作为这个样本的分类。\n\n#### 零概率值的解决\n\n在做连乘的时候如果有一个的概率为0，那么整个计算结果都为0。可以假设训练数据集很大，将每个取值的计数都加1而造成的概率估计可以忽略不计。这样就可以避免出现零概率的情况，称之为**拉普拉斯估计或这拉普拉斯校准法**\n\n### 评价\n\n朴素贝叶斯的优势：比较容易实现，在大多数情况可以取得好结果。缺点是：因为做了属性互相独立的假设，因此会降低准确率。而且实际上，大部分属性之间并不互相独立。\n\n可以使用贝叶斯信念网络来处理。\n\n## BP神经网络\n\n### 多层前馈神经网络\n\n后向传播算法Back propagation在多层前馈神经网络上学习。由输入层、一个或多个隐藏层和一个输出层组成。\n\n![](C:\\Users\\BraveY\\Documents\\BraveY\\blog\\images\\data mining\\multi_layer_feed_forward_network.jpg)\n\n输入层的单元称作输入单元，隐藏层和输出层单元称作输出单元或者神经节点。输入向量输入进输入单元，然后加权同时地提供给隐藏层的输出单元。在全连接的情况下每一层单元与前后层单元都会有相应的权重，因为权重不会回馈到输入节点，所以称为前馈的。因此一次输入就完成输出。\n\n### 网络拓扑的定义\n\n应该设计多少层隐藏层，每一层有多少单元，输入层单元应该有多少，是否全连接等都是网络拓扑需要考虑的。\n\n需要先对输入值进行归一化，将值落入[0,1]之间。离散值的属性可以进行重新编码，让每一个域值都有一个输入单元。如果属性A有3个可能的值${a_0, a_1, a_2}$那么就需要设计3个输入单元$I_0, I_1,I_2$，输入单元$I_1$为1对应属性$A=a_1$。\n\n如果进行分类的话如果只有两类那么输出单元只用一个就可以了，多于2类的情况每一类都有一个输出单元。\n\n隐藏层单元数目的设计，没有明确的规定，通过反复实验的过程，来确定。一般选择一个隐藏层就可以了，权重的初始值也会影响结果的准确率。\n\n## 后向传播\n\n### 步骤\n\n后向传播通过迭代地处理训练数据，把每个样本的网络预测值与实际已知的目标值相比较。对每个训练样本，修改网络的权重使得网络预测和实际目标值之间的均方误差最小。修改后向进行，从输出层一直传递到输入层的，因此叫做后向传播。\n\n算法伪代码为：\n\n![](https://res.cloudinary.com/bravey/image/upload/v1574086256/blog/Data%20Mining/bp_code.jpg)\n\n步骤为：\n\n**初始化权重：**权重被初始化为小随机数（比如-1到1，或者-0.5到0.5），偏倚bias也初始化为小随机数。\n\n**向前传播输入**：输入单元的输出就是输入值。隐藏层和输出层单元的净输入用上一层输入的线性组合计算。输出单元的输出用激活函数计算，激活函数是logistic或这S型sigmoid函数,激活函数将较大的输入值域映射到区间[0,1]\n\n![](https://res.cloudinary.com/bravey/image/upload/v1574086256/blog/Data%20Mining/bpnn_io.jpg)\n\n隐藏层或者输出层单元j其输入为如下，其中$w_{ij}$是上层单元i到单元j的权重，$O_i$是上一层单元的输出，$\\theta_j$是单元j的偏倚。偏倚用来充当阈值，改变单元的活性\n$$\nI_j=\\sum_{i}w_{ij}O_i+\\theta_j\n$$\n单元j的输出$O_j$为：\n$$\nO_j=\\dfrac{1}{1+e^{I_j}}\n$$\n**向后传播误差**：通过更新权重和反映网络预测误差的偏倚，向后传播误差。对于输出层单元j，误差如下，其中$O_j$ 是单元j的实际输出， $T_j$ 是j给定训练样本的实际目标值，$O_j(1-O_j)$是逻辑斯提函数的导数。\n$$\nErr_j=O_j(1-O_j)(T_j-O_j)\n$$\n隐藏层单元j的误差，考虑下一层中j连接的单元的误差加权和。误差如下：\n$$\nErr_j=O_j(1-O_j)\\sum_kErr_kw_{jk}\n$$\n其中$w_{jk}$是下一层单元k与单元j的连接权重，而$Err_k$是单元k的误差。\n\n更新权重和偏倚，以反映误差的传播。权重更新公式如下，其中$\\Delta w_{ij}$是权重的改变量。\n$$\n\\begin{split}\n\\Delta w_{ij}&=l\\times Err_jO_i\\\\\nw_{ij}&=w_{ij}+\\Delta w_{ij}\n\\end{split}\n$$\n变量l是**学习率**，通常去[0,1]之间的常数值。学习率帮助避免陷入决策空间的局部极小，并有助于找到全局最小。学习率太低的话，学习将进行的很慢。学习率太高的话，可能出现在不适当的解之间的摆动。一种调整规则是将学习率设置为迭代次数的倒数。\n\n偏倚的更新公式为：其中$\\Delta \\theta_{ij}$是偏倚的改变量。\n$$\n\\begin{split}\n\\Delta \\theta_{ij}&=l\\times Err_j\\\\\n\\theta_{ij}&=\\theta_{ij}+\\Delta \\theta_{ij}\n\\end{split}\n$$\n更新的策略有实例更新：每处理一个样本就更新权重和偏倚。周期更新为处理玩所有样本后再更新。实例更新通常产生更准确的结果。\n\n**终止条件：**\n\n- 前一周期所有的$\\Delta w_{ij}$都太小，小于某个阈值\n- 前一周其误分类的数据百分比小于某个阈值\n- 超过预先指定的周期数。实践中权重收敛可能需要数十万个周期。\n\n和决策树一样，神经网络也可以剪枝，去除那些影响很小的连接。\n\n### 优缺点\n\n优点：\n\n- 对噪声的高容忍\n- 对连续值的良好适配\n- 对真实数据的良好处理\n- 效果很好\n\n缺点：\n\n- 很长的训练时间\n- 要求大量的参数\n- 解释性很差\n\n## 其他分类方法\n\n包括KNN、集成学习比如（Baggin、Boosting）\n\n## 预测\n\n线性回归模型、多项式回归模型、广义线性模型、对数线性模型（针对分类数据）\n\n## 准确率和误差的衡量\n\n使用混淆矩阵confusion matrix来表示分类的情况。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1574086256/blog/Data%20Mining/confusion_matrix.jpg)\n\n准确率和错误率表示为：\n$$\n\\begin{split}\nAccuracy&=\\dfrac{(true\\_pos+true\\_neg)}{pos+neg}\\\\\nError rate&=1-Accuracy\n\\end{split}\n$$\n还有其他几个指标\n$$\n\\begin{split}\nsensitivity&=\\dfrac{true\\_pos}{pos} /* 真阳的识别率*/\\\\\nspecificity&=\\dfrac{true\\_neg}{neg} /* 真阴的识别率*/\\\\\nprecision&=\\dfrac{true\\_pos}{true\\_pos+true\\_neg} /* 预测的精度*/\\\\\n\\end{split}\n$$\n\n## 参考\n\n《数据挖掘概念与技术》第3版 第八章分类：基本概念 第九章 分类高级方法","slug":"2019-11-17-分类与预测","published":1,"updated":"2019-11-18T14:57:24.981Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6he13yy001rdstzkm1sz5re","content":"<h1 id=\"分类与预测\"><a href=\"#分类与预测\" class=\"headerlink\" title=\"分类与预测\"></a>分类与预测</h1><h2 id=\"分类与预测的差别\"><a href=\"#分类与预测的差别\" class=\"headerlink\" title=\"分类与预测的差别\"></a>分类与预测的差别</h2><p>分类对给定的数据集一般是离散的，确定这些数据对应类别。而预测是对连续的数据，根据历史数据来预测未知的数据或者缺失值等。</p>\n<p>分类的过程分为两步：</p>\n<ul>\n<li><p>模型构建</p>\n<p>使用训练数据集对模型进行训练，模型可以被表示为一些分类的规则集合，决策树或者是数学公式。</p>\n</li>\n<li><p>模型使用</p>\n<p>先使用模型来对测试数据进行分类，如果准确率能够接受则使用模型去对没有标注过的数据进行分类。</p>\n</li>\n</ul>\n<p>分类属于有监督学习，训练的数据是经过标注的。聚类属于无监督学习训练数据未经过标注不知道样本的标签。</p>\n<a id=\"more\"></a>\n<p>在进行分类和预测之前需要对数据进行预处理包括数据清洗来处理噪声和缺失值，相关性分析来进行特征提取，数据转换比如归一化等。</p>\n<p>对于分类方法的评测指标有：准确性，速度，鲁棒性，可规模性（硬盘数据），可解释性等</p>\n<h2 id=\"决策树\"><a href=\"#决策树\" class=\"headerlink\" title=\"决策树\"></a>决策树</h2><p>决策树是一个类似于流程图的树结构；其中，每个内部结点表示在一个属性上的测试，每个分枝代表一个测试输出，而每个树叶结点代表类或类分布。树的最顶层结点是根结点。给定数据经过决策树不同节点的决策最终走到叶子节点，从而完成了对数据的分类。决策树不需要任何领域知识也不需要参数，适合探测式知识发现。</p>\n<p>决策数的构建分为两步：</p>\n<ul>\n<li>树的构建 从根节点开始递归的选择属性进行建树</li>\n<li>剪枝 ：减去反映噪声或者离群点的分枝</li>\n</ul>\n<h3 id=\"构建决策树\"><a href=\"#构建决策树\" class=\"headerlink\" title=\"构建决策树\"></a>构建决策树</h3><p>算法伪代码为：</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1574086256/blog/Data%20Mining/decision_tree_code.jpg\" alt=\"\"></p>\n<p>三个参数D是输入的数据集,attribute_list是输入数据中的属性集合和Atrribute_selection_method是指定选择属性的启发式过程，可以选择信息增益或者是基尼指数Gini index。</p>\n<p>步骤为：</p>\n<ol>\n<li><p>首先从根节点N开始，根节点中的数据是原始的需要分类的原始数据集。</p>\n</li>\n<li><p>如果D中的数据都属于同一类，那么根节点N变成叶子节点，标记为这一类。</p>\n</li>\n<li><p>否则，调用Atrribute_selection_method来选择最佳的分裂属性，并给出分裂子集。理想情况下希望分裂子集尽可能的纯，也就是希望分裂自己尽可能的都属于同一类。</p>\n</li>\n<li><p>用选出来的分裂属性在节点N上进行划分，并输出划分的数据子集。并把分裂属性从属性列表中删除。</p>\n<ol>\n<li>选出来的属性是离散值的话，有多少个取值就产生多少个分支</li>\n<li>连续值的话选择一个分裂值，大于这个分裂值为一个分支，小于等于为另外一个分支</li>\n<li>离散值而且必须是二叉树的话：属于这个值为一个分支，否则为另外一个分支</li>\n</ol>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1574086256/blog/Data%20Mining/split_choice.jpg\" alt=\"\"></p>\n</li>\n<li><p>对于每一个删除了最佳分裂属性的输出的子集$D_j$ 递归的调用算法。</p>\n</li>\n<li><p>递归的终止条件：</p>\n<ol>\n<li>数据集D都属于同一类</li>\n<li>属性列表为空，使用数据集中的多数类来标记节点。<strong>（多数投票）</strong></li>\n<li>如果一个分支的数据$D_j$为空，则新增加一个叶子节点，用父节点数据集D中的多数类来标记它。</li>\n</ol>\n</li>\n<li><p>返回决策数的节点N</p>\n</li>\n</ol>\n<h3 id=\"属性选择度量\"><a href=\"#属性选择度量\" class=\"headerlink\" title=\"属性选择度量\"></a>属性选择度量</h3><p>很明显，决策树的关键点是怎么选择分裂的属性。有如下三种方式。</p>\n<h4 id=\"信息增益\"><a href=\"#信息增益\" class=\"headerlink\" title=\"信息增益\"></a>信息增益</h4><p>ID3这种决策树方法使用。</p>\n<p>先计算数据集D的熵：</p>\n<script type=\"math/tex; mode=display\">\nInfo(D)=-\\sum_{i=1}^{m}p_ilog_2(p_i)</script><p>假设数据集中D有m个类别${C_1,C_2\\dots C_m}$，那么每一类的概率可以用所占的比例$p_i=\\dfrac{count(C_i)}{count(D)}$来估计。</p>\n<p>假设属性A 具有v 个不同值${a_1 ,…, a_v}$。可以用属性A 将S 划分为v 个子集${S_1 ,…, S_v}$；其中，<br>$S_j$ 包含S 中这样一些样本，它们在A 上具有值$a_j$。如果A 选作测试属性,则获得的信息增益,也就是划分成了子集后的熵为：</p>\n<script type=\"math/tex; mode=display\">\nInfo_A(D)=\\sum_{j=1}^{v}\\dfrac{|D_j|}{|D|}\\times Info(D_j)</script><p>信息增益定义为原来的的信息需求（近基于类比例）与新的信息需求（对A划分后）之间的差：</p>\n<script type=\"math/tex; mode=display\">\nGain(A)=Info(D)-Info_A(D)</script><p>具有最高信息增益的属性是最佳分裂属性。可以这样理解，划分后越纯那么整个状态越不混乱，也就是熵越低。所以选择划分后熵最低而信息增益最高的属性。</p>\n<h4 id=\"信息增益率\"><a href=\"#信息增益率\" class=\"headerlink\" title=\"信息增益率\"></a>信息增益率</h4><p>信息增益偏向有许多输出的测试，它倾向于选择具有大量值的属性。比如按照唯一的标识符id来划分，每个划分出来的都只包含一个数据都是纯的，但是这样的划分显然没有作用。</p>\n<p>C4.5使用增益率来进行选择分裂属性。增益率用分裂信息值将信息增益归一化。</p>\n<script type=\"math/tex; mode=display\">\nSplitInfo_A(D)=-\\sum_{j=1}^{v}\\dfrac{|D_j|}{|D|}\\times log_2(\\dfrac{|D_j|}{D})</script><p>分裂信息值代表由训练数据集D根据属性A划分v个分区后，这v个分区的熵。前面的$Info_A(D)$是对每个分区还计算了一下分区里面的熵然后进行加权，而这里是全局地看待这v个分局而进行的计算。</p>\n<p>增益率定义为：</p>\n<script type=\"math/tex; mode=display\">\nGainRate(A)=\\dfrac{Gain(A)}{SplitInfo_A(D)}</script><p>选择具有最大增益率的属性作为分裂属性。</p>\n<h4 id=\"基尼指数\"><a href=\"#基尼指数\" class=\"headerlink\" title=\"基尼指数\"></a>基尼指数</h4><p>基尼指数在CART中使用，基尼指数度量数据集的不纯度，定义为：</p>\n<script type=\"math/tex; mode=display\">\nGini(D)=1-\\sum_{i=1}^{m}p_i^2</script><p>$p_i=\\dfrac{|C_i|}{|D|}$依然用每一类的比例来估计。基尼指数考虑每个属性的二元划分，根据属性A划分成两个两个子集$D_1,D_2$在这种划分下的基尼指数为：</p>\n<script type=\"math/tex; mode=display\">\nGini_A(D)=\\dfrac{|D_1|}{|D|}Gini(D_1)+\\dfrac{|D_2|}{|D|}Gini(D_2)</script><p>选择具有最低的基尼指数作为分裂属性。  </p>\n<h3 id=\"决策树决策规则\"><a href=\"#决策树决策规则\" class=\"headerlink\" title=\"决策树决策规则\"></a>决策树决策规则</h3><p>构建好了决策树后，决策规则使用IF-THEN的语句来表示。<img src=\"https://res.cloudinary.com/bravey/image/upload/v1574086256/blog/Data%20Mining/decision_tree_rules.jpg\" alt=\"\"></p>\n<p>比如上图的决策规则是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IF age is Middle_aged THEN buys_computer = yes</span><br><span class=\"line\">IF age is youth AND student = no THEN buys_computer = no</span><br><span class=\"line\">IF age is youth AND student = yes THEN buys_computer = yes</span><br><span class=\"line\">IF age is senior AND credit_rating=excellent THEN buys_computer = no</span><br><span class=\"line\">IF age is senior AND credit_rating=fair THEN buys_computer = yes</span><br></pre></td></tr></table></figure>\n<p>有多少个叶子节点相应的有多少决策规则，在到达叶子节点的路径上有多少个节点就有多少个并列的条件。</p>\n<h3 id=\"过拟合与树剪枝\"><a href=\"#过拟合与树剪枝\" class=\"headerlink\" title=\"过拟合与树剪枝\"></a>过拟合与树剪枝</h3><p>在创建决策树时，由于数据中的噪声和离群点，许多分支反映的是训练数据中的异常。使用剪枝的方法来处理这种过拟合的问题。</p>\n<h4 id=\"先剪枝\"><a href=\"#先剪枝\" class=\"headerlink\" title=\"先剪枝\"></a>先剪枝</h4><p>先剪枝prepruning方法提前停止树的创建。比如设定一个阈值当信息增益等度量超过阈值则分裂，不超过就停止分裂，用投票的方法确定标签。但是阈值的设置比较困难，所以不常用。</p>\n<h4 id=\"后剪枝\"><a href=\"#后剪枝\" class=\"headerlink\" title=\"后剪枝\"></a>后剪枝</h4><p>后剪枝postpruning方法从完全创建好了的决策树进行剪枝。剪去后也依然使用投票的方法来确定标签。</p>\n<p>CART使用<strong>代价复杂度</strong>剪枝算法，C4.5使用<strong>悲观剪枝</strong>的方法。二者都是根据错误率，简单说就是如果减去这个分支后错误率提升不大就可以减去。</p>\n<h3 id=\"决策树评价\"><a href=\"#决策树评价\" class=\"headerlink\" title=\"决策树评价\"></a>决策树评价</h3><p>比其他的分类方法有着相对更快的学习速度，能够转换成容易理解的决策规则，准确率也能接受，而且也可以适用于大规模的数据。</p>\n<h2 id=\"贝叶斯分类\"><a href=\"#贝叶斯分类\" class=\"headerlink\" title=\"贝叶斯分类\"></a>贝叶斯分类</h2><p>朴素贝叶斯分类发假定一个属性值在给定类上的影响独立于其他属性的值，这个假定称为类条件独立性。做这个假定是为了简化计算，因而称之为朴素的。</p>\n<h3 id=\"贝叶斯定理\"><a href=\"#贝叶斯定理\" class=\"headerlink\" title=\"贝叶斯定理\"></a>贝叶斯定理</h3><p>贝叶斯定理用来求解后验概率。公式为：</p>\n<script type=\"math/tex; mode=display\">\nP(H|X)=\\dfrac{P(H)P(X|H)}{P(X)}</script><p>X是数据样本，分类未知。H是对X的分类的假设，比如X属于C类。P(H)是猜测的类的概率，P(X)是观察到的样本X的概率，而P(H|X)是在给定H的假设下，观察到X样本的概率。</p>\n<h3 id=\"朴素贝叶斯分类\"><a href=\"#朴素贝叶斯分类\" class=\"headerlink\" title=\"朴素贝叶斯分类\"></a>朴素贝叶斯分类</h3><h4 id=\"工作过程\"><a href=\"#工作过程\" class=\"headerlink\" title=\"工作过程\"></a>工作过程</h4><ol>\n<li><p>训练数据集D中一个样本X向量用一个n维的列向量$[x_1,x_2\\dots x_n]^T$来表示它对应的n个属性$[A_1,A_2\\dots A_n]$的测量值。</p>\n</li>\n<li><p>假定有m个类$C_1,C_2\\dots C_n$,将X预测为拥有最高后验概率的类。</p>\n<script type=\"math/tex; mode=display\">\nmax(P(C_i|X))=max(\\dfrac{P(X|C_i)P(C_i)}{P(X)})</script></li>\n<li><p>因为$P(X)$是常数，所以只用最大化$P(X|C_i)P(C_i)$ $P(C_i)$用类的频率来估计</p>\n</li>\n<li><p>在类条件独立的假定下有：</p>\n<script type=\"math/tex; mode=display\">\nP(X|C_i)=\\prod_{k=1}^nP(x_k|C_i)=P(x_1|C_i)P(x_2|C_i)\\dots P(x_n|C_i)</script><p>$x_k$表示样本X向量对应的第k个属性$A_k$的值。</p>\n<ol>\n<li><p>如果$A_k$是分类属性，那么$P(x_k|C_i)$是D中属性$A_k$的值为$x_k$的$C_i$类的元组数除以D中$C_i$的数目 </p>\n</li>\n<li><p>如果$A_k$是连续值，则假定连续值服从均值为$\\mu$,标准差为$\\sigma$的高斯分布。</p>\n<script type=\"math/tex; mode=display\">\ng(x,\\mu,\\sigma)=\\dfrac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\dfrac{(x-\\mu)^2}{2\\sigma^2}}</script><p>所以可以得到：</p>\n<script type=\"math/tex; mode=display\">\nP(x_k|C_i)=g(x_k,\\mu_{C_i},\\sigma_{C_i})</script></li>\n</ol>\n</li>\n<li><p>对每一类都分别计算$P(X|C_i)P(C_i)$ 最后选择最大的作为这个样本的分类。</p>\n</li>\n</ol>\n<h4 id=\"零概率值的解决\"><a href=\"#零概率值的解决\" class=\"headerlink\" title=\"零概率值的解决\"></a>零概率值的解决</h4><p>在做连乘的时候如果有一个的概率为0，那么整个计算结果都为0。可以假设训练数据集很大，将每个取值的计数都加1而造成的概率估计可以忽略不计。这样就可以避免出现零概率的情况，称之为<strong>拉普拉斯估计或这拉普拉斯校准法</strong></p>\n<h3 id=\"评价\"><a href=\"#评价\" class=\"headerlink\" title=\"评价\"></a>评价</h3><p>朴素贝叶斯的优势：比较容易实现，在大多数情况可以取得好结果。缺点是：因为做了属性互相独立的假设，因此会降低准确率。而且实际上，大部分属性之间并不互相独立。</p>\n<p>可以使用贝叶斯信念网络来处理。</p>\n<h2 id=\"BP神经网络\"><a href=\"#BP神经网络\" class=\"headerlink\" title=\"BP神经网络\"></a>BP神经网络</h2><h3 id=\"多层前馈神经网络\"><a href=\"#多层前馈神经网络\" class=\"headerlink\" title=\"多层前馈神经网络\"></a>多层前馈神经网络</h3><p>后向传播算法Back propagation在多层前馈神经网络上学习。由输入层、一个或多个隐藏层和一个输出层组成。</p>\n<p><img src=\"C:\\Users\\BraveY\\Documents\\BraveY\\blog\\images\\data mining\\multi_layer_feed_forward_network.jpg\" alt=\"\"></p>\n<p>输入层的单元称作输入单元，隐藏层和输出层单元称作输出单元或者神经节点。输入向量输入进输入单元，然后加权同时地提供给隐藏层的输出单元。在全连接的情况下每一层单元与前后层单元都会有相应的权重，因为权重不会回馈到输入节点，所以称为前馈的。因此一次输入就完成输出。</p>\n<h3 id=\"网络拓扑的定义\"><a href=\"#网络拓扑的定义\" class=\"headerlink\" title=\"网络拓扑的定义\"></a>网络拓扑的定义</h3><p>应该设计多少层隐藏层，每一层有多少单元，输入层单元应该有多少，是否全连接等都是网络拓扑需要考虑的。</p>\n<p>需要先对输入值进行归一化，将值落入[0,1]之间。离散值的属性可以进行重新编码，让每一个域值都有一个输入单元。如果属性A有3个可能的值${a_0, a_1, a_2}$那么就需要设计3个输入单元$I_0, I_1,I_2$，输入单元$I_1$为1对应属性$A=a_1$。</p>\n<p>如果进行分类的话如果只有两类那么输出单元只用一个就可以了，多于2类的情况每一类都有一个输出单元。</p>\n<p>隐藏层单元数目的设计，没有明确的规定，通过反复实验的过程，来确定。一般选择一个隐藏层就可以了，权重的初始值也会影响结果的准确率。</p>\n<h2 id=\"后向传播\"><a href=\"#后向传播\" class=\"headerlink\" title=\"后向传播\"></a>后向传播</h2><h3 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h3><p>后向传播通过迭代地处理训练数据，把每个样本的网络预测值与实际已知的目标值相比较。对每个训练样本，修改网络的权重使得网络预测和实际目标值之间的均方误差最小。修改后向进行，从输出层一直传递到输入层的，因此叫做后向传播。</p>\n<p>算法伪代码为：</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1574086256/blog/Data%20Mining/bp_code.jpg\" alt=\"\"></p>\n<p>步骤为：</p>\n<p><strong>初始化权重：</strong>权重被初始化为小随机数（比如-1到1，或者-0.5到0.5），偏倚bias也初始化为小随机数。</p>\n<p><strong>向前传播输入</strong>：输入单元的输出就是输入值。隐藏层和输出层单元的净输入用上一层输入的线性组合计算。输出单元的输出用激活函数计算，激活函数是logistic或这S型sigmoid函数,激活函数将较大的输入值域映射到区间[0,1]</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1574086256/blog/Data%20Mining/bpnn_io.jpg\" alt=\"\"></p>\n<p>隐藏层或者输出层单元j其输入为如下，其中$w_{ij}$是上层单元i到单元j的权重，$O_i$是上一层单元的输出，$\\theta_j$是单元j的偏倚。偏倚用来充当阈值，改变单元的活性</p>\n<script type=\"math/tex; mode=display\">\nI_j=\\sum_{i}w_{ij}O_i+\\theta_j</script><p>单元j的输出$O_j$为：</p>\n<script type=\"math/tex; mode=display\">\nO_j=\\dfrac{1}{1+e^{I_j}}</script><p><strong>向后传播误差</strong>：通过更新权重和反映网络预测误差的偏倚，向后传播误差。对于输出层单元j，误差如下，其中$O_j$ 是单元j的实际输出， $T_j$ 是j给定训练样本的实际目标值，$O_j(1-O_j)$是逻辑斯提函数的导数。</p>\n<script type=\"math/tex; mode=display\">\nErr_j=O_j(1-O_j)(T_j-O_j)</script><p>隐藏层单元j的误差，考虑下一层中j连接的单元的误差加权和。误差如下：</p>\n<script type=\"math/tex; mode=display\">\nErr_j=O_j(1-O_j)\\sum_kErr_kw_{jk}</script><p>其中$w_{jk}$是下一层单元k与单元j的连接权重，而$Err_k$是单元k的误差。</p>\n<p>更新权重和偏倚，以反映误差的传播。权重更新公式如下，其中$\\Delta w_{ij}$是权重的改变量。</p>\n<script type=\"math/tex; mode=display\">\n\\begin{split}\n\\Delta w_{ij}&=l\\times Err_jO_i\\\\\nw_{ij}&=w_{ij}+\\Delta w_{ij}\n\\end{split}</script><p>变量l是<strong>学习率</strong>，通常去[0,1]之间的常数值。学习率帮助避免陷入决策空间的局部极小，并有助于找到全局最小。学习率太低的话，学习将进行的很慢。学习率太高的话，可能出现在不适当的解之间的摆动。一种调整规则是将学习率设置为迭代次数的倒数。</p>\n<p>偏倚的更新公式为：其中$\\Delta \\theta_{ij}$是偏倚的改变量。</p>\n<script type=\"math/tex; mode=display\">\n\\begin{split}\n\\Delta \\theta_{ij}&=l\\times Err_j\\\\\n\\theta_{ij}&=\\theta_{ij}+\\Delta \\theta_{ij}\n\\end{split}</script><p>更新的策略有实例更新：每处理一个样本就更新权重和偏倚。周期更新为处理玩所有样本后再更新。实例更新通常产生更准确的结果。</p>\n<p><strong>终止条件：</strong></p>\n<ul>\n<li>前一周期所有的$\\Delta w_{ij}$都太小，小于某个阈值</li>\n<li>前一周其误分类的数据百分比小于某个阈值</li>\n<li>超过预先指定的周期数。实践中权重收敛可能需要数十万个周期。</li>\n</ul>\n<p>和决策树一样，神经网络也可以剪枝，去除那些影响很小的连接。</p>\n<h3 id=\"优缺点\"><a href=\"#优缺点\" class=\"headerlink\" title=\"优缺点\"></a>优缺点</h3><p>优点：</p>\n<ul>\n<li>对噪声的高容忍</li>\n<li>对连续值的良好适配</li>\n<li>对真实数据的良好处理</li>\n<li>效果很好</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>很长的训练时间</li>\n<li>要求大量的参数</li>\n<li>解释性很差</li>\n</ul>\n<h2 id=\"其他分类方法\"><a href=\"#其他分类方法\" class=\"headerlink\" title=\"其他分类方法\"></a>其他分类方法</h2><p>包括KNN、集成学习比如（Baggin、Boosting）</p>\n<h2 id=\"预测\"><a href=\"#预测\" class=\"headerlink\" title=\"预测\"></a>预测</h2><p>线性回归模型、多项式回归模型、广义线性模型、对数线性模型（针对分类数据）</p>\n<h2 id=\"准确率和误差的衡量\"><a href=\"#准确率和误差的衡量\" class=\"headerlink\" title=\"准确率和误差的衡量\"></a>准确率和误差的衡量</h2><p>使用混淆矩阵confusion matrix来表示分类的情况。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1574086256/blog/Data%20Mining/confusion_matrix.jpg\" alt=\"\"></p>\n<p>准确率和错误率表示为：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{split}\nAccuracy&=\\dfrac{(true\\_pos+true\\_neg)}{pos+neg}\\\\\nError rate&=1-Accuracy\n\\end{split}</script><p>还有其他几个指标</p>\n<script type=\"math/tex; mode=display\">\n\\begin{split}\nsensitivity&=\\dfrac{true\\_pos}{pos} /* 真阳的识别率*/\\\\\nspecificity&=\\dfrac{true\\_neg}{neg} /* 真阴的识别率*/\\\\\nprecision&=\\dfrac{true\\_pos}{true\\_pos+true\\_neg} /* 预测的精度*/\\\\\n\\end{split}</script><h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>《数据挖掘概念与技术》第3版 第八章分类：基本概念 第九章 分类高级方法</p>\n","site":{"data":{}},"length":6129,"excerpt":"<h1 id=\"分类与预测\"><a href=\"#分类与预测\" class=\"headerlink\" title=\"分类与预测\"></a>分类与预测</h1><h2 id=\"分类与预测的差别\"><a href=\"#分类与预测的差别\" class=\"headerlink\" title=\"分类与预测的差别\"></a>分类与预测的差别</h2><p>分类对给定的数据集一般是离散的，确定这些数据对应类别。而预测是对连续的数据，根据历史数据来预测未知的数据或者缺失值等。</p>\n<p>分类的过程分为两步：</p>\n<ul>\n<li><p>模型构建</p>\n<p>使用训练数据集对模型进行训练，模型可以被表示为一些分类的规则集合，决策树或者是数学公式。</p>\n</li>\n<li><p>模型使用</p>\n<p>先使用模型来对测试数据进行分类，如果准确率能够接受则使用模型去对没有标注过的数据进行分类。</p>\n</li>\n</ul>\n<p>分类属于有监督学习，训练的数据是经过标注的。聚类属于无监督学习训练数据未经过标注不知道样本的标签。</p>","more":"<p>在进行分类和预测之前需要对数据进行预处理包括数据清洗来处理噪声和缺失值，相关性分析来进行特征提取，数据转换比如归一化等。</p>\n<p>对于分类方法的评测指标有：准确性，速度，鲁棒性，可规模性（硬盘数据），可解释性等</p>\n<h2 id=\"决策树\"><a href=\"#决策树\" class=\"headerlink\" title=\"决策树\"></a>决策树</h2><p>决策树是一个类似于流程图的树结构；其中，每个内部结点表示在一个属性上的测试，每个分枝代表一个测试输出，而每个树叶结点代表类或类分布。树的最顶层结点是根结点。给定数据经过决策树不同节点的决策最终走到叶子节点，从而完成了对数据的分类。决策树不需要任何领域知识也不需要参数，适合探测式知识发现。</p>\n<p>决策数的构建分为两步：</p>\n<ul>\n<li>树的构建 从根节点开始递归的选择属性进行建树</li>\n<li>剪枝 ：减去反映噪声或者离群点的分枝</li>\n</ul>\n<h3 id=\"构建决策树\"><a href=\"#构建决策树\" class=\"headerlink\" title=\"构建决策树\"></a>构建决策树</h3><p>算法伪代码为：</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1574086256/blog/Data%20Mining/decision_tree_code.jpg\" alt=\"\"></p>\n<p>三个参数D是输入的数据集,attribute_list是输入数据中的属性集合和Atrribute_selection_method是指定选择属性的启发式过程，可以选择信息增益或者是基尼指数Gini index。</p>\n<p>步骤为：</p>\n<ol>\n<li><p>首先从根节点N开始，根节点中的数据是原始的需要分类的原始数据集。</p>\n</li>\n<li><p>如果D中的数据都属于同一类，那么根节点N变成叶子节点，标记为这一类。</p>\n</li>\n<li><p>否则，调用Atrribute_selection_method来选择最佳的分裂属性，并给出分裂子集。理想情况下希望分裂子集尽可能的纯，也就是希望分裂自己尽可能的都属于同一类。</p>\n</li>\n<li><p>用选出来的分裂属性在节点N上进行划分，并输出划分的数据子集。并把分裂属性从属性列表中删除。</p>\n<ol>\n<li>选出来的属性是离散值的话，有多少个取值就产生多少个分支</li>\n<li>连续值的话选择一个分裂值，大于这个分裂值为一个分支，小于等于为另外一个分支</li>\n<li>离散值而且必须是二叉树的话：属于这个值为一个分支，否则为另外一个分支</li>\n</ol>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1574086256/blog/Data%20Mining/split_choice.jpg\" alt=\"\"></p>\n</li>\n<li><p>对于每一个删除了最佳分裂属性的输出的子集$D_j$ 递归的调用算法。</p>\n</li>\n<li><p>递归的终止条件：</p>\n<ol>\n<li>数据集D都属于同一类</li>\n<li>属性列表为空，使用数据集中的多数类来标记节点。<strong>（多数投票）</strong></li>\n<li>如果一个分支的数据$D_j$为空，则新增加一个叶子节点，用父节点数据集D中的多数类来标记它。</li>\n</ol>\n</li>\n<li><p>返回决策数的节点N</p>\n</li>\n</ol>\n<h3 id=\"属性选择度量\"><a href=\"#属性选择度量\" class=\"headerlink\" title=\"属性选择度量\"></a>属性选择度量</h3><p>很明显，决策树的关键点是怎么选择分裂的属性。有如下三种方式。</p>\n<h4 id=\"信息增益\"><a href=\"#信息增益\" class=\"headerlink\" title=\"信息增益\"></a>信息增益</h4><p>ID3这种决策树方法使用。</p>\n<p>先计算数据集D的熵：</p>\n<script type=\"math/tex; mode=display\">\nInfo(D)=-\\sum_{i=1}^{m}p_ilog_2(p_i)</script><p>假设数据集中D有m个类别${C_1,C_2\\dots C_m}$，那么每一类的概率可以用所占的比例$p_i=\\dfrac{count(C_i)}{count(D)}$来估计。</p>\n<p>假设属性A 具有v 个不同值${a_1 ,…, a_v}$。可以用属性A 将S 划分为v 个子集${S_1 ,…, S_v}$；其中，<br>$S_j$ 包含S 中这样一些样本，它们在A 上具有值$a_j$。如果A 选作测试属性,则获得的信息增益,也就是划分成了子集后的熵为：</p>\n<script type=\"math/tex; mode=display\">\nInfo_A(D)=\\sum_{j=1}^{v}\\dfrac{|D_j|}{|D|}\\times Info(D_j)</script><p>信息增益定义为原来的的信息需求（近基于类比例）与新的信息需求（对A划分后）之间的差：</p>\n<script type=\"math/tex; mode=display\">\nGain(A)=Info(D)-Info_A(D)</script><p>具有最高信息增益的属性是最佳分裂属性。可以这样理解，划分后越纯那么整个状态越不混乱，也就是熵越低。所以选择划分后熵最低而信息增益最高的属性。</p>\n<h4 id=\"信息增益率\"><a href=\"#信息增益率\" class=\"headerlink\" title=\"信息增益率\"></a>信息增益率</h4><p>信息增益偏向有许多输出的测试，它倾向于选择具有大量值的属性。比如按照唯一的标识符id来划分，每个划分出来的都只包含一个数据都是纯的，但是这样的划分显然没有作用。</p>\n<p>C4.5使用增益率来进行选择分裂属性。增益率用分裂信息值将信息增益归一化。</p>\n<script type=\"math/tex; mode=display\">\nSplitInfo_A(D)=-\\sum_{j=1}^{v}\\dfrac{|D_j|}{|D|}\\times log_2(\\dfrac{|D_j|}{D})</script><p>分裂信息值代表由训练数据集D根据属性A划分v个分区后，这v个分区的熵。前面的$Info_A(D)$是对每个分区还计算了一下分区里面的熵然后进行加权，而这里是全局地看待这v个分局而进行的计算。</p>\n<p>增益率定义为：</p>\n<script type=\"math/tex; mode=display\">\nGainRate(A)=\\dfrac{Gain(A)}{SplitInfo_A(D)}</script><p>选择具有最大增益率的属性作为分裂属性。</p>\n<h4 id=\"基尼指数\"><a href=\"#基尼指数\" class=\"headerlink\" title=\"基尼指数\"></a>基尼指数</h4><p>基尼指数在CART中使用，基尼指数度量数据集的不纯度，定义为：</p>\n<script type=\"math/tex; mode=display\">\nGini(D)=1-\\sum_{i=1}^{m}p_i^2</script><p>$p_i=\\dfrac{|C_i|}{|D|}$依然用每一类的比例来估计。基尼指数考虑每个属性的二元划分，根据属性A划分成两个两个子集$D_1,D_2$在这种划分下的基尼指数为：</p>\n<script type=\"math/tex; mode=display\">\nGini_A(D)=\\dfrac{|D_1|}{|D|}Gini(D_1)+\\dfrac{|D_2|}{|D|}Gini(D_2)</script><p>选择具有最低的基尼指数作为分裂属性。  </p>\n<h3 id=\"决策树决策规则\"><a href=\"#决策树决策规则\" class=\"headerlink\" title=\"决策树决策规则\"></a>决策树决策规则</h3><p>构建好了决策树后，决策规则使用IF-THEN的语句来表示。<img src=\"https://res.cloudinary.com/bravey/image/upload/v1574086256/blog/Data%20Mining/decision_tree_rules.jpg\" alt=\"\"></p>\n<p>比如上图的决策规则是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IF age is Middle_aged THEN buys_computer = yes</span><br><span class=\"line\">IF age is youth AND student = no THEN buys_computer = no</span><br><span class=\"line\">IF age is youth AND student = yes THEN buys_computer = yes</span><br><span class=\"line\">IF age is senior AND credit_rating=excellent THEN buys_computer = no</span><br><span class=\"line\">IF age is senior AND credit_rating=fair THEN buys_computer = yes</span><br></pre></td></tr></table></figure>\n<p>有多少个叶子节点相应的有多少决策规则，在到达叶子节点的路径上有多少个节点就有多少个并列的条件。</p>\n<h3 id=\"过拟合与树剪枝\"><a href=\"#过拟合与树剪枝\" class=\"headerlink\" title=\"过拟合与树剪枝\"></a>过拟合与树剪枝</h3><p>在创建决策树时，由于数据中的噪声和离群点，许多分支反映的是训练数据中的异常。使用剪枝的方法来处理这种过拟合的问题。</p>\n<h4 id=\"先剪枝\"><a href=\"#先剪枝\" class=\"headerlink\" title=\"先剪枝\"></a>先剪枝</h4><p>先剪枝prepruning方法提前停止树的创建。比如设定一个阈值当信息增益等度量超过阈值则分裂，不超过就停止分裂，用投票的方法确定标签。但是阈值的设置比较困难，所以不常用。</p>\n<h4 id=\"后剪枝\"><a href=\"#后剪枝\" class=\"headerlink\" title=\"后剪枝\"></a>后剪枝</h4><p>后剪枝postpruning方法从完全创建好了的决策树进行剪枝。剪去后也依然使用投票的方法来确定标签。</p>\n<p>CART使用<strong>代价复杂度</strong>剪枝算法，C4.5使用<strong>悲观剪枝</strong>的方法。二者都是根据错误率，简单说就是如果减去这个分支后错误率提升不大就可以减去。</p>\n<h3 id=\"决策树评价\"><a href=\"#决策树评价\" class=\"headerlink\" title=\"决策树评价\"></a>决策树评价</h3><p>比其他的分类方法有着相对更快的学习速度，能够转换成容易理解的决策规则，准确率也能接受，而且也可以适用于大规模的数据。</p>\n<h2 id=\"贝叶斯分类\"><a href=\"#贝叶斯分类\" class=\"headerlink\" title=\"贝叶斯分类\"></a>贝叶斯分类</h2><p>朴素贝叶斯分类发假定一个属性值在给定类上的影响独立于其他属性的值，这个假定称为类条件独立性。做这个假定是为了简化计算，因而称之为朴素的。</p>\n<h3 id=\"贝叶斯定理\"><a href=\"#贝叶斯定理\" class=\"headerlink\" title=\"贝叶斯定理\"></a>贝叶斯定理</h3><p>贝叶斯定理用来求解后验概率。公式为：</p>\n<script type=\"math/tex; mode=display\">\nP(H|X)=\\dfrac{P(H)P(X|H)}{P(X)}</script><p>X是数据样本，分类未知。H是对X的分类的假设，比如X属于C类。P(H)是猜测的类的概率，P(X)是观察到的样本X的概率，而P(H|X)是在给定H的假设下，观察到X样本的概率。</p>\n<h3 id=\"朴素贝叶斯分类\"><a href=\"#朴素贝叶斯分类\" class=\"headerlink\" title=\"朴素贝叶斯分类\"></a>朴素贝叶斯分类</h3><h4 id=\"工作过程\"><a href=\"#工作过程\" class=\"headerlink\" title=\"工作过程\"></a>工作过程</h4><ol>\n<li><p>训练数据集D中一个样本X向量用一个n维的列向量$[x_1,x_2\\dots x_n]^T$来表示它对应的n个属性$[A_1,A_2\\dots A_n]$的测量值。</p>\n</li>\n<li><p>假定有m个类$C_1,C_2\\dots C_n$,将X预测为拥有最高后验概率的类。</p>\n<script type=\"math/tex; mode=display\">\nmax(P(C_i|X))=max(\\dfrac{P(X|C_i)P(C_i)}{P(X)})</script></li>\n<li><p>因为$P(X)$是常数，所以只用最大化$P(X|C_i)P(C_i)$ $P(C_i)$用类的频率来估计</p>\n</li>\n<li><p>在类条件独立的假定下有：</p>\n<script type=\"math/tex; mode=display\">\nP(X|C_i)=\\prod_{k=1}^nP(x_k|C_i)=P(x_1|C_i)P(x_2|C_i)\\dots P(x_n|C_i)</script><p>$x_k$表示样本X向量对应的第k个属性$A_k$的值。</p>\n<ol>\n<li><p>如果$A_k$是分类属性，那么$P(x_k|C_i)$是D中属性$A_k$的值为$x_k$的$C_i$类的元组数除以D中$C_i$的数目 </p>\n</li>\n<li><p>如果$A_k$是连续值，则假定连续值服从均值为$\\mu$,标准差为$\\sigma$的高斯分布。</p>\n<script type=\"math/tex; mode=display\">\ng(x,\\mu,\\sigma)=\\dfrac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\dfrac{(x-\\mu)^2}{2\\sigma^2}}</script><p>所以可以得到：</p>\n<script type=\"math/tex; mode=display\">\nP(x_k|C_i)=g(x_k,\\mu_{C_i},\\sigma_{C_i})</script></li>\n</ol>\n</li>\n<li><p>对每一类都分别计算$P(X|C_i)P(C_i)$ 最后选择最大的作为这个样本的分类。</p>\n</li>\n</ol>\n<h4 id=\"零概率值的解决\"><a href=\"#零概率值的解决\" class=\"headerlink\" title=\"零概率值的解决\"></a>零概率值的解决</h4><p>在做连乘的时候如果有一个的概率为0，那么整个计算结果都为0。可以假设训练数据集很大，将每个取值的计数都加1而造成的概率估计可以忽略不计。这样就可以避免出现零概率的情况，称之为<strong>拉普拉斯估计或这拉普拉斯校准法</strong></p>\n<h3 id=\"评价\"><a href=\"#评价\" class=\"headerlink\" title=\"评价\"></a>评价</h3><p>朴素贝叶斯的优势：比较容易实现，在大多数情况可以取得好结果。缺点是：因为做了属性互相独立的假设，因此会降低准确率。而且实际上，大部分属性之间并不互相独立。</p>\n<p>可以使用贝叶斯信念网络来处理。</p>\n<h2 id=\"BP神经网络\"><a href=\"#BP神经网络\" class=\"headerlink\" title=\"BP神经网络\"></a>BP神经网络</h2><h3 id=\"多层前馈神经网络\"><a href=\"#多层前馈神经网络\" class=\"headerlink\" title=\"多层前馈神经网络\"></a>多层前馈神经网络</h3><p>后向传播算法Back propagation在多层前馈神经网络上学习。由输入层、一个或多个隐藏层和一个输出层组成。</p>\n<p><img src=\"C:\\Users\\BraveY\\Documents\\BraveY\\blog\\images\\data mining\\multi_layer_feed_forward_network.jpg\" alt=\"\"></p>\n<p>输入层的单元称作输入单元，隐藏层和输出层单元称作输出单元或者神经节点。输入向量输入进输入单元，然后加权同时地提供给隐藏层的输出单元。在全连接的情况下每一层单元与前后层单元都会有相应的权重，因为权重不会回馈到输入节点，所以称为前馈的。因此一次输入就完成输出。</p>\n<h3 id=\"网络拓扑的定义\"><a href=\"#网络拓扑的定义\" class=\"headerlink\" title=\"网络拓扑的定义\"></a>网络拓扑的定义</h3><p>应该设计多少层隐藏层，每一层有多少单元，输入层单元应该有多少，是否全连接等都是网络拓扑需要考虑的。</p>\n<p>需要先对输入值进行归一化，将值落入[0,1]之间。离散值的属性可以进行重新编码，让每一个域值都有一个输入单元。如果属性A有3个可能的值${a_0, a_1, a_2}$那么就需要设计3个输入单元$I_0, I_1,I_2$，输入单元$I_1$为1对应属性$A=a_1$。</p>\n<p>如果进行分类的话如果只有两类那么输出单元只用一个就可以了，多于2类的情况每一类都有一个输出单元。</p>\n<p>隐藏层单元数目的设计，没有明确的规定，通过反复实验的过程，来确定。一般选择一个隐藏层就可以了，权重的初始值也会影响结果的准确率。</p>\n<h2 id=\"后向传播\"><a href=\"#后向传播\" class=\"headerlink\" title=\"后向传播\"></a>后向传播</h2><h3 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h3><p>后向传播通过迭代地处理训练数据，把每个样本的网络预测值与实际已知的目标值相比较。对每个训练样本，修改网络的权重使得网络预测和实际目标值之间的均方误差最小。修改后向进行，从输出层一直传递到输入层的，因此叫做后向传播。</p>\n<p>算法伪代码为：</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1574086256/blog/Data%20Mining/bp_code.jpg\" alt=\"\"></p>\n<p>步骤为：</p>\n<p><strong>初始化权重：</strong>权重被初始化为小随机数（比如-1到1，或者-0.5到0.5），偏倚bias也初始化为小随机数。</p>\n<p><strong>向前传播输入</strong>：输入单元的输出就是输入值。隐藏层和输出层单元的净输入用上一层输入的线性组合计算。输出单元的输出用激活函数计算，激活函数是logistic或这S型sigmoid函数,激活函数将较大的输入值域映射到区间[0,1]</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1574086256/blog/Data%20Mining/bpnn_io.jpg\" alt=\"\"></p>\n<p>隐藏层或者输出层单元j其输入为如下，其中$w_{ij}$是上层单元i到单元j的权重，$O_i$是上一层单元的输出，$\\theta_j$是单元j的偏倚。偏倚用来充当阈值，改变单元的活性</p>\n<script type=\"math/tex; mode=display\">\nI_j=\\sum_{i}w_{ij}O_i+\\theta_j</script><p>单元j的输出$O_j$为：</p>\n<script type=\"math/tex; mode=display\">\nO_j=\\dfrac{1}{1+e^{I_j}}</script><p><strong>向后传播误差</strong>：通过更新权重和反映网络预测误差的偏倚，向后传播误差。对于输出层单元j，误差如下，其中$O_j$ 是单元j的实际输出， $T_j$ 是j给定训练样本的实际目标值，$O_j(1-O_j)$是逻辑斯提函数的导数。</p>\n<script type=\"math/tex; mode=display\">\nErr_j=O_j(1-O_j)(T_j-O_j)</script><p>隐藏层单元j的误差，考虑下一层中j连接的单元的误差加权和。误差如下：</p>\n<script type=\"math/tex; mode=display\">\nErr_j=O_j(1-O_j)\\sum_kErr_kw_{jk}</script><p>其中$w_{jk}$是下一层单元k与单元j的连接权重，而$Err_k$是单元k的误差。</p>\n<p>更新权重和偏倚，以反映误差的传播。权重更新公式如下，其中$\\Delta w_{ij}$是权重的改变量。</p>\n<script type=\"math/tex; mode=display\">\n\\begin{split}\n\\Delta w_{ij}&=l\\times Err_jO_i\\\\\nw_{ij}&=w_{ij}+\\Delta w_{ij}\n\\end{split}</script><p>变量l是<strong>学习率</strong>，通常去[0,1]之间的常数值。学习率帮助避免陷入决策空间的局部极小，并有助于找到全局最小。学习率太低的话，学习将进行的很慢。学习率太高的话，可能出现在不适当的解之间的摆动。一种调整规则是将学习率设置为迭代次数的倒数。</p>\n<p>偏倚的更新公式为：其中$\\Delta \\theta_{ij}$是偏倚的改变量。</p>\n<script type=\"math/tex; mode=display\">\n\\begin{split}\n\\Delta \\theta_{ij}&=l\\times Err_j\\\\\n\\theta_{ij}&=\\theta_{ij}+\\Delta \\theta_{ij}\n\\end{split}</script><p>更新的策略有实例更新：每处理一个样本就更新权重和偏倚。周期更新为处理玩所有样本后再更新。实例更新通常产生更准确的结果。</p>\n<p><strong>终止条件：</strong></p>\n<ul>\n<li>前一周期所有的$\\Delta w_{ij}$都太小，小于某个阈值</li>\n<li>前一周其误分类的数据百分比小于某个阈值</li>\n<li>超过预先指定的周期数。实践中权重收敛可能需要数十万个周期。</li>\n</ul>\n<p>和决策树一样，神经网络也可以剪枝，去除那些影响很小的连接。</p>\n<h3 id=\"优缺点\"><a href=\"#优缺点\" class=\"headerlink\" title=\"优缺点\"></a>优缺点</h3><p>优点：</p>\n<ul>\n<li>对噪声的高容忍</li>\n<li>对连续值的良好适配</li>\n<li>对真实数据的良好处理</li>\n<li>效果很好</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>很长的训练时间</li>\n<li>要求大量的参数</li>\n<li>解释性很差</li>\n</ul>\n<h2 id=\"其他分类方法\"><a href=\"#其他分类方法\" class=\"headerlink\" title=\"其他分类方法\"></a>其他分类方法</h2><p>包括KNN、集成学习比如（Baggin、Boosting）</p>\n<h2 id=\"预测\"><a href=\"#预测\" class=\"headerlink\" title=\"预测\"></a>预测</h2><p>线性回归模型、多项式回归模型、广义线性模型、对数线性模型（针对分类数据）</p>\n<h2 id=\"准确率和误差的衡量\"><a href=\"#准确率和误差的衡量\" class=\"headerlink\" title=\"准确率和误差的衡量\"></a>准确率和误差的衡量</h2><p>使用混淆矩阵confusion matrix来表示分类的情况。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1574086256/blog/Data%20Mining/confusion_matrix.jpg\" alt=\"\"></p>\n<p>准确率和错误率表示为：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{split}\nAccuracy&=\\dfrac{(true\\_pos+true\\_neg)}{pos+neg}\\\\\nError rate&=1-Accuracy\n\\end{split}</script><p>还有其他几个指标</p>\n<script type=\"math/tex; mode=display\">\n\\begin{split}\nsensitivity&=\\dfrac{true\\_pos}{pos} /* 真阳的识别率*/\\\\\nspecificity&=\\dfrac{true\\_neg}{neg} /* 真阴的识别率*/\\\\\nprecision&=\\dfrac{true\\_pos}{true\\_pos+true\\_neg} /* 预测的精度*/\\\\\n\\end{split}</script><h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>《数据挖掘概念与技术》第3版 第八章分类：基本概念 第九章 分类高级方法</p>"},{"title":"内嵌汇编","date":"2019-10-31T08:39:47.000Z","copyright":true,"_content":"\n# 内嵌汇编\n\n操作系统高级教程上面需要阅读Linux内核0.11的源码，其中在书《Linux内核设计的一书》第2.5节异常处理类中段服务程序挂接的部分，遇到了嵌入在C语言中的汇编代码，之前从来没有学习过汇编，因此记录下。\n\n<!--more-->\n\n\n\n## AT&T基础知识\n\n内嵌汇编使用的是AT&T汇编，所以首先稍微讲解下AT&T的汇编指令的基础知识。\n\n### 操作数前缀\n\n```assembly\nmovl   $8,%eax \nmovl   $0xffff,%ebx \nint     $0x80 \n```\n\n看到在AT%T汇编中诸如\"%eax\"、\"%ebx\"之类的寄存器名字前都要加上\"%\"；\"$8\"、\"$0xffff\"这样的立即数之前都要加上\"$\"。  \n\n### 源/目的操作数顺序 \n\n   在Intel语法中，第一个操作数是目的操作数，第二个操作数源操作数。而在AT&T中，第一个数是源操作数，第二个数是目的操作数。 \n\n```assembly\n// INTEL语法\nMOV EAX,8 //EAX是目的操作数， 8是源操作数\n// AT&T语法\nmovl   $8,%eax //8是源操作数 EAX是目的操作数\n```\n\n### 标识长度的操作码后缀 \n\n在AT&T的操作码后面有时还会有一个后缀，其含义就是指出操作码的大小。“l”表示长整数（32位），“w”表示字（16位），“b”表示字节（8位）。\n\n```assembly\nmovb    %bl,%al\nmovw   %bx,%ax\nmovl     %ebx,%eax\nmovl     (%ebx),%eax\n```\n\n## GCC内嵌汇编\n\nLinux操作系统内核代码绝大部分使用C语言编写，只有一小部分使用汇编语言编写，例如与特定体系结构相关的代码和对性能影响很大的代码。GCC提供了内嵌汇编的功能，可以在C代码中直接内嵌汇编语言语句，大大方便了程序设计。 \n\n### 基本行内汇编\n\n基本行内汇编很容易理解，一般是按照下面的格式：\n\n  ``` asm(“statements”); ```\n\n在“asm”后面有时也会加上“__volatile__”表示编译器不要优化代码，后面的指令保留原样 \n\n ```__asm__  __volatile__(\"hlt\");``` \n\n如果有很多行汇编，则每一行后要加上“\\n\\t” ：\n\n```assembly\n asm( \"pushl %eax\\n\\t\"\n \"movl $0,%eax\\n\\t\"\n\"popl %eax\"); \n```\n\n或者我们也可以分成几行来写，如： \n\n```assembly\nasm(\"movl %eax,%ebx\");\nasm(\"xorl %ebx,%edx\");\nasm(\"movl $0,_booga); \n```\n\n通常使用汇编语句最方便的方式是把它们放在一个宏内，而宏语句需要在一行上定义，因此使用反斜杠`\\`将这些语句连成一行，所以上述语句如果在宏中定义的话就是：\n\n```c\n asm( \"pushl %eax; \\\n movl $0,%eax; \\\npopl %eax\"); \n```\n\n### 扩展的行内汇编\n\n在扩展的行内汇编中，可以将C语言表达式（比如C语言中的变量）指定为汇编指令的操作数，而且不用去管如何将C语言表达式的值读入寄存器，以及如何将计算结果写回C变量，你只要告诉程序中C语言表达式与汇编指令操作数之间的对应关系即可， GCC会自动插入代码完成必要的操作。 \n\n使用内嵌汇编，要先编写汇编指令模板，然后将C语言表达式与指令的操作数相关联，并告诉GCC对这些操作有哪些限制条件。例如下面的内嵌汇编语句： \n\n```c\nint main(){\n\tint input = 8;\n\tint result = 0;\n    __asm__ __violate__  (\"movl %1,%0\" : \"=r\" (result) : \"r\" (input));\n    printf(\"%d\\n\",result);\n    return 0;\n}\n \n```\n\n`“movl %1,%0”`是指令模板；“%0”和“%1”代表指令的操作数，称为占位符，“=r”代表它之后是输入变量且需用到寄存器，指令模板后面用小括号括起来的是C语言表达式 ，其中input是输入变量，该指令会完成把input的值复制到result中的操作 。\n\n### 扩展的行内汇编的语法 \n\n内嵌汇编语法如下：\n\n  ```\n asm(\"汇编语句模块\"\n\n      :输出寄存器 \n\n      :输入寄存器 \n\n      :会被修改的寄存器);\n  ```\n\n即格式为`asm ( \"statements\" : output_regs : input_regs : clobbered_regs) `\n\n汇编语句模块必不可少，其他三部分可选，如果使用了后面的部分，而前面部分为空，也需要用“:”格开，相应部分内容为空。 \n\n#### 汇编语句模块\n\n汇编语句模块由汇编语句序列组成，语句之间使用“;”、“\\n”或“\\n\\t”分开。指令中的操作数可以使用占位符引用C语言变量，**操作数占位符**最多10个，名称如下：%0，%1…，%9。指令中使用占位符表示的操作数，总被视为long型（4，个字节），但对其施加的操作根据指令可以是字或者字节，当把操作数当作字或者字节使用时，默认为低字或者低字节。对字节操作可以显式的指明是低字节还是次字节。方法是在%和序号之间插入一个字母，“b”代表低字节，“h”代表高字节，例如：%h1。 \n\n占位符的理解：将汇编输出寄存器与输入寄存器从输出寄存器行开始左到右从上到下进行编号分别为：%0，%1…，%9。比如有代码：\n\n```assembly\n#define get_seg_byte(seg,addr) \\\n({ \\\nregister char __res; \\\n__asm__(\"push %%fs; \\\nmov %%ax,%%fs; \\\nmovb %%fs:%2,%%al; \\\npop %%fs\" \\\n:\"=a\" (__res) \\\n:\"\" (seg),\"m\" (*(addr))); \\\n__res;})\n```\n\n输出寄存器\"=a\"eax记为%0,输入寄存器\"\"(依然是eax)记为%1,输入寄存器\"m\"为%2。\n\n#### 输出寄存器\n\n描述输出操作数，不同的操作数描述符之间用逗号格开，每个操作数描述符由**限定字符串和C语言变量**组成。每个**输出操作数的限定字符串必须包含“=”**，表示它是一个输出操作数。例如：\n\n```__asm__   __volatile__ (\"pushfl ; popl %0 ; cli\":\"=g\" (x) )```\n\n在这里“x”便是最终存放输出结果的C程序变量，而“=g”则是限定字符串，限定字符串表示了对它之后的变量的限制条件 。\n\n#### 输入寄存器\n\n描述输入操作数，不同的操作数描述符之间使用逗号格开，每个操作数描述符同样也由限定字符串和C语言表达式或者C语言变量组成。例：\n\n```c\n__asm__ volatile__ (\"lidt %0\" : : \"m\" (real_mode_idt));\n```\n\n其中%0是占位操作符，而输出寄存器为空，输入寄存器的值为C语言表达式real_mode_idt。\n\n#### 限定字符串\n\n又叫做寄存器加载代码\n\n| 限定字符      | 描述           | 限定字符 | 描述 |\n| ------------- | -------------- | -------- | ---- |\n| a             | 使用寄存器eax  | m | 使用内存地址 |\n| b      | 使用寄存器ebx | o | 使用内存地址并可以加偏移值 |\n| m、o、V、p    | 使用寄存器ecx | I | 使用常数0~31 立即数 |\n| g、X          | 寄存器或内存   | J | 使用常数0~63 立即数 |\n| I、J、N、i、n | 立即数         | K | 使用常数0~255立即数 |\n| D         | 使用edi | L | 使用常数0~65535 立即数 |\n| q | 使用动态分配字节可寻址寄存器（eax、ebx、ecx或edx） | M | 使用常数0~3  立即数 |\n| r | 使用任意动态分配的寄存器 | N | 使用1字节常数（0~255）立即数 |\n| g | 使用通用有效的地址即可（eax、ebx、ecx、edx或内存变量） | O | 使用常数0~31 立即数 |\n| A | 使用eax与edx联合（64位） | i | 立即数 |\n\n## 例子\n\n直接摘抄自《Linux内核完全注释》第5.2.2 traps.c程序的第82页\n\n- 例子1：\n\n```assembly\n01 #define get_seg_byte(seg,addr) \\\n02 ({ \\\n03 register char __res; \\\n04 __asm__(\"push %%fs; \\\n05 mov %%ax,%%fs; \\\n06 movb %%fs:%2,%%al; \\\n07 pop %%fs\" \\\n08 :\"=a\" (__res) \\\n09 :\"\" (seg),\"m\" (*(addr))); \\\n10 __res;})\n```\n\n 第1 行定义了宏的名称，也即是宏函数名称 `get_seg_byte(seg,addr)` 。第 3 行定义了一个寄存器变量 res 。第 4 行上的 `__asm__ `表示嵌入汇编语句的开始。从第 4 行到第 7 行的 4 条语句是 AT&T 格式的汇编语句。\n\n第 8 行即是输出寄存器，这句的含义是在这段代码运行结束后将 eax 所代表的寄存器的值放入` __res`变量中，作为本函数的输出值， \"=a\" 中的 \"a\" 称为加载代码， \"=\" 表示这是输出寄存器。第 9 行表示在这段代码开始运行时将 seg 放到 eax 寄存器中， \"\" 表示使用与上面同个位置的输出相同的寄存器。而 (*(addr))表示一个内存偏移地址值。为了在上面汇编语句中使用该地址值，嵌入汇编程序规定把输出和输入寄存器统一按顺序编号，顺序是从输出寄存器序列从左到右从上到下以 \"%0\" 开始，分别记为 %0 、 %1 、 …%9 。因此，输出寄存器的编号是 %0 （这里只有一个输出寄存器），输入寄存器前一部分 (\"\" (seg)) 的编号是 %1 ，而后部分的编号是 %2 。上面第 6 行上的 %2 即代表 (*(addr)) 这个内存偏移量。现在我们来研究 4—7 行上的代码的作用。第一句将 fs 段寄存器的内容入栈；第二句将 eax 中的段值赋给 fs 段寄存器；第三句是把 fs:(*(addr)) 所指定的字节放入 al 寄存器中。当执行完汇编语句后，输出寄存器 eax 的值将被放入 `__res` ，作为该宏函数（块结构表达式）的返回值。\n\n通过上面分析，我们知道，宏名称中的 seg 代表一指定的内存段值，而 addr 表示一内存偏移地址量。到现在为止，我们应该很清楚这段程序的功能了吧！该宏函数的功能是从指定段和偏移值的内存地址处取一个字节。\n\n通过上面的例子说明，阅读这段代码时应该像CPU处理指令时的逻辑一样，先从输出输入寄存器语句开始知道输入输出是什么，然后再阅读汇编语句，处理完后再看最后的返回是什么。\n\n- 例子2\n\n再来看下Linux 内核中main()中对中断异常挂接的trap_init()中的设计到的一个GCC内嵌汇编。代码路径为；include\\asm\\system.h\n\n```assembly\n1 #define _set_gate(gate_addr,type,dpl,addr) \\\n2 __asm__ (\"movw %%dx,%%ax\\n\\t\" \\\n3\t\"movw %0,%%dx\\n\\t\" \\\n4\t\"movl %%eax,%1\\n\\t\" \\\n5\t\"movl %%edx,%2\" \\\n6\t: \\\n7\t: \"i\" ((short) (0x8000+(dpl<<13)+(type<<8))), \\\n8\t\"o\" (*((char *) (gate_addr))), \\\n9\t\"o\" (*(4+(char *) (gate_addr))), \\\n10\t\"d\" ((char *) (addr)),\"a\" (0x00080000)) \n```\n\n首先从第6行输出寄存器开始阅读：输出寄存器为空。然后是第7至10行的输入寄存器。第%0个输入寄存器使用“i”表示输入立即数，第%1个输入寄存器使用“o”表示使用内存地址并可以加偏移值，第%2个输入寄存器依然使用“o”代码，第%3个寄存器使用“d”表示使用寄存器edx，第%4个寄存器使用“a”表示使用寄存器eax。\n\n之后再看下汇编语句：依次进行值的传递。\n\n## 参考\n\n《Linux内核设计的艺术》新设计团队 著\n\n《Linux内核完全注释》赵炯 编著","source":"_posts/2019-10-31-内嵌汇编.md","raw":"---\ntitle: 内嵌汇编\ndate: 2019-10-31 16:39:47\ncategories: 编程语言\ntags: \n- 汇编\n- C语言\ncopyright: true\n---\n\n# 内嵌汇编\n\n操作系统高级教程上面需要阅读Linux内核0.11的源码，其中在书《Linux内核设计的一书》第2.5节异常处理类中段服务程序挂接的部分，遇到了嵌入在C语言中的汇编代码，之前从来没有学习过汇编，因此记录下。\n\n<!--more-->\n\n\n\n## AT&T基础知识\n\n内嵌汇编使用的是AT&T汇编，所以首先稍微讲解下AT&T的汇编指令的基础知识。\n\n### 操作数前缀\n\n```assembly\nmovl   $8,%eax \nmovl   $0xffff,%ebx \nint     $0x80 \n```\n\n看到在AT%T汇编中诸如\"%eax\"、\"%ebx\"之类的寄存器名字前都要加上\"%\"；\"$8\"、\"$0xffff\"这样的立即数之前都要加上\"$\"。  \n\n### 源/目的操作数顺序 \n\n   在Intel语法中，第一个操作数是目的操作数，第二个操作数源操作数。而在AT&T中，第一个数是源操作数，第二个数是目的操作数。 \n\n```assembly\n// INTEL语法\nMOV EAX,8 //EAX是目的操作数， 8是源操作数\n// AT&T语法\nmovl   $8,%eax //8是源操作数 EAX是目的操作数\n```\n\n### 标识长度的操作码后缀 \n\n在AT&T的操作码后面有时还会有一个后缀，其含义就是指出操作码的大小。“l”表示长整数（32位），“w”表示字（16位），“b”表示字节（8位）。\n\n```assembly\nmovb    %bl,%al\nmovw   %bx,%ax\nmovl     %ebx,%eax\nmovl     (%ebx),%eax\n```\n\n## GCC内嵌汇编\n\nLinux操作系统内核代码绝大部分使用C语言编写，只有一小部分使用汇编语言编写，例如与特定体系结构相关的代码和对性能影响很大的代码。GCC提供了内嵌汇编的功能，可以在C代码中直接内嵌汇编语言语句，大大方便了程序设计。 \n\n### 基本行内汇编\n\n基本行内汇编很容易理解，一般是按照下面的格式：\n\n  ``` asm(“statements”); ```\n\n在“asm”后面有时也会加上“__volatile__”表示编译器不要优化代码，后面的指令保留原样 \n\n ```__asm__  __volatile__(\"hlt\");``` \n\n如果有很多行汇编，则每一行后要加上“\\n\\t” ：\n\n```assembly\n asm( \"pushl %eax\\n\\t\"\n \"movl $0,%eax\\n\\t\"\n\"popl %eax\"); \n```\n\n或者我们也可以分成几行来写，如： \n\n```assembly\nasm(\"movl %eax,%ebx\");\nasm(\"xorl %ebx,%edx\");\nasm(\"movl $0,_booga); \n```\n\n通常使用汇编语句最方便的方式是把它们放在一个宏内，而宏语句需要在一行上定义，因此使用反斜杠`\\`将这些语句连成一行，所以上述语句如果在宏中定义的话就是：\n\n```c\n asm( \"pushl %eax; \\\n movl $0,%eax; \\\npopl %eax\"); \n```\n\n### 扩展的行内汇编\n\n在扩展的行内汇编中，可以将C语言表达式（比如C语言中的变量）指定为汇编指令的操作数，而且不用去管如何将C语言表达式的值读入寄存器，以及如何将计算结果写回C变量，你只要告诉程序中C语言表达式与汇编指令操作数之间的对应关系即可， GCC会自动插入代码完成必要的操作。 \n\n使用内嵌汇编，要先编写汇编指令模板，然后将C语言表达式与指令的操作数相关联，并告诉GCC对这些操作有哪些限制条件。例如下面的内嵌汇编语句： \n\n```c\nint main(){\n\tint input = 8;\n\tint result = 0;\n    __asm__ __violate__  (\"movl %1,%0\" : \"=r\" (result) : \"r\" (input));\n    printf(\"%d\\n\",result);\n    return 0;\n}\n \n```\n\n`“movl %1,%0”`是指令模板；“%0”和“%1”代表指令的操作数，称为占位符，“=r”代表它之后是输入变量且需用到寄存器，指令模板后面用小括号括起来的是C语言表达式 ，其中input是输入变量，该指令会完成把input的值复制到result中的操作 。\n\n### 扩展的行内汇编的语法 \n\n内嵌汇编语法如下：\n\n  ```\n asm(\"汇编语句模块\"\n\n      :输出寄存器 \n\n      :输入寄存器 \n\n      :会被修改的寄存器);\n  ```\n\n即格式为`asm ( \"statements\" : output_regs : input_regs : clobbered_regs) `\n\n汇编语句模块必不可少，其他三部分可选，如果使用了后面的部分，而前面部分为空，也需要用“:”格开，相应部分内容为空。 \n\n#### 汇编语句模块\n\n汇编语句模块由汇编语句序列组成，语句之间使用“;”、“\\n”或“\\n\\t”分开。指令中的操作数可以使用占位符引用C语言变量，**操作数占位符**最多10个，名称如下：%0，%1…，%9。指令中使用占位符表示的操作数，总被视为long型（4，个字节），但对其施加的操作根据指令可以是字或者字节，当把操作数当作字或者字节使用时，默认为低字或者低字节。对字节操作可以显式的指明是低字节还是次字节。方法是在%和序号之间插入一个字母，“b”代表低字节，“h”代表高字节，例如：%h1。 \n\n占位符的理解：将汇编输出寄存器与输入寄存器从输出寄存器行开始左到右从上到下进行编号分别为：%0，%1…，%9。比如有代码：\n\n```assembly\n#define get_seg_byte(seg,addr) \\\n({ \\\nregister char __res; \\\n__asm__(\"push %%fs; \\\nmov %%ax,%%fs; \\\nmovb %%fs:%2,%%al; \\\npop %%fs\" \\\n:\"=a\" (__res) \\\n:\"\" (seg),\"m\" (*(addr))); \\\n__res;})\n```\n\n输出寄存器\"=a\"eax记为%0,输入寄存器\"\"(依然是eax)记为%1,输入寄存器\"m\"为%2。\n\n#### 输出寄存器\n\n描述输出操作数，不同的操作数描述符之间用逗号格开，每个操作数描述符由**限定字符串和C语言变量**组成。每个**输出操作数的限定字符串必须包含“=”**，表示它是一个输出操作数。例如：\n\n```__asm__   __volatile__ (\"pushfl ; popl %0 ; cli\":\"=g\" (x) )```\n\n在这里“x”便是最终存放输出结果的C程序变量，而“=g”则是限定字符串，限定字符串表示了对它之后的变量的限制条件 。\n\n#### 输入寄存器\n\n描述输入操作数，不同的操作数描述符之间使用逗号格开，每个操作数描述符同样也由限定字符串和C语言表达式或者C语言变量组成。例：\n\n```c\n__asm__ volatile__ (\"lidt %0\" : : \"m\" (real_mode_idt));\n```\n\n其中%0是占位操作符，而输出寄存器为空，输入寄存器的值为C语言表达式real_mode_idt。\n\n#### 限定字符串\n\n又叫做寄存器加载代码\n\n| 限定字符      | 描述           | 限定字符 | 描述 |\n| ------------- | -------------- | -------- | ---- |\n| a             | 使用寄存器eax  | m | 使用内存地址 |\n| b      | 使用寄存器ebx | o | 使用内存地址并可以加偏移值 |\n| m、o、V、p    | 使用寄存器ecx | I | 使用常数0~31 立即数 |\n| g、X          | 寄存器或内存   | J | 使用常数0~63 立即数 |\n| I、J、N、i、n | 立即数         | K | 使用常数0~255立即数 |\n| D         | 使用edi | L | 使用常数0~65535 立即数 |\n| q | 使用动态分配字节可寻址寄存器（eax、ebx、ecx或edx） | M | 使用常数0~3  立即数 |\n| r | 使用任意动态分配的寄存器 | N | 使用1字节常数（0~255）立即数 |\n| g | 使用通用有效的地址即可（eax、ebx、ecx、edx或内存变量） | O | 使用常数0~31 立即数 |\n| A | 使用eax与edx联合（64位） | i | 立即数 |\n\n## 例子\n\n直接摘抄自《Linux内核完全注释》第5.2.2 traps.c程序的第82页\n\n- 例子1：\n\n```assembly\n01 #define get_seg_byte(seg,addr) \\\n02 ({ \\\n03 register char __res; \\\n04 __asm__(\"push %%fs; \\\n05 mov %%ax,%%fs; \\\n06 movb %%fs:%2,%%al; \\\n07 pop %%fs\" \\\n08 :\"=a\" (__res) \\\n09 :\"\" (seg),\"m\" (*(addr))); \\\n10 __res;})\n```\n\n 第1 行定义了宏的名称，也即是宏函数名称 `get_seg_byte(seg,addr)` 。第 3 行定义了一个寄存器变量 res 。第 4 行上的 `__asm__ `表示嵌入汇编语句的开始。从第 4 行到第 7 行的 4 条语句是 AT&T 格式的汇编语句。\n\n第 8 行即是输出寄存器，这句的含义是在这段代码运行结束后将 eax 所代表的寄存器的值放入` __res`变量中，作为本函数的输出值， \"=a\" 中的 \"a\" 称为加载代码， \"=\" 表示这是输出寄存器。第 9 行表示在这段代码开始运行时将 seg 放到 eax 寄存器中， \"\" 表示使用与上面同个位置的输出相同的寄存器。而 (*(addr))表示一个内存偏移地址值。为了在上面汇编语句中使用该地址值，嵌入汇编程序规定把输出和输入寄存器统一按顺序编号，顺序是从输出寄存器序列从左到右从上到下以 \"%0\" 开始，分别记为 %0 、 %1 、 …%9 。因此，输出寄存器的编号是 %0 （这里只有一个输出寄存器），输入寄存器前一部分 (\"\" (seg)) 的编号是 %1 ，而后部分的编号是 %2 。上面第 6 行上的 %2 即代表 (*(addr)) 这个内存偏移量。现在我们来研究 4—7 行上的代码的作用。第一句将 fs 段寄存器的内容入栈；第二句将 eax 中的段值赋给 fs 段寄存器；第三句是把 fs:(*(addr)) 所指定的字节放入 al 寄存器中。当执行完汇编语句后，输出寄存器 eax 的值将被放入 `__res` ，作为该宏函数（块结构表达式）的返回值。\n\n通过上面分析，我们知道，宏名称中的 seg 代表一指定的内存段值，而 addr 表示一内存偏移地址量。到现在为止，我们应该很清楚这段程序的功能了吧！该宏函数的功能是从指定段和偏移值的内存地址处取一个字节。\n\n通过上面的例子说明，阅读这段代码时应该像CPU处理指令时的逻辑一样，先从输出输入寄存器语句开始知道输入输出是什么，然后再阅读汇编语句，处理完后再看最后的返回是什么。\n\n- 例子2\n\n再来看下Linux 内核中main()中对中断异常挂接的trap_init()中的设计到的一个GCC内嵌汇编。代码路径为；include\\asm\\system.h\n\n```assembly\n1 #define _set_gate(gate_addr,type,dpl,addr) \\\n2 __asm__ (\"movw %%dx,%%ax\\n\\t\" \\\n3\t\"movw %0,%%dx\\n\\t\" \\\n4\t\"movl %%eax,%1\\n\\t\" \\\n5\t\"movl %%edx,%2\" \\\n6\t: \\\n7\t: \"i\" ((short) (0x8000+(dpl<<13)+(type<<8))), \\\n8\t\"o\" (*((char *) (gate_addr))), \\\n9\t\"o\" (*(4+(char *) (gate_addr))), \\\n10\t\"d\" ((char *) (addr)),\"a\" (0x00080000)) \n```\n\n首先从第6行输出寄存器开始阅读：输出寄存器为空。然后是第7至10行的输入寄存器。第%0个输入寄存器使用“i”表示输入立即数，第%1个输入寄存器使用“o”表示使用内存地址并可以加偏移值，第%2个输入寄存器依然使用“o”代码，第%3个寄存器使用“d”表示使用寄存器edx，第%4个寄存器使用“a”表示使用寄存器eax。\n\n之后再看下汇编语句：依次进行值的传递。\n\n## 参考\n\n《Linux内核设计的艺术》新设计团队 著\n\n《Linux内核完全注释》赵炯 编著","slug":"2019-10-31-内嵌汇编","published":1,"updated":"2019-12-19T15:38:48.527Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6he13z0001tdstz6js1m9i1","content":"<h1 id=\"内嵌汇编\"><a href=\"#内嵌汇编\" class=\"headerlink\" title=\"内嵌汇编\"></a>内嵌汇编</h1><p>操作系统高级教程上面需要阅读Linux内核0.11的源码，其中在书《Linux内核设计的一书》第2.5节异常处理类中段服务程序挂接的部分，遇到了嵌入在C语言中的汇编代码，之前从来没有学习过汇编，因此记录下。</p>\n<a id=\"more\"></a>\n<h2 id=\"AT-amp-T基础知识\"><a href=\"#AT-amp-T基础知识\" class=\"headerlink\" title=\"AT&amp;T基础知识\"></a>AT&amp;T基础知识</h2><p>内嵌汇编使用的是AT&amp;T汇编，所以首先稍微讲解下AT&amp;T的汇编指令的基础知识。</p>\n<h3 id=\"操作数前缀\"><a href=\"#操作数前缀\" class=\"headerlink\" title=\"操作数前缀\"></a>操作数前缀</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">movl   $8,%eax </span><br><span class=\"line\">movl   $0xffff,%ebx </span><br><span class=\"line\">int     $0x80</span><br></pre></td></tr></table></figure>\n<p>看到在AT%T汇编中诸如”%eax”、”%ebx”之类的寄存器名字前都要加上”%”；”$8”、”$0xffff”这样的立即数之前都要加上”$”。  </p>\n<h3 id=\"源-目的操作数顺序\"><a href=\"#源-目的操作数顺序\" class=\"headerlink\" title=\"源/目的操作数顺序\"></a>源/目的操作数顺序</h3><p>   在Intel语法中，第一个操作数是目的操作数，第二个操作数源操作数。而在AT&amp;T中，第一个数是源操作数，第二个数是目的操作数。 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// INTEL语法</span><br><span class=\"line\">MOV EAX,8 //EAX是目的操作数， 8是源操作数</span><br><span class=\"line\">// AT&amp;T语法</span><br><span class=\"line\">movl   $8,%eax //8是源操作数 EAX是目的操作数</span><br></pre></td></tr></table></figure>\n<h3 id=\"标识长度的操作码后缀\"><a href=\"#标识长度的操作码后缀\" class=\"headerlink\" title=\"标识长度的操作码后缀\"></a>标识长度的操作码后缀</h3><p>在AT&amp;T的操作码后面有时还会有一个后缀，其含义就是指出操作码的大小。“l”表示长整数（32位），“w”表示字（16位），“b”表示字节（8位）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">movb    %bl,%al</span><br><span class=\"line\">movw   %bx,%ax</span><br><span class=\"line\">movl     %ebx,%eax</span><br><span class=\"line\">movl     (%ebx),%eax</span><br></pre></td></tr></table></figure>\n<h2 id=\"GCC内嵌汇编\"><a href=\"#GCC内嵌汇编\" class=\"headerlink\" title=\"GCC内嵌汇编\"></a>GCC内嵌汇编</h2><p>Linux操作系统内核代码绝大部分使用C语言编写，只有一小部分使用汇编语言编写，例如与特定体系结构相关的代码和对性能影响很大的代码。GCC提供了内嵌汇编的功能，可以在C代码中直接内嵌汇编语言语句，大大方便了程序设计。 </p>\n<h3 id=\"基本行内汇编\"><a href=\"#基本行内汇编\" class=\"headerlink\" title=\"基本行内汇编\"></a>基本行内汇编</h3><p>基本行内汇编很容易理解，一般是按照下面的格式：</p>\n  <figure class=\"highlight plain\"><figcaption><span>```</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">在“asm”后面有时也会加上“__volatile__”表示编译器不要优化代码，后面的指令保留原样 </span><br><span class=\"line\"></span><br><span class=\"line\"> ```__asm__  __volatile__(&quot;hlt&quot;);``` </span><br><span class=\"line\"></span><br><span class=\"line\">如果有很多行汇编，则每一行后要加上“\\n\\t” ：</span><br><span class=\"line\"></span><br><span class=\"line\">```assembly</span><br><span class=\"line\"> asm( &quot;pushl %eax\\n\\t&quot;</span><br><span class=\"line\"> &quot;movl $0,%eax\\n\\t&quot;</span><br><span class=\"line\">&quot;popl %eax&quot;);</span><br></pre></td></tr></table></figure>\n<p>或者我们也可以分成几行来写，如： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">asm(&quot;movl %eax,%ebx&quot;);</span><br><span class=\"line\">asm(&quot;xorl %ebx,%edx&quot;);</span><br><span class=\"line\">asm(&quot;movl $0,_booga);</span><br></pre></td></tr></table></figure>\n<p>通常使用汇编语句最方便的方式是把它们放在一个宏内，而宏语句需要在一行上定义，因此使用反斜杠<code>\\</code>将这些语句连成一行，所以上述语句如果在宏中定义的话就是：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">asm</span>( <span class=\"string\">\"pushl %eax; \\</span></span><br><span class=\"line\"><span class=\"string\"> movl $0,%eax; \\</span></span><br><span class=\"line\"><span class=\"string\">popl %eax\"</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"扩展的行内汇编\"><a href=\"#扩展的行内汇编\" class=\"headerlink\" title=\"扩展的行内汇编\"></a>扩展的行内汇编</h3><p>在扩展的行内汇编中，可以将C语言表达式（比如C语言中的变量）指定为汇编指令的操作数，而且不用去管如何将C语言表达式的值读入寄存器，以及如何将计算结果写回C变量，你只要告诉程序中C语言表达式与汇编指令操作数之间的对应关系即可， GCC会自动插入代码完成必要的操作。 </p>\n<p>使用内嵌汇编，要先编写汇编指令模板，然后将C语言表达式与指令的操作数相关联，并告诉GCC对这些操作有哪些限制条件。例如下面的内嵌汇编语句： </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> input = <span class=\"number\">8</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">    __asm__ __violate__  (<span class=\"string\">\"movl %1,%0\"</span> : <span class=\"string\">\"=r\"</span> (result) : <span class=\"string\">\"r\"</span> (input));</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,result);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>“movl %1,%0”</code>是指令模板；“%0”和“%1”代表指令的操作数，称为占位符，“=r”代表它之后是输入变量且需用到寄存器，指令模板后面用小括号括起来的是C语言表达式 ，其中input是输入变量，该指令会完成把input的值复制到result中的操作 。</p>\n<h3 id=\"扩展的行内汇编的语法\"><a href=\"#扩展的行内汇编的语法\" class=\"headerlink\" title=\"扩展的行内汇编的语法\"></a>扩展的行内汇编的语法</h3><p>内嵌汇编语法如下：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">asm(&quot;汇编语句模块&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">     :输出寄存器 </span><br><span class=\"line\"></span><br><span class=\"line\">     :输入寄存器 </span><br><span class=\"line\"></span><br><span class=\"line\">     :会被修改的寄存器);</span><br></pre></td></tr></table></figure>\n<p>即格式为<code>asm ( &quot;statements&quot; : output_regs : input_regs : clobbered_regs)</code></p>\n<p>汇编语句模块必不可少，其他三部分可选，如果使用了后面的部分，而前面部分为空，也需要用“:”格开，相应部分内容为空。 </p>\n<h4 id=\"汇编语句模块\"><a href=\"#汇编语句模块\" class=\"headerlink\" title=\"汇编语句模块\"></a>汇编语句模块</h4><p>汇编语句模块由汇编语句序列组成，语句之间使用“;”、“\\n”或“\\n\\t”分开。指令中的操作数可以使用占位符引用C语言变量，<strong>操作数占位符</strong>最多10个，名称如下：%0，%1…，%9。指令中使用占位符表示的操作数，总被视为long型（4，个字节），但对其施加的操作根据指令可以是字或者字节，当把操作数当作字或者字节使用时，默认为低字或者低字节。对字节操作可以显式的指明是低字节还是次字节。方法是在%和序号之间插入一个字母，“b”代表低字节，“h”代表高字节，例如：%h1。 </p>\n<p>占位符的理解：将汇编输出寄存器与输入寄存器从输出寄存器行开始左到右从上到下进行编号分别为：%0，%1…，%9。比如有代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define get_seg_byte(seg,addr) \\</span><br><span class=\"line\">(&#123; \\</span><br><span class=\"line\">register char __res; \\</span><br><span class=\"line\">__asm__(&quot;push %%fs; \\</span><br><span class=\"line\">mov %%ax,%%fs; \\</span><br><span class=\"line\">movb %%fs:%2,%%al; \\</span><br><span class=\"line\">pop %%fs&quot; \\</span><br><span class=\"line\">:&quot;=a&quot; (__res) \\</span><br><span class=\"line\">:&quot;&quot; (seg),&quot;m&quot; (*(addr))); \\</span><br><span class=\"line\">__res;&#125;)</span><br></pre></td></tr></table></figure>\n<p>输出寄存器”=a”eax记为%0,输入寄存器””(依然是eax)记为%1,输入寄存器”m”为%2。</p>\n<h4 id=\"输出寄存器\"><a href=\"#输出寄存器\" class=\"headerlink\" title=\"输出寄存器\"></a>输出寄存器</h4><p>描述输出操作数，不同的操作数描述符之间用逗号格开，每个操作数描述符由<strong>限定字符串和C语言变量</strong>组成。每个<strong>输出操作数的限定字符串必须包含“=”</strong>，表示它是一个输出操作数。例如：</p>\n<figure class=\"highlight plain\"><figcaption><span>__volatile__ (\"pushfl ; popl %0 ; cli\":\"</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">在这里“x”便是最终存放输出结果的C程序变量，而“=g”则是限定字符串，限定字符串表示了对它之后的变量的限制条件 。</span><br><span class=\"line\"></span><br><span class=\"line\">#### 输入寄存器</span><br><span class=\"line\"></span><br><span class=\"line\">描述输入操作数，不同的操作数描述符之间使用逗号格开，每个操作数描述符同样也由限定字符串和C语言表达式或者C语言变量组成。例：</span><br><span class=\"line\"></span><br><span class=\"line\">```c</span><br><span class=\"line\">__asm__ volatile__ (&quot;lidt %0&quot; : : &quot;m&quot; (real_mode_idt));</span><br></pre></td></tr></table></figure>\n<p>其中%0是占位操作符，而输出寄存器为空，输入寄存器的值为C语言表达式real_mode_idt。</p>\n<h4 id=\"限定字符串\"><a href=\"#限定字符串\" class=\"headerlink\" title=\"限定字符串\"></a>限定字符串</h4><p>又叫做寄存器加载代码</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>限定字符</th>\n<th>描述</th>\n<th>限定字符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a</td>\n<td>使用寄存器eax</td>\n<td>m</td>\n<td>使用内存地址</td>\n</tr>\n<tr>\n<td>b</td>\n<td>使用寄存器ebx</td>\n<td>o</td>\n<td>使用内存地址并可以加偏移值</td>\n</tr>\n<tr>\n<td>m、o、V、p</td>\n<td>使用寄存器ecx</td>\n<td>I</td>\n<td>使用常数0~31 立即数</td>\n</tr>\n<tr>\n<td>g、X</td>\n<td>寄存器或内存</td>\n<td>J</td>\n<td>使用常数0~63 立即数</td>\n</tr>\n<tr>\n<td>I、J、N、i、n</td>\n<td>立即数</td>\n<td>K</td>\n<td>使用常数0~255立即数</td>\n</tr>\n<tr>\n<td>D</td>\n<td>使用edi</td>\n<td>L</td>\n<td>使用常数0~65535 立即数</td>\n</tr>\n<tr>\n<td>q</td>\n<td>使用动态分配字节可寻址寄存器（eax、ebx、ecx或edx）</td>\n<td>M</td>\n<td>使用常数0~3  立即数</td>\n</tr>\n<tr>\n<td>r</td>\n<td>使用任意动态分配的寄存器</td>\n<td>N</td>\n<td>使用1字节常数（0~255）立即数</td>\n</tr>\n<tr>\n<td>g</td>\n<td>使用通用有效的地址即可（eax、ebx、ecx、edx或内存变量）</td>\n<td>O</td>\n<td>使用常数0~31 立即数</td>\n</tr>\n<tr>\n<td>A</td>\n<td>使用eax与edx联合（64位）</td>\n<td>i</td>\n<td>立即数</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>直接摘抄自《Linux内核完全注释》第5.2.2 traps.c程序的第82页</p>\n<ul>\n<li>例子1：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">01 #define get_seg_byte(seg,addr) \\</span><br><span class=\"line\">02 (&#123; \\</span><br><span class=\"line\">03 register char __res; \\</span><br><span class=\"line\">04 __asm__(&quot;push %%fs; \\</span><br><span class=\"line\">05 mov %%ax,%%fs; \\</span><br><span class=\"line\">06 movb %%fs:%2,%%al; \\</span><br><span class=\"line\">07 pop %%fs&quot; \\</span><br><span class=\"line\">08 :&quot;=a&quot; (__res) \\</span><br><span class=\"line\">09 :&quot;&quot; (seg),&quot;m&quot; (*(addr))); \\</span><br><span class=\"line\">10 __res;&#125;)</span><br></pre></td></tr></table></figure>\n<p> 第1 行定义了宏的名称，也即是宏函数名称 <code>get_seg_byte(seg,addr)</code> 。第 3 行定义了一个寄存器变量 res 。第 4 行上的 <code>__asm__</code>表示嵌入汇编语句的开始。从第 4 行到第 7 行的 4 条语句是 AT&amp;T 格式的汇编语句。</p>\n<p>第 8 行即是输出寄存器，这句的含义是在这段代码运行结束后将 eax 所代表的寄存器的值放入<code>__res</code>变量中，作为本函数的输出值， “=a” 中的 “a” 称为加载代码， “=” 表示这是输出寄存器。第 9 行表示在这段代码开始运行时将 seg 放到 eax 寄存器中， “” 表示使用与上面同个位置的输出相同的寄存器。而 (<em>(addr))表示一个内存偏移地址值。为了在上面汇编语句中使用该地址值，嵌入汇编程序规定把输出和输入寄存器统一按顺序编号，顺序是从输出寄存器序列从左到右从上到下以 “%0” 开始，分别记为 %0 、 %1 、 …%9 。因此，输出寄存器的编号是 %0 （这里只有一个输出寄存器），输入寄存器前一部分 (“” (seg)) 的编号是 %1 ，而后部分的编号是 %2 。上面第 6 行上的 %2 即代表 (</em>(addr)) 这个内存偏移量。现在我们来研究 4—7 行上的代码的作用。第一句将 fs 段寄存器的内容入栈；第二句将 eax 中的段值赋给 fs 段寄存器；第三句是把 fs:(*(addr)) 所指定的字节放入 al 寄存器中。当执行完汇编语句后，输出寄存器 eax 的值将被放入 <code>__res</code> ，作为该宏函数（块结构表达式）的返回值。</p>\n<p>通过上面分析，我们知道，宏名称中的 seg 代表一指定的内存段值，而 addr 表示一内存偏移地址量。到现在为止，我们应该很清楚这段程序的功能了吧！该宏函数的功能是从指定段和偏移值的内存地址处取一个字节。</p>\n<p>通过上面的例子说明，阅读这段代码时应该像CPU处理指令时的逻辑一样，先从输出输入寄存器语句开始知道输入输出是什么，然后再阅读汇编语句，处理完后再看最后的返回是什么。</p>\n<ul>\n<li>例子2</li>\n</ul>\n<p>再来看下Linux 内核中main()中对中断异常挂接的trap_init()中的设计到的一个GCC内嵌汇编。代码路径为；include\\asm\\system.h</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 #define _set_gate(gate_addr,type,dpl,addr) \\</span><br><span class=\"line\">2 __asm__ (&quot;movw %%dx,%%ax\\n\\t&quot; \\</span><br><span class=\"line\">3\t&quot;movw %0,%%dx\\n\\t&quot; \\</span><br><span class=\"line\">4\t&quot;movl %%eax,%1\\n\\t&quot; \\</span><br><span class=\"line\">5\t&quot;movl %%edx,%2&quot; \\</span><br><span class=\"line\">6\t: \\</span><br><span class=\"line\">7\t: &quot;i&quot; ((short) (0x8000+(dpl&lt;&lt;13)+(type&lt;&lt;8))), \\</span><br><span class=\"line\">8\t&quot;o&quot; (*((char *) (gate_addr))), \\</span><br><span class=\"line\">9\t&quot;o&quot; (*(4+(char *) (gate_addr))), \\</span><br><span class=\"line\">10\t&quot;d&quot; ((char *) (addr)),&quot;a&quot; (0x00080000))</span><br></pre></td></tr></table></figure>\n<p>首先从第6行输出寄存器开始阅读：输出寄存器为空。然后是第7至10行的输入寄存器。第%0个输入寄存器使用“i”表示输入立即数，第%1个输入寄存器使用“o”表示使用内存地址并可以加偏移值，第%2个输入寄存器依然使用“o”代码，第%3个寄存器使用“d”表示使用寄存器edx，第%4个寄存器使用“a”表示使用寄存器eax。</p>\n<p>之后再看下汇编语句：依次进行值的传递。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>《Linux内核设计的艺术》新设计团队 著</p>\n<p>《Linux内核完全注释》赵炯 编著</p>\n","site":{"data":{}},"length":4810,"excerpt":"<h1 id=\"内嵌汇编\"><a href=\"#内嵌汇编\" class=\"headerlink\" title=\"内嵌汇编\"></a>内嵌汇编</h1><p>操作系统高级教程上面需要阅读Linux内核0.11的源码，其中在书《Linux内核设计的一书》第2.5节异常处理类中段服务程序挂接的部分，遇到了嵌入在C语言中的汇编代码，之前从来没有学习过汇编，因此记录下。</p>","more":"<h2 id=\"AT-amp-T基础知识\"><a href=\"#AT-amp-T基础知识\" class=\"headerlink\" title=\"AT&amp;T基础知识\"></a>AT&amp;T基础知识</h2><p>内嵌汇编使用的是AT&amp;T汇编，所以首先稍微讲解下AT&amp;T的汇编指令的基础知识。</p>\n<h3 id=\"操作数前缀\"><a href=\"#操作数前缀\" class=\"headerlink\" title=\"操作数前缀\"></a>操作数前缀</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">movl   $8,%eax </span><br><span class=\"line\">movl   $0xffff,%ebx </span><br><span class=\"line\">int     $0x80</span><br></pre></td></tr></table></figure>\n<p>看到在AT%T汇编中诸如”%eax”、”%ebx”之类的寄存器名字前都要加上”%”；”$8”、”$0xffff”这样的立即数之前都要加上”$”。  </p>\n<h3 id=\"源-目的操作数顺序\"><a href=\"#源-目的操作数顺序\" class=\"headerlink\" title=\"源/目的操作数顺序\"></a>源/目的操作数顺序</h3><p>   在Intel语法中，第一个操作数是目的操作数，第二个操作数源操作数。而在AT&amp;T中，第一个数是源操作数，第二个数是目的操作数。 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// INTEL语法</span><br><span class=\"line\">MOV EAX,8 //EAX是目的操作数， 8是源操作数</span><br><span class=\"line\">// AT&amp;T语法</span><br><span class=\"line\">movl   $8,%eax //8是源操作数 EAX是目的操作数</span><br></pre></td></tr></table></figure>\n<h3 id=\"标识长度的操作码后缀\"><a href=\"#标识长度的操作码后缀\" class=\"headerlink\" title=\"标识长度的操作码后缀\"></a>标识长度的操作码后缀</h3><p>在AT&amp;T的操作码后面有时还会有一个后缀，其含义就是指出操作码的大小。“l”表示长整数（32位），“w”表示字（16位），“b”表示字节（8位）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">movb    %bl,%al</span><br><span class=\"line\">movw   %bx,%ax</span><br><span class=\"line\">movl     %ebx,%eax</span><br><span class=\"line\">movl     (%ebx),%eax</span><br></pre></td></tr></table></figure>\n<h2 id=\"GCC内嵌汇编\"><a href=\"#GCC内嵌汇编\" class=\"headerlink\" title=\"GCC内嵌汇编\"></a>GCC内嵌汇编</h2><p>Linux操作系统内核代码绝大部分使用C语言编写，只有一小部分使用汇编语言编写，例如与特定体系结构相关的代码和对性能影响很大的代码。GCC提供了内嵌汇编的功能，可以在C代码中直接内嵌汇编语言语句，大大方便了程序设计。 </p>\n<h3 id=\"基本行内汇编\"><a href=\"#基本行内汇编\" class=\"headerlink\" title=\"基本行内汇编\"></a>基本行内汇编</h3><p>基本行内汇编很容易理解，一般是按照下面的格式：</p>\n  <figure class=\"highlight plain\"><figcaption><span>```</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">在“asm”后面有时也会加上“__volatile__”表示编译器不要优化代码，后面的指令保留原样 </span><br><span class=\"line\"></span><br><span class=\"line\"> ```__asm__  __volatile__(&quot;hlt&quot;);``` </span><br><span class=\"line\"></span><br><span class=\"line\">如果有很多行汇编，则每一行后要加上“\\n\\t” ：</span><br><span class=\"line\"></span><br><span class=\"line\">```assembly</span><br><span class=\"line\"> asm( &quot;pushl %eax\\n\\t&quot;</span><br><span class=\"line\"> &quot;movl $0,%eax\\n\\t&quot;</span><br><span class=\"line\">&quot;popl %eax&quot;);</span><br></pre></td></tr></table></figure>\n<p>或者我们也可以分成几行来写，如： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">asm(&quot;movl %eax,%ebx&quot;);</span><br><span class=\"line\">asm(&quot;xorl %ebx,%edx&quot;);</span><br><span class=\"line\">asm(&quot;movl $0,_booga);</span><br></pre></td></tr></table></figure>\n<p>通常使用汇编语句最方便的方式是把它们放在一个宏内，而宏语句需要在一行上定义，因此使用反斜杠<code>\\</code>将这些语句连成一行，所以上述语句如果在宏中定义的话就是：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">asm</span>( <span class=\"string\">\"pushl %eax; \\</span></span><br><span class=\"line\"><span class=\"string\"> movl $0,%eax; \\</span></span><br><span class=\"line\"><span class=\"string\">popl %eax\"</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"扩展的行内汇编\"><a href=\"#扩展的行内汇编\" class=\"headerlink\" title=\"扩展的行内汇编\"></a>扩展的行内汇编</h3><p>在扩展的行内汇编中，可以将C语言表达式（比如C语言中的变量）指定为汇编指令的操作数，而且不用去管如何将C语言表达式的值读入寄存器，以及如何将计算结果写回C变量，你只要告诉程序中C语言表达式与汇编指令操作数之间的对应关系即可， GCC会自动插入代码完成必要的操作。 </p>\n<p>使用内嵌汇编，要先编写汇编指令模板，然后将C语言表达式与指令的操作数相关联，并告诉GCC对这些操作有哪些限制条件。例如下面的内嵌汇编语句： </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> input = <span class=\"number\">8</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">    __asm__ __violate__  (<span class=\"string\">\"movl %1,%0\"</span> : <span class=\"string\">\"=r\"</span> (result) : <span class=\"string\">\"r\"</span> (input));</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,result);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>“movl %1,%0”</code>是指令模板；“%0”和“%1”代表指令的操作数，称为占位符，“=r”代表它之后是输入变量且需用到寄存器，指令模板后面用小括号括起来的是C语言表达式 ，其中input是输入变量，该指令会完成把input的值复制到result中的操作 。</p>\n<h3 id=\"扩展的行内汇编的语法\"><a href=\"#扩展的行内汇编的语法\" class=\"headerlink\" title=\"扩展的行内汇编的语法\"></a>扩展的行内汇编的语法</h3><p>内嵌汇编语法如下：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">asm(&quot;汇编语句模块&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">     :输出寄存器 </span><br><span class=\"line\"></span><br><span class=\"line\">     :输入寄存器 </span><br><span class=\"line\"></span><br><span class=\"line\">     :会被修改的寄存器);</span><br></pre></td></tr></table></figure>\n<p>即格式为<code>asm ( &quot;statements&quot; : output_regs : input_regs : clobbered_regs)</code></p>\n<p>汇编语句模块必不可少，其他三部分可选，如果使用了后面的部分，而前面部分为空，也需要用“:”格开，相应部分内容为空。 </p>\n<h4 id=\"汇编语句模块\"><a href=\"#汇编语句模块\" class=\"headerlink\" title=\"汇编语句模块\"></a>汇编语句模块</h4><p>汇编语句模块由汇编语句序列组成，语句之间使用“;”、“\\n”或“\\n\\t”分开。指令中的操作数可以使用占位符引用C语言变量，<strong>操作数占位符</strong>最多10个，名称如下：%0，%1…，%9。指令中使用占位符表示的操作数，总被视为long型（4，个字节），但对其施加的操作根据指令可以是字或者字节，当把操作数当作字或者字节使用时，默认为低字或者低字节。对字节操作可以显式的指明是低字节还是次字节。方法是在%和序号之间插入一个字母，“b”代表低字节，“h”代表高字节，例如：%h1。 </p>\n<p>占位符的理解：将汇编输出寄存器与输入寄存器从输出寄存器行开始左到右从上到下进行编号分别为：%0，%1…，%9。比如有代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define get_seg_byte(seg,addr) \\</span><br><span class=\"line\">(&#123; \\</span><br><span class=\"line\">register char __res; \\</span><br><span class=\"line\">__asm__(&quot;push %%fs; \\</span><br><span class=\"line\">mov %%ax,%%fs; \\</span><br><span class=\"line\">movb %%fs:%2,%%al; \\</span><br><span class=\"line\">pop %%fs&quot; \\</span><br><span class=\"line\">:&quot;=a&quot; (__res) \\</span><br><span class=\"line\">:&quot;&quot; (seg),&quot;m&quot; (*(addr))); \\</span><br><span class=\"line\">__res;&#125;)</span><br></pre></td></tr></table></figure>\n<p>输出寄存器”=a”eax记为%0,输入寄存器””(依然是eax)记为%1,输入寄存器”m”为%2。</p>\n<h4 id=\"输出寄存器\"><a href=\"#输出寄存器\" class=\"headerlink\" title=\"输出寄存器\"></a>输出寄存器</h4><p>描述输出操作数，不同的操作数描述符之间用逗号格开，每个操作数描述符由<strong>限定字符串和C语言变量</strong>组成。每个<strong>输出操作数的限定字符串必须包含“=”</strong>，表示它是一个输出操作数。例如：</p>\n<figure class=\"highlight plain\"><figcaption><span>__volatile__ (\"pushfl ; popl %0 ; cli\":\"</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">在这里“x”便是最终存放输出结果的C程序变量，而“=g”则是限定字符串，限定字符串表示了对它之后的变量的限制条件 。</span><br><span class=\"line\"></span><br><span class=\"line\">#### 输入寄存器</span><br><span class=\"line\"></span><br><span class=\"line\">描述输入操作数，不同的操作数描述符之间使用逗号格开，每个操作数描述符同样也由限定字符串和C语言表达式或者C语言变量组成。例：</span><br><span class=\"line\"></span><br><span class=\"line\">```c</span><br><span class=\"line\">__asm__ volatile__ (&quot;lidt %0&quot; : : &quot;m&quot; (real_mode_idt));</span><br></pre></td></tr></table></figure>\n<p>其中%0是占位操作符，而输出寄存器为空，输入寄存器的值为C语言表达式real_mode_idt。</p>\n<h4 id=\"限定字符串\"><a href=\"#限定字符串\" class=\"headerlink\" title=\"限定字符串\"></a>限定字符串</h4><p>又叫做寄存器加载代码</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>限定字符</th>\n<th>描述</th>\n<th>限定字符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a</td>\n<td>使用寄存器eax</td>\n<td>m</td>\n<td>使用内存地址</td>\n</tr>\n<tr>\n<td>b</td>\n<td>使用寄存器ebx</td>\n<td>o</td>\n<td>使用内存地址并可以加偏移值</td>\n</tr>\n<tr>\n<td>m、o、V、p</td>\n<td>使用寄存器ecx</td>\n<td>I</td>\n<td>使用常数0~31 立即数</td>\n</tr>\n<tr>\n<td>g、X</td>\n<td>寄存器或内存</td>\n<td>J</td>\n<td>使用常数0~63 立即数</td>\n</tr>\n<tr>\n<td>I、J、N、i、n</td>\n<td>立即数</td>\n<td>K</td>\n<td>使用常数0~255立即数</td>\n</tr>\n<tr>\n<td>D</td>\n<td>使用edi</td>\n<td>L</td>\n<td>使用常数0~65535 立即数</td>\n</tr>\n<tr>\n<td>q</td>\n<td>使用动态分配字节可寻址寄存器（eax、ebx、ecx或edx）</td>\n<td>M</td>\n<td>使用常数0~3  立即数</td>\n</tr>\n<tr>\n<td>r</td>\n<td>使用任意动态分配的寄存器</td>\n<td>N</td>\n<td>使用1字节常数（0~255）立即数</td>\n</tr>\n<tr>\n<td>g</td>\n<td>使用通用有效的地址即可（eax、ebx、ecx、edx或内存变量）</td>\n<td>O</td>\n<td>使用常数0~31 立即数</td>\n</tr>\n<tr>\n<td>A</td>\n<td>使用eax与edx联合（64位）</td>\n<td>i</td>\n<td>立即数</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>直接摘抄自《Linux内核完全注释》第5.2.2 traps.c程序的第82页</p>\n<ul>\n<li>例子1：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">01 #define get_seg_byte(seg,addr) \\</span><br><span class=\"line\">02 (&#123; \\</span><br><span class=\"line\">03 register char __res; \\</span><br><span class=\"line\">04 __asm__(&quot;push %%fs; \\</span><br><span class=\"line\">05 mov %%ax,%%fs; \\</span><br><span class=\"line\">06 movb %%fs:%2,%%al; \\</span><br><span class=\"line\">07 pop %%fs&quot; \\</span><br><span class=\"line\">08 :&quot;=a&quot; (__res) \\</span><br><span class=\"line\">09 :&quot;&quot; (seg),&quot;m&quot; (*(addr))); \\</span><br><span class=\"line\">10 __res;&#125;)</span><br></pre></td></tr></table></figure>\n<p> 第1 行定义了宏的名称，也即是宏函数名称 <code>get_seg_byte(seg,addr)</code> 。第 3 行定义了一个寄存器变量 res 。第 4 行上的 <code>__asm__</code>表示嵌入汇编语句的开始。从第 4 行到第 7 行的 4 条语句是 AT&amp;T 格式的汇编语句。</p>\n<p>第 8 行即是输出寄存器，这句的含义是在这段代码运行结束后将 eax 所代表的寄存器的值放入<code>__res</code>变量中，作为本函数的输出值， “=a” 中的 “a” 称为加载代码， “=” 表示这是输出寄存器。第 9 行表示在这段代码开始运行时将 seg 放到 eax 寄存器中， “” 表示使用与上面同个位置的输出相同的寄存器。而 (<em>(addr))表示一个内存偏移地址值。为了在上面汇编语句中使用该地址值，嵌入汇编程序规定把输出和输入寄存器统一按顺序编号，顺序是从输出寄存器序列从左到右从上到下以 “%0” 开始，分别记为 %0 、 %1 、 …%9 。因此，输出寄存器的编号是 %0 （这里只有一个输出寄存器），输入寄存器前一部分 (“” (seg)) 的编号是 %1 ，而后部分的编号是 %2 。上面第 6 行上的 %2 即代表 (</em>(addr)) 这个内存偏移量。现在我们来研究 4—7 行上的代码的作用。第一句将 fs 段寄存器的内容入栈；第二句将 eax 中的段值赋给 fs 段寄存器；第三句是把 fs:(*(addr)) 所指定的字节放入 al 寄存器中。当执行完汇编语句后，输出寄存器 eax 的值将被放入 <code>__res</code> ，作为该宏函数（块结构表达式）的返回值。</p>\n<p>通过上面分析，我们知道，宏名称中的 seg 代表一指定的内存段值，而 addr 表示一内存偏移地址量。到现在为止，我们应该很清楚这段程序的功能了吧！该宏函数的功能是从指定段和偏移值的内存地址处取一个字节。</p>\n<p>通过上面的例子说明，阅读这段代码时应该像CPU处理指令时的逻辑一样，先从输出输入寄存器语句开始知道输入输出是什么，然后再阅读汇编语句，处理完后再看最后的返回是什么。</p>\n<ul>\n<li>例子2</li>\n</ul>\n<p>再来看下Linux 内核中main()中对中断异常挂接的trap_init()中的设计到的一个GCC内嵌汇编。代码路径为；include\\asm\\system.h</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 #define _set_gate(gate_addr,type,dpl,addr) \\</span><br><span class=\"line\">2 __asm__ (&quot;movw %%dx,%%ax\\n\\t&quot; \\</span><br><span class=\"line\">3\t&quot;movw %0,%%dx\\n\\t&quot; \\</span><br><span class=\"line\">4\t&quot;movl %%eax,%1\\n\\t&quot; \\</span><br><span class=\"line\">5\t&quot;movl %%edx,%2&quot; \\</span><br><span class=\"line\">6\t: \\</span><br><span class=\"line\">7\t: &quot;i&quot; ((short) (0x8000+(dpl&lt;&lt;13)+(type&lt;&lt;8))), \\</span><br><span class=\"line\">8\t&quot;o&quot; (*((char *) (gate_addr))), \\</span><br><span class=\"line\">9\t&quot;o&quot; (*(4+(char *) (gate_addr))), \\</span><br><span class=\"line\">10\t&quot;d&quot; ((char *) (addr)),&quot;a&quot; (0x00080000))</span><br></pre></td></tr></table></figure>\n<p>首先从第6行输出寄存器开始阅读：输出寄存器为空。然后是第7至10行的输入寄存器。第%0个输入寄存器使用“i”表示输入立即数，第%1个输入寄存器使用“o”表示使用内存地址并可以加偏移值，第%2个输入寄存器依然使用“o”代码，第%3个寄存器使用“d”表示使用寄存器edx，第%4个寄存器使用“a”表示使用寄存器eax。</p>\n<p>之后再看下汇编语句：依次进行值的传递。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>《Linux内核设计的艺术》新设计团队 著</p>\n<p>《Linux内核完全注释》赵炯 编著</p>"},{"title":"数据预处理","date":"2019-11-16T07:30:46.000Z","copyright":true,"mathjax":true,"_content":"\n# 数据预处理\n\n## 为什么数据预处理\n\n原始数据可能掺杂着噪音、空值或者不正确、不一致、充满冗余值等。没有高质量的数据，很难挖掘出高质量的规则，因此需要数据预处理。数据预处理主要有：数据清洗、数据集成、数据归约、数据离散等几个任务。\n\n<!--more-->\n\n## 数据描述\n\n得到一份数据后，需要先对数据进行一个大概的认识，主要从中心趋势和发散特征两方面统计进行描述。\n\n### 中心趋势度量\n\n#### 平均值 mean\n\n均值又分为：\n\n- 算术均值\n\n   $\\bar x=\\frac{1}{n}\\sum_{i=1}^{n}x_i$\n\n- 加权均值\n\n  $\\bar x= \\frac{\\sum_{i=1}^{n}w_ix_i}{\\sum_{i=1}^{n}w_i}$\n\n- 截尾均值 Trimmed mean\n\n  均值对极端数据比如离群点很敏感。因此截取高低两端的一部分数据后再计算均值，但是截去的部分不能太多不超过$20\\%$\n\n#### 中位数 median\n\n对于倾斜（非对称）数据，数据中心的更好度量是中位数。\n\n假定数据有序，则当n为奇数时中位数是中间的值，当n为偶数的时候，中位数不唯一，可以是中间两个值和之间的任意值。如果属性是数值属性，那么一般约定取中间两个值的平均值。\n\n#### 众数 mode\n\n另一种中心趋势的度量方法，众数是集合中出现最频繁的值。数据可能会有多个众数，如果最高频的值有多个的时候。如果每个数据值近出现一次，是没有众数的。\n\n有一个、两个、三个众数的分别称为：单峰的(unimodal)、双峰的（bimodal）和三峰的（trimodal）\n\n#### 中列数 midrange\n\n中列数是数据集的最大和最小值的平均值。\n\n#### 对称与倾斜\n\n完全对称的数据分布的单峰频率曲线中，均值、中位数和众数三者是相同的中心值。\n\n不对称的情况分为：\n\n- 正倾斜：众数小于中位数\n- 负倾斜：众数大于中位数\n\n如下所示,最上方是对称的，左下是正倾斜的，右下是负倾斜的。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1573992640/blog/Data%20Mining/symmetric_skewed.jpg)\n\n### 数据散布度量\n\n#### 极差、四分位数和四分位数极差\n\n**极差（range）**：最大值与最小值之差。\n\n有序数据值下的数据集合的第k 个百分位数是具有如下性质的值x：数据项的百分之k 在x 上或低于x。在中位数M上或低于M 的值对应于第50 个百分位数。\n\n**四分位数**将数据分为4段总共有3个四分位数，Q1是第25个百分位数，Q2即是Median是第50个百分位数，Q3是第75个百分位数。\n\n100-分位数通常称为百分位数，它们把数据分成100个大小相等的连贯集。中位数、四分位数和百分位数是使用最广泛的分位数。\n\n第一个和第三个四分位数之间的距离是分布的一种简单度量，它给出被数据的中间一半\n所覆盖的范围。该距离称为中间**四分位数极差（IQR）**：$IQR=Q_3-Q_1$\n\n#### 五数概括、盒图与离群点\n\n**离群点(Outlier)**：与$Q_1$或者$Q_3$这两个分位数的值超过$1.5IQR$\n\n五数概括使用最小值、$Q_1$ 、中位数、$Q_3$、最大值来概述数据的中心与散布。\n\n可以使用盒图来体现五数概括 。\n\n- 盒的端点在四分位数上，使得盒的长度是中间四分位数区间IQR\n- 中位数用盒内的线标记\n- 盒外的两条线（称作胡须）延伸到最小（Minimum）和最大（Maximum）观测值。如果最大最小值超过$1.5IQR$，那么只延伸到这个部分。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1573992640/blog/Data%20Mining/box_plot.jpg)\n\n如上图所示，最大值超过了$1.5IQR$所以只延伸到了$1.5IQR$，而超过$1.5IQR$部分的被标记为离群点。\n\n#### 方差、标准差\n\n方差Variance与标准差Standard deviation指出数据分布的散布程度。\n\n总体方差的计算：$\\sigma^2=\\frac{1}{n}\\sum_{i=1}^{n}(x_i-\\mu)^2={\\frac{1}{n}\\sum_{i=1}^{n}x_i^2}-{\\mu}^2$\n\n样本方差的计算：$s^2=\\frac{1}{n-1}\\sum_{i=1}^{n}(x_i-\\bar x)^2={\\frac{1}{n-1}（\\sum_{i=1}^{n}x_i^2}-\\frac{1}{n}\\sum_{i=1}^{n}x_i^2）$\n\n$\\mu$是总体数据的平均值，而$\\bar x$是总体数据中的一部分样本的均值，可以用样本的均值来估计总体的均值。样本方差是无偏估计的，[样本方差与总体方差的差别](<https://www.zhihu.com/question/20099757> )\n\n标准差是方差的平方根，就是$\\sigma$或者s。它的性质是：\n\n- $\\sigma$**度量关于平均值的发散**，仅当选择平均值作为中心度量时使用。\n- 仅当不存在发散时，即当所有的观测值都相同时，$\\sigma=0$。否则，$\\sigma>0$。\n\n### 数据描述的图形表示\n\n#### 直方图\n\n直方图Histogram 或者频率直方图Frequency histograms 针对单变量，对于比较单变量观测组，它可能不如分位数图、q-q 图和盒图方法有效。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1573992639/blog/Data%20Mining/histogram.jpg)\n\n#### 分位数图 \n\n分位数图Quantile Plot每个观测值$x_i$与一个百分数$f_i$配对，指出大约$f_i \\times 100\\%$的数据小于值$x_i$，“大约”是因为可能没有一个精确的小数值$f_i$，使得数据的$f_i\\%$小于或等于$x_i$。0.25 分位数对应于Q1，0.50 分位数对应于中位数，而0.75 分位数对应于Q3。\n\n$f_i$的定义：$f_i=\\frac{i-0.5}{N}$这些数由$\\frac{1}{2N}$（稍大于0）到$1-\\frac{1}{2N}$（稍小于1），以相同的步长1/n 递增。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1573992640/blog/Data%20Mining/Quantile_Plot.jpg)\n\n#### 分位数-分位数图\n\n分位数-分位数图Quantile-Quantile Plot，或q-q 图对着另一个的对应分位数，绘制一个单变量分布的分位数。它是一种强有力的直观表示工具，使得用户可以观察从一个分布到另一个是否有漂移。![]https://res.cloudinary.com/bravey/image/upload/v1573992640/blog/Data%20Mining/qq_plot.jpg)\n\n部门1的分布相对于部门2有一个漂移，更趋向于部门2，说明部门2的单价趋向于比部门1高。\n\n#### 散点图\n\n散点图(scatter plot)是确定两个量化变量之间看上去是否有联系、模式或趋势的最有效的图形方法之一。\n\n它观察的是**双变量**，可以观察点簇和离群点，或者考察相关性。正相关x随着y的增加而增加，负相关x随着y的增长而减少。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1573992640/blog/Data%20Mining/scatter_plot.jpg)\n\n## 数据清洗\n\n#### 缺失值\n\n- 忽略元组\n- 人工填写缺值\n- 使用全局常量填充 ：比如Unknown \n- 所有样本的中心值填充：均值或者中位数 均值要求数据对称分布，倾斜分布用中位数\n- 给定元组的分类相同的样本的均值或者中位数\n- 最可能的值：使用贝叶斯推理、回归、决策数等进行预测。 前面几种是有偏的，这种方法最常用。\n\n#### 噪声数据\n\n##### 分箱\n\n分箱方法通过考察“邻居”（即，周围的值）来平滑存储数据的值。存储的值被分布到一些“桶”或箱中。由于分箱方法导致值相邻，因此它进行局部平滑。\n\n要求数据有序因此需要**先进行排序**，有三种方法：\n\n- **箱均值光滑**：箱中的每一个值被替换为箱中的均值\n- **箱中位数光滑：**箱中的每一个值被替换为箱中的中位数\n- **箱边界光滑：**边界为箱中的最大与最小值，每个值被替换为距离其最近的边界值。\n\n而箱子的分法有**等频（等深）**：每个箱子中的样本数目一样。**等宽**：按照取值范围将样本划分，每个箱子中的取值范围一致，比如样本数据取值为[0,10]那么可以按照等宽为2，把[0,2),[2,4)这样的取值范围来把样本划分到对应区间所在的范围中。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1573992639/blog/Data%20Mining/bin.jpg)\n\n##### 回归\n\n用函数拟合数据来光滑数据，将离拟合曲线远的数据标记为噪声数据。\n\n##### 聚类\n\n使用聚类分析后，检测出离群点，然后把离群点标记为噪声数据。\n\n## 数据转换\n\n### 归一化/规范化\n\n#### 最大-最小归一化 \n\n对原始数据进行线性变换，映射到新的区间[new_min, new_max]中去。这种方法保持了原始数据之间的联系。\n$$\nv_i'=\\frac{v_i-min_A}{max_A-min_A}(new\\_max_A-new\\_min_A)\n$$\n\n#### z-score归一化\n\n新的值使用均值和标准差进行映射。$\\bar A$和$\\sigma_A$ 分别是样本的均值和他的标准差。\n$$\nv_i'=\\frac{v_i-\\bar A}{\\sigma_A}\n$$\n\n#### 小数定标归一化\n\n小数定标归一化 Normalization by decimal scaling。移动原来的小数点的位置来进行归一化。\n$$\nv_i'=\\dfrac{v_i}{10^j}\n$$\nj是让$Max(|v_i'|<1)$的最小整数，比如如果是254，那么j取3就可以让其为0.254小于1。\n\n## 冗余与相关性分析\n\n一个属性可以由另外的属性导出，那么另外的属性就是冗余的。有些冗余可以通过**相关性分析**来检测\n\n### 数值数据的相关系数\n\n相关系数Correlation coefficient也称作皮尔森积矩系数Pearson’s product moment coefficient估计两个属性A,B的相关度。\n$$\nr_{A.B}=\\dfrac{\\sum_{i=1}^{n}(a_i-\\bar A)(b_i-\\bar B)}{(n-1)\\sigma_A\\sigma_B}=\\dfrac{\\sum_{i=1}^{n}(a_ib_i)-n\\bar A\\bar B}{(n-1)\\sigma_A\\sigma_b}\n$$\n$-1\\le r_{A,B}\\le 1$ ,$r_{A,B}>0$ A和B两个属性正相关，A的值随着B的值增长而增长。$r_{A,B}<0$为负相关，A的值随着B的值增长而减少。该值越大，一个属性蕴涵另一个的可能性越大。因此，一个很大的值表明A（或B）可以作为冗余而被去掉。如果结果值等于0，则A 和B 是独立的，它们之间不相关。可以参见前述的散点图。\n\n### 分类数据的$\\chi^2$相关检验\n\n分类数据Categorical Data中，两类数据可以通过$\\chi^2$卡方检验来发现它们的相关性。计算公式为：\n$$\n\\begin{split}\n&\\chi^2=\\sum_{i=1}^{c}\\sum_{j=1}^{r}\\dfrac{o_{ij}-e_{ij}}{e_{ij}}\\\\\\\\\n&e_{ij}=\\dfrac{count(A=a_i)\\times count(B=b_j)}{n}\n\\end{split}\n$$\n$o_{ij}$ 是联合事件$(A_i,B_j)$的观测频度也就是实际频数，而$e_{ij}$ 是$(A_i,B_j)$的期望值。n是总的数据样本数。使用相依表来表示数据。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1573992639/blog/Data%20Mining/rely_table.jpg)\n\n图中括号中的是每个单元的预测值。总共抽取1500个样本，因此n=1500。A类是否喜欢看小说有两类取值，B类性别也有两类取值，因此c=2，r=2。计算单元（男，小说）的预测值有：\n$$\ne_{11}=\\dfrac{count(男)\\times count(小说)}{n}=\\dfrac{300\\times450}{1500}=90\n$$\n其他几个单元的预测值都在括号中。因此可以计算出：\n$$\n\\chi^2=\\dfrac{(250-90)^2}{90}+\\dfrac{(50-210)^2}{210}+\\dfrac{(200-360)^2}{360}+\\dfrac{(1000-840)^2}{840}=507.93\n$$\n对于这个2*2的表，自由度为（2-1)(2-1)=1。对于自由度1，在0.001的置信水平下，查表得到拒绝假设的值是10.828。算出来的值大与它，因此认为性别和爱看小说不是独立的，是强相关的。\n\n## 数据归约\n\n数据归约技术 Data Reduction可以用来得到数据集的归约表示，它小得多，但仍接近地保持原数据的完整性。\n\n分为：\n\n- 维规约：降维\n- 数量规约：用替代的、较小的的数据形式替换原始数据。比如只存放数据的模型参数\n- 数据压缩：通过变换将原始数据压缩，不损失原来的信息叫做无损，否则是有损\n\n### 维规约\n\n#### 小波变换\n\nDWT）是一种线性信号处理技术，当用于数据向量D 时，将它转换成不同的数值向量小波系数D’。两个向量具有相同的长度。虽然变换后向量维度一样，但是可以仅存放一小部分最强的小波系数，就能保留近似的压缩数据。DWT提供比离散傅利叶DFT更好的有损压缩，DWT 将提供原数据更精确的近似。因此，对于等价的近似，DWT 比DFT 需要的空间小。不像DFT，小波空间局部性相当好，有助于保留局部细节。\n\n该方法如下：\n\n1. 输入数据向量的长度L 必须是2 的整数幂。必要时，通过在数据向量后添加0，这一条件可以满足。\n2. 每个变换涉及应用两个函数。第一个使用某种数据平滑，如求和或加权平均。第二个进行加权差分，产生数据的细节特征。\n3. 两个函数作用于输入数据对，产生两个长度为L/2 的数据集。一般地，它们分别代表输入数据的平滑后或低频的版本和它的高频内容。\n4. 两个函数递归地作用于前面循环得到的数据集，直到结果数据集的长度为2。\n5. 由以上迭代得到的数据集中选择值，指定其为数据变换的小波系数。\n\n#### 主成分分析\n\n主成分分析PCA 又称Karhunen-Loeve 或K-L 方法）搜索c 个最能代表数据的k-维正交向量；这里c ≤ k。这样，原来的数据投影到一个较小的空间，导致数据压缩。PCA 可以作为一种维归约形式使用。然而，不象属性子集选择通过保留原属性集的一个子集来减少属性集的大小。PCA 通过创建一个替换的、较小的变量集“组合”属性的本质。原数据可以投影到该较小的集合中。\n\n详解的过程暂时不记录，查看模式识别的教材。**只适用数值数据**\n\n#### 属性/特征子集选择\n\n也就是降维。使用压缩搜索空间的启发式的算法，典型的是贪心算法。每次找到一个局部的好的属性，剔除掉差的属性。\n\n属性子集选择的基本启发式方法包括以下技术：\n\n- 逐步向前选择：该过程由空属性集开始，选择原属性集中最好的属性，并将它添加到该集合中。\n- 逐步向后删除：该过程由整个属性集开始。在每一步，删除掉尚在属性集中的最坏属性。\n- 向前选择和向后删除的结合：向前选择和向后删除方法可以结合在一起，每一步选择一个最好的属性，并在剩余属性中删除一个最坏的属性。\n- 判定树归纳：判定树算法，如ID3 和C4.5 。\n\n### 数量规约\n\n#### 数据立方体集成\n\n将数据整理成之前介绍过的数据立方体，把感兴趣的数据整理到基本立方体base cuboid上面。比如如果只关注每个季度的销售数据，那么可以将原来的每天的数据整理成每个季度的销售数据。这样就可以大大减少原来的数据量了。\n\n#### 回归\n\n因为展开内容很多，只记录下有这些方法。当把数据拟合为某一种模型后只用记录这些模型的参数就可以了\n\n- 线性回归\n- 多元线性回归\n- 对数线性模型\n\n#### 直方图\n\n就是前面叙述的分箱的方法，使用一个桶来记录一个属性的频次。或者等宽的方法，用区间来记录每个区间中的频次。\n\n#### 聚类\n\n聚类后，用数据的簇代表替换实际的数据。即只记录簇的中心点。\n\n#### 抽样\n\n假定大的数据集D 包含N 个元组。我们看看对D 的可能选样。\n\n简单选择n 个样本，不回放(**SRSWOR**)：由D 的N 个元组中抽取n 个样本（n < N）；其中， D中任何元组被抽取的概率均为1/N。即，所有元组是等可能的。\n\n简单选择n 个样本，回放(**SRSWR**)：该方法类似于SRSWOR，不同在于当一个元组被抽取后，记录它，然后放回去。这样，一个元组被抽取后，它又被放回D，以便它可以再次被抽取。\n\n### 数据压缩\n\n主要使用编码机制来进行压缩。包括字符串、音频、视频的压缩。\n\n### 数据离散和概念分层\n\n可以使用分箱来、聚类、决策树和相关分析来进行离散化。而对于标称数据可以进行概念分层，前面的数据立方体就是用的这个思路。\n\n## 参考\n\n《数据挖掘概念与技术》第3版 第三章数据预处理\n\n","source":"_posts/2019-11-16-数据预处理.md","raw":"---\ntitle: 数据预处理\ndate: 2019-11-16 15:30:46\ncategories: 数据挖掘\ntags:\n- 课程\n- 国科大\n- 降维\n- 相关性分析\ncopyright: true\nmathjax: true\n---\n\n# 数据预处理\n\n## 为什么数据预处理\n\n原始数据可能掺杂着噪音、空值或者不正确、不一致、充满冗余值等。没有高质量的数据，很难挖掘出高质量的规则，因此需要数据预处理。数据预处理主要有：数据清洗、数据集成、数据归约、数据离散等几个任务。\n\n<!--more-->\n\n## 数据描述\n\n得到一份数据后，需要先对数据进行一个大概的认识，主要从中心趋势和发散特征两方面统计进行描述。\n\n### 中心趋势度量\n\n#### 平均值 mean\n\n均值又分为：\n\n- 算术均值\n\n   $\\bar x=\\frac{1}{n}\\sum_{i=1}^{n}x_i$\n\n- 加权均值\n\n  $\\bar x= \\frac{\\sum_{i=1}^{n}w_ix_i}{\\sum_{i=1}^{n}w_i}$\n\n- 截尾均值 Trimmed mean\n\n  均值对极端数据比如离群点很敏感。因此截取高低两端的一部分数据后再计算均值，但是截去的部分不能太多不超过$20\\%$\n\n#### 中位数 median\n\n对于倾斜（非对称）数据，数据中心的更好度量是中位数。\n\n假定数据有序，则当n为奇数时中位数是中间的值，当n为偶数的时候，中位数不唯一，可以是中间两个值和之间的任意值。如果属性是数值属性，那么一般约定取中间两个值的平均值。\n\n#### 众数 mode\n\n另一种中心趋势的度量方法，众数是集合中出现最频繁的值。数据可能会有多个众数，如果最高频的值有多个的时候。如果每个数据值近出现一次，是没有众数的。\n\n有一个、两个、三个众数的分别称为：单峰的(unimodal)、双峰的（bimodal）和三峰的（trimodal）\n\n#### 中列数 midrange\n\n中列数是数据集的最大和最小值的平均值。\n\n#### 对称与倾斜\n\n完全对称的数据分布的单峰频率曲线中，均值、中位数和众数三者是相同的中心值。\n\n不对称的情况分为：\n\n- 正倾斜：众数小于中位数\n- 负倾斜：众数大于中位数\n\n如下所示,最上方是对称的，左下是正倾斜的，右下是负倾斜的。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1573992640/blog/Data%20Mining/symmetric_skewed.jpg)\n\n### 数据散布度量\n\n#### 极差、四分位数和四分位数极差\n\n**极差（range）**：最大值与最小值之差。\n\n有序数据值下的数据集合的第k 个百分位数是具有如下性质的值x：数据项的百分之k 在x 上或低于x。在中位数M上或低于M 的值对应于第50 个百分位数。\n\n**四分位数**将数据分为4段总共有3个四分位数，Q1是第25个百分位数，Q2即是Median是第50个百分位数，Q3是第75个百分位数。\n\n100-分位数通常称为百分位数，它们把数据分成100个大小相等的连贯集。中位数、四分位数和百分位数是使用最广泛的分位数。\n\n第一个和第三个四分位数之间的距离是分布的一种简单度量，它给出被数据的中间一半\n所覆盖的范围。该距离称为中间**四分位数极差（IQR）**：$IQR=Q_3-Q_1$\n\n#### 五数概括、盒图与离群点\n\n**离群点(Outlier)**：与$Q_1$或者$Q_3$这两个分位数的值超过$1.5IQR$\n\n五数概括使用最小值、$Q_1$ 、中位数、$Q_3$、最大值来概述数据的中心与散布。\n\n可以使用盒图来体现五数概括 。\n\n- 盒的端点在四分位数上，使得盒的长度是中间四分位数区间IQR\n- 中位数用盒内的线标记\n- 盒外的两条线（称作胡须）延伸到最小（Minimum）和最大（Maximum）观测值。如果最大最小值超过$1.5IQR$，那么只延伸到这个部分。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1573992640/blog/Data%20Mining/box_plot.jpg)\n\n如上图所示，最大值超过了$1.5IQR$所以只延伸到了$1.5IQR$，而超过$1.5IQR$部分的被标记为离群点。\n\n#### 方差、标准差\n\n方差Variance与标准差Standard deviation指出数据分布的散布程度。\n\n总体方差的计算：$\\sigma^2=\\frac{1}{n}\\sum_{i=1}^{n}(x_i-\\mu)^2={\\frac{1}{n}\\sum_{i=1}^{n}x_i^2}-{\\mu}^2$\n\n样本方差的计算：$s^2=\\frac{1}{n-1}\\sum_{i=1}^{n}(x_i-\\bar x)^2={\\frac{1}{n-1}（\\sum_{i=1}^{n}x_i^2}-\\frac{1}{n}\\sum_{i=1}^{n}x_i^2）$\n\n$\\mu$是总体数据的平均值，而$\\bar x$是总体数据中的一部分样本的均值，可以用样本的均值来估计总体的均值。样本方差是无偏估计的，[样本方差与总体方差的差别](<https://www.zhihu.com/question/20099757> )\n\n标准差是方差的平方根，就是$\\sigma$或者s。它的性质是：\n\n- $\\sigma$**度量关于平均值的发散**，仅当选择平均值作为中心度量时使用。\n- 仅当不存在发散时，即当所有的观测值都相同时，$\\sigma=0$。否则，$\\sigma>0$。\n\n### 数据描述的图形表示\n\n#### 直方图\n\n直方图Histogram 或者频率直方图Frequency histograms 针对单变量，对于比较单变量观测组，它可能不如分位数图、q-q 图和盒图方法有效。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1573992639/blog/Data%20Mining/histogram.jpg)\n\n#### 分位数图 \n\n分位数图Quantile Plot每个观测值$x_i$与一个百分数$f_i$配对，指出大约$f_i \\times 100\\%$的数据小于值$x_i$，“大约”是因为可能没有一个精确的小数值$f_i$，使得数据的$f_i\\%$小于或等于$x_i$。0.25 分位数对应于Q1，0.50 分位数对应于中位数，而0.75 分位数对应于Q3。\n\n$f_i$的定义：$f_i=\\frac{i-0.5}{N}$这些数由$\\frac{1}{2N}$（稍大于0）到$1-\\frac{1}{2N}$（稍小于1），以相同的步长1/n 递增。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1573992640/blog/Data%20Mining/Quantile_Plot.jpg)\n\n#### 分位数-分位数图\n\n分位数-分位数图Quantile-Quantile Plot，或q-q 图对着另一个的对应分位数，绘制一个单变量分布的分位数。它是一种强有力的直观表示工具，使得用户可以观察从一个分布到另一个是否有漂移。![]https://res.cloudinary.com/bravey/image/upload/v1573992640/blog/Data%20Mining/qq_plot.jpg)\n\n部门1的分布相对于部门2有一个漂移，更趋向于部门2，说明部门2的单价趋向于比部门1高。\n\n#### 散点图\n\n散点图(scatter plot)是确定两个量化变量之间看上去是否有联系、模式或趋势的最有效的图形方法之一。\n\n它观察的是**双变量**，可以观察点簇和离群点，或者考察相关性。正相关x随着y的增加而增加，负相关x随着y的增长而减少。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1573992640/blog/Data%20Mining/scatter_plot.jpg)\n\n## 数据清洗\n\n#### 缺失值\n\n- 忽略元组\n- 人工填写缺值\n- 使用全局常量填充 ：比如Unknown \n- 所有样本的中心值填充：均值或者中位数 均值要求数据对称分布，倾斜分布用中位数\n- 给定元组的分类相同的样本的均值或者中位数\n- 最可能的值：使用贝叶斯推理、回归、决策数等进行预测。 前面几种是有偏的，这种方法最常用。\n\n#### 噪声数据\n\n##### 分箱\n\n分箱方法通过考察“邻居”（即，周围的值）来平滑存储数据的值。存储的值被分布到一些“桶”或箱中。由于分箱方法导致值相邻，因此它进行局部平滑。\n\n要求数据有序因此需要**先进行排序**，有三种方法：\n\n- **箱均值光滑**：箱中的每一个值被替换为箱中的均值\n- **箱中位数光滑：**箱中的每一个值被替换为箱中的中位数\n- **箱边界光滑：**边界为箱中的最大与最小值，每个值被替换为距离其最近的边界值。\n\n而箱子的分法有**等频（等深）**：每个箱子中的样本数目一样。**等宽**：按照取值范围将样本划分，每个箱子中的取值范围一致，比如样本数据取值为[0,10]那么可以按照等宽为2，把[0,2),[2,4)这样的取值范围来把样本划分到对应区间所在的范围中。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1573992639/blog/Data%20Mining/bin.jpg)\n\n##### 回归\n\n用函数拟合数据来光滑数据，将离拟合曲线远的数据标记为噪声数据。\n\n##### 聚类\n\n使用聚类分析后，检测出离群点，然后把离群点标记为噪声数据。\n\n## 数据转换\n\n### 归一化/规范化\n\n#### 最大-最小归一化 \n\n对原始数据进行线性变换，映射到新的区间[new_min, new_max]中去。这种方法保持了原始数据之间的联系。\n$$\nv_i'=\\frac{v_i-min_A}{max_A-min_A}(new\\_max_A-new\\_min_A)\n$$\n\n#### z-score归一化\n\n新的值使用均值和标准差进行映射。$\\bar A$和$\\sigma_A$ 分别是样本的均值和他的标准差。\n$$\nv_i'=\\frac{v_i-\\bar A}{\\sigma_A}\n$$\n\n#### 小数定标归一化\n\n小数定标归一化 Normalization by decimal scaling。移动原来的小数点的位置来进行归一化。\n$$\nv_i'=\\dfrac{v_i}{10^j}\n$$\nj是让$Max(|v_i'|<1)$的最小整数，比如如果是254，那么j取3就可以让其为0.254小于1。\n\n## 冗余与相关性分析\n\n一个属性可以由另外的属性导出，那么另外的属性就是冗余的。有些冗余可以通过**相关性分析**来检测\n\n### 数值数据的相关系数\n\n相关系数Correlation coefficient也称作皮尔森积矩系数Pearson’s product moment coefficient估计两个属性A,B的相关度。\n$$\nr_{A.B}=\\dfrac{\\sum_{i=1}^{n}(a_i-\\bar A)(b_i-\\bar B)}{(n-1)\\sigma_A\\sigma_B}=\\dfrac{\\sum_{i=1}^{n}(a_ib_i)-n\\bar A\\bar B}{(n-1)\\sigma_A\\sigma_b}\n$$\n$-1\\le r_{A,B}\\le 1$ ,$r_{A,B}>0$ A和B两个属性正相关，A的值随着B的值增长而增长。$r_{A,B}<0$为负相关，A的值随着B的值增长而减少。该值越大，一个属性蕴涵另一个的可能性越大。因此，一个很大的值表明A（或B）可以作为冗余而被去掉。如果结果值等于0，则A 和B 是独立的，它们之间不相关。可以参见前述的散点图。\n\n### 分类数据的$\\chi^2$相关检验\n\n分类数据Categorical Data中，两类数据可以通过$\\chi^2$卡方检验来发现它们的相关性。计算公式为：\n$$\n\\begin{split}\n&\\chi^2=\\sum_{i=1}^{c}\\sum_{j=1}^{r}\\dfrac{o_{ij}-e_{ij}}{e_{ij}}\\\\\\\\\n&e_{ij}=\\dfrac{count(A=a_i)\\times count(B=b_j)}{n}\n\\end{split}\n$$\n$o_{ij}$ 是联合事件$(A_i,B_j)$的观测频度也就是实际频数，而$e_{ij}$ 是$(A_i,B_j)$的期望值。n是总的数据样本数。使用相依表来表示数据。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1573992639/blog/Data%20Mining/rely_table.jpg)\n\n图中括号中的是每个单元的预测值。总共抽取1500个样本，因此n=1500。A类是否喜欢看小说有两类取值，B类性别也有两类取值，因此c=2，r=2。计算单元（男，小说）的预测值有：\n$$\ne_{11}=\\dfrac{count(男)\\times count(小说)}{n}=\\dfrac{300\\times450}{1500}=90\n$$\n其他几个单元的预测值都在括号中。因此可以计算出：\n$$\n\\chi^2=\\dfrac{(250-90)^2}{90}+\\dfrac{(50-210)^2}{210}+\\dfrac{(200-360)^2}{360}+\\dfrac{(1000-840)^2}{840}=507.93\n$$\n对于这个2*2的表，自由度为（2-1)(2-1)=1。对于自由度1，在0.001的置信水平下，查表得到拒绝假设的值是10.828。算出来的值大与它，因此认为性别和爱看小说不是独立的，是强相关的。\n\n## 数据归约\n\n数据归约技术 Data Reduction可以用来得到数据集的归约表示，它小得多，但仍接近地保持原数据的完整性。\n\n分为：\n\n- 维规约：降维\n- 数量规约：用替代的、较小的的数据形式替换原始数据。比如只存放数据的模型参数\n- 数据压缩：通过变换将原始数据压缩，不损失原来的信息叫做无损，否则是有损\n\n### 维规约\n\n#### 小波变换\n\nDWT）是一种线性信号处理技术，当用于数据向量D 时，将它转换成不同的数值向量小波系数D’。两个向量具有相同的长度。虽然变换后向量维度一样，但是可以仅存放一小部分最强的小波系数，就能保留近似的压缩数据。DWT提供比离散傅利叶DFT更好的有损压缩，DWT 将提供原数据更精确的近似。因此，对于等价的近似，DWT 比DFT 需要的空间小。不像DFT，小波空间局部性相当好，有助于保留局部细节。\n\n该方法如下：\n\n1. 输入数据向量的长度L 必须是2 的整数幂。必要时，通过在数据向量后添加0，这一条件可以满足。\n2. 每个变换涉及应用两个函数。第一个使用某种数据平滑，如求和或加权平均。第二个进行加权差分，产生数据的细节特征。\n3. 两个函数作用于输入数据对，产生两个长度为L/2 的数据集。一般地，它们分别代表输入数据的平滑后或低频的版本和它的高频内容。\n4. 两个函数递归地作用于前面循环得到的数据集，直到结果数据集的长度为2。\n5. 由以上迭代得到的数据集中选择值，指定其为数据变换的小波系数。\n\n#### 主成分分析\n\n主成分分析PCA 又称Karhunen-Loeve 或K-L 方法）搜索c 个最能代表数据的k-维正交向量；这里c ≤ k。这样，原来的数据投影到一个较小的空间，导致数据压缩。PCA 可以作为一种维归约形式使用。然而，不象属性子集选择通过保留原属性集的一个子集来减少属性集的大小。PCA 通过创建一个替换的、较小的变量集“组合”属性的本质。原数据可以投影到该较小的集合中。\n\n详解的过程暂时不记录，查看模式识别的教材。**只适用数值数据**\n\n#### 属性/特征子集选择\n\n也就是降维。使用压缩搜索空间的启发式的算法，典型的是贪心算法。每次找到一个局部的好的属性，剔除掉差的属性。\n\n属性子集选择的基本启发式方法包括以下技术：\n\n- 逐步向前选择：该过程由空属性集开始，选择原属性集中最好的属性，并将它添加到该集合中。\n- 逐步向后删除：该过程由整个属性集开始。在每一步，删除掉尚在属性集中的最坏属性。\n- 向前选择和向后删除的结合：向前选择和向后删除方法可以结合在一起，每一步选择一个最好的属性，并在剩余属性中删除一个最坏的属性。\n- 判定树归纳：判定树算法，如ID3 和C4.5 。\n\n### 数量规约\n\n#### 数据立方体集成\n\n将数据整理成之前介绍过的数据立方体，把感兴趣的数据整理到基本立方体base cuboid上面。比如如果只关注每个季度的销售数据，那么可以将原来的每天的数据整理成每个季度的销售数据。这样就可以大大减少原来的数据量了。\n\n#### 回归\n\n因为展开内容很多，只记录下有这些方法。当把数据拟合为某一种模型后只用记录这些模型的参数就可以了\n\n- 线性回归\n- 多元线性回归\n- 对数线性模型\n\n#### 直方图\n\n就是前面叙述的分箱的方法，使用一个桶来记录一个属性的频次。或者等宽的方法，用区间来记录每个区间中的频次。\n\n#### 聚类\n\n聚类后，用数据的簇代表替换实际的数据。即只记录簇的中心点。\n\n#### 抽样\n\n假定大的数据集D 包含N 个元组。我们看看对D 的可能选样。\n\n简单选择n 个样本，不回放(**SRSWOR**)：由D 的N 个元组中抽取n 个样本（n < N）；其中， D中任何元组被抽取的概率均为1/N。即，所有元组是等可能的。\n\n简单选择n 个样本，回放(**SRSWR**)：该方法类似于SRSWOR，不同在于当一个元组被抽取后，记录它，然后放回去。这样，一个元组被抽取后，它又被放回D，以便它可以再次被抽取。\n\n### 数据压缩\n\n主要使用编码机制来进行压缩。包括字符串、音频、视频的压缩。\n\n### 数据离散和概念分层\n\n可以使用分箱来、聚类、决策树和相关分析来进行离散化。而对于标称数据可以进行概念分层，前面的数据立方体就是用的这个思路。\n\n## 参考\n\n《数据挖掘概念与技术》第3版 第三章数据预处理\n\n","slug":"2019-11-16-数据预处理","published":1,"updated":"2019-11-19T15:21:43.723Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6he13z1001wdstz0j3e2vfx","content":"<h1 id=\"数据预处理\"><a href=\"#数据预处理\" class=\"headerlink\" title=\"数据预处理\"></a>数据预处理</h1><h2 id=\"为什么数据预处理\"><a href=\"#为什么数据预处理\" class=\"headerlink\" title=\"为什么数据预处理\"></a>为什么数据预处理</h2><p>原始数据可能掺杂着噪音、空值或者不正确、不一致、充满冗余值等。没有高质量的数据，很难挖掘出高质量的规则，因此需要数据预处理。数据预处理主要有：数据清洗、数据集成、数据归约、数据离散等几个任务。</p>\n<a id=\"more\"></a>\n<h2 id=\"数据描述\"><a href=\"#数据描述\" class=\"headerlink\" title=\"数据描述\"></a>数据描述</h2><p>得到一份数据后，需要先对数据进行一个大概的认识，主要从中心趋势和发散特征两方面统计进行描述。</p>\n<h3 id=\"中心趋势度量\"><a href=\"#中心趋势度量\" class=\"headerlink\" title=\"中心趋势度量\"></a>中心趋势度量</h3><h4 id=\"平均值-mean\"><a href=\"#平均值-mean\" class=\"headerlink\" title=\"平均值 mean\"></a>平均值 mean</h4><p>均值又分为：</p>\n<ul>\n<li><p>算术均值</p>\n<p> $\\bar x=\\frac{1}{n}\\sum_{i=1}^{n}x_i$</p>\n</li>\n<li><p>加权均值</p>\n<p>$\\bar x= \\frac{\\sum_{i=1}^{n}w_ix_i}{\\sum_{i=1}^{n}w_i}$</p>\n</li>\n<li><p>截尾均值 Trimmed mean</p>\n<p>均值对极端数据比如离群点很敏感。因此截取高低两端的一部分数据后再计算均值，但是截去的部分不能太多不超过$20\\%$</p>\n</li>\n</ul>\n<h4 id=\"中位数-median\"><a href=\"#中位数-median\" class=\"headerlink\" title=\"中位数 median\"></a>中位数 median</h4><p>对于倾斜（非对称）数据，数据中心的更好度量是中位数。</p>\n<p>假定数据有序，则当n为奇数时中位数是中间的值，当n为偶数的时候，中位数不唯一，可以是中间两个值和之间的任意值。如果属性是数值属性，那么一般约定取中间两个值的平均值。</p>\n<h4 id=\"众数-mode\"><a href=\"#众数-mode\" class=\"headerlink\" title=\"众数 mode\"></a>众数 mode</h4><p>另一种中心趋势的度量方法，众数是集合中出现最频繁的值。数据可能会有多个众数，如果最高频的值有多个的时候。如果每个数据值近出现一次，是没有众数的。</p>\n<p>有一个、两个、三个众数的分别称为：单峰的(unimodal)、双峰的（bimodal）和三峰的（trimodal）</p>\n<h4 id=\"中列数-midrange\"><a href=\"#中列数-midrange\" class=\"headerlink\" title=\"中列数 midrange\"></a>中列数 midrange</h4><p>中列数是数据集的最大和最小值的平均值。</p>\n<h4 id=\"对称与倾斜\"><a href=\"#对称与倾斜\" class=\"headerlink\" title=\"对称与倾斜\"></a>对称与倾斜</h4><p>完全对称的数据分布的单峰频率曲线中，均值、中位数和众数三者是相同的中心值。</p>\n<p>不对称的情况分为：</p>\n<ul>\n<li>正倾斜：众数小于中位数</li>\n<li>负倾斜：众数大于中位数</li>\n</ul>\n<p>如下所示,最上方是对称的，左下是正倾斜的，右下是负倾斜的。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573992640/blog/Data%20Mining/symmetric_skewed.jpg\" alt=\"\"></p>\n<h3 id=\"数据散布度量\"><a href=\"#数据散布度量\" class=\"headerlink\" title=\"数据散布度量\"></a>数据散布度量</h3><h4 id=\"极差、四分位数和四分位数极差\"><a href=\"#极差、四分位数和四分位数极差\" class=\"headerlink\" title=\"极差、四分位数和四分位数极差\"></a>极差、四分位数和四分位数极差</h4><p><strong>极差（range）</strong>：最大值与最小值之差。</p>\n<p>有序数据值下的数据集合的第k 个百分位数是具有如下性质的值x：数据项的百分之k 在x 上或低于x。在中位数M上或低于M 的值对应于第50 个百分位数。</p>\n<p><strong>四分位数</strong>将数据分为4段总共有3个四分位数，Q1是第25个百分位数，Q2即是Median是第50个百分位数，Q3是第75个百分位数。</p>\n<p>100-分位数通常称为百分位数，它们把数据分成100个大小相等的连贯集。中位数、四分位数和百分位数是使用最广泛的分位数。</p>\n<p>第一个和第三个四分位数之间的距离是分布的一种简单度量，它给出被数据的中间一半<br>所覆盖的范围。该距离称为中间<strong>四分位数极差（IQR）</strong>：$IQR=Q_3-Q_1$</p>\n<h4 id=\"五数概括、盒图与离群点\"><a href=\"#五数概括、盒图与离群点\" class=\"headerlink\" title=\"五数概括、盒图与离群点\"></a>五数概括、盒图与离群点</h4><p><strong>离群点(Outlier)</strong>：与$Q_1$或者$Q_3$这两个分位数的值超过$1.5IQR$</p>\n<p>五数概括使用最小值、$Q_1$ 、中位数、$Q_3$、最大值来概述数据的中心与散布。</p>\n<p>可以使用盒图来体现五数概括 。</p>\n<ul>\n<li>盒的端点在四分位数上，使得盒的长度是中间四分位数区间IQR</li>\n<li>中位数用盒内的线标记</li>\n<li>盒外的两条线（称作胡须）延伸到最小（Minimum）和最大（Maximum）观测值。如果最大最小值超过$1.5IQR$，那么只延伸到这个部分。</li>\n</ul>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573992640/blog/Data%20Mining/box_plot.jpg\" alt=\"\"></p>\n<p>如上图所示，最大值超过了$1.5IQR$所以只延伸到了$1.5IQR$，而超过$1.5IQR$部分的被标记为离群点。</p>\n<h4 id=\"方差、标准差\"><a href=\"#方差、标准差\" class=\"headerlink\" title=\"方差、标准差\"></a>方差、标准差</h4><p>方差Variance与标准差Standard deviation指出数据分布的散布程度。</p>\n<p>总体方差的计算：$\\sigma^2=\\frac{1}{n}\\sum_{i=1}^{n}(x_i-\\mu)^2={\\frac{1}{n}\\sum_{i=1}^{n}x_i^2}-{\\mu}^2$</p>\n<p>样本方差的计算：$s^2=\\frac{1}{n-1}\\sum_{i=1}^{n}(x_i-\\bar x)^2={\\frac{1}{n-1}（\\sum_{i=1}^{n}x_i^2}-\\frac{1}{n}\\sum_{i=1}^{n}x_i^2）$</p>\n<p>$\\mu$是总体数据的平均值，而$\\bar x$是总体数据中的一部分样本的均值，可以用样本的均值来估计总体的均值。样本方差是无偏估计的，<a href=\"https://www.zhihu.com/question/20099757\" target=\"_blank\" rel=\"noopener\">样本方差与总体方差的差别</a></p>\n<p>标准差是方差的平方根，就是$\\sigma$或者s。它的性质是：</p>\n<ul>\n<li>$\\sigma$<strong>度量关于平均值的发散</strong>，仅当选择平均值作为中心度量时使用。</li>\n<li>仅当不存在发散时，即当所有的观测值都相同时，$\\sigma=0$。否则，$\\sigma&gt;0$。</li>\n</ul>\n<h3 id=\"数据描述的图形表示\"><a href=\"#数据描述的图形表示\" class=\"headerlink\" title=\"数据描述的图形表示\"></a>数据描述的图形表示</h3><h4 id=\"直方图\"><a href=\"#直方图\" class=\"headerlink\" title=\"直方图\"></a>直方图</h4><p>直方图Histogram 或者频率直方图Frequency histograms 针对单变量，对于比较单变量观测组，它可能不如分位数图、q-q 图和盒图方法有效。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573992639/blog/Data%20Mining/histogram.jpg\" alt=\"\"></p>\n<h4 id=\"分位数图\"><a href=\"#分位数图\" class=\"headerlink\" title=\"分位数图\"></a>分位数图</h4><p>分位数图Quantile Plot每个观测值$x_i$与一个百分数$f_i$配对，指出大约$f_i \\times 100\\%$的数据小于值$x_i$，“大约”是因为可能没有一个精确的小数值$f_i$，使得数据的$f_i\\%$小于或等于$x_i$。0.25 分位数对应于Q1，0.50 分位数对应于中位数，而0.75 分位数对应于Q3。</p>\n<p>$f_i$的定义：$f_i=\\frac{i-0.5}{N}$这些数由$\\frac{1}{2N}$（稍大于0）到$1-\\frac{1}{2N}$（稍小于1），以相同的步长1/n 递增。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573992640/blog/Data%20Mining/Quantile_Plot.jpg\" alt=\"\"></p>\n<h4 id=\"分位数-分位数图\"><a href=\"#分位数-分位数图\" class=\"headerlink\" title=\"分位数-分位数图\"></a>分位数-分位数图</h4><p>分位数-分位数图Quantile-Quantile Plot，或q-q 图对着另一个的对应分位数，绘制一个单变量分布的分位数。它是一种强有力的直观表示工具，使得用户可以观察从一个分布到另一个是否有漂移。![]<a href=\"https://res.cloudinary.com/bravey/image/upload/v1573992640/blog/Data%20Mining/qq_plot.jpg\" target=\"_blank\" rel=\"noopener\">https://res.cloudinary.com/bravey/image/upload/v1573992640/blog/Data%20Mining/qq_plot.jpg</a>)</p>\n<p>部门1的分布相对于部门2有一个漂移，更趋向于部门2，说明部门2的单价趋向于比部门1高。</p>\n<h4 id=\"散点图\"><a href=\"#散点图\" class=\"headerlink\" title=\"散点图\"></a>散点图</h4><p>散点图(scatter plot)是确定两个量化变量之间看上去是否有联系、模式或趋势的最有效的图形方法之一。</p>\n<p>它观察的是<strong>双变量</strong>，可以观察点簇和离群点，或者考察相关性。正相关x随着y的增加而增加，负相关x随着y的增长而减少。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573992640/blog/Data%20Mining/scatter_plot.jpg\" alt=\"\"></p>\n<h2 id=\"数据清洗\"><a href=\"#数据清洗\" class=\"headerlink\" title=\"数据清洗\"></a>数据清洗</h2><h4 id=\"缺失值\"><a href=\"#缺失值\" class=\"headerlink\" title=\"缺失值\"></a>缺失值</h4><ul>\n<li>忽略元组</li>\n<li>人工填写缺值</li>\n<li>使用全局常量填充 ：比如Unknown </li>\n<li>所有样本的中心值填充：均值或者中位数 均值要求数据对称分布，倾斜分布用中位数</li>\n<li>给定元组的分类相同的样本的均值或者中位数</li>\n<li>最可能的值：使用贝叶斯推理、回归、决策数等进行预测。 前面几种是有偏的，这种方法最常用。</li>\n</ul>\n<h4 id=\"噪声数据\"><a href=\"#噪声数据\" class=\"headerlink\" title=\"噪声数据\"></a>噪声数据</h4><h5 id=\"分箱\"><a href=\"#分箱\" class=\"headerlink\" title=\"分箱\"></a>分箱</h5><p>分箱方法通过考察“邻居”（即，周围的值）来平滑存储数据的值。存储的值被分布到一些“桶”或箱中。由于分箱方法导致值相邻，因此它进行局部平滑。</p>\n<p>要求数据有序因此需要<strong>先进行排序</strong>，有三种方法：</p>\n<ul>\n<li><strong>箱均值光滑</strong>：箱中的每一个值被替换为箱中的均值</li>\n<li><strong>箱中位数光滑：</strong>箱中的每一个值被替换为箱中的中位数</li>\n<li><strong>箱边界光滑：</strong>边界为箱中的最大与最小值，每个值被替换为距离其最近的边界值。</li>\n</ul>\n<p>而箱子的分法有<strong>等频（等深）</strong>：每个箱子中的样本数目一样。<strong>等宽</strong>：按照取值范围将样本划分，每个箱子中的取值范围一致，比如样本数据取值为[0,10]那么可以按照等宽为2，把[0,2),[2,4)这样的取值范围来把样本划分到对应区间所在的范围中。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573992639/blog/Data%20Mining/bin.jpg\" alt=\"\"></p>\n<h5 id=\"回归\"><a href=\"#回归\" class=\"headerlink\" title=\"回归\"></a>回归</h5><p>用函数拟合数据来光滑数据，将离拟合曲线远的数据标记为噪声数据。</p>\n<h5 id=\"聚类\"><a href=\"#聚类\" class=\"headerlink\" title=\"聚类\"></a>聚类</h5><p>使用聚类分析后，检测出离群点，然后把离群点标记为噪声数据。</p>\n<h2 id=\"数据转换\"><a href=\"#数据转换\" class=\"headerlink\" title=\"数据转换\"></a>数据转换</h2><h3 id=\"归一化-规范化\"><a href=\"#归一化-规范化\" class=\"headerlink\" title=\"归一化/规范化\"></a>归一化/规范化</h3><h4 id=\"最大-最小归一化\"><a href=\"#最大-最小归一化\" class=\"headerlink\" title=\"最大-最小归一化\"></a>最大-最小归一化</h4><p>对原始数据进行线性变换，映射到新的区间[new_min, new_max]中去。这种方法保持了原始数据之间的联系。</p>\n<script type=\"math/tex; mode=display\">\nv_i'=\\frac{v_i-min_A}{max_A-min_A}(new\\_max_A-new\\_min_A)</script><h4 id=\"z-score归一化\"><a href=\"#z-score归一化\" class=\"headerlink\" title=\"z-score归一化\"></a>z-score归一化</h4><p>新的值使用均值和标准差进行映射。$\\bar A$和$\\sigma_A$ 分别是样本的均值和他的标准差。</p>\n<script type=\"math/tex; mode=display\">\nv_i'=\\frac{v_i-\\bar A}{\\sigma_A}</script><h4 id=\"小数定标归一化\"><a href=\"#小数定标归一化\" class=\"headerlink\" title=\"小数定标归一化\"></a>小数定标归一化</h4><p>小数定标归一化 Normalization by decimal scaling。移动原来的小数点的位置来进行归一化。</p>\n<script type=\"math/tex; mode=display\">\nv_i'=\\dfrac{v_i}{10^j}</script><p>j是让$Max(|v_i’|&lt;1)$的最小整数，比如如果是254，那么j取3就可以让其为0.254小于1。</p>\n<h2 id=\"冗余与相关性分析\"><a href=\"#冗余与相关性分析\" class=\"headerlink\" title=\"冗余与相关性分析\"></a>冗余与相关性分析</h2><p>一个属性可以由另外的属性导出，那么另外的属性就是冗余的。有些冗余可以通过<strong>相关性分析</strong>来检测</p>\n<h3 id=\"数值数据的相关系数\"><a href=\"#数值数据的相关系数\" class=\"headerlink\" title=\"数值数据的相关系数\"></a>数值数据的相关系数</h3><p>相关系数Correlation coefficient也称作皮尔森积矩系数Pearson’s product moment coefficient估计两个属性A,B的相关度。</p>\n<script type=\"math/tex; mode=display\">\nr_{A.B}=\\dfrac{\\sum_{i=1}^{n}(a_i-\\bar A)(b_i-\\bar B)}{(n-1)\\sigma_A\\sigma_B}=\\dfrac{\\sum_{i=1}^{n}(a_ib_i)-n\\bar A\\bar B}{(n-1)\\sigma_A\\sigma_b}</script><p>$-1\\le r_{A,B}\\le 1$ ,$r_{A,B}&gt;0$ A和B两个属性正相关，A的值随着B的值增长而增长。$r_{A,B}&lt;0$为负相关，A的值随着B的值增长而减少。该值越大，一个属性蕴涵另一个的可能性越大。因此，一个很大的值表明A（或B）可以作为冗余而被去掉。如果结果值等于0，则A 和B 是独立的，它们之间不相关。可以参见前述的散点图。</p>\n<h3 id=\"分类数据的-chi-2-相关检验\"><a href=\"#分类数据的-chi-2-相关检验\" class=\"headerlink\" title=\"分类数据的$\\chi^2$相关检验\"></a>分类数据的$\\chi^2$相关检验</h3><p>分类数据Categorical Data中，两类数据可以通过$\\chi^2$卡方检验来发现它们的相关性。计算公式为：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{split}\n&\\chi^2=\\sum_{i=1}^{c}\\sum_{j=1}^{r}\\dfrac{o_{ij}-e_{ij}}{e_{ij}}\\\\\\\\\n&e_{ij}=\\dfrac{count(A=a_i)\\times count(B=b_j)}{n}\n\\end{split}</script><p>$o_{ij}$ 是联合事件$(A_i,B_j)$的观测频度也就是实际频数，而$e_{ij}$ 是$(A_i,B_j)$的期望值。n是总的数据样本数。使用相依表来表示数据。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573992639/blog/Data%20Mining/rely_table.jpg\" alt=\"\"></p>\n<p>图中括号中的是每个单元的预测值。总共抽取1500个样本，因此n=1500。A类是否喜欢看小说有两类取值，B类性别也有两类取值，因此c=2，r=2。计算单元（男，小说）的预测值有：</p>\n<script type=\"math/tex; mode=display\">\ne_{11}=\\dfrac{count(男)\\times count(小说)}{n}=\\dfrac{300\\times450}{1500}=90</script><p>其他几个单元的预测值都在括号中。因此可以计算出：</p>\n<script type=\"math/tex; mode=display\">\n\\chi^2=\\dfrac{(250-90)^2}{90}+\\dfrac{(50-210)^2}{210}+\\dfrac{(200-360)^2}{360}+\\dfrac{(1000-840)^2}{840}=507.93</script><p>对于这个2*2的表，自由度为（2-1)(2-1)=1。对于自由度1，在0.001的置信水平下，查表得到拒绝假设的值是10.828。算出来的值大与它，因此认为性别和爱看小说不是独立的，是强相关的。</p>\n<h2 id=\"数据归约\"><a href=\"#数据归约\" class=\"headerlink\" title=\"数据归约\"></a>数据归约</h2><p>数据归约技术 Data Reduction可以用来得到数据集的归约表示，它小得多，但仍接近地保持原数据的完整性。</p>\n<p>分为：</p>\n<ul>\n<li>维规约：降维</li>\n<li>数量规约：用替代的、较小的的数据形式替换原始数据。比如只存放数据的模型参数</li>\n<li>数据压缩：通过变换将原始数据压缩，不损失原来的信息叫做无损，否则是有损</li>\n</ul>\n<h3 id=\"维规约\"><a href=\"#维规约\" class=\"headerlink\" title=\"维规约\"></a>维规约</h3><h4 id=\"小波变换\"><a href=\"#小波变换\" class=\"headerlink\" title=\"小波变换\"></a>小波变换</h4><p>DWT）是一种线性信号处理技术，当用于数据向量D 时，将它转换成不同的数值向量小波系数D’。两个向量具有相同的长度。虽然变换后向量维度一样，但是可以仅存放一小部分最强的小波系数，就能保留近似的压缩数据。DWT提供比离散傅利叶DFT更好的有损压缩，DWT 将提供原数据更精确的近似。因此，对于等价的近似，DWT 比DFT 需要的空间小。不像DFT，小波空间局部性相当好，有助于保留局部细节。</p>\n<p>该方法如下：</p>\n<ol>\n<li>输入数据向量的长度L 必须是2 的整数幂。必要时，通过在数据向量后添加0，这一条件可以满足。</li>\n<li>每个变换涉及应用两个函数。第一个使用某种数据平滑，如求和或加权平均。第二个进行加权差分，产生数据的细节特征。</li>\n<li>两个函数作用于输入数据对，产生两个长度为L/2 的数据集。一般地，它们分别代表输入数据的平滑后或低频的版本和它的高频内容。</li>\n<li>两个函数递归地作用于前面循环得到的数据集，直到结果数据集的长度为2。</li>\n<li>由以上迭代得到的数据集中选择值，指定其为数据变换的小波系数。</li>\n</ol>\n<h4 id=\"主成分分析\"><a href=\"#主成分分析\" class=\"headerlink\" title=\"主成分分析\"></a>主成分分析</h4><p>主成分分析PCA 又称Karhunen-Loeve 或K-L 方法）搜索c 个最能代表数据的k-维正交向量；这里c ≤ k。这样，原来的数据投影到一个较小的空间，导致数据压缩。PCA 可以作为一种维归约形式使用。然而，不象属性子集选择通过保留原属性集的一个子集来减少属性集的大小。PCA 通过创建一个替换的、较小的变量集“组合”属性的本质。原数据可以投影到该较小的集合中。</p>\n<p>详解的过程暂时不记录，查看模式识别的教材。<strong>只适用数值数据</strong></p>\n<h4 id=\"属性-特征子集选择\"><a href=\"#属性-特征子集选择\" class=\"headerlink\" title=\"属性/特征子集选择\"></a>属性/特征子集选择</h4><p>也就是降维。使用压缩搜索空间的启发式的算法，典型的是贪心算法。每次找到一个局部的好的属性，剔除掉差的属性。</p>\n<p>属性子集选择的基本启发式方法包括以下技术：</p>\n<ul>\n<li>逐步向前选择：该过程由空属性集开始，选择原属性集中最好的属性，并将它添加到该集合中。</li>\n<li>逐步向后删除：该过程由整个属性集开始。在每一步，删除掉尚在属性集中的最坏属性。</li>\n<li>向前选择和向后删除的结合：向前选择和向后删除方法可以结合在一起，每一步选择一个最好的属性，并在剩余属性中删除一个最坏的属性。</li>\n<li>判定树归纳：判定树算法，如ID3 和C4.5 。</li>\n</ul>\n<h3 id=\"数量规约\"><a href=\"#数量规约\" class=\"headerlink\" title=\"数量规约\"></a>数量规约</h3><h4 id=\"数据立方体集成\"><a href=\"#数据立方体集成\" class=\"headerlink\" title=\"数据立方体集成\"></a>数据立方体集成</h4><p>将数据整理成之前介绍过的数据立方体，把感兴趣的数据整理到基本立方体base cuboid上面。比如如果只关注每个季度的销售数据，那么可以将原来的每天的数据整理成每个季度的销售数据。这样就可以大大减少原来的数据量了。</p>\n<h4 id=\"回归-1\"><a href=\"#回归-1\" class=\"headerlink\" title=\"回归\"></a>回归</h4><p>因为展开内容很多，只记录下有这些方法。当把数据拟合为某一种模型后只用记录这些模型的参数就可以了</p>\n<ul>\n<li>线性回归</li>\n<li>多元线性回归</li>\n<li>对数线性模型</li>\n</ul>\n<h4 id=\"直方图-1\"><a href=\"#直方图-1\" class=\"headerlink\" title=\"直方图\"></a>直方图</h4><p>就是前面叙述的分箱的方法，使用一个桶来记录一个属性的频次。或者等宽的方法，用区间来记录每个区间中的频次。</p>\n<h4 id=\"聚类-1\"><a href=\"#聚类-1\" class=\"headerlink\" title=\"聚类\"></a>聚类</h4><p>聚类后，用数据的簇代表替换实际的数据。即只记录簇的中心点。</p>\n<h4 id=\"抽样\"><a href=\"#抽样\" class=\"headerlink\" title=\"抽样\"></a>抽样</h4><p>假定大的数据集D 包含N 个元组。我们看看对D 的可能选样。</p>\n<p>简单选择n 个样本，不回放(<strong>SRSWOR</strong>)：由D 的N 个元组中抽取n 个样本（n &lt; N）；其中， D中任何元组被抽取的概率均为1/N。即，所有元组是等可能的。</p>\n<p>简单选择n 个样本，回放(<strong>SRSWR</strong>)：该方法类似于SRSWOR，不同在于当一个元组被抽取后，记录它，然后放回去。这样，一个元组被抽取后，它又被放回D，以便它可以再次被抽取。</p>\n<h3 id=\"数据压缩\"><a href=\"#数据压缩\" class=\"headerlink\" title=\"数据压缩\"></a>数据压缩</h3><p>主要使用编码机制来进行压缩。包括字符串、音频、视频的压缩。</p>\n<h3 id=\"数据离散和概念分层\"><a href=\"#数据离散和概念分层\" class=\"headerlink\" title=\"数据离散和概念分层\"></a>数据离散和概念分层</h3><p>可以使用分箱来、聚类、决策树和相关分析来进行离散化。而对于标称数据可以进行概念分层，前面的数据立方体就是用的这个思路。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>《数据挖掘概念与技术》第3版 第三章数据预处理</p>\n","site":{"data":{}},"length":6103,"excerpt":"<h1 id=\"数据预处理\"><a href=\"#数据预处理\" class=\"headerlink\" title=\"数据预处理\"></a>数据预处理</h1><h2 id=\"为什么数据预处理\"><a href=\"#为什么数据预处理\" class=\"headerlink\" title=\"为什么数据预处理\"></a>为什么数据预处理</h2><p>原始数据可能掺杂着噪音、空值或者不正确、不一致、充满冗余值等。没有高质量的数据，很难挖掘出高质量的规则，因此需要数据预处理。数据预处理主要有：数据清洗、数据集成、数据归约、数据离散等几个任务。</p>","more":"<h2 id=\"数据描述\"><a href=\"#数据描述\" class=\"headerlink\" title=\"数据描述\"></a>数据描述</h2><p>得到一份数据后，需要先对数据进行一个大概的认识，主要从中心趋势和发散特征两方面统计进行描述。</p>\n<h3 id=\"中心趋势度量\"><a href=\"#中心趋势度量\" class=\"headerlink\" title=\"中心趋势度量\"></a>中心趋势度量</h3><h4 id=\"平均值-mean\"><a href=\"#平均值-mean\" class=\"headerlink\" title=\"平均值 mean\"></a>平均值 mean</h4><p>均值又分为：</p>\n<ul>\n<li><p>算术均值</p>\n<p> $\\bar x=\\frac{1}{n}\\sum_{i=1}^{n}x_i$</p>\n</li>\n<li><p>加权均值</p>\n<p>$\\bar x= \\frac{\\sum_{i=1}^{n}w_ix_i}{\\sum_{i=1}^{n}w_i}$</p>\n</li>\n<li><p>截尾均值 Trimmed mean</p>\n<p>均值对极端数据比如离群点很敏感。因此截取高低两端的一部分数据后再计算均值，但是截去的部分不能太多不超过$20\\%$</p>\n</li>\n</ul>\n<h4 id=\"中位数-median\"><a href=\"#中位数-median\" class=\"headerlink\" title=\"中位数 median\"></a>中位数 median</h4><p>对于倾斜（非对称）数据，数据中心的更好度量是中位数。</p>\n<p>假定数据有序，则当n为奇数时中位数是中间的值，当n为偶数的时候，中位数不唯一，可以是中间两个值和之间的任意值。如果属性是数值属性，那么一般约定取中间两个值的平均值。</p>\n<h4 id=\"众数-mode\"><a href=\"#众数-mode\" class=\"headerlink\" title=\"众数 mode\"></a>众数 mode</h4><p>另一种中心趋势的度量方法，众数是集合中出现最频繁的值。数据可能会有多个众数，如果最高频的值有多个的时候。如果每个数据值近出现一次，是没有众数的。</p>\n<p>有一个、两个、三个众数的分别称为：单峰的(unimodal)、双峰的（bimodal）和三峰的（trimodal）</p>\n<h4 id=\"中列数-midrange\"><a href=\"#中列数-midrange\" class=\"headerlink\" title=\"中列数 midrange\"></a>中列数 midrange</h4><p>中列数是数据集的最大和最小值的平均值。</p>\n<h4 id=\"对称与倾斜\"><a href=\"#对称与倾斜\" class=\"headerlink\" title=\"对称与倾斜\"></a>对称与倾斜</h4><p>完全对称的数据分布的单峰频率曲线中，均值、中位数和众数三者是相同的中心值。</p>\n<p>不对称的情况分为：</p>\n<ul>\n<li>正倾斜：众数小于中位数</li>\n<li>负倾斜：众数大于中位数</li>\n</ul>\n<p>如下所示,最上方是对称的，左下是正倾斜的，右下是负倾斜的。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573992640/blog/Data%20Mining/symmetric_skewed.jpg\" alt=\"\"></p>\n<h3 id=\"数据散布度量\"><a href=\"#数据散布度量\" class=\"headerlink\" title=\"数据散布度量\"></a>数据散布度量</h3><h4 id=\"极差、四分位数和四分位数极差\"><a href=\"#极差、四分位数和四分位数极差\" class=\"headerlink\" title=\"极差、四分位数和四分位数极差\"></a>极差、四分位数和四分位数极差</h4><p><strong>极差（range）</strong>：最大值与最小值之差。</p>\n<p>有序数据值下的数据集合的第k 个百分位数是具有如下性质的值x：数据项的百分之k 在x 上或低于x。在中位数M上或低于M 的值对应于第50 个百分位数。</p>\n<p><strong>四分位数</strong>将数据分为4段总共有3个四分位数，Q1是第25个百分位数，Q2即是Median是第50个百分位数，Q3是第75个百分位数。</p>\n<p>100-分位数通常称为百分位数，它们把数据分成100个大小相等的连贯集。中位数、四分位数和百分位数是使用最广泛的分位数。</p>\n<p>第一个和第三个四分位数之间的距离是分布的一种简单度量，它给出被数据的中间一半<br>所覆盖的范围。该距离称为中间<strong>四分位数极差（IQR）</strong>：$IQR=Q_3-Q_1$</p>\n<h4 id=\"五数概括、盒图与离群点\"><a href=\"#五数概括、盒图与离群点\" class=\"headerlink\" title=\"五数概括、盒图与离群点\"></a>五数概括、盒图与离群点</h4><p><strong>离群点(Outlier)</strong>：与$Q_1$或者$Q_3$这两个分位数的值超过$1.5IQR$</p>\n<p>五数概括使用最小值、$Q_1$ 、中位数、$Q_3$、最大值来概述数据的中心与散布。</p>\n<p>可以使用盒图来体现五数概括 。</p>\n<ul>\n<li>盒的端点在四分位数上，使得盒的长度是中间四分位数区间IQR</li>\n<li>中位数用盒内的线标记</li>\n<li>盒外的两条线（称作胡须）延伸到最小（Minimum）和最大（Maximum）观测值。如果最大最小值超过$1.5IQR$，那么只延伸到这个部分。</li>\n</ul>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573992640/blog/Data%20Mining/box_plot.jpg\" alt=\"\"></p>\n<p>如上图所示，最大值超过了$1.5IQR$所以只延伸到了$1.5IQR$，而超过$1.5IQR$部分的被标记为离群点。</p>\n<h4 id=\"方差、标准差\"><a href=\"#方差、标准差\" class=\"headerlink\" title=\"方差、标准差\"></a>方差、标准差</h4><p>方差Variance与标准差Standard deviation指出数据分布的散布程度。</p>\n<p>总体方差的计算：$\\sigma^2=\\frac{1}{n}\\sum_{i=1}^{n}(x_i-\\mu)^2={\\frac{1}{n}\\sum_{i=1}^{n}x_i^2}-{\\mu}^2$</p>\n<p>样本方差的计算：$s^2=\\frac{1}{n-1}\\sum_{i=1}^{n}(x_i-\\bar x)^2={\\frac{1}{n-1}（\\sum_{i=1}^{n}x_i^2}-\\frac{1}{n}\\sum_{i=1}^{n}x_i^2）$</p>\n<p>$\\mu$是总体数据的平均值，而$\\bar x$是总体数据中的一部分样本的均值，可以用样本的均值来估计总体的均值。样本方差是无偏估计的，<a href=\"https://www.zhihu.com/question/20099757\" target=\"_blank\" rel=\"noopener\">样本方差与总体方差的差别</a></p>\n<p>标准差是方差的平方根，就是$\\sigma$或者s。它的性质是：</p>\n<ul>\n<li>$\\sigma$<strong>度量关于平均值的发散</strong>，仅当选择平均值作为中心度量时使用。</li>\n<li>仅当不存在发散时，即当所有的观测值都相同时，$\\sigma=0$。否则，$\\sigma&gt;0$。</li>\n</ul>\n<h3 id=\"数据描述的图形表示\"><a href=\"#数据描述的图形表示\" class=\"headerlink\" title=\"数据描述的图形表示\"></a>数据描述的图形表示</h3><h4 id=\"直方图\"><a href=\"#直方图\" class=\"headerlink\" title=\"直方图\"></a>直方图</h4><p>直方图Histogram 或者频率直方图Frequency histograms 针对单变量，对于比较单变量观测组，它可能不如分位数图、q-q 图和盒图方法有效。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573992639/blog/Data%20Mining/histogram.jpg\" alt=\"\"></p>\n<h4 id=\"分位数图\"><a href=\"#分位数图\" class=\"headerlink\" title=\"分位数图\"></a>分位数图</h4><p>分位数图Quantile Plot每个观测值$x_i$与一个百分数$f_i$配对，指出大约$f_i \\times 100\\%$的数据小于值$x_i$，“大约”是因为可能没有一个精确的小数值$f_i$，使得数据的$f_i\\%$小于或等于$x_i$。0.25 分位数对应于Q1，0.50 分位数对应于中位数，而0.75 分位数对应于Q3。</p>\n<p>$f_i$的定义：$f_i=\\frac{i-0.5}{N}$这些数由$\\frac{1}{2N}$（稍大于0）到$1-\\frac{1}{2N}$（稍小于1），以相同的步长1/n 递增。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573992640/blog/Data%20Mining/Quantile_Plot.jpg\" alt=\"\"></p>\n<h4 id=\"分位数-分位数图\"><a href=\"#分位数-分位数图\" class=\"headerlink\" title=\"分位数-分位数图\"></a>分位数-分位数图</h4><p>分位数-分位数图Quantile-Quantile Plot，或q-q 图对着另一个的对应分位数，绘制一个单变量分布的分位数。它是一种强有力的直观表示工具，使得用户可以观察从一个分布到另一个是否有漂移。![]<a href=\"https://res.cloudinary.com/bravey/image/upload/v1573992640/blog/Data%20Mining/qq_plot.jpg\" target=\"_blank\" rel=\"noopener\">https://res.cloudinary.com/bravey/image/upload/v1573992640/blog/Data%20Mining/qq_plot.jpg</a>)</p>\n<p>部门1的分布相对于部门2有一个漂移，更趋向于部门2，说明部门2的单价趋向于比部门1高。</p>\n<h4 id=\"散点图\"><a href=\"#散点图\" class=\"headerlink\" title=\"散点图\"></a>散点图</h4><p>散点图(scatter plot)是确定两个量化变量之间看上去是否有联系、模式或趋势的最有效的图形方法之一。</p>\n<p>它观察的是<strong>双变量</strong>，可以观察点簇和离群点，或者考察相关性。正相关x随着y的增加而增加，负相关x随着y的增长而减少。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573992640/blog/Data%20Mining/scatter_plot.jpg\" alt=\"\"></p>\n<h2 id=\"数据清洗\"><a href=\"#数据清洗\" class=\"headerlink\" title=\"数据清洗\"></a>数据清洗</h2><h4 id=\"缺失值\"><a href=\"#缺失值\" class=\"headerlink\" title=\"缺失值\"></a>缺失值</h4><ul>\n<li>忽略元组</li>\n<li>人工填写缺值</li>\n<li>使用全局常量填充 ：比如Unknown </li>\n<li>所有样本的中心值填充：均值或者中位数 均值要求数据对称分布，倾斜分布用中位数</li>\n<li>给定元组的分类相同的样本的均值或者中位数</li>\n<li>最可能的值：使用贝叶斯推理、回归、决策数等进行预测。 前面几种是有偏的，这种方法最常用。</li>\n</ul>\n<h4 id=\"噪声数据\"><a href=\"#噪声数据\" class=\"headerlink\" title=\"噪声数据\"></a>噪声数据</h4><h5 id=\"分箱\"><a href=\"#分箱\" class=\"headerlink\" title=\"分箱\"></a>分箱</h5><p>分箱方法通过考察“邻居”（即，周围的值）来平滑存储数据的值。存储的值被分布到一些“桶”或箱中。由于分箱方法导致值相邻，因此它进行局部平滑。</p>\n<p>要求数据有序因此需要<strong>先进行排序</strong>，有三种方法：</p>\n<ul>\n<li><strong>箱均值光滑</strong>：箱中的每一个值被替换为箱中的均值</li>\n<li><strong>箱中位数光滑：</strong>箱中的每一个值被替换为箱中的中位数</li>\n<li><strong>箱边界光滑：</strong>边界为箱中的最大与最小值，每个值被替换为距离其最近的边界值。</li>\n</ul>\n<p>而箱子的分法有<strong>等频（等深）</strong>：每个箱子中的样本数目一样。<strong>等宽</strong>：按照取值范围将样本划分，每个箱子中的取值范围一致，比如样本数据取值为[0,10]那么可以按照等宽为2，把[0,2),[2,4)这样的取值范围来把样本划分到对应区间所在的范围中。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573992639/blog/Data%20Mining/bin.jpg\" alt=\"\"></p>\n<h5 id=\"回归\"><a href=\"#回归\" class=\"headerlink\" title=\"回归\"></a>回归</h5><p>用函数拟合数据来光滑数据，将离拟合曲线远的数据标记为噪声数据。</p>\n<h5 id=\"聚类\"><a href=\"#聚类\" class=\"headerlink\" title=\"聚类\"></a>聚类</h5><p>使用聚类分析后，检测出离群点，然后把离群点标记为噪声数据。</p>\n<h2 id=\"数据转换\"><a href=\"#数据转换\" class=\"headerlink\" title=\"数据转换\"></a>数据转换</h2><h3 id=\"归一化-规范化\"><a href=\"#归一化-规范化\" class=\"headerlink\" title=\"归一化/规范化\"></a>归一化/规范化</h3><h4 id=\"最大-最小归一化\"><a href=\"#最大-最小归一化\" class=\"headerlink\" title=\"最大-最小归一化\"></a>最大-最小归一化</h4><p>对原始数据进行线性变换，映射到新的区间[new_min, new_max]中去。这种方法保持了原始数据之间的联系。</p>\n<script type=\"math/tex; mode=display\">\nv_i'=\\frac{v_i-min_A}{max_A-min_A}(new\\_max_A-new\\_min_A)</script><h4 id=\"z-score归一化\"><a href=\"#z-score归一化\" class=\"headerlink\" title=\"z-score归一化\"></a>z-score归一化</h4><p>新的值使用均值和标准差进行映射。$\\bar A$和$\\sigma_A$ 分别是样本的均值和他的标准差。</p>\n<script type=\"math/tex; mode=display\">\nv_i'=\\frac{v_i-\\bar A}{\\sigma_A}</script><h4 id=\"小数定标归一化\"><a href=\"#小数定标归一化\" class=\"headerlink\" title=\"小数定标归一化\"></a>小数定标归一化</h4><p>小数定标归一化 Normalization by decimal scaling。移动原来的小数点的位置来进行归一化。</p>\n<script type=\"math/tex; mode=display\">\nv_i'=\\dfrac{v_i}{10^j}</script><p>j是让$Max(|v_i’|&lt;1)$的最小整数，比如如果是254，那么j取3就可以让其为0.254小于1。</p>\n<h2 id=\"冗余与相关性分析\"><a href=\"#冗余与相关性分析\" class=\"headerlink\" title=\"冗余与相关性分析\"></a>冗余与相关性分析</h2><p>一个属性可以由另外的属性导出，那么另外的属性就是冗余的。有些冗余可以通过<strong>相关性分析</strong>来检测</p>\n<h3 id=\"数值数据的相关系数\"><a href=\"#数值数据的相关系数\" class=\"headerlink\" title=\"数值数据的相关系数\"></a>数值数据的相关系数</h3><p>相关系数Correlation coefficient也称作皮尔森积矩系数Pearson’s product moment coefficient估计两个属性A,B的相关度。</p>\n<script type=\"math/tex; mode=display\">\nr_{A.B}=\\dfrac{\\sum_{i=1}^{n}(a_i-\\bar A)(b_i-\\bar B)}{(n-1)\\sigma_A\\sigma_B}=\\dfrac{\\sum_{i=1}^{n}(a_ib_i)-n\\bar A\\bar B}{(n-1)\\sigma_A\\sigma_b}</script><p>$-1\\le r_{A,B}\\le 1$ ,$r_{A,B}&gt;0$ A和B两个属性正相关，A的值随着B的值增长而增长。$r_{A,B}&lt;0$为负相关，A的值随着B的值增长而减少。该值越大，一个属性蕴涵另一个的可能性越大。因此，一个很大的值表明A（或B）可以作为冗余而被去掉。如果结果值等于0，则A 和B 是独立的，它们之间不相关。可以参见前述的散点图。</p>\n<h3 id=\"分类数据的-chi-2-相关检验\"><a href=\"#分类数据的-chi-2-相关检验\" class=\"headerlink\" title=\"分类数据的$\\chi^2$相关检验\"></a>分类数据的$\\chi^2$相关检验</h3><p>分类数据Categorical Data中，两类数据可以通过$\\chi^2$卡方检验来发现它们的相关性。计算公式为：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{split}\n&\\chi^2=\\sum_{i=1}^{c}\\sum_{j=1}^{r}\\dfrac{o_{ij}-e_{ij}}{e_{ij}}\\\\\\\\\n&e_{ij}=\\dfrac{count(A=a_i)\\times count(B=b_j)}{n}\n\\end{split}</script><p>$o_{ij}$ 是联合事件$(A_i,B_j)$的观测频度也就是实际频数，而$e_{ij}$ 是$(A_i,B_j)$的期望值。n是总的数据样本数。使用相依表来表示数据。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573992639/blog/Data%20Mining/rely_table.jpg\" alt=\"\"></p>\n<p>图中括号中的是每个单元的预测值。总共抽取1500个样本，因此n=1500。A类是否喜欢看小说有两类取值，B类性别也有两类取值，因此c=2，r=2。计算单元（男，小说）的预测值有：</p>\n<script type=\"math/tex; mode=display\">\ne_{11}=\\dfrac{count(男)\\times count(小说)}{n}=\\dfrac{300\\times450}{1500}=90</script><p>其他几个单元的预测值都在括号中。因此可以计算出：</p>\n<script type=\"math/tex; mode=display\">\n\\chi^2=\\dfrac{(250-90)^2}{90}+\\dfrac{(50-210)^2}{210}+\\dfrac{(200-360)^2}{360}+\\dfrac{(1000-840)^2}{840}=507.93</script><p>对于这个2*2的表，自由度为（2-1)(2-1)=1。对于自由度1，在0.001的置信水平下，查表得到拒绝假设的值是10.828。算出来的值大与它，因此认为性别和爱看小说不是独立的，是强相关的。</p>\n<h2 id=\"数据归约\"><a href=\"#数据归约\" class=\"headerlink\" title=\"数据归约\"></a>数据归约</h2><p>数据归约技术 Data Reduction可以用来得到数据集的归约表示，它小得多，但仍接近地保持原数据的完整性。</p>\n<p>分为：</p>\n<ul>\n<li>维规约：降维</li>\n<li>数量规约：用替代的、较小的的数据形式替换原始数据。比如只存放数据的模型参数</li>\n<li>数据压缩：通过变换将原始数据压缩，不损失原来的信息叫做无损，否则是有损</li>\n</ul>\n<h3 id=\"维规约\"><a href=\"#维规约\" class=\"headerlink\" title=\"维规约\"></a>维规约</h3><h4 id=\"小波变换\"><a href=\"#小波变换\" class=\"headerlink\" title=\"小波变换\"></a>小波变换</h4><p>DWT）是一种线性信号处理技术，当用于数据向量D 时，将它转换成不同的数值向量小波系数D’。两个向量具有相同的长度。虽然变换后向量维度一样，但是可以仅存放一小部分最强的小波系数，就能保留近似的压缩数据。DWT提供比离散傅利叶DFT更好的有损压缩，DWT 将提供原数据更精确的近似。因此，对于等价的近似，DWT 比DFT 需要的空间小。不像DFT，小波空间局部性相当好，有助于保留局部细节。</p>\n<p>该方法如下：</p>\n<ol>\n<li>输入数据向量的长度L 必须是2 的整数幂。必要时，通过在数据向量后添加0，这一条件可以满足。</li>\n<li>每个变换涉及应用两个函数。第一个使用某种数据平滑，如求和或加权平均。第二个进行加权差分，产生数据的细节特征。</li>\n<li>两个函数作用于输入数据对，产生两个长度为L/2 的数据集。一般地，它们分别代表输入数据的平滑后或低频的版本和它的高频内容。</li>\n<li>两个函数递归地作用于前面循环得到的数据集，直到结果数据集的长度为2。</li>\n<li>由以上迭代得到的数据集中选择值，指定其为数据变换的小波系数。</li>\n</ol>\n<h4 id=\"主成分分析\"><a href=\"#主成分分析\" class=\"headerlink\" title=\"主成分分析\"></a>主成分分析</h4><p>主成分分析PCA 又称Karhunen-Loeve 或K-L 方法）搜索c 个最能代表数据的k-维正交向量；这里c ≤ k。这样，原来的数据投影到一个较小的空间，导致数据压缩。PCA 可以作为一种维归约形式使用。然而，不象属性子集选择通过保留原属性集的一个子集来减少属性集的大小。PCA 通过创建一个替换的、较小的变量集“组合”属性的本质。原数据可以投影到该较小的集合中。</p>\n<p>详解的过程暂时不记录，查看模式识别的教材。<strong>只适用数值数据</strong></p>\n<h4 id=\"属性-特征子集选择\"><a href=\"#属性-特征子集选择\" class=\"headerlink\" title=\"属性/特征子集选择\"></a>属性/特征子集选择</h4><p>也就是降维。使用压缩搜索空间的启发式的算法，典型的是贪心算法。每次找到一个局部的好的属性，剔除掉差的属性。</p>\n<p>属性子集选择的基本启发式方法包括以下技术：</p>\n<ul>\n<li>逐步向前选择：该过程由空属性集开始，选择原属性集中最好的属性，并将它添加到该集合中。</li>\n<li>逐步向后删除：该过程由整个属性集开始。在每一步，删除掉尚在属性集中的最坏属性。</li>\n<li>向前选择和向后删除的结合：向前选择和向后删除方法可以结合在一起，每一步选择一个最好的属性，并在剩余属性中删除一个最坏的属性。</li>\n<li>判定树归纳：判定树算法，如ID3 和C4.5 。</li>\n</ul>\n<h3 id=\"数量规约\"><a href=\"#数量规约\" class=\"headerlink\" title=\"数量规约\"></a>数量规约</h3><h4 id=\"数据立方体集成\"><a href=\"#数据立方体集成\" class=\"headerlink\" title=\"数据立方体集成\"></a>数据立方体集成</h4><p>将数据整理成之前介绍过的数据立方体，把感兴趣的数据整理到基本立方体base cuboid上面。比如如果只关注每个季度的销售数据，那么可以将原来的每天的数据整理成每个季度的销售数据。这样就可以大大减少原来的数据量了。</p>\n<h4 id=\"回归-1\"><a href=\"#回归-1\" class=\"headerlink\" title=\"回归\"></a>回归</h4><p>因为展开内容很多，只记录下有这些方法。当把数据拟合为某一种模型后只用记录这些模型的参数就可以了</p>\n<ul>\n<li>线性回归</li>\n<li>多元线性回归</li>\n<li>对数线性模型</li>\n</ul>\n<h4 id=\"直方图-1\"><a href=\"#直方图-1\" class=\"headerlink\" title=\"直方图\"></a>直方图</h4><p>就是前面叙述的分箱的方法，使用一个桶来记录一个属性的频次。或者等宽的方法，用区间来记录每个区间中的频次。</p>\n<h4 id=\"聚类-1\"><a href=\"#聚类-1\" class=\"headerlink\" title=\"聚类\"></a>聚类</h4><p>聚类后，用数据的簇代表替换实际的数据。即只记录簇的中心点。</p>\n<h4 id=\"抽样\"><a href=\"#抽样\" class=\"headerlink\" title=\"抽样\"></a>抽样</h4><p>假定大的数据集D 包含N 个元组。我们看看对D 的可能选样。</p>\n<p>简单选择n 个样本，不回放(<strong>SRSWOR</strong>)：由D 的N 个元组中抽取n 个样本（n &lt; N）；其中， D中任何元组被抽取的概率均为1/N。即，所有元组是等可能的。</p>\n<p>简单选择n 个样本，回放(<strong>SRSWR</strong>)：该方法类似于SRSWOR，不同在于当一个元组被抽取后，记录它，然后放回去。这样，一个元组被抽取后，它又被放回D，以便它可以再次被抽取。</p>\n<h3 id=\"数据压缩\"><a href=\"#数据压缩\" class=\"headerlink\" title=\"数据压缩\"></a>数据压缩</h3><p>主要使用编码机制来进行压缩。包括字符串、音频、视频的压缩。</p>\n<h3 id=\"数据离散和概念分层\"><a href=\"#数据离散和概念分层\" class=\"headerlink\" title=\"数据离散和概念分层\"></a>数据离散和概念分层</h3><p>可以使用分箱来、聚类、决策树和相关分析来进行离散化。而对于标称数据可以进行概念分层，前面的数据立方体就是用的这个思路。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>《数据挖掘概念与技术》第3版 第三章数据预处理</p>"},{"title":"聚类方法","date":"2019-11-19T07:44:49.000Z","copyright":true,"mathjax":true,"_content":"\n# 聚类方法\n\n聚类属于无监督学习，因为输入的数据是没有标签的，通过算法每个样本自动的划分到相应的簇中。\n\n## K-means\n\nk均值是一种基于形心的技术。给定一个包含n 个数据对象的数据库，以及要生成的簇的数目k，一个划分类的算法将数据对象组织为k 个划分（k≤n），其中每个划分代表一个簇。通常会采用一个划分准则（经常称为相似度函数，similarity function），例如距离dist(i,j)，以便在同一个簇中的对象是“相似的”，而不同簇中的对象是“相异的”。\n\nK-means把簇的形心定义为簇内点的均值，通过贪心的方法不断迭代形心的坐标，直到形心的坐标不再改变而结束迭代。\n\n<!--more-->\n\n### 步骤\n\n算法的步骤为：\n\n- 首先在数据集D中选择k个对象，每个对象代表一个簇的初试均值即形心。\n- 对剩下的对象，根据其与这个k个形心的欧式距离将其分配到距离最近的形心的簇。\n- 完成了分配后重新计算每个簇的均值中心点并更新。\n- 使用更新后的均值中心点，重新分配每一个对象。\n- 不断迭代，直到本轮的中心点与上一轮的相同，即本轮形成的簇与上一轮相同。\n\n### 伪代码\n\n伪代码为：\n\n![](https://res.cloudinary.com/bravey/image/upload/v1574157674/blog/Data%20Mining/kmeans_code.jpg)\n\n\n\nK-means对离群点敏感，因为当一个离群点被分配到一个簇的时候，可能会严重扭曲簇的均值。\n\nk中心点算法是基于对象的，通过挑选实际的对象来代表簇，其余的对象被分配与其最为相似的代表对象所在的簇。\n\n## 参考\n\n《数据挖掘概念与技术》第3版 第十章聚类分析：基本概念和方法","source":"_posts/2019-11-19-聚类方法.md","raw":"---\ntitle: 聚类方法\ndate: 2019-11-19 15:44:49\ncategories: 数据挖掘\ntags:\n- 聚类\n- K-Means\n- 国科大\n- 课程\ncopyright: true\nmathjax: true\n---\n\n# 聚类方法\n\n聚类属于无监督学习，因为输入的数据是没有标签的，通过算法每个样本自动的划分到相应的簇中。\n\n## K-means\n\nk均值是一种基于形心的技术。给定一个包含n 个数据对象的数据库，以及要生成的簇的数目k，一个划分类的算法将数据对象组织为k 个划分（k≤n），其中每个划分代表一个簇。通常会采用一个划分准则（经常称为相似度函数，similarity function），例如距离dist(i,j)，以便在同一个簇中的对象是“相似的”，而不同簇中的对象是“相异的”。\n\nK-means把簇的形心定义为簇内点的均值，通过贪心的方法不断迭代形心的坐标，直到形心的坐标不再改变而结束迭代。\n\n<!--more-->\n\n### 步骤\n\n算法的步骤为：\n\n- 首先在数据集D中选择k个对象，每个对象代表一个簇的初试均值即形心。\n- 对剩下的对象，根据其与这个k个形心的欧式距离将其分配到距离最近的形心的簇。\n- 完成了分配后重新计算每个簇的均值中心点并更新。\n- 使用更新后的均值中心点，重新分配每一个对象。\n- 不断迭代，直到本轮的中心点与上一轮的相同，即本轮形成的簇与上一轮相同。\n\n### 伪代码\n\n伪代码为：\n\n![](https://res.cloudinary.com/bravey/image/upload/v1574157674/blog/Data%20Mining/kmeans_code.jpg)\n\n\n\nK-means对离群点敏感，因为当一个离群点被分配到一个簇的时候，可能会严重扭曲簇的均值。\n\nk中心点算法是基于对象的，通过挑选实际的对象来代表簇，其余的对象被分配与其最为相似的代表对象所在的簇。\n\n## 参考\n\n《数据挖掘概念与技术》第3版 第十章聚类分析：基本概念和方法","slug":"2019-11-19-聚类方法","published":1,"updated":"2019-11-19T10:02:47.887Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6he13z3001zdstz900nq0mt","content":"<h1 id=\"聚类方法\"><a href=\"#聚类方法\" class=\"headerlink\" title=\"聚类方法\"></a>聚类方法</h1><p>聚类属于无监督学习，因为输入的数据是没有标签的，通过算法每个样本自动的划分到相应的簇中。</p>\n<h2 id=\"K-means\"><a href=\"#K-means\" class=\"headerlink\" title=\"K-means\"></a>K-means</h2><p>k均值是一种基于形心的技术。给定一个包含n 个数据对象的数据库，以及要生成的簇的数目k，一个划分类的算法将数据对象组织为k 个划分（k≤n），其中每个划分代表一个簇。通常会采用一个划分准则（经常称为相似度函数，similarity function），例如距离dist(i,j)，以便在同一个簇中的对象是“相似的”，而不同簇中的对象是“相异的”。</p>\n<p>K-means把簇的形心定义为簇内点的均值，通过贪心的方法不断迭代形心的坐标，直到形心的坐标不再改变而结束迭代。</p>\n<a id=\"more\"></a>\n<h3 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h3><p>算法的步骤为：</p>\n<ul>\n<li>首先在数据集D中选择k个对象，每个对象代表一个簇的初试均值即形心。</li>\n<li>对剩下的对象，根据其与这个k个形心的欧式距离将其分配到距离最近的形心的簇。</li>\n<li>完成了分配后重新计算每个簇的均值中心点并更新。</li>\n<li>使用更新后的均值中心点，重新分配每一个对象。</li>\n<li>不断迭代，直到本轮的中心点与上一轮的相同，即本轮形成的簇与上一轮相同。</li>\n</ul>\n<h3 id=\"伪代码\"><a href=\"#伪代码\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h3><p>伪代码为：</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1574157674/blog/Data%20Mining/kmeans_code.jpg\" alt=\"\"></p>\n<p>K-means对离群点敏感，因为当一个离群点被分配到一个簇的时候，可能会严重扭曲簇的均值。</p>\n<p>k中心点算法是基于对象的，通过挑选实际的对象来代表簇，其余的对象被分配与其最为相似的代表对象所在的簇。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>《数据挖掘概念与技术》第3版 第十章聚类分析：基本概念和方法</p>\n","site":{"data":{}},"length":575,"excerpt":"<h1 id=\"聚类方法\"><a href=\"#聚类方法\" class=\"headerlink\" title=\"聚类方法\"></a>聚类方法</h1><p>聚类属于无监督学习，因为输入的数据是没有标签的，通过算法每个样本自动的划分到相应的簇中。</p>\n<h2 id=\"K-means\"><a href=\"#K-means\" class=\"headerlink\" title=\"K-means\"></a>K-means</h2><p>k均值是一种基于形心的技术。给定一个包含n 个数据对象的数据库，以及要生成的簇的数目k，一个划分类的算法将数据对象组织为k 个划分（k≤n），其中每个划分代表一个簇。通常会采用一个划分准则（经常称为相似度函数，similarity function），例如距离dist(i,j)，以便在同一个簇中的对象是“相似的”，而不同簇中的对象是“相异的”。</p>\n<p>K-means把簇的形心定义为簇内点的均值，通过贪心的方法不断迭代形心的坐标，直到形心的坐标不再改变而结束迭代。</p>","more":"<h3 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h3><p>算法的步骤为：</p>\n<ul>\n<li>首先在数据集D中选择k个对象，每个对象代表一个簇的初试均值即形心。</li>\n<li>对剩下的对象，根据其与这个k个形心的欧式距离将其分配到距离最近的形心的簇。</li>\n<li>完成了分配后重新计算每个簇的均值中心点并更新。</li>\n<li>使用更新后的均值中心点，重新分配每一个对象。</li>\n<li>不断迭代，直到本轮的中心点与上一轮的相同，即本轮形成的簇与上一轮相同。</li>\n</ul>\n<h3 id=\"伪代码\"><a href=\"#伪代码\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h3><p>伪代码为：</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1574157674/blog/Data%20Mining/kmeans_code.jpg\" alt=\"\"></p>\n<p>K-means对离群点敏感，因为当一个离群点被分配到一个簇的时候，可能会严重扭曲簇的均值。</p>\n<p>k中心点算法是基于对象的，通过挑选实际的对象来代表簇，其余的对象被分配与其最为相似的代表对象所在的簇。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>《数据挖掘概念与技术》第3版 第十章聚类分析：基本概念和方法</p>"},{"title":"推荐系统","date":"2019-11-19T08:27:02.000Z","copyright":true,"mathjax":true,"_content":"\n# 推荐系统\n\n## 定义\n\n推荐的基本思路是根据历史数据比如用户以往的喜好或者相似用户的喜好来预测用户未来的喜好。基本假设是：（1）用户的喜好是会保持的并且随着时间而缓慢改变。（2）拥有相同品味的用户对与一个项目的打分也是相似的。因此可以根据以往的历史数据来进行推荐。\n\n与搜索的不同：搜索的数据不是根据用户的资料而定制的，给出的答案是与搜素查询语句相关联的结果。\n\n<!--more-->\n\n## 推荐算法\n\n### 基于内容的方法\n\n基于内容的方法基于这样一个事实：一个用户的兴趣应该和被推荐物品的描述想匹配。核心思路是找到用户资料与物品之间的相似度，推荐相似度高的物品。\n\n步骤为：\n\n- 描述将被推荐的物品I\n- 建立用户个人资料U来描述用户喜欢的物品\n- 比较物品和用户个人资料来决定推荐的物品\n\n用户个人资料与物品的描述可以根据关键词进行向量化。使用例如TF-IDF的方法将物品与个人资料向量话后，就可以计算两者的相似度了。\n\n#### 余弦相似度\n\n使用预先相似度计算这两个向量的相似度。对与两个n维向量X和Y其余弦相似度为：\n$$\nsim(X,Y)=\\dfrac{X\\cdot Y}{||X||\\times ||Y||}\n$$\n分子是点乘，$||X||=\\sqrt {x_1^2+x_2^2+\\dots+x_n^2}$ 是向量的欧几里得范数，也就是向量的长度。\n\n### 协同过滤算法\n\n协同过滤Collaborative Filtering有两中假设\n\n- 基于用户的协同过滤：假设之前对各物品打分相似的用户对于一个新的物品的打分也是相似的\n- 基于物品的协同过滤：假设两个物品的用户打分是相似的，那么一个新用户对二者的打分也是相似的。\n\n算法的步骤是：\n\n- 对所有的用户或物品根据他们与当前的用户或物品的相似度来进行赋权。\n- 选择相邻的用户或者物品的一个自己作为推荐\n- 对于一个用户对一个具体的物品的打分，使用相邻的用户对该物品（或者与该物品相似物品）的打分来预测。\n- 推荐拥有最高预测打分值的物品。\n\n用户/物品之间的相似度可以用余弦相似度或者皮尔森相关系数。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1574157674/blog/Data%20Mining/correlation_coefficient.jpg)\n\n最终的打分的预测更新为：\n\n![](https://res.cloudinary.com/bravey/image/upload/v1574157674/blog/Data%20Mining/update_rating.jpg)\n\n用户u对物品i的打分有原来的该用户的平均打分$\\bar r_u$与和该用户最相似的用户一起决定。\n\n## 例子\n\n![](https://res.cloudinary.com/bravey/image/upload/v1574157674/blog/Data%20Mining/example_1.jpg)\n\n为了预测Jane对Aladdin的打分，第一步首先计算每个用户对电影的平均打分。第二步计算其他4个用户与Jane 的相似度，使用的是余弦相似度并且其他用户对Aladdin的打分不算进去，因此用的是除了Aladdin外的3部电影来计算的。计算出来选择与Jane最相似的2个用户Joe、Jorge。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1574157674/blog/Data%20Mining/example_2.jpg)\n\n根据前面两部计算的结果计算Jane对Aladdin的打分。\n\n## 推荐系统的评测\n\n主要使用精确率，召回率，F1-Score3个指标来进行评价。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1574157674/blog/Data%20Mining/presicion_recall.jpg)\n\nF1-Score的计算方式为：\n$$\nF1-Score = \\dfrac{2Precison\\times Recall}{Precision+Recall}\n$$\n精确率表示所有相关的物品中被推荐出来的比例，召回率表示所有推荐的物品中实际相关的比例，F1-Score则是二者的总体评价。","source":"_posts/2019-11-19-推荐系统.md","raw":"---\ntitle: 推荐系统\ndate: 2019-11-19 16:27:02\ncategories: 数据挖掘\ntags:\n- 国科大\n- 课程\n- 余弦相似度\n- 推荐\ncopyright: true\nmathjax: true\n---\n\n# 推荐系统\n\n## 定义\n\n推荐的基本思路是根据历史数据比如用户以往的喜好或者相似用户的喜好来预测用户未来的喜好。基本假设是：（1）用户的喜好是会保持的并且随着时间而缓慢改变。（2）拥有相同品味的用户对与一个项目的打分也是相似的。因此可以根据以往的历史数据来进行推荐。\n\n与搜索的不同：搜索的数据不是根据用户的资料而定制的，给出的答案是与搜素查询语句相关联的结果。\n\n<!--more-->\n\n## 推荐算法\n\n### 基于内容的方法\n\n基于内容的方法基于这样一个事实：一个用户的兴趣应该和被推荐物品的描述想匹配。核心思路是找到用户资料与物品之间的相似度，推荐相似度高的物品。\n\n步骤为：\n\n- 描述将被推荐的物品I\n- 建立用户个人资料U来描述用户喜欢的物品\n- 比较物品和用户个人资料来决定推荐的物品\n\n用户个人资料与物品的描述可以根据关键词进行向量化。使用例如TF-IDF的方法将物品与个人资料向量话后，就可以计算两者的相似度了。\n\n#### 余弦相似度\n\n使用预先相似度计算这两个向量的相似度。对与两个n维向量X和Y其余弦相似度为：\n$$\nsim(X,Y)=\\dfrac{X\\cdot Y}{||X||\\times ||Y||}\n$$\n分子是点乘，$||X||=\\sqrt {x_1^2+x_2^2+\\dots+x_n^2}$ 是向量的欧几里得范数，也就是向量的长度。\n\n### 协同过滤算法\n\n协同过滤Collaborative Filtering有两中假设\n\n- 基于用户的协同过滤：假设之前对各物品打分相似的用户对于一个新的物品的打分也是相似的\n- 基于物品的协同过滤：假设两个物品的用户打分是相似的，那么一个新用户对二者的打分也是相似的。\n\n算法的步骤是：\n\n- 对所有的用户或物品根据他们与当前的用户或物品的相似度来进行赋权。\n- 选择相邻的用户或者物品的一个自己作为推荐\n- 对于一个用户对一个具体的物品的打分，使用相邻的用户对该物品（或者与该物品相似物品）的打分来预测。\n- 推荐拥有最高预测打分值的物品。\n\n用户/物品之间的相似度可以用余弦相似度或者皮尔森相关系数。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1574157674/blog/Data%20Mining/correlation_coefficient.jpg)\n\n最终的打分的预测更新为：\n\n![](https://res.cloudinary.com/bravey/image/upload/v1574157674/blog/Data%20Mining/update_rating.jpg)\n\n用户u对物品i的打分有原来的该用户的平均打分$\\bar r_u$与和该用户最相似的用户一起决定。\n\n## 例子\n\n![](https://res.cloudinary.com/bravey/image/upload/v1574157674/blog/Data%20Mining/example_1.jpg)\n\n为了预测Jane对Aladdin的打分，第一步首先计算每个用户对电影的平均打分。第二步计算其他4个用户与Jane 的相似度，使用的是余弦相似度并且其他用户对Aladdin的打分不算进去，因此用的是除了Aladdin外的3部电影来计算的。计算出来选择与Jane最相似的2个用户Joe、Jorge。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1574157674/blog/Data%20Mining/example_2.jpg)\n\n根据前面两部计算的结果计算Jane对Aladdin的打分。\n\n## 推荐系统的评测\n\n主要使用精确率，召回率，F1-Score3个指标来进行评价。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1574157674/blog/Data%20Mining/presicion_recall.jpg)\n\nF1-Score的计算方式为：\n$$\nF1-Score = \\dfrac{2Precison\\times Recall}{Precision+Recall}\n$$\n精确率表示所有相关的物品中被推荐出来的比例，召回率表示所有推荐的物品中实际相关的比例，F1-Score则是二者的总体评价。","slug":"2019-11-19-推荐系统","published":1,"updated":"2019-11-19T10:04:32.466Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6he13z50023dstzv0sdd58j","content":"<h1 id=\"推荐系统\"><a href=\"#推荐系统\" class=\"headerlink\" title=\"推荐系统\"></a>推荐系统</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>推荐的基本思路是根据历史数据比如用户以往的喜好或者相似用户的喜好来预测用户未来的喜好。基本假设是：（1）用户的喜好是会保持的并且随着时间而缓慢改变。（2）拥有相同品味的用户对与一个项目的打分也是相似的。因此可以根据以往的历史数据来进行推荐。</p>\n<p>与搜索的不同：搜索的数据不是根据用户的资料而定制的，给出的答案是与搜素查询语句相关联的结果。</p>\n<a id=\"more\"></a>\n<h2 id=\"推荐算法\"><a href=\"#推荐算法\" class=\"headerlink\" title=\"推荐算法\"></a>推荐算法</h2><h3 id=\"基于内容的方法\"><a href=\"#基于内容的方法\" class=\"headerlink\" title=\"基于内容的方法\"></a>基于内容的方法</h3><p>基于内容的方法基于这样一个事实：一个用户的兴趣应该和被推荐物品的描述想匹配。核心思路是找到用户资料与物品之间的相似度，推荐相似度高的物品。</p>\n<p>步骤为：</p>\n<ul>\n<li>描述将被推荐的物品I</li>\n<li>建立用户个人资料U来描述用户喜欢的物品</li>\n<li>比较物品和用户个人资料来决定推荐的物品</li>\n</ul>\n<p>用户个人资料与物品的描述可以根据关键词进行向量化。使用例如TF-IDF的方法将物品与个人资料向量话后，就可以计算两者的相似度了。</p>\n<h4 id=\"余弦相似度\"><a href=\"#余弦相似度\" class=\"headerlink\" title=\"余弦相似度\"></a>余弦相似度</h4><p>使用预先相似度计算这两个向量的相似度。对与两个n维向量X和Y其余弦相似度为：</p>\n<script type=\"math/tex; mode=display\">\nsim(X,Y)=\\dfrac{X\\cdot Y}{||X||\\times ||Y||}</script><p>分子是点乘，$||X||=\\sqrt {x_1^2+x_2^2+\\dots+x_n^2}$ 是向量的欧几里得范数，也就是向量的长度。</p>\n<h3 id=\"协同过滤算法\"><a href=\"#协同过滤算法\" class=\"headerlink\" title=\"协同过滤算法\"></a>协同过滤算法</h3><p>协同过滤Collaborative Filtering有两中假设</p>\n<ul>\n<li>基于用户的协同过滤：假设之前对各物品打分相似的用户对于一个新的物品的打分也是相似的</li>\n<li>基于物品的协同过滤：假设两个物品的用户打分是相似的，那么一个新用户对二者的打分也是相似的。</li>\n</ul>\n<p>算法的步骤是：</p>\n<ul>\n<li>对所有的用户或物品根据他们与当前的用户或物品的相似度来进行赋权。</li>\n<li>选择相邻的用户或者物品的一个自己作为推荐</li>\n<li>对于一个用户对一个具体的物品的打分，使用相邻的用户对该物品（或者与该物品相似物品）的打分来预测。</li>\n<li>推荐拥有最高预测打分值的物品。</li>\n</ul>\n<p>用户/物品之间的相似度可以用余弦相似度或者皮尔森相关系数。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1574157674/blog/Data%20Mining/correlation_coefficient.jpg\" alt=\"\"></p>\n<p>最终的打分的预测更新为：</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1574157674/blog/Data%20Mining/update_rating.jpg\" alt=\"\"></p>\n<p>用户u对物品i的打分有原来的该用户的平均打分$\\bar r_u$与和该用户最相似的用户一起决定。</p>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1574157674/blog/Data%20Mining/example_1.jpg\" alt=\"\"></p>\n<p>为了预测Jane对Aladdin的打分，第一步首先计算每个用户对电影的平均打分。第二步计算其他4个用户与Jane 的相似度，使用的是余弦相似度并且其他用户对Aladdin的打分不算进去，因此用的是除了Aladdin外的3部电影来计算的。计算出来选择与Jane最相似的2个用户Joe、Jorge。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1574157674/blog/Data%20Mining/example_2.jpg\" alt=\"\"></p>\n<p>根据前面两部计算的结果计算Jane对Aladdin的打分。</p>\n<h2 id=\"推荐系统的评测\"><a href=\"#推荐系统的评测\" class=\"headerlink\" title=\"推荐系统的评测\"></a>推荐系统的评测</h2><p>主要使用精确率，召回率，F1-Score3个指标来进行评价。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1574157674/blog/Data%20Mining/presicion_recall.jpg\" alt=\"\"></p>\n<p>F1-Score的计算方式为：</p>\n<script type=\"math/tex; mode=display\">\nF1-Score = \\dfrac{2Precison\\times Recall}{Precision+Recall}</script><p>精确率表示所有相关的物品中被推荐出来的比例，召回率表示所有推荐的物品中实际相关的比例，F1-Score则是二者的总体评价。</p>\n","site":{"data":{}},"length":1196,"excerpt":"<h1 id=\"推荐系统\"><a href=\"#推荐系统\" class=\"headerlink\" title=\"推荐系统\"></a>推荐系统</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>推荐的基本思路是根据历史数据比如用户以往的喜好或者相似用户的喜好来预测用户未来的喜好。基本假设是：（1）用户的喜好是会保持的并且随着时间而缓慢改变。（2）拥有相同品味的用户对与一个项目的打分也是相似的。因此可以根据以往的历史数据来进行推荐。</p>\n<p>与搜索的不同：搜索的数据不是根据用户的资料而定制的，给出的答案是与搜素查询语句相关联的结果。</p>","more":"<h2 id=\"推荐算法\"><a href=\"#推荐算法\" class=\"headerlink\" title=\"推荐算法\"></a>推荐算法</h2><h3 id=\"基于内容的方法\"><a href=\"#基于内容的方法\" class=\"headerlink\" title=\"基于内容的方法\"></a>基于内容的方法</h3><p>基于内容的方法基于这样一个事实：一个用户的兴趣应该和被推荐物品的描述想匹配。核心思路是找到用户资料与物品之间的相似度，推荐相似度高的物品。</p>\n<p>步骤为：</p>\n<ul>\n<li>描述将被推荐的物品I</li>\n<li>建立用户个人资料U来描述用户喜欢的物品</li>\n<li>比较物品和用户个人资料来决定推荐的物品</li>\n</ul>\n<p>用户个人资料与物品的描述可以根据关键词进行向量化。使用例如TF-IDF的方法将物品与个人资料向量话后，就可以计算两者的相似度了。</p>\n<h4 id=\"余弦相似度\"><a href=\"#余弦相似度\" class=\"headerlink\" title=\"余弦相似度\"></a>余弦相似度</h4><p>使用预先相似度计算这两个向量的相似度。对与两个n维向量X和Y其余弦相似度为：</p>\n<script type=\"math/tex; mode=display\">\nsim(X,Y)=\\dfrac{X\\cdot Y}{||X||\\times ||Y||}</script><p>分子是点乘，$||X||=\\sqrt {x_1^2+x_2^2+\\dots+x_n^2}$ 是向量的欧几里得范数，也就是向量的长度。</p>\n<h3 id=\"协同过滤算法\"><a href=\"#协同过滤算法\" class=\"headerlink\" title=\"协同过滤算法\"></a>协同过滤算法</h3><p>协同过滤Collaborative Filtering有两中假设</p>\n<ul>\n<li>基于用户的协同过滤：假设之前对各物品打分相似的用户对于一个新的物品的打分也是相似的</li>\n<li>基于物品的协同过滤：假设两个物品的用户打分是相似的，那么一个新用户对二者的打分也是相似的。</li>\n</ul>\n<p>算法的步骤是：</p>\n<ul>\n<li>对所有的用户或物品根据他们与当前的用户或物品的相似度来进行赋权。</li>\n<li>选择相邻的用户或者物品的一个自己作为推荐</li>\n<li>对于一个用户对一个具体的物品的打分，使用相邻的用户对该物品（或者与该物品相似物品）的打分来预测。</li>\n<li>推荐拥有最高预测打分值的物品。</li>\n</ul>\n<p>用户/物品之间的相似度可以用余弦相似度或者皮尔森相关系数。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1574157674/blog/Data%20Mining/correlation_coefficient.jpg\" alt=\"\"></p>\n<p>最终的打分的预测更新为：</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1574157674/blog/Data%20Mining/update_rating.jpg\" alt=\"\"></p>\n<p>用户u对物品i的打分有原来的该用户的平均打分$\\bar r_u$与和该用户最相似的用户一起决定。</p>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1574157674/blog/Data%20Mining/example_1.jpg\" alt=\"\"></p>\n<p>为了预测Jane对Aladdin的打分，第一步首先计算每个用户对电影的平均打分。第二步计算其他4个用户与Jane 的相似度，使用的是余弦相似度并且其他用户对Aladdin的打分不算进去，因此用的是除了Aladdin外的3部电影来计算的。计算出来选择与Jane最相似的2个用户Joe、Jorge。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1574157674/blog/Data%20Mining/example_2.jpg\" alt=\"\"></p>\n<p>根据前面两部计算的结果计算Jane对Aladdin的打分。</p>\n<h2 id=\"推荐系统的评测\"><a href=\"#推荐系统的评测\" class=\"headerlink\" title=\"推荐系统的评测\"></a>推荐系统的评测</h2><p>主要使用精确率，召回率，F1-Score3个指标来进行评价。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1574157674/blog/Data%20Mining/presicion_recall.jpg\" alt=\"\"></p>\n<p>F1-Score的计算方式为：</p>\n<script type=\"math/tex; mode=display\">\nF1-Score = \\dfrac{2Precison\\times Recall}{Precision+Recall}</script><p>精确率表示所有相关的物品中被推荐出来的比例，召回率表示所有推荐的物品中实际相关的比例，F1-Score则是二者的总体评价。</p>"},{"title":"leetcode153 154 Find Minimum in Rotated Sorted Array I/II","date":"2019-11-22T13:07:54.000Z","copyright":true,"_content":"\n# leetcode153 154. Find Minimum in Rotated Sorted Array I/II\n\n题目来源[leetcode153](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/) 和[leetcode154](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/) 要求在排序的旋转数组中寻找最小值。最小值可以很简单的遍历一次数组得到，时间复杂度为$O(n)$但是没有用到题目给的性质，所以会超时。\n\n<!--more-->\n\n## 解题思路\n\n### leetcode153 无重复元素\n\n先分析leetcode153中没有重复值的情况，采用二分查找的思路，设输入的数组长度为n表示为$A[n]$,经过观察可以发现pivot将A划分成了两个递增子数组L，R。使用指针p指向A的第一个元素A[0],指针q指向A的最后一个元素$A[n-1]$,使用指针m指向A的中间元素$A[\\frac{n}{2}]$。如果中间元素位于第一个递增数组L，则有关系：A[p]<A[m],A[m]>A[q],此时最小元素在m与q之间，将p移动到m，原来规模为n的问题变成规模为$q-m=\\frac{n}{2}$的子问题。如果中间元素位于第二个递增数组R，则有关系：A[p]>A[m],A[m]<A[q],此时最小元素在p与m之间，将q移动到m，原来规模为n的问题变成规模为$m-p=\\frac{n}{2}$的子问题。直到最后q=p+1时，问题规模下降到2的情况，得到答案最小的元素为q指针指向的元素。可以看到每一次迭代，都会将n规模的问题下降到$\\frac{n}{2}$规模。\n\n### leetcode154 有重复元素\n\n在有重复值的情况下，会出现$A[m]==A[p]$的情况，这个时候是无法判断到底左右两边谁为递增序列。如\n$$\n[2, 2, 2, 2, 1,1,1, 2]\n$$\n这时候的$A[m]==A[3]$与$A[p]==A[0]$是相等的都是2，所以只能把两边的最小值，递归的调用求解出来。\n\n## 复杂度\n\n### leetcode153 无重复元素\n\n可以画出递归图:\n\n![](https://res.cloudinary.com/bravey/image/upload/v1574430318/blog/coding/leetcode_153_reduction_graph.jpg )\n\n用$T(n)​$表示对于一个长度为n的旋转数组进行查找最小值需要的次数，对于每一次迭代都有$T[n]=T[{\\lfloor\\frac{n}{2}\\rfloor]+C}​$,C是一个常数。所以有\n$$\n\\begin{split}\n\nT(n)&=T[{\\lfloor\\frac{n}{2}\\rfloor]+C}\\\\\n\n&=T[{\\lfloor\\frac{n}{2^2}\\rfloor]+2C}\\\\\n\n&=T[{\\lfloor\\frac{n}{2^3}\\rfloor]+3C}\\\\\n\n\\dots\\\\\n\n&=T[{\\lfloor\\frac{n}{2^k}\\rfloor]+kC}\\\\\n\n\\end{split}\n$$\n\n设在第k次迭代的时候长度下降到2，  此时有$\\frac{n}{2^k}=2$解出$k=\\log_2n-1$，所以有$T[n]=(\\log_2n-1)C=O(\\log_2n)$，所以算法的时间复杂度为$O(logn)$\n\n### leetcode154 有重复元素\n\n最坏的情况，当出现$A[m]==A[p]$的情况的时候有递推表达式：\n$$\n\\begin{split}\nT(n)&=2T[{\\lfloor\\frac{n}{2}\\rfloor]+C}\\\\\n&=2^2T[{\\lfloor\\frac{n}{2^2}\\rfloor]+C+2C}\\\\\n&=2^3T[{\\lfloor\\frac{n}{2^3}\\rfloor]+C+2C+2C}\\\\\n\\dots\\\\\n&=2^kT[{\\lfloor\\frac{n}{2^k}\\rfloor]+(2k-1)C}\\\\\n\\end{split} \n$$\n设当第k次的时候下降到n=1，因此有$\\frac{n}{2^k}=1$推出$k=\\log_2n$所以有$T(n)=n+(2\\log_2n-1)C=O(n)$,所以时间复杂度为O(n)。如果没有出现$A[m]==A[p]$的情况则和无重复值的情况一样，时间复杂度为$O(n)$\n\n## 代码\n\n使用迭代和循环两种方式实现。 循环的时候比较的选择？mid是该和左边还是右边比呢？我自己写的是和左边的比，但是我看leetcode的题解都是和右边的比。\n\n### leetcode153 无重复元素\n\n```c++\n/*leetcode#153\nhttps://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/*/\n#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\n#include<utility>\n#include <string>\n#include <stdio.h>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int findMin(vector<int>& nums) {\n        int len = nums.size();\n        if(len==1 || nums[0]<nums[len-1]) return nums[0];//长度为1的时候或者不旋转的时候直接返回\n        // return dc_find(nums, 0, len-1);\n        return loop_find(nums, 0, len-1);\n    }\nprivate:\n\tint dc_find(vector<int>& nums, int lo, int hi){\n\t\tif((hi -lo)==1) return nums[hi];\n\t\tint ans = 0;\n\t\tint mid = lo + (hi -lo)/2;\n\t\tif(nums[mid]>nums[lo]) ans = dc_find(nums, mid, hi);\n\t\telse ans = dc_find(nums, lo, mid);\n\t\treturn ans;\n\t}\n\tint loop_find(vector<int>& nums, int lo, int hi){\n\t\tint ans = 0;\n\t\tint mid = 0;\n\t\twhile(lo<hi){\n\t\t\tif((hi-lo)==1) {\n\t\t\t\tans = nums[hi];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmid = lo + (hi -lo)/2;\n\t\t\tif(nums[mid]>nums[lo]) lo = mid ;\n\t\t\telse hi = mid ;\n\t\t}\n\t\treturn ans;\n\t}\n};\n\nint main(int argc, char const *argv[])\n{\n\t/* code */\n\tios::sync_with_stdio(false);\n\tstd::vector<int> vec = {3, 4, 5, 1, 2};\n\tSolution Sol;\n\tcout<<Sol.findMin(vec)<<endl;\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n### leetcode154 有重复元素\n\n```c++\n/*\nleetcode#154\nhttps://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/\n*/\n#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\n#include<utility>\n#include <string>\n#include <stdio.h>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int findMin(vector<int>& nums) {\n        int len = nums.size();\n        if(len==1 || nums[0]<nums[len-1]) return nums[0];\n        return dc_find(nums, 0, len-1);\n    }\nprivate:\n\tint dc_find(vector<int>& nums, int lo, int hi){\n\t\tif((hi -lo)==1) return min(nums[lo], nums[hi]);// 与无重复值的情况不同\n\t\tint ans = 0;\n\t\tint mid = lo + (hi -lo)/2;\n\t\tif(nums[mid]>nums[lo]) ans = dc_find(nums, mid, hi);\n\t\telse if (nums[mid]==nums[lo]){\n\t\t\tans = min(dc_find(nums, lo, mid), dc_find(nums, mid, hi));\n\t\t}\n\t\telse ans = dc_find(nums, lo, mid);\n\t\treturn ans;\n\t}\n    \n};\n\nint main(int argc, char const *argv[])\n{\n\t/* code */\n\tios::sync_with_stdio(false);\n\tstd::vector<int> vec = {2, 2, 2, 1, 1 ,2 };\n\tSolution Sol;\n\tcout<<Sol.findMin(vec)<<endl;\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n需要注意的是：`if((hi -lo)==1) return min(nums[lo], nums[hi]);` 递归的退出条件， 与无重复值的情况不同是可能出现只有两个值的时候最小值在左边的情况，所以需要比较最小值，而不是直接返回第二个。比如$[2,3,2]$ 的情况，划分为两个子问题$[2, 3] 与[3,2]$第一个子问题的时候最小值在第一个元素。","source":"_posts/2019-11-22-leetcode153-154-Find-Minimum-in-Rotated-Sorted-Array-III.md","raw":"---\ntitle: leetcode153 154 Find Minimum in Rotated Sorted Array I/II\ndate: 2019-11-22 21:07:54\ncategories: 题解\ntags:\n- leetcode\n- 数组\n- 最小值\n- 分治\n- 二分查找\ncopyright: true\n---\n\n# leetcode153 154. Find Minimum in Rotated Sorted Array I/II\n\n题目来源[leetcode153](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/) 和[leetcode154](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/) 要求在排序的旋转数组中寻找最小值。最小值可以很简单的遍历一次数组得到，时间复杂度为$O(n)$但是没有用到题目给的性质，所以会超时。\n\n<!--more-->\n\n## 解题思路\n\n### leetcode153 无重复元素\n\n先分析leetcode153中没有重复值的情况，采用二分查找的思路，设输入的数组长度为n表示为$A[n]$,经过观察可以发现pivot将A划分成了两个递增子数组L，R。使用指针p指向A的第一个元素A[0],指针q指向A的最后一个元素$A[n-1]$,使用指针m指向A的中间元素$A[\\frac{n}{2}]$。如果中间元素位于第一个递增数组L，则有关系：A[p]<A[m],A[m]>A[q],此时最小元素在m与q之间，将p移动到m，原来规模为n的问题变成规模为$q-m=\\frac{n}{2}$的子问题。如果中间元素位于第二个递增数组R，则有关系：A[p]>A[m],A[m]<A[q],此时最小元素在p与m之间，将q移动到m，原来规模为n的问题变成规模为$m-p=\\frac{n}{2}$的子问题。直到最后q=p+1时，问题规模下降到2的情况，得到答案最小的元素为q指针指向的元素。可以看到每一次迭代，都会将n规模的问题下降到$\\frac{n}{2}$规模。\n\n### leetcode154 有重复元素\n\n在有重复值的情况下，会出现$A[m]==A[p]$的情况，这个时候是无法判断到底左右两边谁为递增序列。如\n$$\n[2, 2, 2, 2, 1,1,1, 2]\n$$\n这时候的$A[m]==A[3]$与$A[p]==A[0]$是相等的都是2，所以只能把两边的最小值，递归的调用求解出来。\n\n## 复杂度\n\n### leetcode153 无重复元素\n\n可以画出递归图:\n\n![](https://res.cloudinary.com/bravey/image/upload/v1574430318/blog/coding/leetcode_153_reduction_graph.jpg )\n\n用$T(n)​$表示对于一个长度为n的旋转数组进行查找最小值需要的次数，对于每一次迭代都有$T[n]=T[{\\lfloor\\frac{n}{2}\\rfloor]+C}​$,C是一个常数。所以有\n$$\n\\begin{split}\n\nT(n)&=T[{\\lfloor\\frac{n}{2}\\rfloor]+C}\\\\\n\n&=T[{\\lfloor\\frac{n}{2^2}\\rfloor]+2C}\\\\\n\n&=T[{\\lfloor\\frac{n}{2^3}\\rfloor]+3C}\\\\\n\n\\dots\\\\\n\n&=T[{\\lfloor\\frac{n}{2^k}\\rfloor]+kC}\\\\\n\n\\end{split}\n$$\n\n设在第k次迭代的时候长度下降到2，  此时有$\\frac{n}{2^k}=2$解出$k=\\log_2n-1$，所以有$T[n]=(\\log_2n-1)C=O(\\log_2n)$，所以算法的时间复杂度为$O(logn)$\n\n### leetcode154 有重复元素\n\n最坏的情况，当出现$A[m]==A[p]$的情况的时候有递推表达式：\n$$\n\\begin{split}\nT(n)&=2T[{\\lfloor\\frac{n}{2}\\rfloor]+C}\\\\\n&=2^2T[{\\lfloor\\frac{n}{2^2}\\rfloor]+C+2C}\\\\\n&=2^3T[{\\lfloor\\frac{n}{2^3}\\rfloor]+C+2C+2C}\\\\\n\\dots\\\\\n&=2^kT[{\\lfloor\\frac{n}{2^k}\\rfloor]+(2k-1)C}\\\\\n\\end{split} \n$$\n设当第k次的时候下降到n=1，因此有$\\frac{n}{2^k}=1$推出$k=\\log_2n$所以有$T(n)=n+(2\\log_2n-1)C=O(n)$,所以时间复杂度为O(n)。如果没有出现$A[m]==A[p]$的情况则和无重复值的情况一样，时间复杂度为$O(n)$\n\n## 代码\n\n使用迭代和循环两种方式实现。 循环的时候比较的选择？mid是该和左边还是右边比呢？我自己写的是和左边的比，但是我看leetcode的题解都是和右边的比。\n\n### leetcode153 无重复元素\n\n```c++\n/*leetcode#153\nhttps://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/*/\n#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\n#include<utility>\n#include <string>\n#include <stdio.h>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int findMin(vector<int>& nums) {\n        int len = nums.size();\n        if(len==1 || nums[0]<nums[len-1]) return nums[0];//长度为1的时候或者不旋转的时候直接返回\n        // return dc_find(nums, 0, len-1);\n        return loop_find(nums, 0, len-1);\n    }\nprivate:\n\tint dc_find(vector<int>& nums, int lo, int hi){\n\t\tif((hi -lo)==1) return nums[hi];\n\t\tint ans = 0;\n\t\tint mid = lo + (hi -lo)/2;\n\t\tif(nums[mid]>nums[lo]) ans = dc_find(nums, mid, hi);\n\t\telse ans = dc_find(nums, lo, mid);\n\t\treturn ans;\n\t}\n\tint loop_find(vector<int>& nums, int lo, int hi){\n\t\tint ans = 0;\n\t\tint mid = 0;\n\t\twhile(lo<hi){\n\t\t\tif((hi-lo)==1) {\n\t\t\t\tans = nums[hi];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmid = lo + (hi -lo)/2;\n\t\t\tif(nums[mid]>nums[lo]) lo = mid ;\n\t\t\telse hi = mid ;\n\t\t}\n\t\treturn ans;\n\t}\n};\n\nint main(int argc, char const *argv[])\n{\n\t/* code */\n\tios::sync_with_stdio(false);\n\tstd::vector<int> vec = {3, 4, 5, 1, 2};\n\tSolution Sol;\n\tcout<<Sol.findMin(vec)<<endl;\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n### leetcode154 有重复元素\n\n```c++\n/*\nleetcode#154\nhttps://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/\n*/\n#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\n#include<utility>\n#include <string>\n#include <stdio.h>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int findMin(vector<int>& nums) {\n        int len = nums.size();\n        if(len==1 || nums[0]<nums[len-1]) return nums[0];\n        return dc_find(nums, 0, len-1);\n    }\nprivate:\n\tint dc_find(vector<int>& nums, int lo, int hi){\n\t\tif((hi -lo)==1) return min(nums[lo], nums[hi]);// 与无重复值的情况不同\n\t\tint ans = 0;\n\t\tint mid = lo + (hi -lo)/2;\n\t\tif(nums[mid]>nums[lo]) ans = dc_find(nums, mid, hi);\n\t\telse if (nums[mid]==nums[lo]){\n\t\t\tans = min(dc_find(nums, lo, mid), dc_find(nums, mid, hi));\n\t\t}\n\t\telse ans = dc_find(nums, lo, mid);\n\t\treturn ans;\n\t}\n    \n};\n\nint main(int argc, char const *argv[])\n{\n\t/* code */\n\tios::sync_with_stdio(false);\n\tstd::vector<int> vec = {2, 2, 2, 1, 1 ,2 };\n\tSolution Sol;\n\tcout<<Sol.findMin(vec)<<endl;\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n需要注意的是：`if((hi -lo)==1) return min(nums[lo], nums[hi]);` 递归的退出条件， 与无重复值的情况不同是可能出现只有两个值的时候最小值在左边的情况，所以需要比较最小值，而不是直接返回第二个。比如$[2,3,2]$ 的情况，划分为两个子问题$[2, 3] 与[3,2]$第一个子问题的时候最小值在第一个元素。","slug":"2019-11-22-leetcode153-154-Find-Minimum-in-Rotated-Sorted-Array-III","published":1,"updated":"2019-11-28T03:40:41.687Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6he13z60025dstz240gyadr","content":"<h1 id=\"leetcode153-154-Find-Minimum-in-Rotated-Sorted-Array-I-II\"><a href=\"#leetcode153-154-Find-Minimum-in-Rotated-Sorted-Array-I-II\" class=\"headerlink\" title=\"leetcode153 154. Find Minimum in Rotated Sorted Array I/II\"></a>leetcode153 154. Find Minimum in Rotated Sorted Array I/II</h1><p>题目来源<a href=\"https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/\" target=\"_blank\" rel=\"noopener\">leetcode153</a> 和<a href=\"https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/\" target=\"_blank\" rel=\"noopener\">leetcode154</a> 要求在排序的旋转数组中寻找最小值。最小值可以很简单的遍历一次数组得到，时间复杂度为$O(n)$但是没有用到题目给的性质，所以会超时。</p>\n<a id=\"more\"></a>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><h3 id=\"leetcode153-无重复元素\"><a href=\"#leetcode153-无重复元素\" class=\"headerlink\" title=\"leetcode153 无重复元素\"></a>leetcode153 无重复元素</h3><p>先分析leetcode153中没有重复值的情况，采用二分查找的思路，设输入的数组长度为n表示为$A[n]$,经过观察可以发现pivot将A划分成了两个递增子数组L，R。使用指针p指向A的第一个元素A[0],指针q指向A的最后一个元素$A[n-1]$,使用指针m指向A的中间元素$A[\\frac{n}{2}]$。如果中间元素位于第一个递增数组L，则有关系：A[p]<a[m],a[m]>A[q],此时最小元素在m与q之间，将p移动到m，原来规模为n的问题变成规模为$q-m=\\frac{n}{2}$的子问题。如果中间元素位于第二个递增数组R，则有关系：A[p]&gt;A[m],A[m]&lt;A[q],此时最小元素在p与m之间，将q移动到m，原来规模为n的问题变成规模为$m-p=\\frac{n}{2}$的子问题。直到最后q=p+1时，问题规模下降到2的情况，得到答案最小的元素为q指针指向的元素。可以看到每一次迭代，都会将n规模的问题下降到$\\frac{n}{2}$规模。</a[m],a[m]></p>\n<h3 id=\"leetcode154-有重复元素\"><a href=\"#leetcode154-有重复元素\" class=\"headerlink\" title=\"leetcode154 有重复元素\"></a>leetcode154 有重复元素</h3><p>在有重复值的情况下，会出现$A[m]==A[p]$的情况，这个时候是无法判断到底左右两边谁为递增序列。如</p>\n<script type=\"math/tex; mode=display\">\n[2, 2, 2, 2, 1,1,1, 2]</script><p>这时候的$A[m]==A[3]$与$A[p]==A[0]$是相等的都是2，所以只能把两边的最小值，递归的调用求解出来。</p>\n<h2 id=\"复杂度\"><a href=\"#复杂度\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h2><h3 id=\"leetcode153-无重复元素-1\"><a href=\"#leetcode153-无重复元素-1\" class=\"headerlink\" title=\"leetcode153 无重复元素\"></a>leetcode153 无重复元素</h3><p>可以画出递归图:</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1574430318/blog/coding/leetcode_153_reduction_graph.jpg\" alt=\"\"></p>\n<p>用$T(n)​$表示对于一个长度为n的旋转数组进行查找最小值需要的次数，对于每一次迭代都有$T[n]=T[{\\lfloor\\frac{n}{2}\\rfloor]+C}​$,C是一个常数。所以有</p>\n<script type=\"math/tex; mode=display\">\n\\begin{split}\n\nT(n)&=T[{\\lfloor\\frac{n}{2}\\rfloor]+C}\\\\\n\n&=T[{\\lfloor\\frac{n}{2^2}\\rfloor]+2C}\\\\\n\n&=T[{\\lfloor\\frac{n}{2^3}\\rfloor]+3C}\\\\\n\n\\dots\\\\\n\n&=T[{\\lfloor\\frac{n}{2^k}\\rfloor]+kC}\\\\\n\n\\end{split}</script><p>设在第k次迭代的时候长度下降到2，  此时有$\\frac{n}{2^k}=2$解出$k=\\log_2n-1$，所以有$T[n]=(\\log_2n-1)C=O(\\log_2n)$，所以算法的时间复杂度为$O(logn)$</p>\n<h3 id=\"leetcode154-有重复元素-1\"><a href=\"#leetcode154-有重复元素-1\" class=\"headerlink\" title=\"leetcode154 有重复元素\"></a>leetcode154 有重复元素</h3><p>最坏的情况，当出现$A[m]==A[p]$的情况的时候有递推表达式：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{split}\nT(n)&=2T[{\\lfloor\\frac{n}{2}\\rfloor]+C}\\\\\n&=2^2T[{\\lfloor\\frac{n}{2^2}\\rfloor]+C+2C}\\\\\n&=2^3T[{\\lfloor\\frac{n}{2^3}\\rfloor]+C+2C+2C}\\\\\n\\dots\\\\\n&=2^kT[{\\lfloor\\frac{n}{2^k}\\rfloor]+(2k-1)C}\\\\\n\\end{split}</script><p>设当第k次的时候下降到n=1，因此有$\\frac{n}{2^k}=1$推出$k=\\log_2n$所以有$T(n)=n+(2\\log_2n-1)C=O(n)$,所以时间复杂度为O(n)。如果没有出现$A[m]==A[p]$的情况则和无重复值的情况一样，时间复杂度为$O(n)$</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>使用迭代和循环两种方式实现。 循环的时候比较的选择？mid是该和左边还是右边比呢？我自己写的是和左边的比，但是我看leetcode的题解都是和右边的比。</p>\n<h3 id=\"leetcode153-无重复元素-2\"><a href=\"#leetcode153-无重复元素-2\" class=\"headerlink\" title=\"leetcode153 无重复元素\"></a>leetcode153 无重复元素</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*leetcode#153</span></span><br><span class=\"line\"><span class=\"comment\">https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/*/</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;utility&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findMin</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = nums.size();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(len==<span class=\"number\">1</span> || nums[<span class=\"number\">0</span>]&lt;nums[len<span class=\"number\">-1</span>]) <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>];<span class=\"comment\">//长度为1的时候或者不旋转的时候直接返回</span></span><br><span class=\"line\">        <span class=\"comment\">// return dc_find(nums, 0, len-1);</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> loop_find(nums, <span class=\"number\">0</span>, len<span class=\"number\">-1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dc_find</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>((hi -lo)==<span class=\"number\">1</span>) <span class=\"keyword\">return</span> nums[hi];</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> mid = lo + (hi -lo)/<span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(nums[mid]&gt;nums[lo]) ans = dc_find(nums, mid, hi);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> ans = dc_find(nums, lo, mid);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">loop_find</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> mid = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(lo&lt;hi)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>((hi-lo)==<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t\t\tans = nums[hi];</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tmid = lo + (hi -lo)/<span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(nums[mid]&gt;nums[lo]) lo = mid ;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> hi = mid ;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">/* code */</span></span><br><span class=\"line\">\tios::sync_with_stdio(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec = &#123;<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">\tSolution Sol;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;Sol.findMin(vec)&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\tsystem(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"leetcode154-有重复元素-2\"><a href=\"#leetcode154-有重复元素-2\" class=\"headerlink\" title=\"leetcode154 有重复元素\"></a>leetcode154 有重复元素</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">leetcode#154</span></span><br><span class=\"line\"><span class=\"comment\">https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;utility&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findMin</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = nums.size();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(len==<span class=\"number\">1</span> || nums[<span class=\"number\">0</span>]&lt;nums[len<span class=\"number\">-1</span>]) <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dc_find(nums, <span class=\"number\">0</span>, len<span class=\"number\">-1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dc_find</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>((hi -lo)==<span class=\"number\">1</span>) <span class=\"keyword\">return</span> min(nums[lo], nums[hi]);<span class=\"comment\">// 与无重复值的情况不同</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> mid = lo + (hi -lo)/<span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(nums[mid]&gt;nums[lo]) ans = dc_find(nums, mid, hi);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid]==nums[lo])&#123;</span><br><span class=\"line\">\t\t\tans = min(dc_find(nums, lo, mid), dc_find(nums, mid, hi));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> ans = dc_find(nums, lo, mid);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">/* code */</span></span><br><span class=\"line\">\tios::sync_with_stdio(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec = &#123;<span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span> ,<span class=\"number\">2</span> &#125;;</span><br><span class=\"line\">\tSolution Sol;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;Sol.findMin(vec)&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\tsystem(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要注意的是：<code>if((hi -lo)==1) return min(nums[lo], nums[hi]);</code> 递归的退出条件， 与无重复值的情况不同是可能出现只有两个值的时候最小值在左边的情况，所以需要比较最小值，而不是直接返回第二个。比如$[2,3,2]$ 的情况，划分为两个子问题$[2, 3] 与[3,2]$第一个子问题的时候最小值在第一个元素。</p>\n","site":{"data":{}},"length":4138,"excerpt":"<h1 id=\"leetcode153-154-Find-Minimum-in-Rotated-Sorted-Array-I-II\"><a href=\"#leetcode153-154-Find-Minimum-in-Rotated-Sorted-Array-I-II\" class=\"headerlink\" title=\"leetcode153 154. Find Minimum in Rotated Sorted Array I/II\"></a>leetcode153 154. Find Minimum in Rotated Sorted Array I/II</h1><p>题目来源<a href=\"https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/\" target=\"_blank\" rel=\"noopener\">leetcode153</a> 和<a href=\"https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/\" target=\"_blank\" rel=\"noopener\">leetcode154</a> 要求在排序的旋转数组中寻找最小值。最小值可以很简单的遍历一次数组得到，时间复杂度为$O(n)$但是没有用到题目给的性质，所以会超时。</p>","more":"<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><h3 id=\"leetcode153-无重复元素\"><a href=\"#leetcode153-无重复元素\" class=\"headerlink\" title=\"leetcode153 无重复元素\"></a>leetcode153 无重复元素</h3><p>先分析leetcode153中没有重复值的情况，采用二分查找的思路，设输入的数组长度为n表示为$A[n]$,经过观察可以发现pivot将A划分成了两个递增子数组L，R。使用指针p指向A的第一个元素A[0],指针q指向A的最后一个元素$A[n-1]$,使用指针m指向A的中间元素$A[\\frac{n}{2}]$。如果中间元素位于第一个递增数组L，则有关系：A[p]<a[m],a[m]>A[q],此时最小元素在m与q之间，将p移动到m，原来规模为n的问题变成规模为$q-m=\\frac{n}{2}$的子问题。如果中间元素位于第二个递增数组R，则有关系：A[p]&gt;A[m],A[m]&lt;A[q],此时最小元素在p与m之间，将q移动到m，原来规模为n的问题变成规模为$m-p=\\frac{n}{2}$的子问题。直到最后q=p+1时，问题规模下降到2的情况，得到答案最小的元素为q指针指向的元素。可以看到每一次迭代，都会将n规模的问题下降到$\\frac{n}{2}$规模。</a[m],a[m]></p>\n<h3 id=\"leetcode154-有重复元素\"><a href=\"#leetcode154-有重复元素\" class=\"headerlink\" title=\"leetcode154 有重复元素\"></a>leetcode154 有重复元素</h3><p>在有重复值的情况下，会出现$A[m]==A[p]$的情况，这个时候是无法判断到底左右两边谁为递增序列。如</p>\n<script type=\"math/tex; mode=display\">\n[2, 2, 2, 2, 1,1,1, 2]</script><p>这时候的$A[m]==A[3]$与$A[p]==A[0]$是相等的都是2，所以只能把两边的最小值，递归的调用求解出来。</p>\n<h2 id=\"复杂度\"><a href=\"#复杂度\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h2><h3 id=\"leetcode153-无重复元素-1\"><a href=\"#leetcode153-无重复元素-1\" class=\"headerlink\" title=\"leetcode153 无重复元素\"></a>leetcode153 无重复元素</h3><p>可以画出递归图:</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1574430318/blog/coding/leetcode_153_reduction_graph.jpg\" alt=\"\"></p>\n<p>用$T(n)​$表示对于一个长度为n的旋转数组进行查找最小值需要的次数，对于每一次迭代都有$T[n]=T[{\\lfloor\\frac{n}{2}\\rfloor]+C}​$,C是一个常数。所以有</p>\n<script type=\"math/tex; mode=display\">\n\\begin{split}\n\nT(n)&=T[{\\lfloor\\frac{n}{2}\\rfloor]+C}\\\\\n\n&=T[{\\lfloor\\frac{n}{2^2}\\rfloor]+2C}\\\\\n\n&=T[{\\lfloor\\frac{n}{2^3}\\rfloor]+3C}\\\\\n\n\\dots\\\\\n\n&=T[{\\lfloor\\frac{n}{2^k}\\rfloor]+kC}\\\\\n\n\\end{split}</script><p>设在第k次迭代的时候长度下降到2，  此时有$\\frac{n}{2^k}=2$解出$k=\\log_2n-1$，所以有$T[n]=(\\log_2n-1)C=O(\\log_2n)$，所以算法的时间复杂度为$O(logn)$</p>\n<h3 id=\"leetcode154-有重复元素-1\"><a href=\"#leetcode154-有重复元素-1\" class=\"headerlink\" title=\"leetcode154 有重复元素\"></a>leetcode154 有重复元素</h3><p>最坏的情况，当出现$A[m]==A[p]$的情况的时候有递推表达式：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{split}\nT(n)&=2T[{\\lfloor\\frac{n}{2}\\rfloor]+C}\\\\\n&=2^2T[{\\lfloor\\frac{n}{2^2}\\rfloor]+C+2C}\\\\\n&=2^3T[{\\lfloor\\frac{n}{2^3}\\rfloor]+C+2C+2C}\\\\\n\\dots\\\\\n&=2^kT[{\\lfloor\\frac{n}{2^k}\\rfloor]+(2k-1)C}\\\\\n\\end{split}</script><p>设当第k次的时候下降到n=1，因此有$\\frac{n}{2^k}=1$推出$k=\\log_2n$所以有$T(n)=n+(2\\log_2n-1)C=O(n)$,所以时间复杂度为O(n)。如果没有出现$A[m]==A[p]$的情况则和无重复值的情况一样，时间复杂度为$O(n)$</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>使用迭代和循环两种方式实现。 循环的时候比较的选择？mid是该和左边还是右边比呢？我自己写的是和左边的比，但是我看leetcode的题解都是和右边的比。</p>\n<h3 id=\"leetcode153-无重复元素-2\"><a href=\"#leetcode153-无重复元素-2\" class=\"headerlink\" title=\"leetcode153 无重复元素\"></a>leetcode153 无重复元素</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*leetcode#153</span></span><br><span class=\"line\"><span class=\"comment\">https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/*/</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;utility&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findMin</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = nums.size();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(len==<span class=\"number\">1</span> || nums[<span class=\"number\">0</span>]&lt;nums[len<span class=\"number\">-1</span>]) <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>];<span class=\"comment\">//长度为1的时候或者不旋转的时候直接返回</span></span><br><span class=\"line\">        <span class=\"comment\">// return dc_find(nums, 0, len-1);</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> loop_find(nums, <span class=\"number\">0</span>, len<span class=\"number\">-1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dc_find</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>((hi -lo)==<span class=\"number\">1</span>) <span class=\"keyword\">return</span> nums[hi];</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> mid = lo + (hi -lo)/<span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(nums[mid]&gt;nums[lo]) ans = dc_find(nums, mid, hi);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> ans = dc_find(nums, lo, mid);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">loop_find</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> mid = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(lo&lt;hi)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>((hi-lo)==<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t\t\tans = nums[hi];</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tmid = lo + (hi -lo)/<span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(nums[mid]&gt;nums[lo]) lo = mid ;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> hi = mid ;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">/* code */</span></span><br><span class=\"line\">\tios::sync_with_stdio(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec = &#123;<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">\tSolution Sol;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;Sol.findMin(vec)&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\tsystem(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"leetcode154-有重复元素-2\"><a href=\"#leetcode154-有重复元素-2\" class=\"headerlink\" title=\"leetcode154 有重复元素\"></a>leetcode154 有重复元素</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">leetcode#154</span></span><br><span class=\"line\"><span class=\"comment\">https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;utility&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findMin</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = nums.size();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(len==<span class=\"number\">1</span> || nums[<span class=\"number\">0</span>]&lt;nums[len<span class=\"number\">-1</span>]) <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dc_find(nums, <span class=\"number\">0</span>, len<span class=\"number\">-1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dc_find</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>((hi -lo)==<span class=\"number\">1</span>) <span class=\"keyword\">return</span> min(nums[lo], nums[hi]);<span class=\"comment\">// 与无重复值的情况不同</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> mid = lo + (hi -lo)/<span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(nums[mid]&gt;nums[lo]) ans = dc_find(nums, mid, hi);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid]==nums[lo])&#123;</span><br><span class=\"line\">\t\t\tans = min(dc_find(nums, lo, mid), dc_find(nums, mid, hi));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> ans = dc_find(nums, lo, mid);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">/* code */</span></span><br><span class=\"line\">\tios::sync_with_stdio(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec = &#123;<span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span> ,<span class=\"number\">2</span> &#125;;</span><br><span class=\"line\">\tSolution Sol;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;Sol.findMin(vec)&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\tsystem(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要注意的是：<code>if((hi -lo)==1) return min(nums[lo], nums[hi]);</code> 递归的退出条件， 与无重复值的情况不同是可能出现只有两个值的时候最小值在左边的情况，所以需要比较最小值，而不是直接返回第二个。比如$[2,3,2]$ 的情况，划分为两个子问题$[2, 3] 与[3,2]$第一个子问题的时候最小值在第一个元素。</p>"},{"title":"leetcode 881 Boats to Save People","date":"2019-11-29T07:49:08.000Z","copyright":true,"_content":"\n# leetcode 881 Boats to Save People\n\n[题目来源](<https://leetcode.com/problems/boats-to-save-people/> )。要求在船有载重量和人数限制为2的情况下，给出将所有人运过河的最小船数。\n\n<!--more-->\n\n## 思路\n\n使用贪心算法，进行求解。\n\n### 桶排序 \n\n首先是自己的思路：贪心的考虑每只船都尽可能的装满限重，然后优先让胖的人先上船，之后寻找在剩下载重量限制的情况下，找最胖的人。\n\n在具体实现上，先遍历一遍人数的重量，按照重量进行桶排序，因为重量不会超过limit，而且都是整数所以是可以实现的。每个桶记录该重量下的人数，然后先将重量最大的给安排上船，并寻找能够匹配的第二个重量。直到最轻的被遍历完得到答案。\n\n## 双指针\n\n提交后发现网上的思路和自己有一点差别：配对的贪心规则是最胖的先走之后，选择最轻的进行匹配。这样就很容易的使用双指针来实现。不过为什么两种规则都能够过，自己还在思考中,参考链接中有对这种贪心规则的证明。\n\n## 代码\n\n### 桶排序\n\n```cpp\nclass Solution {\npublic:\n\t/* 桶排序 贪心的选择最胖的先走\n\tRuntime: 96 ms\n\tMemory Usage: 16.5 MB*/\n    int numRescueBoats(vector<int>& people, int limit) {\n        int num = people.size();\n\t\tif(num<=0) return 0;\n        vector<int> person(limit+1, 0);\n        for(int i=0; i<num; i++){\n            person[people[i]]++;\n        }\n\t\tint ans = 0;\n\t\t// int crossed = 0;\n\t\tfor(int i = limit; i>0; i--){\n\t\t\tfor(int j=person[i]; j>0; j--){\n\t\t\t\tans++;\n\t\t\t\t// crossed++;\n\t\t\t\tperson[i]--;// 运走一个人后 计数减1\n\t\t\t\tint rest = limit - i;\n\t\t\t\tfor(int k=rest; k>0; k--){\n\t\t\t\t\tif(person[k]>0){\n\t\t\t\t\t\tperson[k]--;\n\t\t\t\t\t\tif(k==i) j--; // 如果减去的和当前指向的weight一样 则需要减去自身\n\t\t\t\t\t\t// crossed++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// if(crossed==num) cout<<\"all crossed\" <<endl;\n\t\treturn ans;   \n    }\n};\n```\n\n需要注意的是如果剩下的重量和当前重量一致的时候，迭代的计数也要减1，比如limit为4，当前迭代的重量为2，剩下的匹配重量也为2情况。\n\n### 双指针\n\n```cpp\nclass Solution {\npublic:\n\t/*排序后 双指针\n\tRuntime: 116 ms\n\tMemory Usage: 13.6 MB\n    */\n    int numRescueBoats(vector<int>& people, int limit){\n    \tsort(people.begin(), people.end());\n    \tint ans = 0;\n    \tint i = 0;\n    \tint j = people.size() - 1;\n    \twhile(i<=j){\n    \t\tif(people[i]+people[j]<=limit){\n    \t\t\ti++;\n    \t\t\tj--;\n    \t\t\tans++;\n    \t\t}\n    \t\telse{\n    \t\t\tj--;\n    \t\t\tans++;\n    \t\t}\n    \t}\n    \treturn ans;\n    }\n};\n```\n\n## 复杂度\n\nleetcode上面显示桶排序的速度能够超过96%的提交，但是空间使用仅超过11%.\n\n### 桶排序\n\n桶排序的时间复杂读为O(n)，但是空间消耗较多为O(limit)。自己实现的代码中虽然有三层for循环，但是每一层都不是人数n，从总的被遍历到的人来考虑，前面两层是遍历的人数因此是O(n)，而每一个重量的人都需要去寻找匹配的重量，考虑最坏的情况是O(limit)，但是一般来说不会寻找太多次，所以可以认为近似的是O(1)。因此总得时间复杂度为O(n)，空间复杂度为O(limit)\n\n### 双指针\n\n双指针的时间复杂度为排序的时间复杂度，使用快排的话是O(nlogn)。不需要额外的空间，所以是O(1)。\n\n## 参考\n\n对于第二种匹配规则的贪心的证明[参考](<https://zhanghuimeng.github.io/post/leetcode-881-boats-to-save-people/>  ) 但是存疑，因为我用第一种的匹配规则也做出来了。","source":"_posts/2019-11-29-leetcode-881-Boats-to-Save-People.md","raw":"---\ntitle: leetcode 881 Boats to Save People\ndate: 2019-11-29 15:49:08\ncategories: 题解\ntags:\n- 贪心\n- leetcode\ncopyright: true\n---\n\n# leetcode 881 Boats to Save People\n\n[题目来源](<https://leetcode.com/problems/boats-to-save-people/> )。要求在船有载重量和人数限制为2的情况下，给出将所有人运过河的最小船数。\n\n<!--more-->\n\n## 思路\n\n使用贪心算法，进行求解。\n\n### 桶排序 \n\n首先是自己的思路：贪心的考虑每只船都尽可能的装满限重，然后优先让胖的人先上船，之后寻找在剩下载重量限制的情况下，找最胖的人。\n\n在具体实现上，先遍历一遍人数的重量，按照重量进行桶排序，因为重量不会超过limit，而且都是整数所以是可以实现的。每个桶记录该重量下的人数，然后先将重量最大的给安排上船，并寻找能够匹配的第二个重量。直到最轻的被遍历完得到答案。\n\n## 双指针\n\n提交后发现网上的思路和自己有一点差别：配对的贪心规则是最胖的先走之后，选择最轻的进行匹配。这样就很容易的使用双指针来实现。不过为什么两种规则都能够过，自己还在思考中,参考链接中有对这种贪心规则的证明。\n\n## 代码\n\n### 桶排序\n\n```cpp\nclass Solution {\npublic:\n\t/* 桶排序 贪心的选择最胖的先走\n\tRuntime: 96 ms\n\tMemory Usage: 16.5 MB*/\n    int numRescueBoats(vector<int>& people, int limit) {\n        int num = people.size();\n\t\tif(num<=0) return 0;\n        vector<int> person(limit+1, 0);\n        for(int i=0; i<num; i++){\n            person[people[i]]++;\n        }\n\t\tint ans = 0;\n\t\t// int crossed = 0;\n\t\tfor(int i = limit; i>0; i--){\n\t\t\tfor(int j=person[i]; j>0; j--){\n\t\t\t\tans++;\n\t\t\t\t// crossed++;\n\t\t\t\tperson[i]--;// 运走一个人后 计数减1\n\t\t\t\tint rest = limit - i;\n\t\t\t\tfor(int k=rest; k>0; k--){\n\t\t\t\t\tif(person[k]>0){\n\t\t\t\t\t\tperson[k]--;\n\t\t\t\t\t\tif(k==i) j--; // 如果减去的和当前指向的weight一样 则需要减去自身\n\t\t\t\t\t\t// crossed++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// if(crossed==num) cout<<\"all crossed\" <<endl;\n\t\treturn ans;   \n    }\n};\n```\n\n需要注意的是如果剩下的重量和当前重量一致的时候，迭代的计数也要减1，比如limit为4，当前迭代的重量为2，剩下的匹配重量也为2情况。\n\n### 双指针\n\n```cpp\nclass Solution {\npublic:\n\t/*排序后 双指针\n\tRuntime: 116 ms\n\tMemory Usage: 13.6 MB\n    */\n    int numRescueBoats(vector<int>& people, int limit){\n    \tsort(people.begin(), people.end());\n    \tint ans = 0;\n    \tint i = 0;\n    \tint j = people.size() - 1;\n    \twhile(i<=j){\n    \t\tif(people[i]+people[j]<=limit){\n    \t\t\ti++;\n    \t\t\tj--;\n    \t\t\tans++;\n    \t\t}\n    \t\telse{\n    \t\t\tj--;\n    \t\t\tans++;\n    \t\t}\n    \t}\n    \treturn ans;\n    }\n};\n```\n\n## 复杂度\n\nleetcode上面显示桶排序的速度能够超过96%的提交，但是空间使用仅超过11%.\n\n### 桶排序\n\n桶排序的时间复杂读为O(n)，但是空间消耗较多为O(limit)。自己实现的代码中虽然有三层for循环，但是每一层都不是人数n，从总的被遍历到的人来考虑，前面两层是遍历的人数因此是O(n)，而每一个重量的人都需要去寻找匹配的重量，考虑最坏的情况是O(limit)，但是一般来说不会寻找太多次，所以可以认为近似的是O(1)。因此总得时间复杂度为O(n)，空间复杂度为O(limit)\n\n### 双指针\n\n双指针的时间复杂度为排序的时间复杂度，使用快排的话是O(nlogn)。不需要额外的空间，所以是O(1)。\n\n## 参考\n\n对于第二种匹配规则的贪心的证明[参考](<https://zhanghuimeng.github.io/post/leetcode-881-boats-to-save-people/>  ) 但是存疑，因为我用第一种的匹配规则也做出来了。","slug":"2019-11-29-leetcode-881-Boats-to-Save-People","published":1,"updated":"2019-11-29T08:27:46.912Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6he13z70029dstz3nmffhms","content":"<h1 id=\"leetcode-881-Boats-to-Save-People\"><a href=\"#leetcode-881-Boats-to-Save-People\" class=\"headerlink\" title=\"leetcode 881 Boats to Save People\"></a>leetcode 881 Boats to Save People</h1><p><a href=\"https://leetcode.com/problems/boats-to-save-people/\" target=\"_blank\" rel=\"noopener\">题目来源</a>。要求在船有载重量和人数限制为2的情况下，给出将所有人运过河的最小船数。</p>\n<a id=\"more\"></a>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>使用贪心算法，进行求解。</p>\n<h3 id=\"桶排序\"><a href=\"#桶排序\" class=\"headerlink\" title=\"桶排序\"></a>桶排序</h3><p>首先是自己的思路：贪心的考虑每只船都尽可能的装满限重，然后优先让胖的人先上船，之后寻找在剩下载重量限制的情况下，找最胖的人。</p>\n<p>在具体实现上，先遍历一遍人数的重量，按照重量进行桶排序，因为重量不会超过limit，而且都是整数所以是可以实现的。每个桶记录该重量下的人数，然后先将重量最大的给安排上船，并寻找能够匹配的第二个重量。直到最轻的被遍历完得到答案。</p>\n<h2 id=\"双指针\"><a href=\"#双指针\" class=\"headerlink\" title=\"双指针\"></a>双指针</h2><p>提交后发现网上的思路和自己有一点差别：配对的贪心规则是最胖的先走之后，选择最轻的进行匹配。这样就很容易的使用双指针来实现。不过为什么两种规则都能够过，自己还在思考中,参考链接中有对这种贪心规则的证明。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><h3 id=\"桶排序-1\"><a href=\"#桶排序-1\" class=\"headerlink\" title=\"桶排序\"></a>桶排序</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"comment\">/* 桶排序 贪心的选择最胖的先走</span></span><br><span class=\"line\"><span class=\"comment\">\tRuntime: 96 ms</span></span><br><span class=\"line\"><span class=\"comment\">\tMemory Usage: 16.5 MB*/</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">numRescueBoats</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; people, <span class=\"keyword\">int</span> limit)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> num = people.size();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(num&lt;=<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; person(limit+<span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;num; i++)&#123;</span><br><span class=\"line\">            person[people[i]]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">// int crossed = 0;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = limit; i&gt;<span class=\"number\">0</span>; i--)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=person[i]; j&gt;<span class=\"number\">0</span>; j--)&#123;</span><br><span class=\"line\">\t\t\t\tans++;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// crossed++;</span></span><br><span class=\"line\">\t\t\t\tperson[i]--;<span class=\"comment\">// 运走一个人后 计数减1</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">int</span> rest = limit - i;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k=rest; k&gt;<span class=\"number\">0</span>; k--)&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span>(person[k]&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\t\tperson[k]--;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span>(k==i) j--; <span class=\"comment\">// 如果减去的和当前指向的weight一样 则需要减去自身</span></span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// crossed++;</span></span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// if(crossed==num) cout&lt;&lt;\"all crossed\" &lt;&lt;endl;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ans;   </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>需要注意的是如果剩下的重量和当前重量一致的时候，迭代的计数也要减1，比如limit为4，当前迭代的重量为2，剩下的匹配重量也为2情况。</p>\n<h3 id=\"双指针-1\"><a href=\"#双指针-1\" class=\"headerlink\" title=\"双指针\"></a>双指针</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"comment\">/*排序后 双指针</span></span><br><span class=\"line\"><span class=\"comment\">\tRuntime: 116 ms</span></span><br><span class=\"line\"><span class=\"comment\">\tMemory Usage: 13.6 MB</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">numRescueBoats</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; people, <span class=\"keyword\">int</span> limit)</span></span>&#123;</span><br><span class=\"line\">    \tsort(people.begin(), people.end());</span><br><span class=\"line\">    \t<span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    \t<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    \t<span class=\"keyword\">int</span> j = people.size() - <span class=\"number\">1</span>;</span><br><span class=\"line\">    \t<span class=\"keyword\">while</span>(i&lt;=j)&#123;</span><br><span class=\"line\">    \t\t<span class=\"keyword\">if</span>(people[i]+people[j]&lt;=limit)&#123;</span><br><span class=\"line\">    \t\t\ti++;</span><br><span class=\"line\">    \t\t\tj--;</span><br><span class=\"line\">    \t\t\tans++;</span><br><span class=\"line\">    \t\t&#125;</span><br><span class=\"line\">    \t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    \t\t\tj--;</span><br><span class=\"line\">    \t\t\tans++;</span><br><span class=\"line\">    \t\t&#125;</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"复杂度\"><a href=\"#复杂度\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h2><p>leetcode上面显示桶排序的速度能够超过96%的提交，但是空间使用仅超过11%.</p>\n<h3 id=\"桶排序-2\"><a href=\"#桶排序-2\" class=\"headerlink\" title=\"桶排序\"></a>桶排序</h3><p>桶排序的时间复杂读为O(n)，但是空间消耗较多为O(limit)。自己实现的代码中虽然有三层for循环，但是每一层都不是人数n，从总的被遍历到的人来考虑，前面两层是遍历的人数因此是O(n)，而每一个重量的人都需要去寻找匹配的重量，考虑最坏的情况是O(limit)，但是一般来说不会寻找太多次，所以可以认为近似的是O(1)。因此总得时间复杂度为O(n)，空间复杂度为O(limit)</p>\n<h3 id=\"双指针-2\"><a href=\"#双指针-2\" class=\"headerlink\" title=\"双指针\"></a>双指针</h3><p>双指针的时间复杂度为排序的时间复杂度，使用快排的话是O(nlogn)。不需要额外的空间，所以是O(1)。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>对于第二种匹配规则的贪心的证明<a href=\"https://zhanghuimeng.github.io/post/leetcode-881-boats-to-save-people/\" target=\"_blank\" rel=\"noopener\">参考</a> 但是存疑，因为我用第一种的匹配规则也做出来了。</p>\n","site":{"data":{}},"length":1852,"excerpt":"<h1 id=\"leetcode-881-Boats-to-Save-People\"><a href=\"#leetcode-881-Boats-to-Save-People\" class=\"headerlink\" title=\"leetcode 881 Boats to Save People\"></a>leetcode 881 Boats to Save People</h1><p><a href=\"https://leetcode.com/problems/boats-to-save-people/\" target=\"_blank\" rel=\"noopener\">题目来源</a>。要求在船有载重量和人数限制为2的情况下，给出将所有人运过河的最小船数。</p>","more":"<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>使用贪心算法，进行求解。</p>\n<h3 id=\"桶排序\"><a href=\"#桶排序\" class=\"headerlink\" title=\"桶排序\"></a>桶排序</h3><p>首先是自己的思路：贪心的考虑每只船都尽可能的装满限重，然后优先让胖的人先上船，之后寻找在剩下载重量限制的情况下，找最胖的人。</p>\n<p>在具体实现上，先遍历一遍人数的重量，按照重量进行桶排序，因为重量不会超过limit，而且都是整数所以是可以实现的。每个桶记录该重量下的人数，然后先将重量最大的给安排上船，并寻找能够匹配的第二个重量。直到最轻的被遍历完得到答案。</p>\n<h2 id=\"双指针\"><a href=\"#双指针\" class=\"headerlink\" title=\"双指针\"></a>双指针</h2><p>提交后发现网上的思路和自己有一点差别：配对的贪心规则是最胖的先走之后，选择最轻的进行匹配。这样就很容易的使用双指针来实现。不过为什么两种规则都能够过，自己还在思考中,参考链接中有对这种贪心规则的证明。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><h3 id=\"桶排序-1\"><a href=\"#桶排序-1\" class=\"headerlink\" title=\"桶排序\"></a>桶排序</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"comment\">/* 桶排序 贪心的选择最胖的先走</span></span><br><span class=\"line\"><span class=\"comment\">\tRuntime: 96 ms</span></span><br><span class=\"line\"><span class=\"comment\">\tMemory Usage: 16.5 MB*/</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">numRescueBoats</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; people, <span class=\"keyword\">int</span> limit)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> num = people.size();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(num&lt;=<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; person(limit+<span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;num; i++)&#123;</span><br><span class=\"line\">            person[people[i]]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">// int crossed = 0;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = limit; i&gt;<span class=\"number\">0</span>; i--)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=person[i]; j&gt;<span class=\"number\">0</span>; j--)&#123;</span><br><span class=\"line\">\t\t\t\tans++;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// crossed++;</span></span><br><span class=\"line\">\t\t\t\tperson[i]--;<span class=\"comment\">// 运走一个人后 计数减1</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">int</span> rest = limit - i;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k=rest; k&gt;<span class=\"number\">0</span>; k--)&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span>(person[k]&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\t\tperson[k]--;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span>(k==i) j--; <span class=\"comment\">// 如果减去的和当前指向的weight一样 则需要减去自身</span></span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// crossed++;</span></span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// if(crossed==num) cout&lt;&lt;\"all crossed\" &lt;&lt;endl;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ans;   </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>需要注意的是如果剩下的重量和当前重量一致的时候，迭代的计数也要减1，比如limit为4，当前迭代的重量为2，剩下的匹配重量也为2情况。</p>\n<h3 id=\"双指针-1\"><a href=\"#双指针-1\" class=\"headerlink\" title=\"双指针\"></a>双指针</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"comment\">/*排序后 双指针</span></span><br><span class=\"line\"><span class=\"comment\">\tRuntime: 116 ms</span></span><br><span class=\"line\"><span class=\"comment\">\tMemory Usage: 13.6 MB</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">numRescueBoats</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; people, <span class=\"keyword\">int</span> limit)</span></span>&#123;</span><br><span class=\"line\">    \tsort(people.begin(), people.end());</span><br><span class=\"line\">    \t<span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    \t<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    \t<span class=\"keyword\">int</span> j = people.size() - <span class=\"number\">1</span>;</span><br><span class=\"line\">    \t<span class=\"keyword\">while</span>(i&lt;=j)&#123;</span><br><span class=\"line\">    \t\t<span class=\"keyword\">if</span>(people[i]+people[j]&lt;=limit)&#123;</span><br><span class=\"line\">    \t\t\ti++;</span><br><span class=\"line\">    \t\t\tj--;</span><br><span class=\"line\">    \t\t\tans++;</span><br><span class=\"line\">    \t\t&#125;</span><br><span class=\"line\">    \t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    \t\t\tj--;</span><br><span class=\"line\">    \t\t\tans++;</span><br><span class=\"line\">    \t\t&#125;</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"复杂度\"><a href=\"#复杂度\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h2><p>leetcode上面显示桶排序的速度能够超过96%的提交，但是空间使用仅超过11%.</p>\n<h3 id=\"桶排序-2\"><a href=\"#桶排序-2\" class=\"headerlink\" title=\"桶排序\"></a>桶排序</h3><p>桶排序的时间复杂读为O(n)，但是空间消耗较多为O(limit)。自己实现的代码中虽然有三层for循环，但是每一层都不是人数n，从总的被遍历到的人来考虑，前面两层是遍历的人数因此是O(n)，而每一个重量的人都需要去寻找匹配的重量，考虑最坏的情况是O(limit)，但是一般来说不会寻找太多次，所以可以认为近似的是O(1)。因此总得时间复杂度为O(n)，空间复杂度为O(limit)</p>\n<h3 id=\"双指针-2\"><a href=\"#双指针-2\" class=\"headerlink\" title=\"双指针\"></a>双指针</h3><p>双指针的时间复杂度为排序的时间复杂度，使用快排的话是O(nlogn)。不需要额外的空间，所以是O(1)。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>对于第二种匹配规则的贪心的证明<a href=\"https://zhanghuimeng.github.io/post/leetcode-881-boats-to-save-people/\" target=\"_blank\" rel=\"noopener\">参考</a> 但是存疑，因为我用第一种的匹配规则也做出来了。</p>"},{"title":"关联规则","date":"2019-11-18T14:58:08.000Z","copyright":true,"mathjax":true,"_content":"\n# 关联规则\n\n## 基本概念\n\n关联规则挖掘Association rules mining 挖掘出数据库中的频繁模式，频繁项之间的关联规则。\n\n<!--more-->\n\n关联规则的形式为\n$$\nA\\Rightarrow B[support=?, confident=?]\n$$\n规则的支持度support和置信度confident分别反映出规则的有用性和确定性。定义为：\n$$\n\\begin{split}\nsupport(A\\Rightarrow B)&=P(A\\bigcap B)=\\dfrac{count(A\\bigcap B)}{count(total)}\\\\\nconfident(A\\Rightarrow B)&=P(B|A)=\\dfrac{count(A\\bigcap B)}{count(A)}\n\\end{split}\n$$\n$A\\bigcap B$ 表示A事件和B事件一起发生。使用比例的支持度称为相对支持度，使用直接的次数称为绝对支持度。当规则满足设定的最小支持度和最小置信度的时候，规则是强关联规则。强关联规则并不一定是有趣的，使用提升度lift来衡量两个事件之间的相关性\n$$\nlift=\\dfrac{P(A\\bigcap B)}{P(A)P(B)}\n$$\n当lift大于1的时候表示A事件和B时间是正相关的，A随着B的出现而出现，lift为1的时候二者是独立的，lift小与1的时候二者负相关，意味着一个的出现可能导致另一个不出现。\n\n关联规则的挖掘分为两步：\n\n1. 找出所有的频繁项集 一个详细的出现次数大于最小支持度的次数则是频繁的\n2. 由频繁项集产生强关联规则\n\n包含k个项的项集称之为k项集，如果集合中的项都是频繁的，那么集合称之为频繁k项集。\n\n挖掘频繁项集的算法：Apriori和FP-Growth\n\n## Apriori\n\nApriori运用了一个先验规则：每个频繁项集的子集一定也是频繁的项集，使用这个规则来剪枝很多候选项（非频繁的子集其父集也一定不是频繁的所以可以不用考虑）。\n\n算法步骤为：\n\n- 首先扫描一次数据库得到频繁1项集\n- 根据频繁k项集$L_k$生成频繁k+1项集（连接步和剪枝步组成）\n  - 先根据频繁k项集组合生成候选项\n  - 扫描数据库得到候选项的支持度\n  - 将不满足支持度的剔除\n- 当没有频繁项或者候选项可以生成的时候终止\n\n### 连接步\n\n为了找出$L_k$ ,通过$L_{k-1}$与自身连接产生候选k项集的集合$C_k$设$l_1$和$l_2$ 是$L_{k - 1}$ 中的项集。记号$l_i[j]$表示$l_i$ 的第j 项（例如，$l_1[k-2]$表示$l_1$ 的倒数第3 项）。为方便计，假定事务或项集中的项按字典次序排序即$l_i[k]<l_i[k+1]$。执行连接$L_{k - 1}$ 与$L_{k - 1}$；其中，$L_{k - 1}$ 的元素是可连接的，如果它们前(k-2)个项相同；即，$L_{k - 1}$ 的元素l1 和l2 是可连接的，如果$(l_1 [1] = l_2 [1]) ∧ (l_1 [2]= l_2 [2]) ∧ ... ∧ (l_1 [k-2] = l_2 [k-2]) ∧ (l_1 [k-1] < l_2 [k-1])$。条件$(l_1 [k-1] < l_2 [k-1])$是简单地保证不产生重复。连接$l_1$ 和$l_2$ 产生的结果项集是$l_1 [1] l_1 [2]... l_1 [k-1] l_2 [k-1]$。\n\n举个例子假设频繁三项集有$l_1=[a,b,c], l_2=[a.b,d]$ 满足前缀相同最后一项不同所以可以产生候选的4项集：$C_4=[a,b,c,d]$ 把$l_2$的最后一项拼接到$l_1$后面。\n\n### 剪枝步\n\n$C_k$是频繁k项集的$L_k$的父集，可以扫描数据库来确定每一个$C_k$中的计数。但是$C_k$可能很大，所涉及的计算量也就很大。为压缩$C_k$，可以用以下办法使用Apriori 的先验性质：任何非频繁的(k-1)-项集都不是可能是频繁k-项集的子集。因此，如果一个候选k-项集的(k-1)项子集不在$L_{k - 1}$ 中，则该候选也不可能是频繁的，从而可以由$C_k$ 中删除。这种子集测试可以使用所有频繁项集的散列树(hash tree)快速完成。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1574157675/blog/Data%20Mining/Apriori_example.jpg)\n\n如上图的例子，第一次扫描得到频繁1项集的候选项$C_1$，然后根据支持度去除支持度计数小于2的$\\{D\\}$ 得到$L_1$，然后$L_1$中的各项进行连接步操作得到$C_2$，$C_2$ 执行剪枝步操作，因为所有项的子集都在$L_1$中所以不需要剪枝。进行第二次扫描得到$C_2$各项的支持度计数，然后把低于最小支持度的$\\{A,B\\},\\{A,E\\}$ 两项删除从而得到频繁2项集$L_2$。根据$L_2$执行连接步(只能由{B,C} 和{B, E}连接，其他的前缀不同)生成的$C_3=\\{B,C,E\\}$ 因为对应的3个子集{B,C},｛B,E｝和{C, E}都在频繁2项集中，所以也不需要剪枝。第三次扫描后得到$C_3$中各项的支持度计数，因为大于最小支持度计数，因此不需要删去得到了频繁3项集，因为频繁3项集只有一项无法进行连接步操作生成候选项集，所以算法终止。\n\n### 产生关联规则\n\n以上图为例，得到了频繁3项集$L_3={\\{B,C,E\\}}$后，对其所有非空子集$\\{B\\},\\{C\\},\\{E\\},\\{B,E\\},\\{B,C\\},\\{C,E\\}$ 计算对应的关联规则$l_1 \\Rightarrow l_2\\space or \\space l_2 \\Rightarrow l_1 $的置信度，如果满足最小置信度阈值则是强关联规则。\n\n### 算法伪代码\n\n![](https://res.cloudinary.com/bravey/image/upload/v1574157676/blog/Data%20Mining/Apriori_code.jpg)\n\n### 改进算法\n\n- Partition ：仅扫描数据库两次\n- DHP：降低候选项的数目\n- DIC：降低扫描次数\n\n### 评价\n\nApriori算法需要多次扫描数据库这带来的开销很大，同时会生成大量的候选项集并做子集测试也造成了很大的计算开销。\n\n## FP-Growth\n\n频繁模式增长FP-Growth将代表频繁项集的数据库压缩到一颗频繁模式树Frequent Patterns (FP树)中。\n\n### FP树的构建\n\n- 首先扫描一次数据库，找到频繁一项集。\n- 根据支持度计数降序排列频繁项记为L\n- 创建一个根节点，并标记为null\n- 再次扫描数据库，将每个事务按照L中的顺序排列。为每个事务新建一个分支\n  - 如果事务中的项已经在分支中，则分支上的节点计数+1\n  - 如果项不在分支中，则在前缀路径下新建一个节点，计数为1\n- 建立一个项头表把FP树中的每一项的节点相连。\n\n![FP树](https://res.cloudinary.com/bravey/image/upload/v1574157675/blog/Data%20Mining/FP_tree_construct.jpg)\n\n以上图为例，第一次扫描后得到的频繁一项集为$L_1=\\{f:4,c:4,a:3,b:3,m:3,p:3\\}$ 已经按照支持度计数降序排列为F-list。第二次扫描数据库，并按照F-list的顺序将每个事务排列（注意：低于支持度计数的项已经被删除了）。建立一个根节点并标记为null,第一个事务是$\\{f,c,a,m,p\\}$\n\n![](https://res.cloudinary.com/bravey/image/upload/v1574157675/blog/Data%20Mining/fp_tree_1.jpg)\n\n因为是第一个事务所以没有前缀路径可以共用，每个项都需要建立一个节点。第二个事务是$\\{f,c,a,b,m\\}$因为$\\{f,c,a\\}$ 是已经有的路径，所以对应的在这3个节点计数+1，$\\{b,m\\}$ 没有可以共享的路径所以需要新建立这两个节点。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1574157674/blog/Data%20Mining/fp_tree_2.jpg)\n\n当所有事务都被加入到FP树后建立项头表将相同的项给链接起来就可以得到前面的完整的FP树。\n\n### 条件模式基的构造\n\n从项头表中具有最低的支持度计数的项开始构造每一个项的条件模式基Conditional Pattern Base。一个项的条件模式基定义为以这个项为后缀的前缀路径。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1574157675/blog/Data%20Mining/conditional_patter_base.jpg)\n\n以上图为例，先构造p的条件模式基，在FP树中，以p为后缀的路径为$fcam:2 和cb:1$ 后面的计数是根据每条路径的后缀的计数来确定的因此第一条$fcamp$路径的计数为2而$cbp$为1。 依次可以得到每个项的条件模式基。对每一个项的条件模式基都可以按照前述的FP树的构造方法得到其对应的条件FP树。以m的条件模式基构建的条件FP树为：\n![](https://res.cloudinary.com/bravey/image/upload/v1574157675/blog/Data%20Mining/m_conditional_fptree.jpg)\n\n\n\n因为b的支持度计数只有1所以删去。\n\n### 频繁模式的产生\n\n根据条件FP树的路径产生频繁模式，路径的每个非空子集与对应的项组合产生对应的频繁模式。比如m的FP树路径为：$\\{fca\\}$ 对应的子集有$\\{f\\},\\{c\\},\\{a\\}, \\{f,c\\},\\{f,a\\},\\{a,c\\},\\{f,c,a\\}$与m组合后得到的频繁模式有：$\\{f,m\\},\\{c,m\\},\\{a.m\\}, \\{f,c,m\\},\\{f,a.m\\},\\{a,c,m\\},\\{f,c,a,m\\}$\n\n### FP树的优点\n\n完整的保留了频繁模式挖掘的所有信息，不损失每个事务可能的频繁项集。将发现长频繁模式的问题转换成递归地发现一些短模式，然后与后缀连接。它使用最不频繁的项作后缀，提供了好的选择性。该方法大大降低了搜索开销。\n\nFP-Growth采用分治的方法专注于小的数据集，不产生候选项集，只扫描两次数据库。因此性能比Apriori算法好。\n\n### FP-Growth 伪代码\n\n![](https://res.cloudinary.com/bravey/image/upload/v1574157675/blog/Data%20Mining/FP-Growth_code.jpg)\n\n## 参考\n\n《数据挖掘概念与技术》第3版 第六章挖掘频繁模式、关联和相关性：基本概念和方法","source":"_posts/2019-11-18-关联规则.md","raw":"---\ntitle: 关联规则\ndate: 2019-11-18 22:58:08\ncategories: 数据挖掘\ntags:\n- 课程\n- 国科大\n- 关联规则\n- Apriori\n- FP-Growth\ncopyright: true\nmathjax: true\n---\n\n# 关联规则\n\n## 基本概念\n\n关联规则挖掘Association rules mining 挖掘出数据库中的频繁模式，频繁项之间的关联规则。\n\n<!--more-->\n\n关联规则的形式为\n$$\nA\\Rightarrow B[support=?, confident=?]\n$$\n规则的支持度support和置信度confident分别反映出规则的有用性和确定性。定义为：\n$$\n\\begin{split}\nsupport(A\\Rightarrow B)&=P(A\\bigcap B)=\\dfrac{count(A\\bigcap B)}{count(total)}\\\\\nconfident(A\\Rightarrow B)&=P(B|A)=\\dfrac{count(A\\bigcap B)}{count(A)}\n\\end{split}\n$$\n$A\\bigcap B$ 表示A事件和B事件一起发生。使用比例的支持度称为相对支持度，使用直接的次数称为绝对支持度。当规则满足设定的最小支持度和最小置信度的时候，规则是强关联规则。强关联规则并不一定是有趣的，使用提升度lift来衡量两个事件之间的相关性\n$$\nlift=\\dfrac{P(A\\bigcap B)}{P(A)P(B)}\n$$\n当lift大于1的时候表示A事件和B时间是正相关的，A随着B的出现而出现，lift为1的时候二者是独立的，lift小与1的时候二者负相关，意味着一个的出现可能导致另一个不出现。\n\n关联规则的挖掘分为两步：\n\n1. 找出所有的频繁项集 一个详细的出现次数大于最小支持度的次数则是频繁的\n2. 由频繁项集产生强关联规则\n\n包含k个项的项集称之为k项集，如果集合中的项都是频繁的，那么集合称之为频繁k项集。\n\n挖掘频繁项集的算法：Apriori和FP-Growth\n\n## Apriori\n\nApriori运用了一个先验规则：每个频繁项集的子集一定也是频繁的项集，使用这个规则来剪枝很多候选项（非频繁的子集其父集也一定不是频繁的所以可以不用考虑）。\n\n算法步骤为：\n\n- 首先扫描一次数据库得到频繁1项集\n- 根据频繁k项集$L_k$生成频繁k+1项集（连接步和剪枝步组成）\n  - 先根据频繁k项集组合生成候选项\n  - 扫描数据库得到候选项的支持度\n  - 将不满足支持度的剔除\n- 当没有频繁项或者候选项可以生成的时候终止\n\n### 连接步\n\n为了找出$L_k$ ,通过$L_{k-1}$与自身连接产生候选k项集的集合$C_k$设$l_1$和$l_2$ 是$L_{k - 1}$ 中的项集。记号$l_i[j]$表示$l_i$ 的第j 项（例如，$l_1[k-2]$表示$l_1$ 的倒数第3 项）。为方便计，假定事务或项集中的项按字典次序排序即$l_i[k]<l_i[k+1]$。执行连接$L_{k - 1}$ 与$L_{k - 1}$；其中，$L_{k - 1}$ 的元素是可连接的，如果它们前(k-2)个项相同；即，$L_{k - 1}$ 的元素l1 和l2 是可连接的，如果$(l_1 [1] = l_2 [1]) ∧ (l_1 [2]= l_2 [2]) ∧ ... ∧ (l_1 [k-2] = l_2 [k-2]) ∧ (l_1 [k-1] < l_2 [k-1])$。条件$(l_1 [k-1] < l_2 [k-1])$是简单地保证不产生重复。连接$l_1$ 和$l_2$ 产生的结果项集是$l_1 [1] l_1 [2]... l_1 [k-1] l_2 [k-1]$。\n\n举个例子假设频繁三项集有$l_1=[a,b,c], l_2=[a.b,d]$ 满足前缀相同最后一项不同所以可以产生候选的4项集：$C_4=[a,b,c,d]$ 把$l_2$的最后一项拼接到$l_1$后面。\n\n### 剪枝步\n\n$C_k$是频繁k项集的$L_k$的父集，可以扫描数据库来确定每一个$C_k$中的计数。但是$C_k$可能很大，所涉及的计算量也就很大。为压缩$C_k$，可以用以下办法使用Apriori 的先验性质：任何非频繁的(k-1)-项集都不是可能是频繁k-项集的子集。因此，如果一个候选k-项集的(k-1)项子集不在$L_{k - 1}$ 中，则该候选也不可能是频繁的，从而可以由$C_k$ 中删除。这种子集测试可以使用所有频繁项集的散列树(hash tree)快速完成。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1574157675/blog/Data%20Mining/Apriori_example.jpg)\n\n如上图的例子，第一次扫描得到频繁1项集的候选项$C_1$，然后根据支持度去除支持度计数小于2的$\\{D\\}$ 得到$L_1$，然后$L_1$中的各项进行连接步操作得到$C_2$，$C_2$ 执行剪枝步操作，因为所有项的子集都在$L_1$中所以不需要剪枝。进行第二次扫描得到$C_2$各项的支持度计数，然后把低于最小支持度的$\\{A,B\\},\\{A,E\\}$ 两项删除从而得到频繁2项集$L_2$。根据$L_2$执行连接步(只能由{B,C} 和{B, E}连接，其他的前缀不同)生成的$C_3=\\{B,C,E\\}$ 因为对应的3个子集{B,C},｛B,E｝和{C, E}都在频繁2项集中，所以也不需要剪枝。第三次扫描后得到$C_3$中各项的支持度计数，因为大于最小支持度计数，因此不需要删去得到了频繁3项集，因为频繁3项集只有一项无法进行连接步操作生成候选项集，所以算法终止。\n\n### 产生关联规则\n\n以上图为例，得到了频繁3项集$L_3={\\{B,C,E\\}}$后，对其所有非空子集$\\{B\\},\\{C\\},\\{E\\},\\{B,E\\},\\{B,C\\},\\{C,E\\}$ 计算对应的关联规则$l_1 \\Rightarrow l_2\\space or \\space l_2 \\Rightarrow l_1 $的置信度，如果满足最小置信度阈值则是强关联规则。\n\n### 算法伪代码\n\n![](https://res.cloudinary.com/bravey/image/upload/v1574157676/blog/Data%20Mining/Apriori_code.jpg)\n\n### 改进算法\n\n- Partition ：仅扫描数据库两次\n- DHP：降低候选项的数目\n- DIC：降低扫描次数\n\n### 评价\n\nApriori算法需要多次扫描数据库这带来的开销很大，同时会生成大量的候选项集并做子集测试也造成了很大的计算开销。\n\n## FP-Growth\n\n频繁模式增长FP-Growth将代表频繁项集的数据库压缩到一颗频繁模式树Frequent Patterns (FP树)中。\n\n### FP树的构建\n\n- 首先扫描一次数据库，找到频繁一项集。\n- 根据支持度计数降序排列频繁项记为L\n- 创建一个根节点，并标记为null\n- 再次扫描数据库，将每个事务按照L中的顺序排列。为每个事务新建一个分支\n  - 如果事务中的项已经在分支中，则分支上的节点计数+1\n  - 如果项不在分支中，则在前缀路径下新建一个节点，计数为1\n- 建立一个项头表把FP树中的每一项的节点相连。\n\n![FP树](https://res.cloudinary.com/bravey/image/upload/v1574157675/blog/Data%20Mining/FP_tree_construct.jpg)\n\n以上图为例，第一次扫描后得到的频繁一项集为$L_1=\\{f:4,c:4,a:3,b:3,m:3,p:3\\}$ 已经按照支持度计数降序排列为F-list。第二次扫描数据库，并按照F-list的顺序将每个事务排列（注意：低于支持度计数的项已经被删除了）。建立一个根节点并标记为null,第一个事务是$\\{f,c,a,m,p\\}$\n\n![](https://res.cloudinary.com/bravey/image/upload/v1574157675/blog/Data%20Mining/fp_tree_1.jpg)\n\n因为是第一个事务所以没有前缀路径可以共用，每个项都需要建立一个节点。第二个事务是$\\{f,c,a,b,m\\}$因为$\\{f,c,a\\}$ 是已经有的路径，所以对应的在这3个节点计数+1，$\\{b,m\\}$ 没有可以共享的路径所以需要新建立这两个节点。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1574157674/blog/Data%20Mining/fp_tree_2.jpg)\n\n当所有事务都被加入到FP树后建立项头表将相同的项给链接起来就可以得到前面的完整的FP树。\n\n### 条件模式基的构造\n\n从项头表中具有最低的支持度计数的项开始构造每一个项的条件模式基Conditional Pattern Base。一个项的条件模式基定义为以这个项为后缀的前缀路径。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1574157675/blog/Data%20Mining/conditional_patter_base.jpg)\n\n以上图为例，先构造p的条件模式基，在FP树中，以p为后缀的路径为$fcam:2 和cb:1$ 后面的计数是根据每条路径的后缀的计数来确定的因此第一条$fcamp$路径的计数为2而$cbp$为1。 依次可以得到每个项的条件模式基。对每一个项的条件模式基都可以按照前述的FP树的构造方法得到其对应的条件FP树。以m的条件模式基构建的条件FP树为：\n![](https://res.cloudinary.com/bravey/image/upload/v1574157675/blog/Data%20Mining/m_conditional_fptree.jpg)\n\n\n\n因为b的支持度计数只有1所以删去。\n\n### 频繁模式的产生\n\n根据条件FP树的路径产生频繁模式，路径的每个非空子集与对应的项组合产生对应的频繁模式。比如m的FP树路径为：$\\{fca\\}$ 对应的子集有$\\{f\\},\\{c\\},\\{a\\}, \\{f,c\\},\\{f,a\\},\\{a,c\\},\\{f,c,a\\}$与m组合后得到的频繁模式有：$\\{f,m\\},\\{c,m\\},\\{a.m\\}, \\{f,c,m\\},\\{f,a.m\\},\\{a,c,m\\},\\{f,c,a,m\\}$\n\n### FP树的优点\n\n完整的保留了频繁模式挖掘的所有信息，不损失每个事务可能的频繁项集。将发现长频繁模式的问题转换成递归地发现一些短模式，然后与后缀连接。它使用最不频繁的项作后缀，提供了好的选择性。该方法大大降低了搜索开销。\n\nFP-Growth采用分治的方法专注于小的数据集，不产生候选项集，只扫描两次数据库。因此性能比Apriori算法好。\n\n### FP-Growth 伪代码\n\n![](https://res.cloudinary.com/bravey/image/upload/v1574157675/blog/Data%20Mining/FP-Growth_code.jpg)\n\n## 参考\n\n《数据挖掘概念与技术》第3版 第六章挖掘频繁模式、关联和相关性：基本概念和方法","slug":"2019-11-18-关联规则","published":1,"updated":"2019-11-19T10:07:09.703Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6he13z9002cdstzripjnm22","content":"<h1 id=\"关联规则\"><a href=\"#关联规则\" class=\"headerlink\" title=\"关联规则\"></a>关联规则</h1><h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>关联规则挖掘Association rules mining 挖掘出数据库中的频繁模式，频繁项之间的关联规则。</p>\n<a id=\"more\"></a>\n<p>关联规则的形式为</p>\n<script type=\"math/tex; mode=display\">\nA\\Rightarrow B[support=?, confident=?]</script><p>规则的支持度support和置信度confident分别反映出规则的有用性和确定性。定义为：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{split}\nsupport(A\\Rightarrow B)&=P(A\\bigcap B)=\\dfrac{count(A\\bigcap B)}{count(total)}\\\\\nconfident(A\\Rightarrow B)&=P(B|A)=\\dfrac{count(A\\bigcap B)}{count(A)}\n\\end{split}</script><p>$A\\bigcap B$ 表示A事件和B事件一起发生。使用比例的支持度称为相对支持度，使用直接的次数称为绝对支持度。当规则满足设定的最小支持度和最小置信度的时候，规则是强关联规则。强关联规则并不一定是有趣的，使用提升度lift来衡量两个事件之间的相关性</p>\n<script type=\"math/tex; mode=display\">\nlift=\\dfrac{P(A\\bigcap B)}{P(A)P(B)}</script><p>当lift大于1的时候表示A事件和B时间是正相关的，A随着B的出现而出现，lift为1的时候二者是独立的，lift小与1的时候二者负相关，意味着一个的出现可能导致另一个不出现。</p>\n<p>关联规则的挖掘分为两步：</p>\n<ol>\n<li>找出所有的频繁项集 一个详细的出现次数大于最小支持度的次数则是频繁的</li>\n<li>由频繁项集产生强关联规则</li>\n</ol>\n<p>包含k个项的项集称之为k项集，如果集合中的项都是频繁的，那么集合称之为频繁k项集。</p>\n<p>挖掘频繁项集的算法：Apriori和FP-Growth</p>\n<h2 id=\"Apriori\"><a href=\"#Apriori\" class=\"headerlink\" title=\"Apriori\"></a>Apriori</h2><p>Apriori运用了一个先验规则：每个频繁项集的子集一定也是频繁的项集，使用这个规则来剪枝很多候选项（非频繁的子集其父集也一定不是频繁的所以可以不用考虑）。</p>\n<p>算法步骤为：</p>\n<ul>\n<li>首先扫描一次数据库得到频繁1项集</li>\n<li>根据频繁k项集$L_k$生成频繁k+1项集（连接步和剪枝步组成）<ul>\n<li>先根据频繁k项集组合生成候选项</li>\n<li>扫描数据库得到候选项的支持度</li>\n<li>将不满足支持度的剔除</li>\n</ul>\n</li>\n<li>当没有频繁项或者候选项可以生成的时候终止</li>\n</ul>\n<h3 id=\"连接步\"><a href=\"#连接步\" class=\"headerlink\" title=\"连接步\"></a>连接步</h3><p>为了找出$L_k$ ,通过$L_{k-1}$与自身连接产生候选k项集的集合$C_k$设$l_1$和$l_2$ 是$L_{k - 1}$ 中的项集。记号$l_i[j]$表示$l_i$ 的第j 项（例如，$l_1[k-2]$表示$l_1$ 的倒数第3 项）。为方便计，假定事务或项集中的项按字典次序排序即$l_i[k]&lt;l_i[k+1]$。执行连接$L_{k - 1}$ 与$L_{k - 1}$；其中，$L_{k - 1}$ 的元素是可连接的，如果它们前(k-2)个项相同；即，$L_{k - 1}$ 的元素l1 和l2 是可连接的，如果$(l_1 [1] = l_2 [1]) ∧ (l_1 [2]= l_2 [2]) ∧ … ∧ (l_1 [k-2] = l_2 [k-2]) ∧ (l_1 [k-1] &lt; l_2 [k-1])$。条件$(l_1 [k-1] &lt; l_2 [k-1])$是简单地保证不产生重复。连接$l_1$ 和$l_2$ 产生的结果项集是$l_1 [1] l_1 [2]… l_1 [k-1] l_2 [k-1]$。</p>\n<p>举个例子假设频繁三项集有$l_1=[a,b,c], l_2=[a.b,d]$ 满足前缀相同最后一项不同所以可以产生候选的4项集：$C_4=[a,b,c,d]$ 把$l_2$的最后一项拼接到$l_1$后面。</p>\n<h3 id=\"剪枝步\"><a href=\"#剪枝步\" class=\"headerlink\" title=\"剪枝步\"></a>剪枝步</h3><p>$C_k$是频繁k项集的$L_k$的父集，可以扫描数据库来确定每一个$C_k$中的计数。但是$C_k$可能很大，所涉及的计算量也就很大。为压缩$C_k$，可以用以下办法使用Apriori 的先验性质：任何非频繁的(k-1)-项集都不是可能是频繁k-项集的子集。因此，如果一个候选k-项集的(k-1)项子集不在$L_{k - 1}$ 中，则该候选也不可能是频繁的，从而可以由$C_k$ 中删除。这种子集测试可以使用所有频繁项集的散列树(hash tree)快速完成。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1574157675/blog/Data%20Mining/Apriori_example.jpg\" alt=\"\"></p>\n<p>如上图的例子，第一次扫描得到频繁1项集的候选项$C_1$，然后根据支持度去除支持度计数小于2的$\\{D\\}$ 得到$L_1$，然后$L_1$中的各项进行连接步操作得到$C_2$，$C_2$ 执行剪枝步操作，因为所有项的子集都在$L_1$中所以不需要剪枝。进行第二次扫描得到$C_2$各项的支持度计数，然后把低于最小支持度的$\\{A,B\\},\\{A,E\\}$ 两项删除从而得到频繁2项集$L_2$。根据$L_2$执行连接步(只能由{B,C} 和{B, E}连接，其他的前缀不同)生成的$C_3=\\{B,C,E\\}$ 因为对应的3个子集{B,C},｛B,E｝和{C, E}都在频繁2项集中，所以也不需要剪枝。第三次扫描后得到$C_3$中各项的支持度计数，因为大于最小支持度计数，因此不需要删去得到了频繁3项集，因为频繁3项集只有一项无法进行连接步操作生成候选项集，所以算法终止。</p>\n<h3 id=\"产生关联规则\"><a href=\"#产生关联规则\" class=\"headerlink\" title=\"产生关联规则\"></a>产生关联规则</h3><p>以上图为例，得到了频繁3项集$L_3={\\{B,C,E\\}}$后，对其所有非空子集$\\{B\\},\\{C\\},\\{E\\},\\{B,E\\},\\{B,C\\},\\{C,E\\}$ 计算对应的关联规则$l_1 \\Rightarrow l_2\\space or \\space l_2 \\Rightarrow l_1 $的置信度，如果满足最小置信度阈值则是强关联规则。</p>\n<h3 id=\"算法伪代码\"><a href=\"#算法伪代码\" class=\"headerlink\" title=\"算法伪代码\"></a>算法伪代码</h3><p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1574157676/blog/Data%20Mining/Apriori_code.jpg\" alt=\"\"></p>\n<h3 id=\"改进算法\"><a href=\"#改进算法\" class=\"headerlink\" title=\"改进算法\"></a>改进算法</h3><ul>\n<li>Partition ：仅扫描数据库两次</li>\n<li>DHP：降低候选项的数目</li>\n<li>DIC：降低扫描次数</li>\n</ul>\n<h3 id=\"评价\"><a href=\"#评价\" class=\"headerlink\" title=\"评价\"></a>评价</h3><p>Apriori算法需要多次扫描数据库这带来的开销很大，同时会生成大量的候选项集并做子集测试也造成了很大的计算开销。</p>\n<h2 id=\"FP-Growth\"><a href=\"#FP-Growth\" class=\"headerlink\" title=\"FP-Growth\"></a>FP-Growth</h2><p>频繁模式增长FP-Growth将代表频繁项集的数据库压缩到一颗频繁模式树Frequent Patterns (FP树)中。</p>\n<h3 id=\"FP树的构建\"><a href=\"#FP树的构建\" class=\"headerlink\" title=\"FP树的构建\"></a>FP树的构建</h3><ul>\n<li>首先扫描一次数据库，找到频繁一项集。</li>\n<li>根据支持度计数降序排列频繁项记为L</li>\n<li>创建一个根节点，并标记为null</li>\n<li>再次扫描数据库，将每个事务按照L中的顺序排列。为每个事务新建一个分支<ul>\n<li>如果事务中的项已经在分支中，则分支上的节点计数+1</li>\n<li>如果项不在分支中，则在前缀路径下新建一个节点，计数为1</li>\n</ul>\n</li>\n<li>建立一个项头表把FP树中的每一项的节点相连。</li>\n</ul>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1574157675/blog/Data%20Mining/FP_tree_construct.jpg\" alt=\"FP树\"></p>\n<p>以上图为例，第一次扫描后得到的频繁一项集为$L_1=\\{f:4,c:4,a:3,b:3,m:3,p:3\\}$ 已经按照支持度计数降序排列为F-list。第二次扫描数据库，并按照F-list的顺序将每个事务排列（注意：低于支持度计数的项已经被删除了）。建立一个根节点并标记为null,第一个事务是$\\{f,c,a,m,p\\}$</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1574157675/blog/Data%20Mining/fp_tree_1.jpg\" alt=\"\"></p>\n<p>因为是第一个事务所以没有前缀路径可以共用，每个项都需要建立一个节点。第二个事务是$\\{f,c,a,b,m\\}$因为$\\{f,c,a\\}$ 是已经有的路径，所以对应的在这3个节点计数+1，$\\{b,m\\}$ 没有可以共享的路径所以需要新建立这两个节点。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1574157674/blog/Data%20Mining/fp_tree_2.jpg\" alt=\"\"></p>\n<p>当所有事务都被加入到FP树后建立项头表将相同的项给链接起来就可以得到前面的完整的FP树。</p>\n<h3 id=\"条件模式基的构造\"><a href=\"#条件模式基的构造\" class=\"headerlink\" title=\"条件模式基的构造\"></a>条件模式基的构造</h3><p>从项头表中具有最低的支持度计数的项开始构造每一个项的条件模式基Conditional Pattern Base。一个项的条件模式基定义为以这个项为后缀的前缀路径。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1574157675/blog/Data%20Mining/conditional_patter_base.jpg\" alt=\"\"></p>\n<p>以上图为例，先构造p的条件模式基，在FP树中，以p为后缀的路径为$fcam:2 和cb:1$ 后面的计数是根据每条路径的后缀的计数来确定的因此第一条$fcamp$路径的计数为2而$cbp$为1。 依次可以得到每个项的条件模式基。对每一个项的条件模式基都可以按照前述的FP树的构造方法得到其对应的条件FP树。以m的条件模式基构建的条件FP树为：<br><img src=\"https://res.cloudinary.com/bravey/image/upload/v1574157675/blog/Data%20Mining/m_conditional_fptree.jpg\" alt=\"\"></p>\n<p>因为b的支持度计数只有1所以删去。</p>\n<h3 id=\"频繁模式的产生\"><a href=\"#频繁模式的产生\" class=\"headerlink\" title=\"频繁模式的产生\"></a>频繁模式的产生</h3><p>根据条件FP树的路径产生频繁模式，路径的每个非空子集与对应的项组合产生对应的频繁模式。比如m的FP树路径为：$\\{fca\\}$ 对应的子集有$\\{f\\},\\{c\\},\\{a\\}, \\{f,c\\},\\{f,a\\},\\{a,c\\},\\{f,c,a\\}$与m组合后得到的频繁模式有：$\\{f,m\\},\\{c,m\\},\\{a.m\\}, \\{f,c,m\\},\\{f,a.m\\},\\{a,c,m\\},\\{f,c,a,m\\}$</p>\n<h3 id=\"FP树的优点\"><a href=\"#FP树的优点\" class=\"headerlink\" title=\"FP树的优点\"></a>FP树的优点</h3><p>完整的保留了频繁模式挖掘的所有信息，不损失每个事务可能的频繁项集。将发现长频繁模式的问题转换成递归地发现一些短模式，然后与后缀连接。它使用最不频繁的项作后缀，提供了好的选择性。该方法大大降低了搜索开销。</p>\n<p>FP-Growth采用分治的方法专注于小的数据集，不产生候选项集，只扫描两次数据库。因此性能比Apriori算法好。</p>\n<h3 id=\"FP-Growth-伪代码\"><a href=\"#FP-Growth-伪代码\" class=\"headerlink\" title=\"FP-Growth 伪代码\"></a>FP-Growth 伪代码</h3><p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1574157675/blog/Data%20Mining/FP-Growth_code.jpg\" alt=\"\"></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>《数据挖掘概念与技术》第3版 第六章挖掘频繁模式、关联和相关性：基本概念和方法</p>\n","site":{"data":{}},"length":3559,"excerpt":"<h1 id=\"关联规则\"><a href=\"#关联规则\" class=\"headerlink\" title=\"关联规则\"></a>关联规则</h1><h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>关联规则挖掘Association rules mining 挖掘出数据库中的频繁模式，频繁项之间的关联规则。</p>","more":"<p>关联规则的形式为</p>\n<script type=\"math/tex; mode=display\">\nA\\Rightarrow B[support=?, confident=?]</script><p>规则的支持度support和置信度confident分别反映出规则的有用性和确定性。定义为：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{split}\nsupport(A\\Rightarrow B)&=P(A\\bigcap B)=\\dfrac{count(A\\bigcap B)}{count(total)}\\\\\nconfident(A\\Rightarrow B)&=P(B|A)=\\dfrac{count(A\\bigcap B)}{count(A)}\n\\end{split}</script><p>$A\\bigcap B$ 表示A事件和B事件一起发生。使用比例的支持度称为相对支持度，使用直接的次数称为绝对支持度。当规则满足设定的最小支持度和最小置信度的时候，规则是强关联规则。强关联规则并不一定是有趣的，使用提升度lift来衡量两个事件之间的相关性</p>\n<script type=\"math/tex; mode=display\">\nlift=\\dfrac{P(A\\bigcap B)}{P(A)P(B)}</script><p>当lift大于1的时候表示A事件和B时间是正相关的，A随着B的出现而出现，lift为1的时候二者是独立的，lift小与1的时候二者负相关，意味着一个的出现可能导致另一个不出现。</p>\n<p>关联规则的挖掘分为两步：</p>\n<ol>\n<li>找出所有的频繁项集 一个详细的出现次数大于最小支持度的次数则是频繁的</li>\n<li>由频繁项集产生强关联规则</li>\n</ol>\n<p>包含k个项的项集称之为k项集，如果集合中的项都是频繁的，那么集合称之为频繁k项集。</p>\n<p>挖掘频繁项集的算法：Apriori和FP-Growth</p>\n<h2 id=\"Apriori\"><a href=\"#Apriori\" class=\"headerlink\" title=\"Apriori\"></a>Apriori</h2><p>Apriori运用了一个先验规则：每个频繁项集的子集一定也是频繁的项集，使用这个规则来剪枝很多候选项（非频繁的子集其父集也一定不是频繁的所以可以不用考虑）。</p>\n<p>算法步骤为：</p>\n<ul>\n<li>首先扫描一次数据库得到频繁1项集</li>\n<li>根据频繁k项集$L_k$生成频繁k+1项集（连接步和剪枝步组成）<ul>\n<li>先根据频繁k项集组合生成候选项</li>\n<li>扫描数据库得到候选项的支持度</li>\n<li>将不满足支持度的剔除</li>\n</ul>\n</li>\n<li>当没有频繁项或者候选项可以生成的时候终止</li>\n</ul>\n<h3 id=\"连接步\"><a href=\"#连接步\" class=\"headerlink\" title=\"连接步\"></a>连接步</h3><p>为了找出$L_k$ ,通过$L_{k-1}$与自身连接产生候选k项集的集合$C_k$设$l_1$和$l_2$ 是$L_{k - 1}$ 中的项集。记号$l_i[j]$表示$l_i$ 的第j 项（例如，$l_1[k-2]$表示$l_1$ 的倒数第3 项）。为方便计，假定事务或项集中的项按字典次序排序即$l_i[k]&lt;l_i[k+1]$。执行连接$L_{k - 1}$ 与$L_{k - 1}$；其中，$L_{k - 1}$ 的元素是可连接的，如果它们前(k-2)个项相同；即，$L_{k - 1}$ 的元素l1 和l2 是可连接的，如果$(l_1 [1] = l_2 [1]) ∧ (l_1 [2]= l_2 [2]) ∧ … ∧ (l_1 [k-2] = l_2 [k-2]) ∧ (l_1 [k-1] &lt; l_2 [k-1])$。条件$(l_1 [k-1] &lt; l_2 [k-1])$是简单地保证不产生重复。连接$l_1$ 和$l_2$ 产生的结果项集是$l_1 [1] l_1 [2]… l_1 [k-1] l_2 [k-1]$。</p>\n<p>举个例子假设频繁三项集有$l_1=[a,b,c], l_2=[a.b,d]$ 满足前缀相同最后一项不同所以可以产生候选的4项集：$C_4=[a,b,c,d]$ 把$l_2$的最后一项拼接到$l_1$后面。</p>\n<h3 id=\"剪枝步\"><a href=\"#剪枝步\" class=\"headerlink\" title=\"剪枝步\"></a>剪枝步</h3><p>$C_k$是频繁k项集的$L_k$的父集，可以扫描数据库来确定每一个$C_k$中的计数。但是$C_k$可能很大，所涉及的计算量也就很大。为压缩$C_k$，可以用以下办法使用Apriori 的先验性质：任何非频繁的(k-1)-项集都不是可能是频繁k-项集的子集。因此，如果一个候选k-项集的(k-1)项子集不在$L_{k - 1}$ 中，则该候选也不可能是频繁的，从而可以由$C_k$ 中删除。这种子集测试可以使用所有频繁项集的散列树(hash tree)快速完成。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1574157675/blog/Data%20Mining/Apriori_example.jpg\" alt=\"\"></p>\n<p>如上图的例子，第一次扫描得到频繁1项集的候选项$C_1$，然后根据支持度去除支持度计数小于2的$\\{D\\}$ 得到$L_1$，然后$L_1$中的各项进行连接步操作得到$C_2$，$C_2$ 执行剪枝步操作，因为所有项的子集都在$L_1$中所以不需要剪枝。进行第二次扫描得到$C_2$各项的支持度计数，然后把低于最小支持度的$\\{A,B\\},\\{A,E\\}$ 两项删除从而得到频繁2项集$L_2$。根据$L_2$执行连接步(只能由{B,C} 和{B, E}连接，其他的前缀不同)生成的$C_3=\\{B,C,E\\}$ 因为对应的3个子集{B,C},｛B,E｝和{C, E}都在频繁2项集中，所以也不需要剪枝。第三次扫描后得到$C_3$中各项的支持度计数，因为大于最小支持度计数，因此不需要删去得到了频繁3项集，因为频繁3项集只有一项无法进行连接步操作生成候选项集，所以算法终止。</p>\n<h3 id=\"产生关联规则\"><a href=\"#产生关联规则\" class=\"headerlink\" title=\"产生关联规则\"></a>产生关联规则</h3><p>以上图为例，得到了频繁3项集$L_3={\\{B,C,E\\}}$后，对其所有非空子集$\\{B\\},\\{C\\},\\{E\\},\\{B,E\\},\\{B,C\\},\\{C,E\\}$ 计算对应的关联规则$l_1 \\Rightarrow l_2\\space or \\space l_2 \\Rightarrow l_1 $的置信度，如果满足最小置信度阈值则是强关联规则。</p>\n<h3 id=\"算法伪代码\"><a href=\"#算法伪代码\" class=\"headerlink\" title=\"算法伪代码\"></a>算法伪代码</h3><p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1574157676/blog/Data%20Mining/Apriori_code.jpg\" alt=\"\"></p>\n<h3 id=\"改进算法\"><a href=\"#改进算法\" class=\"headerlink\" title=\"改进算法\"></a>改进算法</h3><ul>\n<li>Partition ：仅扫描数据库两次</li>\n<li>DHP：降低候选项的数目</li>\n<li>DIC：降低扫描次数</li>\n</ul>\n<h3 id=\"评价\"><a href=\"#评价\" class=\"headerlink\" title=\"评价\"></a>评价</h3><p>Apriori算法需要多次扫描数据库这带来的开销很大，同时会生成大量的候选项集并做子集测试也造成了很大的计算开销。</p>\n<h2 id=\"FP-Growth\"><a href=\"#FP-Growth\" class=\"headerlink\" title=\"FP-Growth\"></a>FP-Growth</h2><p>频繁模式增长FP-Growth将代表频繁项集的数据库压缩到一颗频繁模式树Frequent Patterns (FP树)中。</p>\n<h3 id=\"FP树的构建\"><a href=\"#FP树的构建\" class=\"headerlink\" title=\"FP树的构建\"></a>FP树的构建</h3><ul>\n<li>首先扫描一次数据库，找到频繁一项集。</li>\n<li>根据支持度计数降序排列频繁项记为L</li>\n<li>创建一个根节点，并标记为null</li>\n<li>再次扫描数据库，将每个事务按照L中的顺序排列。为每个事务新建一个分支<ul>\n<li>如果事务中的项已经在分支中，则分支上的节点计数+1</li>\n<li>如果项不在分支中，则在前缀路径下新建一个节点，计数为1</li>\n</ul>\n</li>\n<li>建立一个项头表把FP树中的每一项的节点相连。</li>\n</ul>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1574157675/blog/Data%20Mining/FP_tree_construct.jpg\" alt=\"FP树\"></p>\n<p>以上图为例，第一次扫描后得到的频繁一项集为$L_1=\\{f:4,c:4,a:3,b:3,m:3,p:3\\}$ 已经按照支持度计数降序排列为F-list。第二次扫描数据库，并按照F-list的顺序将每个事务排列（注意：低于支持度计数的项已经被删除了）。建立一个根节点并标记为null,第一个事务是$\\{f,c,a,m,p\\}$</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1574157675/blog/Data%20Mining/fp_tree_1.jpg\" alt=\"\"></p>\n<p>因为是第一个事务所以没有前缀路径可以共用，每个项都需要建立一个节点。第二个事务是$\\{f,c,a,b,m\\}$因为$\\{f,c,a\\}$ 是已经有的路径，所以对应的在这3个节点计数+1，$\\{b,m\\}$ 没有可以共享的路径所以需要新建立这两个节点。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1574157674/blog/Data%20Mining/fp_tree_2.jpg\" alt=\"\"></p>\n<p>当所有事务都被加入到FP树后建立项头表将相同的项给链接起来就可以得到前面的完整的FP树。</p>\n<h3 id=\"条件模式基的构造\"><a href=\"#条件模式基的构造\" class=\"headerlink\" title=\"条件模式基的构造\"></a>条件模式基的构造</h3><p>从项头表中具有最低的支持度计数的项开始构造每一个项的条件模式基Conditional Pattern Base。一个项的条件模式基定义为以这个项为后缀的前缀路径。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1574157675/blog/Data%20Mining/conditional_patter_base.jpg\" alt=\"\"></p>\n<p>以上图为例，先构造p的条件模式基，在FP树中，以p为后缀的路径为$fcam:2 和cb:1$ 后面的计数是根据每条路径的后缀的计数来确定的因此第一条$fcamp$路径的计数为2而$cbp$为1。 依次可以得到每个项的条件模式基。对每一个项的条件模式基都可以按照前述的FP树的构造方法得到其对应的条件FP树。以m的条件模式基构建的条件FP树为：<br><img src=\"https://res.cloudinary.com/bravey/image/upload/v1574157675/blog/Data%20Mining/m_conditional_fptree.jpg\" alt=\"\"></p>\n<p>因为b的支持度计数只有1所以删去。</p>\n<h3 id=\"频繁模式的产生\"><a href=\"#频繁模式的产生\" class=\"headerlink\" title=\"频繁模式的产生\"></a>频繁模式的产生</h3><p>根据条件FP树的路径产生频繁模式，路径的每个非空子集与对应的项组合产生对应的频繁模式。比如m的FP树路径为：$\\{fca\\}$ 对应的子集有$\\{f\\},\\{c\\},\\{a\\}, \\{f,c\\},\\{f,a\\},\\{a,c\\},\\{f,c,a\\}$与m组合后得到的频繁模式有：$\\{f,m\\},\\{c,m\\},\\{a.m\\}, \\{f,c,m\\},\\{f,a.m\\},\\{a,c,m\\},\\{f,c,a,m\\}$</p>\n<h3 id=\"FP树的优点\"><a href=\"#FP树的优点\" class=\"headerlink\" title=\"FP树的优点\"></a>FP树的优点</h3><p>完整的保留了频繁模式挖掘的所有信息，不损失每个事务可能的频繁项集。将发现长频繁模式的问题转换成递归地发现一些短模式，然后与后缀连接。它使用最不频繁的项作后缀，提供了好的选择性。该方法大大降低了搜索开销。</p>\n<p>FP-Growth采用分治的方法专注于小的数据集，不产生候选项集，只扫描两次数据库。因此性能比Apriori算法好。</p>\n<h3 id=\"FP-Growth-伪代码\"><a href=\"#FP-Growth-伪代码\" class=\"headerlink\" title=\"FP-Growth 伪代码\"></a>FP-Growth 伪代码</h3><p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1574157675/blog/Data%20Mining/FP-Growth_code.jpg\" alt=\"\"></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>《数据挖掘概念与技术》第3版 第六章挖掘频繁模式、关联和相关性：基本概念和方法</p>"},{"title":"奇思妙想","date":"2019-12-27T11:17:47.000Z","copyright":true,"_content":"\n# 奇思妙想\n\n记录一些觉得有用的点子，公式推导等。当成便利贴来使用的。23333\n\n<!--more-->\n\n## 条件联合分布的推导\n\n首先搞清楚逗号是与的意思，把逗号去掉，加个括号就好理解了。\n\n$P(S,A|T)$:事件T发生的条件下，事件S、A均发生的概率。直接把逗号给去掉，就是$P((SA)|T)$竖线的优先级别高。因此有：$P(S,A|T)=\\frac{P(SAT)}{P(T)}$\n\n$P(S|A,T)$ ：事件A、T均发生的条件下，事件S发生的概率 。\n$$\nP(X=a,Y=b|Z=c)=P(X=a|Y=b,Z=c)P(Y=b|Z=c)\n$$\n上式的证明如下：\n$$\n\\begin{equation}\\nonumber\n\\begin{split}\nP(X=a,Y=b|Z=c)&=\\frac{P(X=a,Y=b,Z=c)}{P(Z=c)}\\\\\n&=\\frac{P(X=a|Y=b,Z=c)P(Y=b,Z=c)}{P(Z=c)}\\\\\n&=\\frac{P(X=a|Y=b,Z=c)P(Y=b|Z=c)P(Z=c)}{P(Z=c)}\\\\\n&=P(X=a|Y=b,Z=c)P(Y=b|Z=c)\n\\end{split} \n\\end{equation}\n$$\n\n## 贝叶斯估计\n\n根据现有的数据样本集D估计一个新的样本的分布$x$即$P(x|D)$.通过D引入$\\theta$,然后通过$\\theta$来估计x的分布$p(x|\\theta)$\n$$\n\\begin{equation}\\nonumber\n\\begin{split}\nP(x|D)&=\\int P(x,\\theta|D)d\\theta\\\\\n&=\\int \\frac{P(x,\\theta,D)}{P(D)}d\\theta\\\\\n&=\\int \\frac{P(x|\\theta,D)P(\\theta,D)}{P(D)}d\\theta\\\\\n&=\\int \\frac{P(x|\\theta,D)P(\\theta|D)P(D)}{P(D)}d\\theta\\\\\n&=\\int P(x|\\theta,D)P(\\theta|D)P(D)d\\theta\\\\\n\\end{split} \n\\end{equation}\n$$\n关于第一步$P(x|D)=\\int P(x,\\theta|D)d\\theta$ 的理解在D条件下的联合分布对另一个变量求积分，就得到了一个边缘分布，不过这个边缘分布是在D条件下的。\n\n## 点子\n\n1. 目标函数不可导的情况下优化：遗传算法\n2. 中文OCR：github上的开源项目：chinese_ocr\n\n## 待解决的问题\n\n1. 矩阵的特征值的个数怎么判断的？重根的情况。\n2. 算出来特征向量任意取的情况，KL变换的变换矩阵还有什么作用呢？\n3. Adaboost为什么要求迭代后的更新的权重使得上一轮的学习器在这轮的性能为随机猜测呢？","source":"_posts/2019-12-27-奇思妙想.md","raw":"---\ntitle: 奇思妙想\ndate: 2019-12-27 19:17:47\ncategories: 其他\ntags:\n- 数学\n- 点子\ncopyright: true\n---\n\n# 奇思妙想\n\n记录一些觉得有用的点子，公式推导等。当成便利贴来使用的。23333\n\n<!--more-->\n\n## 条件联合分布的推导\n\n首先搞清楚逗号是与的意思，把逗号去掉，加个括号就好理解了。\n\n$P(S,A|T)$:事件T发生的条件下，事件S、A均发生的概率。直接把逗号给去掉，就是$P((SA)|T)$竖线的优先级别高。因此有：$P(S,A|T)=\\frac{P(SAT)}{P(T)}$\n\n$P(S|A,T)$ ：事件A、T均发生的条件下，事件S发生的概率 。\n$$\nP(X=a,Y=b|Z=c)=P(X=a|Y=b,Z=c)P(Y=b|Z=c)\n$$\n上式的证明如下：\n$$\n\\begin{equation}\\nonumber\n\\begin{split}\nP(X=a,Y=b|Z=c)&=\\frac{P(X=a,Y=b,Z=c)}{P(Z=c)}\\\\\n&=\\frac{P(X=a|Y=b,Z=c)P(Y=b,Z=c)}{P(Z=c)}\\\\\n&=\\frac{P(X=a|Y=b,Z=c)P(Y=b|Z=c)P(Z=c)}{P(Z=c)}\\\\\n&=P(X=a|Y=b,Z=c)P(Y=b|Z=c)\n\\end{split} \n\\end{equation}\n$$\n\n## 贝叶斯估计\n\n根据现有的数据样本集D估计一个新的样本的分布$x$即$P(x|D)$.通过D引入$\\theta$,然后通过$\\theta$来估计x的分布$p(x|\\theta)$\n$$\n\\begin{equation}\\nonumber\n\\begin{split}\nP(x|D)&=\\int P(x,\\theta|D)d\\theta\\\\\n&=\\int \\frac{P(x,\\theta,D)}{P(D)}d\\theta\\\\\n&=\\int \\frac{P(x|\\theta,D)P(\\theta,D)}{P(D)}d\\theta\\\\\n&=\\int \\frac{P(x|\\theta,D)P(\\theta|D)P(D)}{P(D)}d\\theta\\\\\n&=\\int P(x|\\theta,D)P(\\theta|D)P(D)d\\theta\\\\\n\\end{split} \n\\end{equation}\n$$\n关于第一步$P(x|D)=\\int P(x,\\theta|D)d\\theta$ 的理解在D条件下的联合分布对另一个变量求积分，就得到了一个边缘分布，不过这个边缘分布是在D条件下的。\n\n## 点子\n\n1. 目标函数不可导的情况下优化：遗传算法\n2. 中文OCR：github上的开源项目：chinese_ocr\n\n## 待解决的问题\n\n1. 矩阵的特征值的个数怎么判断的？重根的情况。\n2. 算出来特征向量任意取的情况，KL变换的变换矩阵还有什么作用呢？\n3. Adaboost为什么要求迭代后的更新的权重使得上一轮的学习器在这轮的性能为随机猜测呢？","slug":"2019-12-27-奇思妙想","published":1,"updated":"2020-02-05T02:38:17.933Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6he13za002fdstzcai2hfje","content":"<h1 id=\"奇思妙想\"><a href=\"#奇思妙想\" class=\"headerlink\" title=\"奇思妙想\"></a>奇思妙想</h1><p>记录一些觉得有用的点子，公式推导等。当成便利贴来使用的。23333</p>\n<a id=\"more\"></a>\n<h2 id=\"条件联合分布的推导\"><a href=\"#条件联合分布的推导\" class=\"headerlink\" title=\"条件联合分布的推导\"></a>条件联合分布的推导</h2><p>首先搞清楚逗号是与的意思，把逗号去掉，加个括号就好理解了。</p>\n<p>$P(S,A|T)$:事件T发生的条件下，事件S、A均发生的概率。直接把逗号给去掉，就是$P((SA)|T)$竖线的优先级别高。因此有：$P(S,A|T)=\\frac{P(SAT)}{P(T)}$</p>\n<p>$P(S|A,T)$ ：事件A、T均发生的条件下，事件S发生的概率 。</p>\n<script type=\"math/tex; mode=display\">\nP(X=a,Y=b|Z=c)=P(X=a|Y=b,Z=c)P(Y=b|Z=c)</script><p>上式的证明如下：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\\nonumber\n\\begin{split}\nP(X=a,Y=b|Z=c)&=\\frac{P(X=a,Y=b,Z=c)}{P(Z=c)}\\\\\n&=\\frac{P(X=a|Y=b,Z=c)P(Y=b,Z=c)}{P(Z=c)}\\\\\n&=\\frac{P(X=a|Y=b,Z=c)P(Y=b|Z=c)P(Z=c)}{P(Z=c)}\\\\\n&=P(X=a|Y=b,Z=c)P(Y=b|Z=c)\n\\end{split} \n\\end{equation}</script><h2 id=\"贝叶斯估计\"><a href=\"#贝叶斯估计\" class=\"headerlink\" title=\"贝叶斯估计\"></a>贝叶斯估计</h2><p>根据现有的数据样本集D估计一个新的样本的分布$x$即$P(x|D)$.通过D引入$\\theta$,然后通过$\\theta$来估计x的分布$p(x|\\theta)$</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\\nonumber\n\\begin{split}\nP(x|D)&=\\int P(x,\\theta|D)d\\theta\\\\\n&=\\int \\frac{P(x,\\theta,D)}{P(D)}d\\theta\\\\\n&=\\int \\frac{P(x|\\theta,D)P(\\theta,D)}{P(D)}d\\theta\\\\\n&=\\int \\frac{P(x|\\theta,D)P(\\theta|D)P(D)}{P(D)}d\\theta\\\\\n&=\\int P(x|\\theta,D)P(\\theta|D)P(D)d\\theta\\\\\n\\end{split} \n\\end{equation}</script><p>关于第一步$P(x|D)=\\int P(x,\\theta|D)d\\theta$ 的理解在D条件下的联合分布对另一个变量求积分，就得到了一个边缘分布，不过这个边缘分布是在D条件下的。</p>\n<h2 id=\"点子\"><a href=\"#点子\" class=\"headerlink\" title=\"点子\"></a>点子</h2><ol>\n<li>目标函数不可导的情况下优化：遗传算法</li>\n<li>中文OCR：github上的开源项目：chinese_ocr</li>\n</ol>\n<h2 id=\"待解决的问题\"><a href=\"#待解决的问题\" class=\"headerlink\" title=\"待解决的问题\"></a>待解决的问题</h2><ol>\n<li>矩阵的特征值的个数怎么判断的？重根的情况。</li>\n<li>算出来特征向量任意取的情况，KL变换的变换矩阵还有什么作用呢？</li>\n<li>Adaboost为什么要求迭代后的更新的权重使得上一轮的学习器在这轮的性能为随机猜测呢？</li>\n</ol>\n","site":{"data":{}},"length":1096,"excerpt":"<h1 id=\"奇思妙想\"><a href=\"#奇思妙想\" class=\"headerlink\" title=\"奇思妙想\"></a>奇思妙想</h1><p>记录一些觉得有用的点子，公式推导等。当成便利贴来使用的。23333</p>","more":"<h2 id=\"条件联合分布的推导\"><a href=\"#条件联合分布的推导\" class=\"headerlink\" title=\"条件联合分布的推导\"></a>条件联合分布的推导</h2><p>首先搞清楚逗号是与的意思，把逗号去掉，加个括号就好理解了。</p>\n<p>$P(S,A|T)$:事件T发生的条件下，事件S、A均发生的概率。直接把逗号给去掉，就是$P((SA)|T)$竖线的优先级别高。因此有：$P(S,A|T)=\\frac{P(SAT)}{P(T)}$</p>\n<p>$P(S|A,T)$ ：事件A、T均发生的条件下，事件S发生的概率 。</p>\n<script type=\"math/tex; mode=display\">\nP(X=a,Y=b|Z=c)=P(X=a|Y=b,Z=c)P(Y=b|Z=c)</script><p>上式的证明如下：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\\nonumber\n\\begin{split}\nP(X=a,Y=b|Z=c)&=\\frac{P(X=a,Y=b,Z=c)}{P(Z=c)}\\\\\n&=\\frac{P(X=a|Y=b,Z=c)P(Y=b,Z=c)}{P(Z=c)}\\\\\n&=\\frac{P(X=a|Y=b,Z=c)P(Y=b|Z=c)P(Z=c)}{P(Z=c)}\\\\\n&=P(X=a|Y=b,Z=c)P(Y=b|Z=c)\n\\end{split} \n\\end{equation}</script><h2 id=\"贝叶斯估计\"><a href=\"#贝叶斯估计\" class=\"headerlink\" title=\"贝叶斯估计\"></a>贝叶斯估计</h2><p>根据现有的数据样本集D估计一个新的样本的分布$x$即$P(x|D)$.通过D引入$\\theta$,然后通过$\\theta$来估计x的分布$p(x|\\theta)$</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\\nonumber\n\\begin{split}\nP(x|D)&=\\int P(x,\\theta|D)d\\theta\\\\\n&=\\int \\frac{P(x,\\theta,D)}{P(D)}d\\theta\\\\\n&=\\int \\frac{P(x|\\theta,D)P(\\theta,D)}{P(D)}d\\theta\\\\\n&=\\int \\frac{P(x|\\theta,D)P(\\theta|D)P(D)}{P(D)}d\\theta\\\\\n&=\\int P(x|\\theta,D)P(\\theta|D)P(D)d\\theta\\\\\n\\end{split} \n\\end{equation}</script><p>关于第一步$P(x|D)=\\int P(x,\\theta|D)d\\theta$ 的理解在D条件下的联合分布对另一个变量求积分，就得到了一个边缘分布，不过这个边缘分布是在D条件下的。</p>\n<h2 id=\"点子\"><a href=\"#点子\" class=\"headerlink\" title=\"点子\"></a>点子</h2><ol>\n<li>目标函数不可导的情况下优化：遗传算法</li>\n<li>中文OCR：github上的开源项目：chinese_ocr</li>\n</ol>\n<h2 id=\"待解决的问题\"><a href=\"#待解决的问题\" class=\"headerlink\" title=\"待解决的问题\"></a>待解决的问题</h2><ol>\n<li>矩阵的特征值的个数怎么判断的？重根的情况。</li>\n<li>算出来特征向量任意取的情况，KL变换的变换矩阵还有什么作用呢？</li>\n<li>Adaboost为什么要求迭代后的更新的权重使得上一轮的学习器在这轮的性能为随机猜测呢？</li>\n</ol>"},{"title":"LSTM与Prophet时间序列预测实验","date":"2019-12-20T14:24:26.000Z","copyright":true,"_content":"\n# LSTM与Prophet时间序列预测实验\n\n分别使用Pytorch构建的LSTM网络与Facebook开源的Prophet工具对时间序列进行预测的一个对比小实验，同时作为一个小白也借着这个实验来学习下Pytorch的使用，因为第一次使用，所以会比较详细的注释代码。\n\n<!--more-->\n\n使用的数据为了与Prophet进行对比，因此使用了Prophet官网例子上用到的数据集。该时间序列数据集来自维基百科上面对美国橄榄球运动员佩顿·曼宁（Peyton Williams Manning）的日访问量的记录日志，时间跨度为2007年12月10号到2016年1月20号共2905条数据。 \n\nJupyter代码与数据集地址在[我的github](<https://github.com/BraveY/AI-with-code/tree/master/time-series> )上，欢迎star。\n\n## LSTM\n\nLSTM的介绍参考[夕小瑶](<https://zhuanlan.zhihu.com/p/30465140> )与[陈诚](<https://zhuanlan.zhihu.com/p/32085405> )的介绍，代码主要参考[凌空的桨](<https://blog.csdn.net/baidu_36669549/article/details/85595807> )与[源码链接](<https://github.com/L1aoXingyu/code-of-learn-deep-learning-with-pytorch/tree/master/chapter5_RNN/time-series> ) ，在Pytorch1.3.1的版本上面改了一下，主要是测试的逻辑修改成了使用测试集以及取消了Variable的使用。整体的逻辑是使用前面的两天的数据来预测下一天的数据，网络的结构是使用了两层LSTM与一层线性回归层。\n\n### 数据预处理\n\n首先是数据的预处理代码如下：\n\n```python\nimport numpy as np \nimport pandas as pd \nimport matplotlib.pyplot as plt \nimport torch \nfrom torch import nn\n\n#数据预处理\ndata = pd.read_csv('example_wp_log_peyton_manning.csv',usecols=[1])\ndata = data.dropna() #丢弃空值\ndataset = data.values\ndataset = dataset.astype('float32')\n\nmax_value = np.max(dataset)\nmin_value = np.min(dataset)\nscalar = max_value - min_value\ndataset = list(map(lambda x: x/scalar, dataset)) #将数据归一化到0~1之间\n\n#划分数据集\n#通过前面几条的数据来预测下一条的数据，look_back设置具体的把前面几条的数据作为预测的输入data_X，而输出就是下一条data_Y\ndef create_dataset(dataset,look_back=2): # 每个的滑动窗口设置为2\n    dataX, dataY=[], []\n    for i in range(len(dataset)-look_back):\n        a=dataset[i:(i+look_back)]\n        dataX.append(a)    # 记录窗口的值\n        dataY.append(dataset[i+look_back]) # 记录除了前面两个以外的所有值作为正确的标签\n    return np.array(dataX), np.array(dataY)\n#创建好输入与输出 data_Y作为正确的预测值\ndata_X, data_Y = create_dataset(dataset)\n\n#划分训练集和测试集，70%作为训练集\ntrain_size = int(len(data_X) * 0.7)\ntest_size = len(data_X)-train_size\n\ntrain_X = data_X[:train_size]\ntrain_Y = data_Y[:train_size]\n\ntest_X = data_X[train_size:]\ntest_Y = data_Y[train_size:]\n\n#最后，我们需要将数据改变一下形状，因为 RNN 读入的数据维度是 (seq, batch, feature)，所以要重新改变一下数据的维度，这里只有一个序列，所以 batch 是 1，而输入的 feature 就是我们希望依据的几天，这里我们定的是两个天，所以 feature 就是 2.\n\ntrain_X = train_X.reshape(-1,1,2)\ntrain_Y = train_Y.reshape(-1,1,1)\ntest_X = test_X.reshape(-1,1,2)\n\n# 转化成torch 的张量\ntrain_x = torch.from_numpy(train_X)\ntrain_y = torch.from_numpy(train_Y)\ntest_x = torch.from_numpy(test_X)\n```\n\n### LSTM网络构建\n\n接着定义好网络模型，模型的第一部分是一个两层的 RNN，每一步模型接受前两天的输入作为特征，得到一个输出特征。接着通过一个线性层将 RNN 的输出回归到流量的具体数值，这里我们需要用 `view` 来重新排列，因为 `nn.Linear` 不接受三维的输入，所以我们先将前两维合并在一起，然后经过线性层之后再将其分开，最后输出结果。 \n\n```python\n#lstm 网络\nclass lstm_reg(nn.Module):#括号中的是python的类继承语法，父类是nn.Module类 不是参数的意思\n    def __init__(self,input_size,hidden_size, output_size=1,num_layers=2): # 构造函数\n        #inpu_size 是输入的样本的特征维度， hidden_size 是LSTM层的神经元个数，\n        #output_size是输出的特征维度\n        super(lstm_reg,self).__init__()# super用于多层继承使用，必须要有的操作\n \n        self.rnn = nn.LSTM(input_size,hidden_size,num_layers)# 两层LSTM网络，\n        self.reg = nn.Linear(hidden_size,output_size)#把上一层总共hidden_size个的神经元的输出向量作为输入向量，然后回归到output_size维度的输出向量中\n \n    def forward(self,x): #x是输入的数据\n        x, _ = self.rnn(x)# 单个下划线表示不在意的变量，这里是LSTM网络输出的两个隐藏层状态\n        s,b,h = x.shape\n        x = x.view(s*b, h)\n        x = self.reg(x)\n        x = x.view(s,b,-1)#使用-1表示第三个维度自动根据原来的shape 和已经定了的s,b来确定\n        return x\n#我使用了GPU加速，如果不用的话需要把.cuda()给注释掉    \nnet = lstm_reg(2,4)\nnet = net.cuda()\ncriterion = nn.MSELoss().cuda()\noptimizer = torch.optim.Adam(net.parameters(),lr=1e-2)    \n```\n\n本来打算把网络拓扑也给画出来的，后面发现自己理解的还不够深入，可以先参考[LSTM神经网络输入输出究竟是怎样的？ - Scofield的回答 - 知乎 ](https://www.zhihu.com/question/41949741/answer/318771336 ) 和[LSTM细节分析理解（pytorch版） - ymmy的文章 - 知乎 ](https://zhuanlan.zhihu.com/p/79064602 )\n\n关于forward函数中为什么每个层可以直接使用输入的数据x这个tensor，而不需要按照构造函数里面的按照形参(input_size,hidden_size,num_layers)来传递参数。以nn.LSTM做例子，官方API为：\n\n- 参数\n  – **input_size**\n  – **hidden_size**\n  – **num_layers**\n  – **bias**\n  – **batch_first**\n  – **dropout**\n  – **bidirectional**\n- 输入\n  – **input** (seq_len, batch, input_size)\n  – **h_0** (num_layers * num_directions, batch, hidden_size)\n  – **c_0** (num_layers * num_directions, batch, hidden_size)\n- 输出\n  – **output** (seq_len, batch, num_directions * hidden_size)\n  – **h_n** (num_layers * num_directions, batch, hidden_size)\n  – **c_n** (num_layers * num_directions, batch, hidden_size)\n\n 所以forward中的x，`x, _ = self.rnn(x)`传递的参数是对应输入**input** (seq_len, batch, input_size)这个tensor，而不是对应的参数列表。同样`_`所代表的参数也就是**h_n** 和**c_n**。\n\n### 迭代\n\n迭代过程进行了10000次迭代：\n\n```python\nfor e in range(10000):\n# 新版本中可以不使用Variable了    \n#     var_x = Variable(train_x).cuda() \n#     var_y = Variable(train_y).cuda()\n\n#将tensor放在GPU上面进行运算\n    var_x = train_x.cuda()\n    var_y = train_y.cuda()\n \n    out = net(var_x)\n    loss = criterion(out, var_y)\n \n    optimizer.zero_grad()\n    loss.backward()\n    optimizer.step()\n    if (e+1)%100 == 0:\n        print('Epoch: {}, Loss:{:.5f}'.format(e+1, loss.item()))\n#存储训练好的模型参数        \ntorch.save(net.state_dict(), 'example_wp_log.net_params.pkl')\n```\n\n### 测试过程\n\n在测试的时候我发现源码中并没有用到之前划分的30%的测试集来单独进行测试，而是直接把原来的完整数据给丢进去来训练的，这儿有点没搞懂。因为按理来说需要单独使用测试集进行测试来评判模型的性能的，所以我单独把测试的数据集给提出来，使用单独的测试集进行了测试。\n\n```python\nnet.load_state_dict(torch.load('example_wp_log.net_params.pkl')) \nvar_data = torch.from_numpy(test_X).cuda()#net在GPU上面，所以输入的测试集合也要转入到GPU上面\npred_test = net(var_data) # 测试集的预测结果\npred_test = pred_test.cpu().view(-1).data.numpy()#先转移到cpu上才能转换为numpy\n\n#乘以原来归一化的刻度放缩回到原来的值域 \norigin_test_Y = test_Y*scalar\norigin_pred_test = pred_test*scalar\n\n#画图\nplt.plot(origin_pred_test, 'r', label='prediction')\nplt.plot(origin_test_Y, 'b', label='real')\nplt.legend(loc='best')\nplt.show()\n\n#计算MSE\n#loss = criterion(out, var_y)？\ntrue_data = origin_test_Y\ntrue_data = np.array(true_data)\ntrue_data = np.squeeze(true_data)  # 从二维变成一维\nMSE = true_data - origin_pred_test\nMSE = MSE*MSE\nMSE_loss = sum(MSE)/len(MSE)\nprint(MSE_loss)\n```\n\n计算出来的MSE为`0.195649022176008`, 画出来的曲线图为：\n\n![](https://res.cloudinary.com/bravey/image/upload/v1576911405/blog/deep-learning/LSTM_time_series.png)\n\n### GPU加速\n\n`use_gpu = torch.cuda.is_available()  # 判断是否有GPU加速`\n\nCUDA 加速需要设置的为：\n\n1. 迭代的过程中输入的tensor放到GPU上  var_x = train_x.cuda()\n2. 模型转移到GPU net.cuda()\n3. 损失函数转移到GPU criterion = nn.MSELoss().cuda()\n\n## Prophet\n\nProphet是facebook开源的一个时间序列预测工具,使用了时间序列分解与机器学习拟合的方法。详细介绍参考[张戎](<https://zhuanlan.zhihu.com/p/52330017> )的介绍。\n\n### Prophet的安装\n\n在安装Prophet的时候并没有想官网介绍的那么简单，首先需要先安装Pystan,但是直接`pip install pystan`会报编译器内部错误，使用`conda install -c conda-forge pystan `之后问题解决，然后再使用`pip install fbprophet ` 进行安装。\n\n### 实验\n\n实验的例子就是官网的例子\n\n```python\nimport pandas as pd\nfrom fbprophet import Prophet\ndf = pd.read_csv('example_wp_log_peyton_manning.csv')\n\n#Prophet使用\nm = Prophet()\nm.fit(df)\n#需要预测时间段为整个365天，也就是下一年的整个天数\nfuture = m.make_future_dataframe(periods=365)\n#开始预测\nforecast = m.predict(future)\n#预测的结果保存在yhat_upper列中\nforecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].tail()\n#画图\nplt.plot(fb_pre, 'r', label='prediction')\nplt.plot(origin_test_Y, 'b', label='real')\nplt.legend(loc='best')\nplt.show()\n#计算MSE\nfb_pre = np.array(forecast['yhat'].iloc[2034:2905])#2034到2905是前面30%的测试集所对应的数据范围\nMSE = true_data - fb_pre\nMSE = MSE*MSE\nMSE_loss = sum(MSE)/len(MSE)\nprint(MSE_loss)\n```\n\n计算出来的MSE为：`0.25229994660830146`,画出来的图像为：\n\n![](https://res.cloudinary.com/bravey/image/upload/v1576911405/blog/deep-learning/Prophet_time_series.png)\n\n## 总结\n\n| 方法    | MSE                 |\n| ------- | ------------------- |\n| LSTM    | 0.195649022176008   |\n| Prophet | 0.25229994660830146 |\n\n可以看到使用LSTM的预测结果要比Prophet的结果好，但是也有可能是我还没有去调整Prophet的参数导致Prophet的性能差一些的。同时Prophet可以预测整整一年的时间，这个比起使用LSTM要厉害很多，实验中的LSTM使用的是单步预测的方法，也就是只能根据前段时刻的数据来预测下一个时刻的数据，如果要做到像Prophet那样预测未来一段时刻的数据，需要使用多步预测的方法，我查了下涉及到seq2seq，貌似比较复杂，还没有做实验。\n\n自己是小白，实验可能存在相关问题与不足之处，欢迎反馈。\n\n## 参考\n\nPytorch中的[LSTM参数](<https://zhuanlan.zhihu.com/p/41261640> )\n\n[Prophet官网](<https://facebook.github.io/prophet/> )\n\n[Prophet安装问题](<https://www.okcode.net/article/43571> ) ","source":"_posts/2019-12-20-LSTM与Prophet时间序列预测实验.md","raw":"---\ntitle: LSTM与Prophet时间序列预测实验\ndate: 2019-12-20 22:24:26\ncategories: 深度学习\ntags:\n- 时间序列\n- LSTM\n- Pytorch\n- Prophet\ncopyright: true\n---\n\n# LSTM与Prophet时间序列预测实验\n\n分别使用Pytorch构建的LSTM网络与Facebook开源的Prophet工具对时间序列进行预测的一个对比小实验，同时作为一个小白也借着这个实验来学习下Pytorch的使用，因为第一次使用，所以会比较详细的注释代码。\n\n<!--more-->\n\n使用的数据为了与Prophet进行对比，因此使用了Prophet官网例子上用到的数据集。该时间序列数据集来自维基百科上面对美国橄榄球运动员佩顿·曼宁（Peyton Williams Manning）的日访问量的记录日志，时间跨度为2007年12月10号到2016年1月20号共2905条数据。 \n\nJupyter代码与数据集地址在[我的github](<https://github.com/BraveY/AI-with-code/tree/master/time-series> )上，欢迎star。\n\n## LSTM\n\nLSTM的介绍参考[夕小瑶](<https://zhuanlan.zhihu.com/p/30465140> )与[陈诚](<https://zhuanlan.zhihu.com/p/32085405> )的介绍，代码主要参考[凌空的桨](<https://blog.csdn.net/baidu_36669549/article/details/85595807> )与[源码链接](<https://github.com/L1aoXingyu/code-of-learn-deep-learning-with-pytorch/tree/master/chapter5_RNN/time-series> ) ，在Pytorch1.3.1的版本上面改了一下，主要是测试的逻辑修改成了使用测试集以及取消了Variable的使用。整体的逻辑是使用前面的两天的数据来预测下一天的数据，网络的结构是使用了两层LSTM与一层线性回归层。\n\n### 数据预处理\n\n首先是数据的预处理代码如下：\n\n```python\nimport numpy as np \nimport pandas as pd \nimport matplotlib.pyplot as plt \nimport torch \nfrom torch import nn\n\n#数据预处理\ndata = pd.read_csv('example_wp_log_peyton_manning.csv',usecols=[1])\ndata = data.dropna() #丢弃空值\ndataset = data.values\ndataset = dataset.astype('float32')\n\nmax_value = np.max(dataset)\nmin_value = np.min(dataset)\nscalar = max_value - min_value\ndataset = list(map(lambda x: x/scalar, dataset)) #将数据归一化到0~1之间\n\n#划分数据集\n#通过前面几条的数据来预测下一条的数据，look_back设置具体的把前面几条的数据作为预测的输入data_X，而输出就是下一条data_Y\ndef create_dataset(dataset,look_back=2): # 每个的滑动窗口设置为2\n    dataX, dataY=[], []\n    for i in range(len(dataset)-look_back):\n        a=dataset[i:(i+look_back)]\n        dataX.append(a)    # 记录窗口的值\n        dataY.append(dataset[i+look_back]) # 记录除了前面两个以外的所有值作为正确的标签\n    return np.array(dataX), np.array(dataY)\n#创建好输入与输出 data_Y作为正确的预测值\ndata_X, data_Y = create_dataset(dataset)\n\n#划分训练集和测试集，70%作为训练集\ntrain_size = int(len(data_X) * 0.7)\ntest_size = len(data_X)-train_size\n\ntrain_X = data_X[:train_size]\ntrain_Y = data_Y[:train_size]\n\ntest_X = data_X[train_size:]\ntest_Y = data_Y[train_size:]\n\n#最后，我们需要将数据改变一下形状，因为 RNN 读入的数据维度是 (seq, batch, feature)，所以要重新改变一下数据的维度，这里只有一个序列，所以 batch 是 1，而输入的 feature 就是我们希望依据的几天，这里我们定的是两个天，所以 feature 就是 2.\n\ntrain_X = train_X.reshape(-1,1,2)\ntrain_Y = train_Y.reshape(-1,1,1)\ntest_X = test_X.reshape(-1,1,2)\n\n# 转化成torch 的张量\ntrain_x = torch.from_numpy(train_X)\ntrain_y = torch.from_numpy(train_Y)\ntest_x = torch.from_numpy(test_X)\n```\n\n### LSTM网络构建\n\n接着定义好网络模型，模型的第一部分是一个两层的 RNN，每一步模型接受前两天的输入作为特征，得到一个输出特征。接着通过一个线性层将 RNN 的输出回归到流量的具体数值，这里我们需要用 `view` 来重新排列，因为 `nn.Linear` 不接受三维的输入，所以我们先将前两维合并在一起，然后经过线性层之后再将其分开，最后输出结果。 \n\n```python\n#lstm 网络\nclass lstm_reg(nn.Module):#括号中的是python的类继承语法，父类是nn.Module类 不是参数的意思\n    def __init__(self,input_size,hidden_size, output_size=1,num_layers=2): # 构造函数\n        #inpu_size 是输入的样本的特征维度， hidden_size 是LSTM层的神经元个数，\n        #output_size是输出的特征维度\n        super(lstm_reg,self).__init__()# super用于多层继承使用，必须要有的操作\n \n        self.rnn = nn.LSTM(input_size,hidden_size,num_layers)# 两层LSTM网络，\n        self.reg = nn.Linear(hidden_size,output_size)#把上一层总共hidden_size个的神经元的输出向量作为输入向量，然后回归到output_size维度的输出向量中\n \n    def forward(self,x): #x是输入的数据\n        x, _ = self.rnn(x)# 单个下划线表示不在意的变量，这里是LSTM网络输出的两个隐藏层状态\n        s,b,h = x.shape\n        x = x.view(s*b, h)\n        x = self.reg(x)\n        x = x.view(s,b,-1)#使用-1表示第三个维度自动根据原来的shape 和已经定了的s,b来确定\n        return x\n#我使用了GPU加速，如果不用的话需要把.cuda()给注释掉    \nnet = lstm_reg(2,4)\nnet = net.cuda()\ncriterion = nn.MSELoss().cuda()\noptimizer = torch.optim.Adam(net.parameters(),lr=1e-2)    \n```\n\n本来打算把网络拓扑也给画出来的，后面发现自己理解的还不够深入，可以先参考[LSTM神经网络输入输出究竟是怎样的？ - Scofield的回答 - 知乎 ](https://www.zhihu.com/question/41949741/answer/318771336 ) 和[LSTM细节分析理解（pytorch版） - ymmy的文章 - 知乎 ](https://zhuanlan.zhihu.com/p/79064602 )\n\n关于forward函数中为什么每个层可以直接使用输入的数据x这个tensor，而不需要按照构造函数里面的按照形参(input_size,hidden_size,num_layers)来传递参数。以nn.LSTM做例子，官方API为：\n\n- 参数\n  – **input_size**\n  – **hidden_size**\n  – **num_layers**\n  – **bias**\n  – **batch_first**\n  – **dropout**\n  – **bidirectional**\n- 输入\n  – **input** (seq_len, batch, input_size)\n  – **h_0** (num_layers * num_directions, batch, hidden_size)\n  – **c_0** (num_layers * num_directions, batch, hidden_size)\n- 输出\n  – **output** (seq_len, batch, num_directions * hidden_size)\n  – **h_n** (num_layers * num_directions, batch, hidden_size)\n  – **c_n** (num_layers * num_directions, batch, hidden_size)\n\n 所以forward中的x，`x, _ = self.rnn(x)`传递的参数是对应输入**input** (seq_len, batch, input_size)这个tensor，而不是对应的参数列表。同样`_`所代表的参数也就是**h_n** 和**c_n**。\n\n### 迭代\n\n迭代过程进行了10000次迭代：\n\n```python\nfor e in range(10000):\n# 新版本中可以不使用Variable了    \n#     var_x = Variable(train_x).cuda() \n#     var_y = Variable(train_y).cuda()\n\n#将tensor放在GPU上面进行运算\n    var_x = train_x.cuda()\n    var_y = train_y.cuda()\n \n    out = net(var_x)\n    loss = criterion(out, var_y)\n \n    optimizer.zero_grad()\n    loss.backward()\n    optimizer.step()\n    if (e+1)%100 == 0:\n        print('Epoch: {}, Loss:{:.5f}'.format(e+1, loss.item()))\n#存储训练好的模型参数        \ntorch.save(net.state_dict(), 'example_wp_log.net_params.pkl')\n```\n\n### 测试过程\n\n在测试的时候我发现源码中并没有用到之前划分的30%的测试集来单独进行测试，而是直接把原来的完整数据给丢进去来训练的，这儿有点没搞懂。因为按理来说需要单独使用测试集进行测试来评判模型的性能的，所以我单独把测试的数据集给提出来，使用单独的测试集进行了测试。\n\n```python\nnet.load_state_dict(torch.load('example_wp_log.net_params.pkl')) \nvar_data = torch.from_numpy(test_X).cuda()#net在GPU上面，所以输入的测试集合也要转入到GPU上面\npred_test = net(var_data) # 测试集的预测结果\npred_test = pred_test.cpu().view(-1).data.numpy()#先转移到cpu上才能转换为numpy\n\n#乘以原来归一化的刻度放缩回到原来的值域 \norigin_test_Y = test_Y*scalar\norigin_pred_test = pred_test*scalar\n\n#画图\nplt.plot(origin_pred_test, 'r', label='prediction')\nplt.plot(origin_test_Y, 'b', label='real')\nplt.legend(loc='best')\nplt.show()\n\n#计算MSE\n#loss = criterion(out, var_y)？\ntrue_data = origin_test_Y\ntrue_data = np.array(true_data)\ntrue_data = np.squeeze(true_data)  # 从二维变成一维\nMSE = true_data - origin_pred_test\nMSE = MSE*MSE\nMSE_loss = sum(MSE)/len(MSE)\nprint(MSE_loss)\n```\n\n计算出来的MSE为`0.195649022176008`, 画出来的曲线图为：\n\n![](https://res.cloudinary.com/bravey/image/upload/v1576911405/blog/deep-learning/LSTM_time_series.png)\n\n### GPU加速\n\n`use_gpu = torch.cuda.is_available()  # 判断是否有GPU加速`\n\nCUDA 加速需要设置的为：\n\n1. 迭代的过程中输入的tensor放到GPU上  var_x = train_x.cuda()\n2. 模型转移到GPU net.cuda()\n3. 损失函数转移到GPU criterion = nn.MSELoss().cuda()\n\n## Prophet\n\nProphet是facebook开源的一个时间序列预测工具,使用了时间序列分解与机器学习拟合的方法。详细介绍参考[张戎](<https://zhuanlan.zhihu.com/p/52330017> )的介绍。\n\n### Prophet的安装\n\n在安装Prophet的时候并没有想官网介绍的那么简单，首先需要先安装Pystan,但是直接`pip install pystan`会报编译器内部错误，使用`conda install -c conda-forge pystan `之后问题解决，然后再使用`pip install fbprophet ` 进行安装。\n\n### 实验\n\n实验的例子就是官网的例子\n\n```python\nimport pandas as pd\nfrom fbprophet import Prophet\ndf = pd.read_csv('example_wp_log_peyton_manning.csv')\n\n#Prophet使用\nm = Prophet()\nm.fit(df)\n#需要预测时间段为整个365天，也就是下一年的整个天数\nfuture = m.make_future_dataframe(periods=365)\n#开始预测\nforecast = m.predict(future)\n#预测的结果保存在yhat_upper列中\nforecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].tail()\n#画图\nplt.plot(fb_pre, 'r', label='prediction')\nplt.plot(origin_test_Y, 'b', label='real')\nplt.legend(loc='best')\nplt.show()\n#计算MSE\nfb_pre = np.array(forecast['yhat'].iloc[2034:2905])#2034到2905是前面30%的测试集所对应的数据范围\nMSE = true_data - fb_pre\nMSE = MSE*MSE\nMSE_loss = sum(MSE)/len(MSE)\nprint(MSE_loss)\n```\n\n计算出来的MSE为：`0.25229994660830146`,画出来的图像为：\n\n![](https://res.cloudinary.com/bravey/image/upload/v1576911405/blog/deep-learning/Prophet_time_series.png)\n\n## 总结\n\n| 方法    | MSE                 |\n| ------- | ------------------- |\n| LSTM    | 0.195649022176008   |\n| Prophet | 0.25229994660830146 |\n\n可以看到使用LSTM的预测结果要比Prophet的结果好，但是也有可能是我还没有去调整Prophet的参数导致Prophet的性能差一些的。同时Prophet可以预测整整一年的时间，这个比起使用LSTM要厉害很多，实验中的LSTM使用的是单步预测的方法，也就是只能根据前段时刻的数据来预测下一个时刻的数据，如果要做到像Prophet那样预测未来一段时刻的数据，需要使用多步预测的方法，我查了下涉及到seq2seq，貌似比较复杂，还没有做实验。\n\n自己是小白，实验可能存在相关问题与不足之处，欢迎反馈。\n\n## 参考\n\nPytorch中的[LSTM参数](<https://zhuanlan.zhihu.com/p/41261640> )\n\n[Prophet官网](<https://facebook.github.io/prophet/> )\n\n[Prophet安装问题](<https://www.okcode.net/article/43571> ) ","slug":"2019-12-20-LSTM与Prophet时间序列预测实验","published":1,"updated":"2019-12-21T08:23:13.385Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6he13zc002idstz2xdtd06n","content":"<h1 id=\"LSTM与Prophet时间序列预测实验\"><a href=\"#LSTM与Prophet时间序列预测实验\" class=\"headerlink\" title=\"LSTM与Prophet时间序列预测实验\"></a>LSTM与Prophet时间序列预测实验</h1><p>分别使用Pytorch构建的LSTM网络与Facebook开源的Prophet工具对时间序列进行预测的一个对比小实验，同时作为一个小白也借着这个实验来学习下Pytorch的使用，因为第一次使用，所以会比较详细的注释代码。</p>\n<a id=\"more\"></a>\n<p>使用的数据为了与Prophet进行对比，因此使用了Prophet官网例子上用到的数据集。该时间序列数据集来自维基百科上面对美国橄榄球运动员佩顿·曼宁（Peyton Williams Manning）的日访问量的记录日志，时间跨度为2007年12月10号到2016年1月20号共2905条数据。 </p>\n<p>Jupyter代码与数据集地址在<a href=\"https://github.com/BraveY/AI-with-code/tree/master/time-series\" target=\"_blank\" rel=\"noopener\">我的github</a>上，欢迎star。</p>\n<h2 id=\"LSTM\"><a href=\"#LSTM\" class=\"headerlink\" title=\"LSTM\"></a>LSTM</h2><p>LSTM的介绍参考<a href=\"https://zhuanlan.zhihu.com/p/30465140\" target=\"_blank\" rel=\"noopener\">夕小瑶</a>与<a href=\"https://zhuanlan.zhihu.com/p/32085405\" target=\"_blank\" rel=\"noopener\">陈诚</a>的介绍，代码主要参考<a href=\"https://blog.csdn.net/baidu_36669549/article/details/85595807\" target=\"_blank\" rel=\"noopener\">凌空的桨</a>与<a href=\"https://github.com/L1aoXingyu/code-of-learn-deep-learning-with-pytorch/tree/master/chapter5_RNN/time-series\" target=\"_blank\" rel=\"noopener\">源码链接</a> ，在Pytorch1.3.1的版本上面改了一下，主要是测试的逻辑修改成了使用测试集以及取消了Variable的使用。整体的逻辑是使用前面的两天的数据来预测下一天的数据，网络的结构是使用了两层LSTM与一层线性回归层。</p>\n<h3 id=\"数据预处理\"><a href=\"#数据预处理\" class=\"headerlink\" title=\"数据预处理\"></a>数据预处理</h3><p>首先是数据的预处理代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np </span><br><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd </span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt </span><br><span class=\"line\"><span class=\"keyword\">import</span> torch </span><br><span class=\"line\"><span class=\"keyword\">from</span> torch <span class=\"keyword\">import</span> nn</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#数据预处理</span></span><br><span class=\"line\">data = pd.read_csv(<span class=\"string\">'example_wp_log_peyton_manning.csv'</span>,usecols=[<span class=\"number\">1</span>])</span><br><span class=\"line\">data = data.dropna() <span class=\"comment\">#丢弃空值</span></span><br><span class=\"line\">dataset = data.values</span><br><span class=\"line\">dataset = dataset.astype(<span class=\"string\">'float32'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">max_value = np.max(dataset)</span><br><span class=\"line\">min_value = np.min(dataset)</span><br><span class=\"line\">scalar = max_value - min_value</span><br><span class=\"line\">dataset = list(map(<span class=\"keyword\">lambda</span> x: x/scalar, dataset)) <span class=\"comment\">#将数据归一化到0~1之间</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#划分数据集</span></span><br><span class=\"line\"><span class=\"comment\">#通过前面几条的数据来预测下一条的数据，look_back设置具体的把前面几条的数据作为预测的输入data_X，而输出就是下一条data_Y</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">create_dataset</span><span class=\"params\">(dataset,look_back=<span class=\"number\">2</span>)</span>:</span> <span class=\"comment\"># 每个的滑动窗口设置为2</span></span><br><span class=\"line\">    dataX, dataY=[], []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(dataset)-look_back):</span><br><span class=\"line\">        a=dataset[i:(i+look_back)]</span><br><span class=\"line\">        dataX.append(a)    <span class=\"comment\"># 记录窗口的值</span></span><br><span class=\"line\">        dataY.append(dataset[i+look_back]) <span class=\"comment\"># 记录除了前面两个以外的所有值作为正确的标签</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> np.array(dataX), np.array(dataY)</span><br><span class=\"line\"><span class=\"comment\">#创建好输入与输出 data_Y作为正确的预测值</span></span><br><span class=\"line\">data_X, data_Y = create_dataset(dataset)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#划分训练集和测试集，70%作为训练集</span></span><br><span class=\"line\">train_size = int(len(data_X) * <span class=\"number\">0.7</span>)</span><br><span class=\"line\">test_size = len(data_X)-train_size</span><br><span class=\"line\"></span><br><span class=\"line\">train_X = data_X[:train_size]</span><br><span class=\"line\">train_Y = data_Y[:train_size]</span><br><span class=\"line\"></span><br><span class=\"line\">test_X = data_X[train_size:]</span><br><span class=\"line\">test_Y = data_Y[train_size:]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#最后，我们需要将数据改变一下形状，因为 RNN 读入的数据维度是 (seq, batch, feature)，所以要重新改变一下数据的维度，这里只有一个序列，所以 batch 是 1，而输入的 feature 就是我们希望依据的几天，这里我们定的是两个天，所以 feature 就是 2.</span></span><br><span class=\"line\"></span><br><span class=\"line\">train_X = train_X.reshape(<span class=\"number\">-1</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>)</span><br><span class=\"line\">train_Y = train_Y.reshape(<span class=\"number\">-1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>)</span><br><span class=\"line\">test_X = test_X.reshape(<span class=\"number\">-1</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 转化成torch 的张量</span></span><br><span class=\"line\">train_x = torch.from_numpy(train_X)</span><br><span class=\"line\">train_y = torch.from_numpy(train_Y)</span><br><span class=\"line\">test_x = torch.from_numpy(test_X)</span><br></pre></td></tr></table></figure>\n<h3 id=\"LSTM网络构建\"><a href=\"#LSTM网络构建\" class=\"headerlink\" title=\"LSTM网络构建\"></a>LSTM网络构建</h3><p>接着定义好网络模型，模型的第一部分是一个两层的 RNN，每一步模型接受前两天的输入作为特征，得到一个输出特征。接着通过一个线性层将 RNN 的输出回归到流量的具体数值，这里我们需要用 <code>view</code> 来重新排列，因为 <code>nn.Linear</code> 不接受三维的输入，所以我们先将前两维合并在一起，然后经过线性层之后再将其分开，最后输出结果。 </p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#lstm 网络</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">lstm_reg</span><span class=\"params\">(nn.Module)</span>:</span><span class=\"comment\">#括号中的是python的类继承语法，父类是nn.Module类 不是参数的意思</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self,input_size,hidden_size, output_size=<span class=\"number\">1</span>,num_layers=<span class=\"number\">2</span>)</span>:</span> <span class=\"comment\"># 构造函数</span></span><br><span class=\"line\">        <span class=\"comment\">#inpu_size 是输入的样本的特征维度， hidden_size 是LSTM层的神经元个数，</span></span><br><span class=\"line\">        <span class=\"comment\">#output_size是输出的特征维度</span></span><br><span class=\"line\">        super(lstm_reg,self).__init__()<span class=\"comment\"># super用于多层继承使用，必须要有的操作</span></span><br><span class=\"line\"> </span><br><span class=\"line\">        self.rnn = nn.LSTM(input_size,hidden_size,num_layers)<span class=\"comment\"># 两层LSTM网络，</span></span><br><span class=\"line\">        self.reg = nn.Linear(hidden_size,output_size)<span class=\"comment\">#把上一层总共hidden_size个的神经元的输出向量作为输入向量，然后回归到output_size维度的输出向量中</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">forward</span><span class=\"params\">(self,x)</span>:</span> <span class=\"comment\">#x是输入的数据</span></span><br><span class=\"line\">        x, _ = self.rnn(x)<span class=\"comment\"># 单个下划线表示不在意的变量，这里是LSTM网络输出的两个隐藏层状态</span></span><br><span class=\"line\">        s,b,h = x.shape</span><br><span class=\"line\">        x = x.view(s*b, h)</span><br><span class=\"line\">        x = self.reg(x)</span><br><span class=\"line\">        x = x.view(s,b,<span class=\"number\">-1</span>)<span class=\"comment\">#使用-1表示第三个维度自动根据原来的shape 和已经定了的s,b来确定</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> x</span><br><span class=\"line\"><span class=\"comment\">#我使用了GPU加速，如果不用的话需要把.cuda()给注释掉    </span></span><br><span class=\"line\">net = lstm_reg(<span class=\"number\">2</span>,<span class=\"number\">4</span>)</span><br><span class=\"line\">net = net.cuda()</span><br><span class=\"line\">criterion = nn.MSELoss().cuda()</span><br><span class=\"line\">optimizer = torch.optim.Adam(net.parameters(),lr=<span class=\"number\">1e-2</span>)</span><br></pre></td></tr></table></figure>\n<p>本来打算把网络拓扑也给画出来的，后面发现自己理解的还不够深入，可以先参考<a href=\"https://www.zhihu.com/question/41949741/answer/318771336\" target=\"_blank\" rel=\"noopener\">LSTM神经网络输入输出究竟是怎样的？ - Scofield的回答 - 知乎 </a> 和<a href=\"https://zhuanlan.zhihu.com/p/79064602\" target=\"_blank\" rel=\"noopener\">LSTM细节分析理解（pytorch版） - ymmy的文章 - 知乎 </a></p>\n<p>关于forward函数中为什么每个层可以直接使用输入的数据x这个tensor，而不需要按照构造函数里面的按照形参(input_size,hidden_size,num_layers)来传递参数。以nn.LSTM做例子，官方API为：</p>\n<ul>\n<li>参数<br>– <strong>input_size</strong><br>– <strong>hidden_size</strong><br>– <strong>num_layers</strong><br>– <strong>bias</strong><br>– <strong>batch_first</strong><br>– <strong>dropout</strong><br>– <strong>bidirectional</strong></li>\n<li>输入<br>– <strong>input</strong> (seq_len, batch, input_size)<br>– <strong>h_0</strong> (num_layers <em> num_directions, batch, hidden_size)<br>– <strong>c_0</strong> (num_layers </em> num_directions, batch, hidden_size)</li>\n<li><p>输出<br>– <strong>output</strong> (seq_len, batch, num_directions <em> hidden_size)<br>– <strong>h_n</strong> (num_layers </em> num_directions, batch, hidden_size)<br>– <strong>c_n</strong> (num_layers * num_directions, batch, hidden_size)</p>\n<p>所以forward中的x，<code>x, _ = self.rnn(x)</code>传递的参数是对应输入<strong>input</strong> (seq_len, batch, input_size)这个tensor，而不是对应的参数列表。同样<code>_</code>所代表的参数也就是<strong>h_n</strong> 和<strong>c_n</strong>。</p>\n</li>\n</ul>\n<h3 id=\"迭代\"><a href=\"#迭代\" class=\"headerlink\" title=\"迭代\"></a>迭代</h3><p>迭代过程进行了10000次迭代：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> e <span class=\"keyword\">in</span> range(<span class=\"number\">10000</span>):</span><br><span class=\"line\"><span class=\"comment\"># 新版本中可以不使用Variable了    </span></span><br><span class=\"line\"><span class=\"comment\">#     var_x = Variable(train_x).cuda() </span></span><br><span class=\"line\"><span class=\"comment\">#     var_y = Variable(train_y).cuda()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#将tensor放在GPU上面进行运算</span></span><br><span class=\"line\">    var_x = train_x.cuda()</span><br><span class=\"line\">    var_y = train_y.cuda()</span><br><span class=\"line\"> </span><br><span class=\"line\">    out = net(var_x)</span><br><span class=\"line\">    loss = criterion(out, var_y)</span><br><span class=\"line\"> </span><br><span class=\"line\">    optimizer.zero_grad()</span><br><span class=\"line\">    loss.backward()</span><br><span class=\"line\">    optimizer.step()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e+<span class=\"number\">1</span>)%<span class=\"number\">100</span> == <span class=\"number\">0</span>:</span><br><span class=\"line\">        print(<span class=\"string\">'Epoch: &#123;&#125;, Loss:&#123;:.5f&#125;'</span>.format(e+<span class=\"number\">1</span>, loss.item()))</span><br><span class=\"line\"><span class=\"comment\">#存储训练好的模型参数        </span></span><br><span class=\"line\">torch.save(net.state_dict(), <span class=\"string\">'example_wp_log.net_params.pkl'</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"测试过程\"><a href=\"#测试过程\" class=\"headerlink\" title=\"测试过程\"></a>测试过程</h3><p>在测试的时候我发现源码中并没有用到之前划分的30%的测试集来单独进行测试，而是直接把原来的完整数据给丢进去来训练的，这儿有点没搞懂。因为按理来说需要单独使用测试集进行测试来评判模型的性能的，所以我单独把测试的数据集给提出来，使用单独的测试集进行了测试。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">net.load_state_dict(torch.load(<span class=\"string\">'example_wp_log.net_params.pkl'</span>)) </span><br><span class=\"line\">var_data = torch.from_numpy(test_X).cuda()<span class=\"comment\">#net在GPU上面，所以输入的测试集合也要转入到GPU上面</span></span><br><span class=\"line\">pred_test = net(var_data) <span class=\"comment\"># 测试集的预测结果</span></span><br><span class=\"line\">pred_test = pred_test.cpu().view(<span class=\"number\">-1</span>).data.numpy()<span class=\"comment\">#先转移到cpu上才能转换为numpy</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#乘以原来归一化的刻度放缩回到原来的值域 </span></span><br><span class=\"line\">origin_test_Y = test_Y*scalar</span><br><span class=\"line\">origin_pred_test = pred_test*scalar</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#画图</span></span><br><span class=\"line\">plt.plot(origin_pred_test, <span class=\"string\">'r'</span>, label=<span class=\"string\">'prediction'</span>)</span><br><span class=\"line\">plt.plot(origin_test_Y, <span class=\"string\">'b'</span>, label=<span class=\"string\">'real'</span>)</span><br><span class=\"line\">plt.legend(loc=<span class=\"string\">'best'</span>)</span><br><span class=\"line\">plt.show()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#计算MSE</span></span><br><span class=\"line\"><span class=\"comment\">#loss = criterion(out, var_y)？</span></span><br><span class=\"line\">true_data = origin_test_Y</span><br><span class=\"line\">true_data = np.array(true_data)</span><br><span class=\"line\">true_data = np.squeeze(true_data)  <span class=\"comment\"># 从二维变成一维</span></span><br><span class=\"line\">MSE = true_data - origin_pred_test</span><br><span class=\"line\">MSE = MSE*MSE</span><br><span class=\"line\">MSE_loss = sum(MSE)/len(MSE)</span><br><span class=\"line\">print(MSE_loss)</span><br></pre></td></tr></table></figure>\n<p>计算出来的MSE为<code>0.195649022176008</code>, 画出来的曲线图为：</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1576911405/blog/deep-learning/LSTM_time_series.png\" alt=\"\"></p>\n<h3 id=\"GPU加速\"><a href=\"#GPU加速\" class=\"headerlink\" title=\"GPU加速\"></a>GPU加速</h3><p><code>use_gpu = torch.cuda.is_available()  # 判断是否有GPU加速</code></p>\n<p>CUDA 加速需要设置的为：</p>\n<ol>\n<li>迭代的过程中输入的tensor放到GPU上  var_x = train_x.cuda()</li>\n<li>模型转移到GPU net.cuda()</li>\n<li>损失函数转移到GPU criterion = nn.MSELoss().cuda()</li>\n</ol>\n<h2 id=\"Prophet\"><a href=\"#Prophet\" class=\"headerlink\" title=\"Prophet\"></a>Prophet</h2><p>Prophet是facebook开源的一个时间序列预测工具,使用了时间序列分解与机器学习拟合的方法。详细介绍参考<a href=\"https://zhuanlan.zhihu.com/p/52330017\" target=\"_blank\" rel=\"noopener\">张戎</a>的介绍。</p>\n<h3 id=\"Prophet的安装\"><a href=\"#Prophet的安装\" class=\"headerlink\" title=\"Prophet的安装\"></a>Prophet的安装</h3><p>在安装Prophet的时候并没有想官网介绍的那么简单，首先需要先安装Pystan,但是直接<code>pip install pystan</code>会报编译器内部错误，使用<code>conda install -c conda-forge pystan</code>之后问题解决，然后再使用<code>pip install fbprophet</code> 进行安装。</p>\n<h3 id=\"实验\"><a href=\"#实验\" class=\"headerlink\" title=\"实验\"></a>实验</h3><p>实验的例子就是官网的例子</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"><span class=\"keyword\">from</span> fbprophet <span class=\"keyword\">import</span> Prophet</span><br><span class=\"line\">df = pd.read_csv(<span class=\"string\">'example_wp_log_peyton_manning.csv'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#Prophet使用</span></span><br><span class=\"line\">m = Prophet()</span><br><span class=\"line\">m.fit(df)</span><br><span class=\"line\"><span class=\"comment\">#需要预测时间段为整个365天，也就是下一年的整个天数</span></span><br><span class=\"line\">future = m.make_future_dataframe(periods=<span class=\"number\">365</span>)</span><br><span class=\"line\"><span class=\"comment\">#开始预测</span></span><br><span class=\"line\">forecast = m.predict(future)</span><br><span class=\"line\"><span class=\"comment\">#预测的结果保存在yhat_upper列中</span></span><br><span class=\"line\">forecast[[<span class=\"string\">'ds'</span>, <span class=\"string\">'yhat'</span>, <span class=\"string\">'yhat_lower'</span>, <span class=\"string\">'yhat_upper'</span>]].tail()</span><br><span class=\"line\"><span class=\"comment\">#画图</span></span><br><span class=\"line\">plt.plot(fb_pre, <span class=\"string\">'r'</span>, label=<span class=\"string\">'prediction'</span>)</span><br><span class=\"line\">plt.plot(origin_test_Y, <span class=\"string\">'b'</span>, label=<span class=\"string\">'real'</span>)</span><br><span class=\"line\">plt.legend(loc=<span class=\"string\">'best'</span>)</span><br><span class=\"line\">plt.show()</span><br><span class=\"line\"><span class=\"comment\">#计算MSE</span></span><br><span class=\"line\">fb_pre = np.array(forecast[<span class=\"string\">'yhat'</span>].iloc[<span class=\"number\">2034</span>:<span class=\"number\">2905</span>])<span class=\"comment\">#2034到2905是前面30%的测试集所对应的数据范围</span></span><br><span class=\"line\">MSE = true_data - fb_pre</span><br><span class=\"line\">MSE = MSE*MSE</span><br><span class=\"line\">MSE_loss = sum(MSE)/len(MSE)</span><br><span class=\"line\">print(MSE_loss)</span><br></pre></td></tr></table></figure>\n<p>计算出来的MSE为：<code>0.25229994660830146</code>,画出来的图像为：</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1576911405/blog/deep-learning/Prophet_time_series.png\" alt=\"\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>MSE</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>LSTM</td>\n<td>0.195649022176008</td>\n</tr>\n<tr>\n<td>Prophet</td>\n<td>0.25229994660830146</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>可以看到使用LSTM的预测结果要比Prophet的结果好，但是也有可能是我还没有去调整Prophet的参数导致Prophet的性能差一些的。同时Prophet可以预测整整一年的时间，这个比起使用LSTM要厉害很多，实验中的LSTM使用的是单步预测的方法，也就是只能根据前段时刻的数据来预测下一个时刻的数据，如果要做到像Prophet那样预测未来一段时刻的数据，需要使用多步预测的方法，我查了下涉及到seq2seq，貌似比较复杂，还没有做实验。</p>\n<p>自己是小白，实验可能存在相关问题与不足之处，欢迎反馈。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>Pytorch中的<a href=\"https://zhuanlan.zhihu.com/p/41261640\" target=\"_blank\" rel=\"noopener\">LSTM参数</a></p>\n<p><a href=\"https://facebook.github.io/prophet/\" target=\"_blank\" rel=\"noopener\">Prophet官网</a></p>\n<p><a href=\"https://www.okcode.net/article/43571\" target=\"_blank\" rel=\"noopener\">Prophet安装问题</a> </p>\n","site":{"data":{}},"length":6131,"excerpt":"<h1 id=\"LSTM与Prophet时间序列预测实验\"><a href=\"#LSTM与Prophet时间序列预测实验\" class=\"headerlink\" title=\"LSTM与Prophet时间序列预测实验\"></a>LSTM与Prophet时间序列预测实验</h1><p>分别使用Pytorch构建的LSTM网络与Facebook开源的Prophet工具对时间序列进行预测的一个对比小实验，同时作为一个小白也借着这个实验来学习下Pytorch的使用，因为第一次使用，所以会比较详细的注释代码。</p>","more":"<p>使用的数据为了与Prophet进行对比，因此使用了Prophet官网例子上用到的数据集。该时间序列数据集来自维基百科上面对美国橄榄球运动员佩顿·曼宁（Peyton Williams Manning）的日访问量的记录日志，时间跨度为2007年12月10号到2016年1月20号共2905条数据。 </p>\n<p>Jupyter代码与数据集地址在<a href=\"https://github.com/BraveY/AI-with-code/tree/master/time-series\" target=\"_blank\" rel=\"noopener\">我的github</a>上，欢迎star。</p>\n<h2 id=\"LSTM\"><a href=\"#LSTM\" class=\"headerlink\" title=\"LSTM\"></a>LSTM</h2><p>LSTM的介绍参考<a href=\"https://zhuanlan.zhihu.com/p/30465140\" target=\"_blank\" rel=\"noopener\">夕小瑶</a>与<a href=\"https://zhuanlan.zhihu.com/p/32085405\" target=\"_blank\" rel=\"noopener\">陈诚</a>的介绍，代码主要参考<a href=\"https://blog.csdn.net/baidu_36669549/article/details/85595807\" target=\"_blank\" rel=\"noopener\">凌空的桨</a>与<a href=\"https://github.com/L1aoXingyu/code-of-learn-deep-learning-with-pytorch/tree/master/chapter5_RNN/time-series\" target=\"_blank\" rel=\"noopener\">源码链接</a> ，在Pytorch1.3.1的版本上面改了一下，主要是测试的逻辑修改成了使用测试集以及取消了Variable的使用。整体的逻辑是使用前面的两天的数据来预测下一天的数据，网络的结构是使用了两层LSTM与一层线性回归层。</p>\n<h3 id=\"数据预处理\"><a href=\"#数据预处理\" class=\"headerlink\" title=\"数据预处理\"></a>数据预处理</h3><p>首先是数据的预处理代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np </span><br><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd </span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt </span><br><span class=\"line\"><span class=\"keyword\">import</span> torch </span><br><span class=\"line\"><span class=\"keyword\">from</span> torch <span class=\"keyword\">import</span> nn</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#数据预处理</span></span><br><span class=\"line\">data = pd.read_csv(<span class=\"string\">'example_wp_log_peyton_manning.csv'</span>,usecols=[<span class=\"number\">1</span>])</span><br><span class=\"line\">data = data.dropna() <span class=\"comment\">#丢弃空值</span></span><br><span class=\"line\">dataset = data.values</span><br><span class=\"line\">dataset = dataset.astype(<span class=\"string\">'float32'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">max_value = np.max(dataset)</span><br><span class=\"line\">min_value = np.min(dataset)</span><br><span class=\"line\">scalar = max_value - min_value</span><br><span class=\"line\">dataset = list(map(<span class=\"keyword\">lambda</span> x: x/scalar, dataset)) <span class=\"comment\">#将数据归一化到0~1之间</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#划分数据集</span></span><br><span class=\"line\"><span class=\"comment\">#通过前面几条的数据来预测下一条的数据，look_back设置具体的把前面几条的数据作为预测的输入data_X，而输出就是下一条data_Y</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">create_dataset</span><span class=\"params\">(dataset,look_back=<span class=\"number\">2</span>)</span>:</span> <span class=\"comment\"># 每个的滑动窗口设置为2</span></span><br><span class=\"line\">    dataX, dataY=[], []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(dataset)-look_back):</span><br><span class=\"line\">        a=dataset[i:(i+look_back)]</span><br><span class=\"line\">        dataX.append(a)    <span class=\"comment\"># 记录窗口的值</span></span><br><span class=\"line\">        dataY.append(dataset[i+look_back]) <span class=\"comment\"># 记录除了前面两个以外的所有值作为正确的标签</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> np.array(dataX), np.array(dataY)</span><br><span class=\"line\"><span class=\"comment\">#创建好输入与输出 data_Y作为正确的预测值</span></span><br><span class=\"line\">data_X, data_Y = create_dataset(dataset)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#划分训练集和测试集，70%作为训练集</span></span><br><span class=\"line\">train_size = int(len(data_X) * <span class=\"number\">0.7</span>)</span><br><span class=\"line\">test_size = len(data_X)-train_size</span><br><span class=\"line\"></span><br><span class=\"line\">train_X = data_X[:train_size]</span><br><span class=\"line\">train_Y = data_Y[:train_size]</span><br><span class=\"line\"></span><br><span class=\"line\">test_X = data_X[train_size:]</span><br><span class=\"line\">test_Y = data_Y[train_size:]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#最后，我们需要将数据改变一下形状，因为 RNN 读入的数据维度是 (seq, batch, feature)，所以要重新改变一下数据的维度，这里只有一个序列，所以 batch 是 1，而输入的 feature 就是我们希望依据的几天，这里我们定的是两个天，所以 feature 就是 2.</span></span><br><span class=\"line\"></span><br><span class=\"line\">train_X = train_X.reshape(<span class=\"number\">-1</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>)</span><br><span class=\"line\">train_Y = train_Y.reshape(<span class=\"number\">-1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>)</span><br><span class=\"line\">test_X = test_X.reshape(<span class=\"number\">-1</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 转化成torch 的张量</span></span><br><span class=\"line\">train_x = torch.from_numpy(train_X)</span><br><span class=\"line\">train_y = torch.from_numpy(train_Y)</span><br><span class=\"line\">test_x = torch.from_numpy(test_X)</span><br></pre></td></tr></table></figure>\n<h3 id=\"LSTM网络构建\"><a href=\"#LSTM网络构建\" class=\"headerlink\" title=\"LSTM网络构建\"></a>LSTM网络构建</h3><p>接着定义好网络模型，模型的第一部分是一个两层的 RNN，每一步模型接受前两天的输入作为特征，得到一个输出特征。接着通过一个线性层将 RNN 的输出回归到流量的具体数值，这里我们需要用 <code>view</code> 来重新排列，因为 <code>nn.Linear</code> 不接受三维的输入，所以我们先将前两维合并在一起，然后经过线性层之后再将其分开，最后输出结果。 </p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#lstm 网络</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">lstm_reg</span><span class=\"params\">(nn.Module)</span>:</span><span class=\"comment\">#括号中的是python的类继承语法，父类是nn.Module类 不是参数的意思</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self,input_size,hidden_size, output_size=<span class=\"number\">1</span>,num_layers=<span class=\"number\">2</span>)</span>:</span> <span class=\"comment\"># 构造函数</span></span><br><span class=\"line\">        <span class=\"comment\">#inpu_size 是输入的样本的特征维度， hidden_size 是LSTM层的神经元个数，</span></span><br><span class=\"line\">        <span class=\"comment\">#output_size是输出的特征维度</span></span><br><span class=\"line\">        super(lstm_reg,self).__init__()<span class=\"comment\"># super用于多层继承使用，必须要有的操作</span></span><br><span class=\"line\"> </span><br><span class=\"line\">        self.rnn = nn.LSTM(input_size,hidden_size,num_layers)<span class=\"comment\"># 两层LSTM网络，</span></span><br><span class=\"line\">        self.reg = nn.Linear(hidden_size,output_size)<span class=\"comment\">#把上一层总共hidden_size个的神经元的输出向量作为输入向量，然后回归到output_size维度的输出向量中</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">forward</span><span class=\"params\">(self,x)</span>:</span> <span class=\"comment\">#x是输入的数据</span></span><br><span class=\"line\">        x, _ = self.rnn(x)<span class=\"comment\"># 单个下划线表示不在意的变量，这里是LSTM网络输出的两个隐藏层状态</span></span><br><span class=\"line\">        s,b,h = x.shape</span><br><span class=\"line\">        x = x.view(s*b, h)</span><br><span class=\"line\">        x = self.reg(x)</span><br><span class=\"line\">        x = x.view(s,b,<span class=\"number\">-1</span>)<span class=\"comment\">#使用-1表示第三个维度自动根据原来的shape 和已经定了的s,b来确定</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> x</span><br><span class=\"line\"><span class=\"comment\">#我使用了GPU加速，如果不用的话需要把.cuda()给注释掉    </span></span><br><span class=\"line\">net = lstm_reg(<span class=\"number\">2</span>,<span class=\"number\">4</span>)</span><br><span class=\"line\">net = net.cuda()</span><br><span class=\"line\">criterion = nn.MSELoss().cuda()</span><br><span class=\"line\">optimizer = torch.optim.Adam(net.parameters(),lr=<span class=\"number\">1e-2</span>)</span><br></pre></td></tr></table></figure>\n<p>本来打算把网络拓扑也给画出来的，后面发现自己理解的还不够深入，可以先参考<a href=\"https://www.zhihu.com/question/41949741/answer/318771336\" target=\"_blank\" rel=\"noopener\">LSTM神经网络输入输出究竟是怎样的？ - Scofield的回答 - 知乎 </a> 和<a href=\"https://zhuanlan.zhihu.com/p/79064602\" target=\"_blank\" rel=\"noopener\">LSTM细节分析理解（pytorch版） - ymmy的文章 - 知乎 </a></p>\n<p>关于forward函数中为什么每个层可以直接使用输入的数据x这个tensor，而不需要按照构造函数里面的按照形参(input_size,hidden_size,num_layers)来传递参数。以nn.LSTM做例子，官方API为：</p>\n<ul>\n<li>参数<br>– <strong>input_size</strong><br>– <strong>hidden_size</strong><br>– <strong>num_layers</strong><br>– <strong>bias</strong><br>– <strong>batch_first</strong><br>– <strong>dropout</strong><br>– <strong>bidirectional</strong></li>\n<li>输入<br>– <strong>input</strong> (seq_len, batch, input_size)<br>– <strong>h_0</strong> (num_layers <em> num_directions, batch, hidden_size)<br>– <strong>c_0</strong> (num_layers </em> num_directions, batch, hidden_size)</li>\n<li><p>输出<br>– <strong>output</strong> (seq_len, batch, num_directions <em> hidden_size)<br>– <strong>h_n</strong> (num_layers </em> num_directions, batch, hidden_size)<br>– <strong>c_n</strong> (num_layers * num_directions, batch, hidden_size)</p>\n<p>所以forward中的x，<code>x, _ = self.rnn(x)</code>传递的参数是对应输入<strong>input</strong> (seq_len, batch, input_size)这个tensor，而不是对应的参数列表。同样<code>_</code>所代表的参数也就是<strong>h_n</strong> 和<strong>c_n</strong>。</p>\n</li>\n</ul>\n<h3 id=\"迭代\"><a href=\"#迭代\" class=\"headerlink\" title=\"迭代\"></a>迭代</h3><p>迭代过程进行了10000次迭代：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> e <span class=\"keyword\">in</span> range(<span class=\"number\">10000</span>):</span><br><span class=\"line\"><span class=\"comment\"># 新版本中可以不使用Variable了    </span></span><br><span class=\"line\"><span class=\"comment\">#     var_x = Variable(train_x).cuda() </span></span><br><span class=\"line\"><span class=\"comment\">#     var_y = Variable(train_y).cuda()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#将tensor放在GPU上面进行运算</span></span><br><span class=\"line\">    var_x = train_x.cuda()</span><br><span class=\"line\">    var_y = train_y.cuda()</span><br><span class=\"line\"> </span><br><span class=\"line\">    out = net(var_x)</span><br><span class=\"line\">    loss = criterion(out, var_y)</span><br><span class=\"line\"> </span><br><span class=\"line\">    optimizer.zero_grad()</span><br><span class=\"line\">    loss.backward()</span><br><span class=\"line\">    optimizer.step()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e+<span class=\"number\">1</span>)%<span class=\"number\">100</span> == <span class=\"number\">0</span>:</span><br><span class=\"line\">        print(<span class=\"string\">'Epoch: &#123;&#125;, Loss:&#123;:.5f&#125;'</span>.format(e+<span class=\"number\">1</span>, loss.item()))</span><br><span class=\"line\"><span class=\"comment\">#存储训练好的模型参数        </span></span><br><span class=\"line\">torch.save(net.state_dict(), <span class=\"string\">'example_wp_log.net_params.pkl'</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"测试过程\"><a href=\"#测试过程\" class=\"headerlink\" title=\"测试过程\"></a>测试过程</h3><p>在测试的时候我发现源码中并没有用到之前划分的30%的测试集来单独进行测试，而是直接把原来的完整数据给丢进去来训练的，这儿有点没搞懂。因为按理来说需要单独使用测试集进行测试来评判模型的性能的，所以我单独把测试的数据集给提出来，使用单独的测试集进行了测试。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">net.load_state_dict(torch.load(<span class=\"string\">'example_wp_log.net_params.pkl'</span>)) </span><br><span class=\"line\">var_data = torch.from_numpy(test_X).cuda()<span class=\"comment\">#net在GPU上面，所以输入的测试集合也要转入到GPU上面</span></span><br><span class=\"line\">pred_test = net(var_data) <span class=\"comment\"># 测试集的预测结果</span></span><br><span class=\"line\">pred_test = pred_test.cpu().view(<span class=\"number\">-1</span>).data.numpy()<span class=\"comment\">#先转移到cpu上才能转换为numpy</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#乘以原来归一化的刻度放缩回到原来的值域 </span></span><br><span class=\"line\">origin_test_Y = test_Y*scalar</span><br><span class=\"line\">origin_pred_test = pred_test*scalar</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#画图</span></span><br><span class=\"line\">plt.plot(origin_pred_test, <span class=\"string\">'r'</span>, label=<span class=\"string\">'prediction'</span>)</span><br><span class=\"line\">plt.plot(origin_test_Y, <span class=\"string\">'b'</span>, label=<span class=\"string\">'real'</span>)</span><br><span class=\"line\">plt.legend(loc=<span class=\"string\">'best'</span>)</span><br><span class=\"line\">plt.show()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#计算MSE</span></span><br><span class=\"line\"><span class=\"comment\">#loss = criterion(out, var_y)？</span></span><br><span class=\"line\">true_data = origin_test_Y</span><br><span class=\"line\">true_data = np.array(true_data)</span><br><span class=\"line\">true_data = np.squeeze(true_data)  <span class=\"comment\"># 从二维变成一维</span></span><br><span class=\"line\">MSE = true_data - origin_pred_test</span><br><span class=\"line\">MSE = MSE*MSE</span><br><span class=\"line\">MSE_loss = sum(MSE)/len(MSE)</span><br><span class=\"line\">print(MSE_loss)</span><br></pre></td></tr></table></figure>\n<p>计算出来的MSE为<code>0.195649022176008</code>, 画出来的曲线图为：</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1576911405/blog/deep-learning/LSTM_time_series.png\" alt=\"\"></p>\n<h3 id=\"GPU加速\"><a href=\"#GPU加速\" class=\"headerlink\" title=\"GPU加速\"></a>GPU加速</h3><p><code>use_gpu = torch.cuda.is_available()  # 判断是否有GPU加速</code></p>\n<p>CUDA 加速需要设置的为：</p>\n<ol>\n<li>迭代的过程中输入的tensor放到GPU上  var_x = train_x.cuda()</li>\n<li>模型转移到GPU net.cuda()</li>\n<li>损失函数转移到GPU criterion = nn.MSELoss().cuda()</li>\n</ol>\n<h2 id=\"Prophet\"><a href=\"#Prophet\" class=\"headerlink\" title=\"Prophet\"></a>Prophet</h2><p>Prophet是facebook开源的一个时间序列预测工具,使用了时间序列分解与机器学习拟合的方法。详细介绍参考<a href=\"https://zhuanlan.zhihu.com/p/52330017\" target=\"_blank\" rel=\"noopener\">张戎</a>的介绍。</p>\n<h3 id=\"Prophet的安装\"><a href=\"#Prophet的安装\" class=\"headerlink\" title=\"Prophet的安装\"></a>Prophet的安装</h3><p>在安装Prophet的时候并没有想官网介绍的那么简单，首先需要先安装Pystan,但是直接<code>pip install pystan</code>会报编译器内部错误，使用<code>conda install -c conda-forge pystan</code>之后问题解决，然后再使用<code>pip install fbprophet</code> 进行安装。</p>\n<h3 id=\"实验\"><a href=\"#实验\" class=\"headerlink\" title=\"实验\"></a>实验</h3><p>实验的例子就是官网的例子</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"><span class=\"keyword\">from</span> fbprophet <span class=\"keyword\">import</span> Prophet</span><br><span class=\"line\">df = pd.read_csv(<span class=\"string\">'example_wp_log_peyton_manning.csv'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#Prophet使用</span></span><br><span class=\"line\">m = Prophet()</span><br><span class=\"line\">m.fit(df)</span><br><span class=\"line\"><span class=\"comment\">#需要预测时间段为整个365天，也就是下一年的整个天数</span></span><br><span class=\"line\">future = m.make_future_dataframe(periods=<span class=\"number\">365</span>)</span><br><span class=\"line\"><span class=\"comment\">#开始预测</span></span><br><span class=\"line\">forecast = m.predict(future)</span><br><span class=\"line\"><span class=\"comment\">#预测的结果保存在yhat_upper列中</span></span><br><span class=\"line\">forecast[[<span class=\"string\">'ds'</span>, <span class=\"string\">'yhat'</span>, <span class=\"string\">'yhat_lower'</span>, <span class=\"string\">'yhat_upper'</span>]].tail()</span><br><span class=\"line\"><span class=\"comment\">#画图</span></span><br><span class=\"line\">plt.plot(fb_pre, <span class=\"string\">'r'</span>, label=<span class=\"string\">'prediction'</span>)</span><br><span class=\"line\">plt.plot(origin_test_Y, <span class=\"string\">'b'</span>, label=<span class=\"string\">'real'</span>)</span><br><span class=\"line\">plt.legend(loc=<span class=\"string\">'best'</span>)</span><br><span class=\"line\">plt.show()</span><br><span class=\"line\"><span class=\"comment\">#计算MSE</span></span><br><span class=\"line\">fb_pre = np.array(forecast[<span class=\"string\">'yhat'</span>].iloc[<span class=\"number\">2034</span>:<span class=\"number\">2905</span>])<span class=\"comment\">#2034到2905是前面30%的测试集所对应的数据范围</span></span><br><span class=\"line\">MSE = true_data - fb_pre</span><br><span class=\"line\">MSE = MSE*MSE</span><br><span class=\"line\">MSE_loss = sum(MSE)/len(MSE)</span><br><span class=\"line\">print(MSE_loss)</span><br></pre></td></tr></table></figure>\n<p>计算出来的MSE为：<code>0.25229994660830146</code>,画出来的图像为：</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1576911405/blog/deep-learning/Prophet_time_series.png\" alt=\"\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>MSE</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>LSTM</td>\n<td>0.195649022176008</td>\n</tr>\n<tr>\n<td>Prophet</td>\n<td>0.25229994660830146</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>可以看到使用LSTM的预测结果要比Prophet的结果好，但是也有可能是我还没有去调整Prophet的参数导致Prophet的性能差一些的。同时Prophet可以预测整整一年的时间，这个比起使用LSTM要厉害很多，实验中的LSTM使用的是单步预测的方法，也就是只能根据前段时刻的数据来预测下一个时刻的数据，如果要做到像Prophet那样预测未来一段时刻的数据，需要使用多步预测的方法，我查了下涉及到seq2seq，貌似比较复杂，还没有做实验。</p>\n<p>自己是小白，实验可能存在相关问题与不足之处，欢迎反馈。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>Pytorch中的<a href=\"https://zhuanlan.zhihu.com/p/41261640\" target=\"_blank\" rel=\"noopener\">LSTM参数</a></p>\n<p><a href=\"https://facebook.github.io/prophet/\" target=\"_blank\" rel=\"noopener\">Prophet官网</a></p>\n<p><a href=\"https://www.okcode.net/article/43571\" target=\"_blank\" rel=\"noopener\">Prophet安装问题</a> </p>"},{"title":"线性判别函数","date":"2019-12-08T02:16:31.000Z","copyright":true,"_content":"\n# 线性判别函数\n\n模式识别与机器学习第三章的笔记。\n\n<!--more-->\n\n## 线性判别函数\n\n### n维线性判别函数的一般形式\n\n一个n维线性判别函数的一般形式： \n$$\nd(x)=w_1x_1+w_2x_2+\\dots+w_nx_n+b=W_0^tx+b\n$$\n其中$W_0=(w_1,w_2,\\dots,w_n)^T$称为**权向量**，如果把b也加入到权向量则$d(x)=W^Tx$ 其中$x=(x_1,x_2,\\dots,x_n,1)$ 称为增广模式向量 (b对应的特征维度取值为1),而权向量也对应的加入b$W=((w_1,w_2,\\dots,w_n,b)^T)$ 称为增广权向量 。\n\n### 两类情况 \n\n样本如果只有两类$\\omega_1,\\omega_2$则可以只用一个线性判别函数进行判别：\n$$\nd(x)=W^Tx=\\left\\{\n  \\begin{array}{**lr**}  \n             >0 &  if\\;x\\in \\omega_1\\\\\\\\  \n             \\le0& if\\;x\\in\\omega_2\n             \\end{array}  \n\\right.\n$$\n\n### 多类情况\n\n#### 多类情况1\n\n用线性判别函数将属于$ω_i$类的模式与不属于$ω_i$类的模式分开，其判别函数为：\n$$\nd(x)=W^Tx=\\left\\{\n  \\begin{array}{**lr**}  \n             >0 &  if\\;x\\in \\omega_i\\\\\\\\  \n             \\le0& if\\;x\\notin\\omega_i\n             \\end{array}  \n\\right.\n$$\n这种情况称为$w_i/\\bar w_i$两分法，即把M类多类问题分成M个两类问题，因此共有**M个判别函数** ，每一类都有一个自己的判别函数，只负责把这一类给判别出来。\n\n把样本点带入所有的判别函数，**有且只有一个**判别函数判定这个样本值为正，其他判别函数都判定为负，则分类成功，否则分类失败。分类失败的区域称为**不确定区域**\n\n![](https://res.cloudinary.com/bravey/image/upload/v1577451087/blog/machine-learning/%E5%A4%9A%E7%B1%BB%E6%83%85%E5%86%B51.jpg)\n\n判别界面**不穿过类**，每个判别界面可以准确的判别出一类样本。\n\n不确定区域在图上就是除了能判定3个类别以外的区域，包括三条直线围成的中间的三角形，和三个角延伸出来的区域。\n\n#### 多类情况2\n\n每个判别函数去划分一对样本，一个判别界面只能分开两种类别，称为$\\omega_i/\\omega_j$两分法。判别函数为：\n$$\nd_{ij}(x)=W_{ij}^Tx\n$$\n其中当$d_{ij}x>0 \\quad\\forall j\\neq i$ 则将样本划入$\\omega_i$类。比如$d_{12}(x)$只能判别是第一类还是第二类样本。\n\n重要的性质：$d_{ij}=-d_{ji}$\n\n对于M类模式，总共需要M(M-1)/2个判别函数。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1577451087/blog/machine-learning/%E5%A4%9A%E7%B1%BB%E6%83%85%E5%86%B52.jpg)\n\n判别界面会穿过类，因此一个单独的判别函数无法准确的判别出一个完整无误的类，所以需要多个判别函数来辅助判别。只有所有的判别函数都判别这个样本都属于同一类，才能确定其属于这一类。\n\n需要依次根据这一类$\\omega_i$的所有判别函数$d_{i1},d_{i2},\\dots,d_{ij}$ 都得到正值，才判断其为$\\omega_i$类。\n\n不确定区域只剩下中间围成的三角区域了。因此多类情况2对模式是线性可分的可能性比多类情况1更大一些。\n\n#### 多类情况3\n\n是多类情况2没有不确定区域的特例。特例引入的条件是：\n\n$d_{ij}(x)=d_i(x)-d_j(x)=(W_i^T-W_j^T)x$ 因此当$d_{ij}(x)>0$有$d_i(x)>d_j(x) \\quad\\forall j\\neq i$ 这时不存在不确定区域，判别界面相交于一点。此时M类情况，对应有M个判别函数。\n\n根据上面的条件，只有当$d_i(x)$大于所有$d_j(x)$的时候，才会有所有的$d_{ij}(x)>0$。因此把样本带入所有的判别函数，选择值最大的一个作为划分的类。\n\n该分类的特点是把M类情况分成M-1个两类问题。 \n\n![](https://res.cloudinary.com/bravey/image/upload/v1577451087/blog/machine-learning/%E5%A4%9A%E7%B1%BB%E6%83%85%E5%86%B53.jpg)\n\n## 广义线性判别函数\n\n### 出发点\n\n- 线性判别函数简单，容易实现；\n- 非线性判别函数复杂，不容易实现；\n-  若能将非线性判别函数转换为线性判别函数，则有利于模式分类的实现。\n\n### 基本思想\n\n如果在低维度中不是线性可分的（判别函数在低维度中是非线性的），将样本用非线性的变换（比如多项式）映射到能够线性可分的高维度中去，然后在高维度中用线性判别函数来分类。\n\n对于原来的样本x向量，可以变换为：\n$$\nx^*=(f_1(x), f_2(x),\\dots,f_k(x))^T, k>n\n$$\n\n### 总项数\n\n对于n维x向量，若用r次多项式，d(x)的权系数的总项数为：\n$$\nN_w=C_{n+r}^{r}=\\dfrac{(n+r)!}{n!r!}\n$$\n\n## Fisher 线性判别\n\n求一个投影后能够分开的权重法向量$W$,从d维空间变换到一维空间。\n\n### 基本参量\n\n#### d维x空间\n\n1. 样本的均值向量\n2. 样本类内离散度矩阵 和总样本类内离散度矩阵\n3. 样本类间离散度矩阵\n\n#### 一维Y空间\n\n1. 样本的均值向量\n2. 样本类内离散度矩阵 和总样本类内离散度矩阵\n\n## 感知器\n\n### 两类\n\n使用误分类的样本点到判别平面的距离作为目标函数，要求最终下降到0，通过随机梯度下降法来进行优化。每次向输入的误分类点移动一步（加上对应的值），直到对于所有的样本点都可以正确分类。负梯度的方向就是样本向量的方向。\n\n感知器的解存在很多，加上b偏置就是余量。距离理解成置信度\n\n### 多类情况3\n\n有多少类就有多少个判别函数，要求对于第i类样本其对应的$d_i(x)$判别函数一定最大的（不存在相等的），如果不是最大的则其对应的加上这个样本$x_i$超过的减去这个样本。\n\n每一次同一个样本要带入所有判别函数，然后再对所有的判别函数进行调整。\n\n## 梯度法\n\n确定好了对误分类敏感的准则函数（目标函数），先对准则函数求得其梯度向量，对于误分类的样本点朝着负梯度方向来更新权重系数。\n\n感知器算法选择准则函数是误分类点的函数间隔$y_i(wx_i+b)$\n\n选择不同的准则函数，得到的梯度也是不一样的，因此权重的更新的值也不一样。\n\n## 最小平方误差算法\n\n最小平方误差(LMSE)算法，除了对可分模式是收敛的以外，对于类别不可分的情况也能指出来。 \n\n### 分类器的不等式方程\n\n将所有样本增广后写入一个矩阵X，X是N*（D+1）的矩阵，每一行是一个具体的样本，N是总共的样本数，其中负类的样本乘以-1规范化，因此判别界面的要求是：$Xw>0$ 其中W是一个D+1维度的权向量，乘法得到的向量是一个N行的列向量，对应的是没一个样本的$w^Tx$ 。\n\n### H-K算法\n\n求解的是$Xw=b$ 式子中$b=(b_1,b_2,\\dots,b_n)^T$的所有分量都是正值。因为X是一个$N*(D+1)$ 通常行大于列的长方阵，属于超定方程，因此一般情况下 ，不存在确定解，但是可以求线性最小二乘解 。\n\n将b看作真实的值，因此平方误差就是$(w^Tx-b)^2$ 。\n\n所以可以将准则函数定义为：\n$$\nJ(w,x,b)=\\dfrac{1}{2}\\sum_{i=1}^{n}(w^Tx_i-b_i)^2=\\dfrac{1}{2}\\sum_{i=1}^{n}||w^Tx_i-b_i||^2=\\dfrac{1}{2}(Xw-b)^T(Xw-b)\n$$\n\n\n\n\n## 势函数\n\n非线性分类的方法。\n\n判别函数由样本向量的势函数产生。每个样本点对应与一个位置所以对应一个势能。\n\n在第k步迭代时的积累位势决定于在该步前所有的单独势函数的累加 。\n\n以K(x)表示积累位势函数，若加入的训练样本xk+1是错误分类，则积累函数需要修改，若是正确分类，则不变。 \n\n两类问题$\\omega_1$的样本产生的势能为正，$\\omega_2$样本产生的势能为负。\n\n迭代的时候，只有错分的样本才会积累势能，正势能的如果被错分（带入积累势能函数中为负）则积累的势能需要加上这个点的势能。反之负势能的如果被错分（代入积累势能函数中为正），则积累势能减去这个点的势能。\n\n积累势能函数由误分类的样本的势函数累加得到。\n\n第一类势函数：可用对称的有限多项式展开。\n$$\nK(x,x_k)=\\sum_i=1^m\\phi_i(x)\\phi_i(x_k)\n$$\n注意是先乘了再相加，第二项的$\\phi_i(x_k)$可以理解成每个样本点对应的权重\n\n最终的迭代关系为：\n$$\nd_{k+1}(x)=\\sum_{i=1}^mC_i(k+1)\\phi_i(x)\\\\\nC_i(k+1)=C_i(k)+r_{k+1}\\phi_i(x_{k+1})\n$$\n势函数确定了，每个样本都是同样的势函数形式，但是判别函数也就是积累势函数随着样本的加入而在不断的更新，特别是误分类的样本会更新势函数。\n\n第二类势函数：选择双变量**x**和**x**k的对称函数作为势函数，即K(**x**, **x**k) = K(**x**k, **x**)，并且它可展开成无穷级数 。如下三种势函数\n$$\nK(x,x_k)=e^{-\\alpha||x-x_k||^2}\\\\\nK(x,x_k)=\\frac{1}{1-\\alpha||x-x_k||^2} \\quad \\alpha >0\\\\\nK(x,x_k)=\\dfrac{sin\\alpha||x-x_k||^2}{\\alpha||x-x_k||^2}\n$$\n","source":"_posts/2019-12-08-线性判别函数.md","raw":"---\ntitle: 线性判别函数\ndate: 2019-12-08 10:16:31\ncategories: 机器学习\ntags:\n- 课程\n- 模式识别\ncopyright: true\n---\n\n# 线性判别函数\n\n模式识别与机器学习第三章的笔记。\n\n<!--more-->\n\n## 线性判别函数\n\n### n维线性判别函数的一般形式\n\n一个n维线性判别函数的一般形式： \n$$\nd(x)=w_1x_1+w_2x_2+\\dots+w_nx_n+b=W_0^tx+b\n$$\n其中$W_0=(w_1,w_2,\\dots,w_n)^T$称为**权向量**，如果把b也加入到权向量则$d(x)=W^Tx$ 其中$x=(x_1,x_2,\\dots,x_n,1)$ 称为增广模式向量 (b对应的特征维度取值为1),而权向量也对应的加入b$W=((w_1,w_2,\\dots,w_n,b)^T)$ 称为增广权向量 。\n\n### 两类情况 \n\n样本如果只有两类$\\omega_1,\\omega_2$则可以只用一个线性判别函数进行判别：\n$$\nd(x)=W^Tx=\\left\\{\n  \\begin{array}{**lr**}  \n             >0 &  if\\;x\\in \\omega_1\\\\\\\\  \n             \\le0& if\\;x\\in\\omega_2\n             \\end{array}  \n\\right.\n$$\n\n### 多类情况\n\n#### 多类情况1\n\n用线性判别函数将属于$ω_i$类的模式与不属于$ω_i$类的模式分开，其判别函数为：\n$$\nd(x)=W^Tx=\\left\\{\n  \\begin{array}{**lr**}  \n             >0 &  if\\;x\\in \\omega_i\\\\\\\\  \n             \\le0& if\\;x\\notin\\omega_i\n             \\end{array}  \n\\right.\n$$\n这种情况称为$w_i/\\bar w_i$两分法，即把M类多类问题分成M个两类问题，因此共有**M个判别函数** ，每一类都有一个自己的判别函数，只负责把这一类给判别出来。\n\n把样本点带入所有的判别函数，**有且只有一个**判别函数判定这个样本值为正，其他判别函数都判定为负，则分类成功，否则分类失败。分类失败的区域称为**不确定区域**\n\n![](https://res.cloudinary.com/bravey/image/upload/v1577451087/blog/machine-learning/%E5%A4%9A%E7%B1%BB%E6%83%85%E5%86%B51.jpg)\n\n判别界面**不穿过类**，每个判别界面可以准确的判别出一类样本。\n\n不确定区域在图上就是除了能判定3个类别以外的区域，包括三条直线围成的中间的三角形，和三个角延伸出来的区域。\n\n#### 多类情况2\n\n每个判别函数去划分一对样本，一个判别界面只能分开两种类别，称为$\\omega_i/\\omega_j$两分法。判别函数为：\n$$\nd_{ij}(x)=W_{ij}^Tx\n$$\n其中当$d_{ij}x>0 \\quad\\forall j\\neq i$ 则将样本划入$\\omega_i$类。比如$d_{12}(x)$只能判别是第一类还是第二类样本。\n\n重要的性质：$d_{ij}=-d_{ji}$\n\n对于M类模式，总共需要M(M-1)/2个判别函数。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1577451087/blog/machine-learning/%E5%A4%9A%E7%B1%BB%E6%83%85%E5%86%B52.jpg)\n\n判别界面会穿过类，因此一个单独的判别函数无法准确的判别出一个完整无误的类，所以需要多个判别函数来辅助判别。只有所有的判别函数都判别这个样本都属于同一类，才能确定其属于这一类。\n\n需要依次根据这一类$\\omega_i$的所有判别函数$d_{i1},d_{i2},\\dots,d_{ij}$ 都得到正值，才判断其为$\\omega_i$类。\n\n不确定区域只剩下中间围成的三角区域了。因此多类情况2对模式是线性可分的可能性比多类情况1更大一些。\n\n#### 多类情况3\n\n是多类情况2没有不确定区域的特例。特例引入的条件是：\n\n$d_{ij}(x)=d_i(x)-d_j(x)=(W_i^T-W_j^T)x$ 因此当$d_{ij}(x)>0$有$d_i(x)>d_j(x) \\quad\\forall j\\neq i$ 这时不存在不确定区域，判别界面相交于一点。此时M类情况，对应有M个判别函数。\n\n根据上面的条件，只有当$d_i(x)$大于所有$d_j(x)$的时候，才会有所有的$d_{ij}(x)>0$。因此把样本带入所有的判别函数，选择值最大的一个作为划分的类。\n\n该分类的特点是把M类情况分成M-1个两类问题。 \n\n![](https://res.cloudinary.com/bravey/image/upload/v1577451087/blog/machine-learning/%E5%A4%9A%E7%B1%BB%E6%83%85%E5%86%B53.jpg)\n\n## 广义线性判别函数\n\n### 出发点\n\n- 线性判别函数简单，容易实现；\n- 非线性判别函数复杂，不容易实现；\n-  若能将非线性判别函数转换为线性判别函数，则有利于模式分类的实现。\n\n### 基本思想\n\n如果在低维度中不是线性可分的（判别函数在低维度中是非线性的），将样本用非线性的变换（比如多项式）映射到能够线性可分的高维度中去，然后在高维度中用线性判别函数来分类。\n\n对于原来的样本x向量，可以变换为：\n$$\nx^*=(f_1(x), f_2(x),\\dots,f_k(x))^T, k>n\n$$\n\n### 总项数\n\n对于n维x向量，若用r次多项式，d(x)的权系数的总项数为：\n$$\nN_w=C_{n+r}^{r}=\\dfrac{(n+r)!}{n!r!}\n$$\n\n## Fisher 线性判别\n\n求一个投影后能够分开的权重法向量$W$,从d维空间变换到一维空间。\n\n### 基本参量\n\n#### d维x空间\n\n1. 样本的均值向量\n2. 样本类内离散度矩阵 和总样本类内离散度矩阵\n3. 样本类间离散度矩阵\n\n#### 一维Y空间\n\n1. 样本的均值向量\n2. 样本类内离散度矩阵 和总样本类内离散度矩阵\n\n## 感知器\n\n### 两类\n\n使用误分类的样本点到判别平面的距离作为目标函数，要求最终下降到0，通过随机梯度下降法来进行优化。每次向输入的误分类点移动一步（加上对应的值），直到对于所有的样本点都可以正确分类。负梯度的方向就是样本向量的方向。\n\n感知器的解存在很多，加上b偏置就是余量。距离理解成置信度\n\n### 多类情况3\n\n有多少类就有多少个判别函数，要求对于第i类样本其对应的$d_i(x)$判别函数一定最大的（不存在相等的），如果不是最大的则其对应的加上这个样本$x_i$超过的减去这个样本。\n\n每一次同一个样本要带入所有判别函数，然后再对所有的判别函数进行调整。\n\n## 梯度法\n\n确定好了对误分类敏感的准则函数（目标函数），先对准则函数求得其梯度向量，对于误分类的样本点朝着负梯度方向来更新权重系数。\n\n感知器算法选择准则函数是误分类点的函数间隔$y_i(wx_i+b)$\n\n选择不同的准则函数，得到的梯度也是不一样的，因此权重的更新的值也不一样。\n\n## 最小平方误差算法\n\n最小平方误差(LMSE)算法，除了对可分模式是收敛的以外，对于类别不可分的情况也能指出来。 \n\n### 分类器的不等式方程\n\n将所有样本增广后写入一个矩阵X，X是N*（D+1）的矩阵，每一行是一个具体的样本，N是总共的样本数，其中负类的样本乘以-1规范化，因此判别界面的要求是：$Xw>0$ 其中W是一个D+1维度的权向量，乘法得到的向量是一个N行的列向量，对应的是没一个样本的$w^Tx$ 。\n\n### H-K算法\n\n求解的是$Xw=b$ 式子中$b=(b_1,b_2,\\dots,b_n)^T$的所有分量都是正值。因为X是一个$N*(D+1)$ 通常行大于列的长方阵，属于超定方程，因此一般情况下 ，不存在确定解，但是可以求线性最小二乘解 。\n\n将b看作真实的值，因此平方误差就是$(w^Tx-b)^2$ 。\n\n所以可以将准则函数定义为：\n$$\nJ(w,x,b)=\\dfrac{1}{2}\\sum_{i=1}^{n}(w^Tx_i-b_i)^2=\\dfrac{1}{2}\\sum_{i=1}^{n}||w^Tx_i-b_i||^2=\\dfrac{1}{2}(Xw-b)^T(Xw-b)\n$$\n\n\n\n\n## 势函数\n\n非线性分类的方法。\n\n判别函数由样本向量的势函数产生。每个样本点对应与一个位置所以对应一个势能。\n\n在第k步迭代时的积累位势决定于在该步前所有的单独势函数的累加 。\n\n以K(x)表示积累位势函数，若加入的训练样本xk+1是错误分类，则积累函数需要修改，若是正确分类，则不变。 \n\n两类问题$\\omega_1$的样本产生的势能为正，$\\omega_2$样本产生的势能为负。\n\n迭代的时候，只有错分的样本才会积累势能，正势能的如果被错分（带入积累势能函数中为负）则积累的势能需要加上这个点的势能。反之负势能的如果被错分（代入积累势能函数中为正），则积累势能减去这个点的势能。\n\n积累势能函数由误分类的样本的势函数累加得到。\n\n第一类势函数：可用对称的有限多项式展开。\n$$\nK(x,x_k)=\\sum_i=1^m\\phi_i(x)\\phi_i(x_k)\n$$\n注意是先乘了再相加，第二项的$\\phi_i(x_k)$可以理解成每个样本点对应的权重\n\n最终的迭代关系为：\n$$\nd_{k+1}(x)=\\sum_{i=1}^mC_i(k+1)\\phi_i(x)\\\\\nC_i(k+1)=C_i(k)+r_{k+1}\\phi_i(x_{k+1})\n$$\n势函数确定了，每个样本都是同样的势函数形式，但是判别函数也就是积累势函数随着样本的加入而在不断的更新，特别是误分类的样本会更新势函数。\n\n第二类势函数：选择双变量**x**和**x**k的对称函数作为势函数，即K(**x**, **x**k) = K(**x**k, **x**)，并且它可展开成无穷级数 。如下三种势函数\n$$\nK(x,x_k)=e^{-\\alpha||x-x_k||^2}\\\\\nK(x,x_k)=\\frac{1}{1-\\alpha||x-x_k||^2} \\quad \\alpha >0\\\\\nK(x,x_k)=\\dfrac{sin\\alpha||x-x_k||^2}{\\alpha||x-x_k||^2}\n$$\n","slug":"2019-12-08-线性判别函数","published":1,"updated":"2019-12-27T12:52:20.495Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6he13zd002mdstz8a7hzh9j","content":"<h1 id=\"线性判别函数\"><a href=\"#线性判别函数\" class=\"headerlink\" title=\"线性判别函数\"></a>线性判别函数</h1><p>模式识别与机器学习第三章的笔记。</p>\n<a id=\"more\"></a>\n<h2 id=\"线性判别函数-1\"><a href=\"#线性判别函数-1\" class=\"headerlink\" title=\"线性判别函数\"></a>线性判别函数</h2><h3 id=\"n维线性判别函数的一般形式\"><a href=\"#n维线性判别函数的一般形式\" class=\"headerlink\" title=\"n维线性判别函数的一般形式\"></a>n维线性判别函数的一般形式</h3><p>一个n维线性判别函数的一般形式： </p>\n<script type=\"math/tex; mode=display\">\nd(x)=w_1x_1+w_2x_2+\\dots+w_nx_n+b=W_0^tx+b</script><p>其中$W_0=(w_1,w_2,\\dots,w_n)^T$称为<strong>权向量</strong>，如果把b也加入到权向量则$d(x)=W^Tx$ 其中$x=(x_1,x_2,\\dots,x_n,1)$ 称为增广模式向量 (b对应的特征维度取值为1),而权向量也对应的加入b$W=((w_1,w_2,\\dots,w_n,b)^T)$ 称为增广权向量 。</p>\n<h3 id=\"两类情况\"><a href=\"#两类情况\" class=\"headerlink\" title=\"两类情况\"></a>两类情况</h3><p>样本如果只有两类$\\omega_1,\\omega_2$则可以只用一个线性判别函数进行判别：</p>\n<script type=\"math/tex; mode=display\">\nd(x)=W^Tx=\\left\\{\n  \\begin{array}{**lr**}  \n             >0 &  if\\;x\\in \\omega_1\\\\\\\\  \n             \\le0& if\\;x\\in\\omega_2\n             \\end{array}  \n\\right.</script><h3 id=\"多类情况\"><a href=\"#多类情况\" class=\"headerlink\" title=\"多类情况\"></a>多类情况</h3><h4 id=\"多类情况1\"><a href=\"#多类情况1\" class=\"headerlink\" title=\"多类情况1\"></a>多类情况1</h4><p>用线性判别函数将属于$ω_i$类的模式与不属于$ω_i$类的模式分开，其判别函数为：</p>\n<script type=\"math/tex; mode=display\">\nd(x)=W^Tx=\\left\\{\n  \\begin{array}{**lr**}  \n             >0 &  if\\;x\\in \\omega_i\\\\\\\\  \n             \\le0& if\\;x\\notin\\omega_i\n             \\end{array}  \n\\right.</script><p>这种情况称为$w_i/\\bar w_i$两分法，即把M类多类问题分成M个两类问题，因此共有<strong>M个判别函数</strong> ，每一类都有一个自己的判别函数，只负责把这一类给判别出来。</p>\n<p>把样本点带入所有的判别函数，<strong>有且只有一个</strong>判别函数判定这个样本值为正，其他判别函数都判定为负，则分类成功，否则分类失败。分类失败的区域称为<strong>不确定区域</strong></p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1577451087/blog/machine-learning/%E5%A4%9A%E7%B1%BB%E6%83%85%E5%86%B51.jpg\" alt=\"\"></p>\n<p>判别界面<strong>不穿过类</strong>，每个判别界面可以准确的判别出一类样本。</p>\n<p>不确定区域在图上就是除了能判定3个类别以外的区域，包括三条直线围成的中间的三角形，和三个角延伸出来的区域。</p>\n<h4 id=\"多类情况2\"><a href=\"#多类情况2\" class=\"headerlink\" title=\"多类情况2\"></a>多类情况2</h4><p>每个判别函数去划分一对样本，一个判别界面只能分开两种类别，称为$\\omega_i/\\omega_j$两分法。判别函数为：</p>\n<script type=\"math/tex; mode=display\">\nd_{ij}(x)=W_{ij}^Tx</script><p>其中当$d_{ij}x&gt;0 \\quad\\forall j\\neq i$ 则将样本划入$\\omega_i$类。比如$d_{12}(x)$只能判别是第一类还是第二类样本。</p>\n<p>重要的性质：$d_{ij}=-d_{ji}$</p>\n<p>对于M类模式，总共需要M(M-1)/2个判别函数。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1577451087/blog/machine-learning/%E5%A4%9A%E7%B1%BB%E6%83%85%E5%86%B52.jpg\" alt=\"\"></p>\n<p>判别界面会穿过类，因此一个单独的判别函数无法准确的判别出一个完整无误的类，所以需要多个判别函数来辅助判别。只有所有的判别函数都判别这个样本都属于同一类，才能确定其属于这一类。</p>\n<p>需要依次根据这一类$\\omega_i$的所有判别函数$d_{i1},d_{i2},\\dots,d_{ij}$ 都得到正值，才判断其为$\\omega_i$类。</p>\n<p>不确定区域只剩下中间围成的三角区域了。因此多类情况2对模式是线性可分的可能性比多类情况1更大一些。</p>\n<h4 id=\"多类情况3\"><a href=\"#多类情况3\" class=\"headerlink\" title=\"多类情况3\"></a>多类情况3</h4><p>是多类情况2没有不确定区域的特例。特例引入的条件是：</p>\n<p>$d_{ij}(x)=d_i(x)-d_j(x)=(W_i^T-W_j^T)x$ 因此当$d_{ij}(x)&gt;0$有$d_i(x)&gt;d_j(x) \\quad\\forall j\\neq i$ 这时不存在不确定区域，判别界面相交于一点。此时M类情况，对应有M个判别函数。</p>\n<p>根据上面的条件，只有当$d_i(x)$大于所有$d_j(x)$的时候，才会有所有的$d_{ij}(x)&gt;0$。因此把样本带入所有的判别函数，选择值最大的一个作为划分的类。</p>\n<p>该分类的特点是把M类情况分成M-1个两类问题。 </p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1577451087/blog/machine-learning/%E5%A4%9A%E7%B1%BB%E6%83%85%E5%86%B53.jpg\" alt=\"\"></p>\n<h2 id=\"广义线性判别函数\"><a href=\"#广义线性判别函数\" class=\"headerlink\" title=\"广义线性判别函数\"></a>广义线性判别函数</h2><h3 id=\"出发点\"><a href=\"#出发点\" class=\"headerlink\" title=\"出发点\"></a>出发点</h3><ul>\n<li>线性判别函数简单，容易实现；</li>\n<li>非线性判别函数复杂，不容易实现；</li>\n<li>若能将非线性判别函数转换为线性判别函数，则有利于模式分类的实现。</li>\n</ul>\n<h3 id=\"基本思想\"><a href=\"#基本思想\" class=\"headerlink\" title=\"基本思想\"></a>基本思想</h3><p>如果在低维度中不是线性可分的（判别函数在低维度中是非线性的），将样本用非线性的变换（比如多项式）映射到能够线性可分的高维度中去，然后在高维度中用线性判别函数来分类。</p>\n<p>对于原来的样本x向量，可以变换为：</p>\n<script type=\"math/tex; mode=display\">\nx^*=(f_1(x), f_2(x),\\dots,f_k(x))^T, k>n</script><h3 id=\"总项数\"><a href=\"#总项数\" class=\"headerlink\" title=\"总项数\"></a>总项数</h3><p>对于n维x向量，若用r次多项式，d(x)的权系数的总项数为：</p>\n<script type=\"math/tex; mode=display\">\nN_w=C_{n+r}^{r}=\\dfrac{(n+r)!}{n!r!}</script><h2 id=\"Fisher-线性判别\"><a href=\"#Fisher-线性判别\" class=\"headerlink\" title=\"Fisher 线性判别\"></a>Fisher 线性判别</h2><p>求一个投影后能够分开的权重法向量$W$,从d维空间变换到一维空间。</p>\n<h3 id=\"基本参量\"><a href=\"#基本参量\" class=\"headerlink\" title=\"基本参量\"></a>基本参量</h3><h4 id=\"d维x空间\"><a href=\"#d维x空间\" class=\"headerlink\" title=\"d维x空间\"></a>d维x空间</h4><ol>\n<li>样本的均值向量</li>\n<li>样本类内离散度矩阵 和总样本类内离散度矩阵</li>\n<li>样本类间离散度矩阵</li>\n</ol>\n<h4 id=\"一维Y空间\"><a href=\"#一维Y空间\" class=\"headerlink\" title=\"一维Y空间\"></a>一维Y空间</h4><ol>\n<li>样本的均值向量</li>\n<li>样本类内离散度矩阵 和总样本类内离散度矩阵</li>\n</ol>\n<h2 id=\"感知器\"><a href=\"#感知器\" class=\"headerlink\" title=\"感知器\"></a>感知器</h2><h3 id=\"两类\"><a href=\"#两类\" class=\"headerlink\" title=\"两类\"></a>两类</h3><p>使用误分类的样本点到判别平面的距离作为目标函数，要求最终下降到0，通过随机梯度下降法来进行优化。每次向输入的误分类点移动一步（加上对应的值），直到对于所有的样本点都可以正确分类。负梯度的方向就是样本向量的方向。</p>\n<p>感知器的解存在很多，加上b偏置就是余量。距离理解成置信度</p>\n<h3 id=\"多类情况3-1\"><a href=\"#多类情况3-1\" class=\"headerlink\" title=\"多类情况3\"></a>多类情况3</h3><p>有多少类就有多少个判别函数，要求对于第i类样本其对应的$d_i(x)$判别函数一定最大的（不存在相等的），如果不是最大的则其对应的加上这个样本$x_i$超过的减去这个样本。</p>\n<p>每一次同一个样本要带入所有判别函数，然后再对所有的判别函数进行调整。</p>\n<h2 id=\"梯度法\"><a href=\"#梯度法\" class=\"headerlink\" title=\"梯度法\"></a>梯度法</h2><p>确定好了对误分类敏感的准则函数（目标函数），先对准则函数求得其梯度向量，对于误分类的样本点朝着负梯度方向来更新权重系数。</p>\n<p>感知器算法选择准则函数是误分类点的函数间隔$y_i(wx_i+b)$</p>\n<p>选择不同的准则函数，得到的梯度也是不一样的，因此权重的更新的值也不一样。</p>\n<h2 id=\"最小平方误差算法\"><a href=\"#最小平方误差算法\" class=\"headerlink\" title=\"最小平方误差算法\"></a>最小平方误差算法</h2><p>最小平方误差(LMSE)算法，除了对可分模式是收敛的以外，对于类别不可分的情况也能指出来。 </p>\n<h3 id=\"分类器的不等式方程\"><a href=\"#分类器的不等式方程\" class=\"headerlink\" title=\"分类器的不等式方程\"></a>分类器的不等式方程</h3><p>将所有样本增广后写入一个矩阵X，X是N*（D+1）的矩阵，每一行是一个具体的样本，N是总共的样本数，其中负类的样本乘以-1规范化，因此判别界面的要求是：$Xw&gt;0$ 其中W是一个D+1维度的权向量，乘法得到的向量是一个N行的列向量，对应的是没一个样本的$w^Tx$ 。</p>\n<h3 id=\"H-K算法\"><a href=\"#H-K算法\" class=\"headerlink\" title=\"H-K算法\"></a>H-K算法</h3><p>求解的是$Xw=b$ 式子中$b=(b_1,b_2,\\dots,b_n)^T$的所有分量都是正值。因为X是一个$N*(D+1)$ 通常行大于列的长方阵，属于超定方程，因此一般情况下 ，不存在确定解，但是可以求线性最小二乘解 。</p>\n<p>将b看作真实的值，因此平方误差就是$(w^Tx-b)^2$ 。</p>\n<p>所以可以将准则函数定义为：</p>\n<script type=\"math/tex; mode=display\">\nJ(w,x,b)=\\dfrac{1}{2}\\sum_{i=1}^{n}(w^Tx_i-b_i)^2=\\dfrac{1}{2}\\sum_{i=1}^{n}||w^Tx_i-b_i||^2=\\dfrac{1}{2}(Xw-b)^T(Xw-b)</script><h2 id=\"势函数\"><a href=\"#势函数\" class=\"headerlink\" title=\"势函数\"></a>势函数</h2><p>非线性分类的方法。</p>\n<p>判别函数由样本向量的势函数产生。每个样本点对应与一个位置所以对应一个势能。</p>\n<p>在第k步迭代时的积累位势决定于在该步前所有的单独势函数的累加 。</p>\n<p>以K(x)表示积累位势函数，若加入的训练样本xk+1是错误分类，则积累函数需要修改，若是正确分类，则不变。 </p>\n<p>两类问题$\\omega_1$的样本产生的势能为正，$\\omega_2$样本产生的势能为负。</p>\n<p>迭代的时候，只有错分的样本才会积累势能，正势能的如果被错分（带入积累势能函数中为负）则积累的势能需要加上这个点的势能。反之负势能的如果被错分（代入积累势能函数中为正），则积累势能减去这个点的势能。</p>\n<p>积累势能函数由误分类的样本的势函数累加得到。</p>\n<p>第一类势函数：可用对称的有限多项式展开。</p>\n<script type=\"math/tex; mode=display\">\nK(x,x_k)=\\sum_i=1^m\\phi_i(x)\\phi_i(x_k)</script><p>注意是先乘了再相加，第二项的$\\phi_i(x_k)$可以理解成每个样本点对应的权重</p>\n<p>最终的迭代关系为：</p>\n<script type=\"math/tex; mode=display\">\nd_{k+1}(x)=\\sum_{i=1}^mC_i(k+1)\\phi_i(x)\\\\\nC_i(k+1)=C_i(k)+r_{k+1}\\phi_i(x_{k+1})</script><p>势函数确定了，每个样本都是同样的势函数形式，但是判别函数也就是积累势函数随着样本的加入而在不断的更新，特别是误分类的样本会更新势函数。</p>\n<p>第二类势函数：选择双变量<strong>x</strong>和<strong>x</strong>k的对称函数作为势函数，即K(<strong>x</strong>, <strong>x</strong>k) = K(<strong>x</strong>k, <strong>x</strong>)，并且它可展开成无穷级数 。如下三种势函数</p>\n<script type=\"math/tex; mode=display\">\nK(x,x_k)=e^{-\\alpha||x-x_k||^2}\\\\\nK(x,x_k)=\\frac{1}{1-\\alpha||x-x_k||^2} \\quad \\alpha >0\\\\\nK(x,x_k)=\\dfrac{sin\\alpha||x-x_k||^2}{\\alpha||x-x_k||^2}</script>","site":{"data":{}},"length":3525,"excerpt":"<h1 id=\"线性判别函数\"><a href=\"#线性判别函数\" class=\"headerlink\" title=\"线性判别函数\"></a>线性判别函数</h1><p>模式识别与机器学习第三章的笔记。</p>","more":"<h2 id=\"线性判别函数-1\"><a href=\"#线性判别函数-1\" class=\"headerlink\" title=\"线性判别函数\"></a>线性判别函数</h2><h3 id=\"n维线性判别函数的一般形式\"><a href=\"#n维线性判别函数的一般形式\" class=\"headerlink\" title=\"n维线性判别函数的一般形式\"></a>n维线性判别函数的一般形式</h3><p>一个n维线性判别函数的一般形式： </p>\n<script type=\"math/tex; mode=display\">\nd(x)=w_1x_1+w_2x_2+\\dots+w_nx_n+b=W_0^tx+b</script><p>其中$W_0=(w_1,w_2,\\dots,w_n)^T$称为<strong>权向量</strong>，如果把b也加入到权向量则$d(x)=W^Tx$ 其中$x=(x_1,x_2,\\dots,x_n,1)$ 称为增广模式向量 (b对应的特征维度取值为1),而权向量也对应的加入b$W=((w_1,w_2,\\dots,w_n,b)^T)$ 称为增广权向量 。</p>\n<h3 id=\"两类情况\"><a href=\"#两类情况\" class=\"headerlink\" title=\"两类情况\"></a>两类情况</h3><p>样本如果只有两类$\\omega_1,\\omega_2$则可以只用一个线性判别函数进行判别：</p>\n<script type=\"math/tex; mode=display\">\nd(x)=W^Tx=\\left\\{\n  \\begin{array}{**lr**}  \n             >0 &  if\\;x\\in \\omega_1\\\\\\\\  \n             \\le0& if\\;x\\in\\omega_2\n             \\end{array}  \n\\right.</script><h3 id=\"多类情况\"><a href=\"#多类情况\" class=\"headerlink\" title=\"多类情况\"></a>多类情况</h3><h4 id=\"多类情况1\"><a href=\"#多类情况1\" class=\"headerlink\" title=\"多类情况1\"></a>多类情况1</h4><p>用线性判别函数将属于$ω_i$类的模式与不属于$ω_i$类的模式分开，其判别函数为：</p>\n<script type=\"math/tex; mode=display\">\nd(x)=W^Tx=\\left\\{\n  \\begin{array}{**lr**}  \n             >0 &  if\\;x\\in \\omega_i\\\\\\\\  \n             \\le0& if\\;x\\notin\\omega_i\n             \\end{array}  \n\\right.</script><p>这种情况称为$w_i/\\bar w_i$两分法，即把M类多类问题分成M个两类问题，因此共有<strong>M个判别函数</strong> ，每一类都有一个自己的判别函数，只负责把这一类给判别出来。</p>\n<p>把样本点带入所有的判别函数，<strong>有且只有一个</strong>判别函数判定这个样本值为正，其他判别函数都判定为负，则分类成功，否则分类失败。分类失败的区域称为<strong>不确定区域</strong></p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1577451087/blog/machine-learning/%E5%A4%9A%E7%B1%BB%E6%83%85%E5%86%B51.jpg\" alt=\"\"></p>\n<p>判别界面<strong>不穿过类</strong>，每个判别界面可以准确的判别出一类样本。</p>\n<p>不确定区域在图上就是除了能判定3个类别以外的区域，包括三条直线围成的中间的三角形，和三个角延伸出来的区域。</p>\n<h4 id=\"多类情况2\"><a href=\"#多类情况2\" class=\"headerlink\" title=\"多类情况2\"></a>多类情况2</h4><p>每个判别函数去划分一对样本，一个判别界面只能分开两种类别，称为$\\omega_i/\\omega_j$两分法。判别函数为：</p>\n<script type=\"math/tex; mode=display\">\nd_{ij}(x)=W_{ij}^Tx</script><p>其中当$d_{ij}x&gt;0 \\quad\\forall j\\neq i$ 则将样本划入$\\omega_i$类。比如$d_{12}(x)$只能判别是第一类还是第二类样本。</p>\n<p>重要的性质：$d_{ij}=-d_{ji}$</p>\n<p>对于M类模式，总共需要M(M-1)/2个判别函数。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1577451087/blog/machine-learning/%E5%A4%9A%E7%B1%BB%E6%83%85%E5%86%B52.jpg\" alt=\"\"></p>\n<p>判别界面会穿过类，因此一个单独的判别函数无法准确的判别出一个完整无误的类，所以需要多个判别函数来辅助判别。只有所有的判别函数都判别这个样本都属于同一类，才能确定其属于这一类。</p>\n<p>需要依次根据这一类$\\omega_i$的所有判别函数$d_{i1},d_{i2},\\dots,d_{ij}$ 都得到正值，才判断其为$\\omega_i$类。</p>\n<p>不确定区域只剩下中间围成的三角区域了。因此多类情况2对模式是线性可分的可能性比多类情况1更大一些。</p>\n<h4 id=\"多类情况3\"><a href=\"#多类情况3\" class=\"headerlink\" title=\"多类情况3\"></a>多类情况3</h4><p>是多类情况2没有不确定区域的特例。特例引入的条件是：</p>\n<p>$d_{ij}(x)=d_i(x)-d_j(x)=(W_i^T-W_j^T)x$ 因此当$d_{ij}(x)&gt;0$有$d_i(x)&gt;d_j(x) \\quad\\forall j\\neq i$ 这时不存在不确定区域，判别界面相交于一点。此时M类情况，对应有M个判别函数。</p>\n<p>根据上面的条件，只有当$d_i(x)$大于所有$d_j(x)$的时候，才会有所有的$d_{ij}(x)&gt;0$。因此把样本带入所有的判别函数，选择值最大的一个作为划分的类。</p>\n<p>该分类的特点是把M类情况分成M-1个两类问题。 </p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1577451087/blog/machine-learning/%E5%A4%9A%E7%B1%BB%E6%83%85%E5%86%B53.jpg\" alt=\"\"></p>\n<h2 id=\"广义线性判别函数\"><a href=\"#广义线性判别函数\" class=\"headerlink\" title=\"广义线性判别函数\"></a>广义线性判别函数</h2><h3 id=\"出发点\"><a href=\"#出发点\" class=\"headerlink\" title=\"出发点\"></a>出发点</h3><ul>\n<li>线性判别函数简单，容易实现；</li>\n<li>非线性判别函数复杂，不容易实现；</li>\n<li>若能将非线性判别函数转换为线性判别函数，则有利于模式分类的实现。</li>\n</ul>\n<h3 id=\"基本思想\"><a href=\"#基本思想\" class=\"headerlink\" title=\"基本思想\"></a>基本思想</h3><p>如果在低维度中不是线性可分的（判别函数在低维度中是非线性的），将样本用非线性的变换（比如多项式）映射到能够线性可分的高维度中去，然后在高维度中用线性判别函数来分类。</p>\n<p>对于原来的样本x向量，可以变换为：</p>\n<script type=\"math/tex; mode=display\">\nx^*=(f_1(x), f_2(x),\\dots,f_k(x))^T, k>n</script><h3 id=\"总项数\"><a href=\"#总项数\" class=\"headerlink\" title=\"总项数\"></a>总项数</h3><p>对于n维x向量，若用r次多项式，d(x)的权系数的总项数为：</p>\n<script type=\"math/tex; mode=display\">\nN_w=C_{n+r}^{r}=\\dfrac{(n+r)!}{n!r!}</script><h2 id=\"Fisher-线性判别\"><a href=\"#Fisher-线性判别\" class=\"headerlink\" title=\"Fisher 线性判别\"></a>Fisher 线性判别</h2><p>求一个投影后能够分开的权重法向量$W$,从d维空间变换到一维空间。</p>\n<h3 id=\"基本参量\"><a href=\"#基本参量\" class=\"headerlink\" title=\"基本参量\"></a>基本参量</h3><h4 id=\"d维x空间\"><a href=\"#d维x空间\" class=\"headerlink\" title=\"d维x空间\"></a>d维x空间</h4><ol>\n<li>样本的均值向量</li>\n<li>样本类内离散度矩阵 和总样本类内离散度矩阵</li>\n<li>样本类间离散度矩阵</li>\n</ol>\n<h4 id=\"一维Y空间\"><a href=\"#一维Y空间\" class=\"headerlink\" title=\"一维Y空间\"></a>一维Y空间</h4><ol>\n<li>样本的均值向量</li>\n<li>样本类内离散度矩阵 和总样本类内离散度矩阵</li>\n</ol>\n<h2 id=\"感知器\"><a href=\"#感知器\" class=\"headerlink\" title=\"感知器\"></a>感知器</h2><h3 id=\"两类\"><a href=\"#两类\" class=\"headerlink\" title=\"两类\"></a>两类</h3><p>使用误分类的样本点到判别平面的距离作为目标函数，要求最终下降到0，通过随机梯度下降法来进行优化。每次向输入的误分类点移动一步（加上对应的值），直到对于所有的样本点都可以正确分类。负梯度的方向就是样本向量的方向。</p>\n<p>感知器的解存在很多，加上b偏置就是余量。距离理解成置信度</p>\n<h3 id=\"多类情况3-1\"><a href=\"#多类情况3-1\" class=\"headerlink\" title=\"多类情况3\"></a>多类情况3</h3><p>有多少类就有多少个判别函数，要求对于第i类样本其对应的$d_i(x)$判别函数一定最大的（不存在相等的），如果不是最大的则其对应的加上这个样本$x_i$超过的减去这个样本。</p>\n<p>每一次同一个样本要带入所有判别函数，然后再对所有的判别函数进行调整。</p>\n<h2 id=\"梯度法\"><a href=\"#梯度法\" class=\"headerlink\" title=\"梯度法\"></a>梯度法</h2><p>确定好了对误分类敏感的准则函数（目标函数），先对准则函数求得其梯度向量，对于误分类的样本点朝着负梯度方向来更新权重系数。</p>\n<p>感知器算法选择准则函数是误分类点的函数间隔$y_i(wx_i+b)$</p>\n<p>选择不同的准则函数，得到的梯度也是不一样的，因此权重的更新的值也不一样。</p>\n<h2 id=\"最小平方误差算法\"><a href=\"#最小平方误差算法\" class=\"headerlink\" title=\"最小平方误差算法\"></a>最小平方误差算法</h2><p>最小平方误差(LMSE)算法，除了对可分模式是收敛的以外，对于类别不可分的情况也能指出来。 </p>\n<h3 id=\"分类器的不等式方程\"><a href=\"#分类器的不等式方程\" class=\"headerlink\" title=\"分类器的不等式方程\"></a>分类器的不等式方程</h3><p>将所有样本增广后写入一个矩阵X，X是N*（D+1）的矩阵，每一行是一个具体的样本，N是总共的样本数，其中负类的样本乘以-1规范化，因此判别界面的要求是：$Xw&gt;0$ 其中W是一个D+1维度的权向量，乘法得到的向量是一个N行的列向量，对应的是没一个样本的$w^Tx$ 。</p>\n<h3 id=\"H-K算法\"><a href=\"#H-K算法\" class=\"headerlink\" title=\"H-K算法\"></a>H-K算法</h3><p>求解的是$Xw=b$ 式子中$b=(b_1,b_2,\\dots,b_n)^T$的所有分量都是正值。因为X是一个$N*(D+1)$ 通常行大于列的长方阵，属于超定方程，因此一般情况下 ，不存在确定解，但是可以求线性最小二乘解 。</p>\n<p>将b看作真实的值，因此平方误差就是$(w^Tx-b)^2$ 。</p>\n<p>所以可以将准则函数定义为：</p>\n<script type=\"math/tex; mode=display\">\nJ(w,x,b)=\\dfrac{1}{2}\\sum_{i=1}^{n}(w^Tx_i-b_i)^2=\\dfrac{1}{2}\\sum_{i=1}^{n}||w^Tx_i-b_i||^2=\\dfrac{1}{2}(Xw-b)^T(Xw-b)</script><h2 id=\"势函数\"><a href=\"#势函数\" class=\"headerlink\" title=\"势函数\"></a>势函数</h2><p>非线性分类的方法。</p>\n<p>判别函数由样本向量的势函数产生。每个样本点对应与一个位置所以对应一个势能。</p>\n<p>在第k步迭代时的积累位势决定于在该步前所有的单独势函数的累加 。</p>\n<p>以K(x)表示积累位势函数，若加入的训练样本xk+1是错误分类，则积累函数需要修改，若是正确分类，则不变。 </p>\n<p>两类问题$\\omega_1$的样本产生的势能为正，$\\omega_2$样本产生的势能为负。</p>\n<p>迭代的时候，只有错分的样本才会积累势能，正势能的如果被错分（带入积累势能函数中为负）则积累的势能需要加上这个点的势能。反之负势能的如果被错分（代入积累势能函数中为正），则积累势能减去这个点的势能。</p>\n<p>积累势能函数由误分类的样本的势函数累加得到。</p>\n<p>第一类势函数：可用对称的有限多项式展开。</p>\n<script type=\"math/tex; mode=display\">\nK(x,x_k)=\\sum_i=1^m\\phi_i(x)\\phi_i(x_k)</script><p>注意是先乘了再相加，第二项的$\\phi_i(x_k)$可以理解成每个样本点对应的权重</p>\n<p>最终的迭代关系为：</p>\n<script type=\"math/tex; mode=display\">\nd_{k+1}(x)=\\sum_{i=1}^mC_i(k+1)\\phi_i(x)\\\\\nC_i(k+1)=C_i(k)+r_{k+1}\\phi_i(x_{k+1})</script><p>势函数确定了，每个样本都是同样的势函数形式，但是判别函数也就是积累势函数随着样本的加入而在不断的更新，特别是误分类的样本会更新势函数。</p>\n<p>第二类势函数：选择双变量<strong>x</strong>和<strong>x</strong>k的对称函数作为势函数，即K(<strong>x</strong>, <strong>x</strong>k) = K(<strong>x</strong>k, <strong>x</strong>)，并且它可展开成无穷级数 。如下三种势函数</p>\n<script type=\"math/tex; mode=display\">\nK(x,x_k)=e^{-\\alpha||x-x_k||^2}\\\\\nK(x,x_k)=\\frac{1}{1-\\alpha||x-x_k||^2} \\quad \\alpha >0\\\\\nK(x,x_k)=\\dfrac{sin\\alpha||x-x_k||^2}{\\alpha||x-x_k||^2}</script>"},{"title":"特征选择和特征提取","date":"2019-12-28T06:19:43.000Z","copyright":true,"_content":"\n# 特征选择和特征提取\n\n## 意义\n\n1. 降低维度，后续的分类器设计更容易计算，可以加快速度\n2. 消除特征之间可能存在的相关性，减少与分类无关的信息（理解成降噪？），从而更好的分类。\n\n<!--more-->\n\n## 类别可分性质的度量\n\n### 距离\n\n1. 点到点之间的距离\n\n   欧式距离：\n   $$\n   D(a, b) = || a – b ||\n   $$\n   平方形式（向量转置相乘，点积的形式）：\n   $$\n   D^{2}(a,b) = (a - b)^{T}(a - b) = \\sum_{k = 1}^{n}{(a_{k} - b_{k})^{2}}\n   $$\n   其中a和b为n维向量，其第k个特征分别是$a_k$和$b_k$。 **各自对应的特征维度差的平方之和。**\n\n2. 点到点集之间的距离\n\n   在n维空间中，点x到点$a^{(i)}$之间的距离平方为：\n   $$\n   D^{2}(x,a^{(i)}) = \\sum_{k = 1}^{n}{(x_{k} - a_{k}^{(i)})^{2}}\n   $$\n   因此x到有K个点组合的均方距离，就是到每个点均方距离相加之后取均值。\n   $$\n   \\overline{D^{2}(x,\\{ a^{(i)}\\})} = \\frac{1}{K}\\sum_{i = 1}^{K}{D^{2}(x,a^{(i)}) =}\\frac{1}{K}\\sum_{i = 1}^{K}\\left\\{ \\sum_{k = 1}^{n}{(x_{k} - a_{k}^{(i)})^{2}} \\right\\}\n   $$\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### 类内距离\n\n   **类中每个点到其他点的均方距离累加之后求均值**\n\n   n维空间中同一类内各模式样本点集$\\{a^{(i)}\\}_{i=1,2,\\ldots{},K}$，其内部各点的均方距离为$\\overline{D^{2}(\\{ a^{(j)}\\},\\{ a^{(i)}\\})}$，其中$i,j = 1,2,\\ldots,K,i \\neq j$，即：\n$$\n   \\overline{D^{2}(\\{ a^{(j)}\\},\\{ a^{(i)}\\})} = \\frac{1}{K}\\sum_{j = 1}^{K}\\left\\lbrack \\frac{1}{K - 1}\\sum_{\\begin{matrix}\n    i = 1 \\\\\n    i \\neq j \\\\\n   \\end{matrix}}^{K}{\\sum_{k = 1}^{n}{(a_{k}^{(j)} - a_{k}^{(i)})^{2}}} \\right\\rbrack\n$$\n   每个点到其他点的平方距离求和，**三层循环**（点j，点i，维度k）\n\n   可证明：\n$$\n   \\overline{D^{2}} = 2\\sum_{k = 1}^{n}\\sigma_{k}^{2}\n$$\n   其中$\\sigma_{k}^{2}$为样本集合$a^{(i)}$在第k个分量上的无偏方差，即：\n$$\n   \\sigma_{k}^{2} = \\frac{1}{K - 1}\\sum_{i = 1}^{K}{(a_{k}^{(i)} - \\overline{a_{k}})^{2}}\n$$\n   其中$\\overline{a_{k}} = \\frac{1}{K}\\sum_{i = 1}^{K}a_{k}^{(i)}$为$a^{(i)}$在第k个分量方向上的均值。\n\n   **无偏估计除以的是K-1，把数据集合用一个完整的$K \\times N$矩阵来理解，就可以很方便的对应这些距离公式，均值，方差的计算了。公式可以不用管。**\n\n#### 类间距离\n\n   **两类样本均值质心的均方距离**\n\n   常用两类样本各自质心间的距离作为类间距离，并假设两类样本出现的概率相等，则：\n$$\n   D^{2} = \\sum_{k = 1}^{n}{(m_{1_{k}} -}m_{2_{k}})^{2}\n$$\n   其中 $m_1$ 和 $m_2$ 为两类模式样本集各自的均值向量， $m_{1k}$ 和$m_{1k}$为 两个均值向量的第k个特征分量，n为维数。\n\n### 散布矩阵\n\n不管类内还是类间都涉及到与均值向量之差的向量乘以其转置。\n\n#### 类内散布矩阵\n\n**每个样本向量减去均值向量后乘以结果的转置(矩阵)，*然后将得到的矩阵再相加***\n\n考虑一类内模式点集$\\{ a^{(i)}\\}_{i = 1,2,\\ldots,K}$，其类内散布矩阵为：\n$$\nS_w = \\sum_{i = 1}^{K}\\{(a^{(i)} - m)(a^{(i)} - m)^{T}\\}\n$$\n其中m是样本集合的**均值向量**\n$$\nm = \\frac{1}{K}\\sum_{i = 1}^{K}a{(i)}\n$$\n对属于同一类的模式样本，**类内散布矩阵表示各样本点围绕其均值周围的散布情况**。\n\n#### 类间散布矩阵\n\n**两个质心之差形成的向量与其转置相乘而形成的矩阵**，类比与类内散布矩阵，**类内**是每个样本向量减去该类的均值向量，是**所有样本向量**都要参与。\n$$\nS_{b2} = (m_{1} - m_{2})(m_{1} - m_{2})^{T}\n$$\n对三个以上的类别，类间散布矩阵常写成：\n$$\nS_{b} = \\sum_{i = 1}^{c}{P(\\omega_{i})}(m_{i} - m_{0})(m_{i} - m_{0})^{T}\n$$\n其中，$m_{0}$为多类模式（如共有c类）分布的总体均值向量，即：\n$$\nm_{0} = E\\{ x\\} = \\sum_{i = 1}^{c}{P(\\omega_{i})m_{i}},\\quad\\forall\\omega_{i},\\mspace{6mu} i = 1,2,\\ldots,c\n$$\n**用质心来代表每一类，多类模式引入概率来取得总体所有样本均值。**计算的形式与类内的很相似了，$m_0$对应着类内中一个类的均值向量，每个质心对应这类内中的一个样本向量。\n\n### 多类模式集散布矩阵 \n\n多类情况的**类内散布矩阵**，可写成**各类的类内散布矩阵的先验概率的加权和**，即：\n$$\nS_{w} = \\sum_{i = 1}^{c}{P(\\omega_{i})E\\{}(x - m_{i})(x - m_{i})^{T}|\\omega_{i}\\} = \\sum_{i = 1}^{c}{P(\\omega_{i})C_{i}}\n$$\n其中$C_{i}$是第i类的协方差矩阵。E是求期望，也就是每个样本的矩阵计算完了之后相加还要除以样本数目N或者N-1（N-1是无偏估计）。\n\n**协方差(两个变量各自与各自均值的差相乘)：**\n$$\nCov(X,Y)=E[(X-m_X)(Y-m_Y)]=E[XY]-E[X]\\times E[Y]\n$$\n协方差矩阵是不同维度之间的相关性的表达，一个d维的样本也能建立协方差矩阵尺度为$d\\times d$, 所以一个类的协方差矩阵是每个样本的协方差矩阵相加后取**均值**得到的。\n\n有时，用多类模式**总体分布的散布矩阵**来反映其**可分性**，即：\n$$\nS_{t} = E\\{(x - m_{0})(x - m_{0})^{T}\\},\\quad x \\in \\forall\\omega_{i},\\mspace{6mu} i = 1,2,\\ldots,c\n$$\n其中，$m_{0}$为多类模式分布的总体均值向量。\n\n可以证明：$S_{t} = S_{w} +S_{b}$，即**总体散布矩阵是各类类内散布矩阵与类间散布矩阵之和。**\n\n## 特征选择\n\n在尽量不降低分类精度的前提下，选择更少的特诊来进行分类。\n\n### 独立特征的选择准则 \n\n**不同类**的均值向量（**质心点**）之间的**距离最大**，而**同一类**的样本向量的方差之和最小（与其**质心**的**距离较近**）。用一个比值来作为度量标准。\n\n假设个特征之间统计独立，那么对**每个特征分量都去计算那个标准**，就能够知道每个特征对样本可分性的贡献了。\n\n对于$ω_{i}$和$ω_{j}$两类训练样本，假设其均值向量为$m_{i}$和$m_{j}$，其k维方向的分量为$m_{ik}$和$m_{jk}$，方差为$\\sigma_{\\text{ik}}^{2}$和$\\sigma_{\\text{jk}}^{2}$，定义可分性准则函数(也就是那个标准)：\n$$\nG_{k} = \\frac{(m_{\\text{ik}} - m_{\\text{jk}})^{2}}{\\sigma_{\\text{ik}}^{2} + \\sigma_{\\text{jk}}^{2}},\\;\\;k = 1,2,\\ldots,n\n$$\n则$G_{K}$为正值。$G_{K}$值越大，表示测度值的第k个分量对分离$ω_{i}$和$ω_{j}$两类越有效。将$\\{G_{K},k=1,2,\\ldots{},n\\}$按大小排队，选出最大的m个对应的测度值作为分类特征，即达到特征选择的目的。\n\n### 一般特征的散布矩阵准则\n\n回顾类内与类间散布矩阵：\n\n多类类内散布矩阵：\n$$\nS_{w} = \\sum_{i = 1}^{c}{P(\\omega_{i})E\\{}(x - m_{i})(x - m_{i})^{T}|\\omega_{i}\\}\n$$\n 多类类间散布矩阵：\n$$\nS_{b} = \\sum_{i = 1}^{c}{P(\\omega_{i})}(m_{i} - m_{0})(m_{i} - m_{0})^{T}\n$$\n直观上，**类间离散度越大且类内离散度越小**，则可分性越好。因此，可推导出散布矩阵准则采用如下形式： (**矩阵的逆类比于除法**)\n\n行列式形式：$J_{1} = \\det(S_{w}^{- 1}S_{b}) = \\prod_{i}^{}\\lambda_{i}$\n\n迹形式：$J_{2} = tr(S_{w}^{- 1}S_{b}) = \\sum_{i}^{}\\lambda_{i}$\n\n其中，$λ_{i}$是矩阵$S_{w}^{- 1}S_{b}$的特征值。使$J_{1}$或$J_{2}$**最大**的子集可作为选择的分类特征。\n\n## 离散K-L变换 \n\n前面讨论的**直接删去**一些特征的做法**不理想**，因为一般来说，原来的n个数据各自在不同程度上反映了识别对象的某些特征，简单地删去某些特征可能会丢失较多的有用信息 。\n\n将样本看成是对应维度D维随机向量的一次采样，对D维向量*x*用一个完备的**正交归一向量系**进行**展开**（理解成用一组正交的基向量来表示）。或者是对D维特征进行**正交变换**，用变换后的维度中选择少数的几个特征，这几个少数的特征**尽可能多地反映各类模式之间的差异**，而这些特征间**又尽可能相互独立 。**\n\n### 展开式的形式\n\n设一连续的随机实函数x(t)，$T_{1} \\leq t \\leq T_{2}$，则x(t)可用已知的**正交函数集**$φ_{j}(t),j=1,2,\\ldots{\\infty}$的**线性组合来展开**，即公式1：\n$$\n\\begin{split}\nx(t) &= a_{1}\\varphi_{1}(t) + a_{2}\\varphi_{2}(t) + \\cdots + a_{j}\\varphi_{j}(t) + \\cdots\\\\\n&=\\sum_{j=1}a_j\\varphi_j(t),\\qquad T_1\\le t \\le T_2 \\qquad (1)\\\\\n\\end{split}\n$$\n\n式中，$a_{j}$为展开式的随机系数，$φ_{j}(t)$为一连续的正交函数，它应满足：\n$$\n\\int_{T_{1}}^{T_{2}}{\\varphi_{n}^{(t)}{\\tilde{\\varphi}}_{m}(t)dt = \\left\\{ \\begin{matrix}\n1, & \\text{if}\\mspace{6mu} m = n \\\\\n0 & \\text{if}\\mspace{6mu} m \\neq n \\\\\n\\end{matrix} \\right.\\ }\n$$\n其中${\\tilde{\\varphi}}_{m}(t)$为$φ_{m}(t)$的共轭复数式。\n\n将上式写成离散的正交函数形式，使连续随机函数x(t)和连续正交函数$φ_{j}(t)$在区间$T_{1} \\leq t \\leq T_{2}$内被等间隔采样为n个离散点，**用采n个点的样本，来描绘原来的函数**即：\n$$\nx(t) \\rightarrow \\{ x(1),x(2),\\cdots,x(n)\\}\\\\\n\\varphi_{j}(t) \\rightarrow \\{\\varphi_{j}(1),\\varphi_{j}(2),\\cdots,\\varphi_{j}(n)\\}\n$$\n写成向量形式：\n$$\n\\begin{split}\nx &= (x(1),x(2),\\cdots,x(n))^{T}\\\\\n\\varphi_{j}& = (\\varphi_{j}(1),\\varphi_{j}(2),\\cdots,\\varphi_{j}(n))^{T},\\mspace{6mu} j = 1,2,\\cdots,n\n\\end{split}\n$$\n**每一个正交函数都要对应的平行采样**，而不是一个函数采一个时刻的样。\n\n将公式(1)**取n项近似**(可以理解成逼近)，并写成离散展开式：\n$$\nx = \\sum_{j = 1}^{n}{a_{j}\\varphi_{j}} = \\Phi a,\\quad T_{1} \\leq t \\leq T_{2} \\qquad(2)\n$$\n\n其中，a为展开式中随机系数的向量形式，即：$a = (a_{1}, a_{2}, \\ldots{},a_{j}, \\ldots{},a_{n})^{T}$\n\n$\\Phi$为n x n维矩阵，即：\n$$\n\\Phi = (\\varphi_{1},\\varphi_{2},\\cdots,\\varphi_{n}) = \\begin{bmatrix}\n\\varphi_{1}(1) & \\varphi_{2}(1) & \\cdots & \\varphi_{n}(1) \\\\\n\\varphi_{1}(2) & \\varphi_{2}(2) & \\cdots & \\varphi_{n}(2) \\\\\n\\cdots & \\cdots & \\cdots & \\cdots \\\\\n\\varphi_{1}(n) & \\varphi_{2}(n) & \\cdots & \\varphi_{n}(n) \\\\\n\\end{bmatrix}\n$$\n其中，每一列为正交函数集中的一个函数，小括号内的序号为正交函数的采样点次序。因此，$\\Phi$实质上是由$φ_{j}$向量组成的正交变换矩阵，它将x变换成a。**不应该是a变换成x吗，x变成a应该是用逆矩阵来变换的？**\n\n对于**每一类正交函数是相同**的，但是每一类的**展开系数向量则不同**\n\n### 展开式的性质\n\n#### 正交向量集$\\varphi_j$的确定\n\nK-L展开式的根本性质是**将随机向量x展开为另一组正交向量$\\varphi_j$的线性和**，且其展开式系数$a_j$（即系数向量a的各个分量）具有不同的性质。\n\n设随机向量x的总体**自相关矩阵**为$R = E\\{xx^{T}\\}$。由$x = \\sum_{j = 1}^{n}{a_{j}\\varphi_{j}} = \\Phi a,\\quad T_{1} \\leq t \\leq T_{2}$将$x=\\Phi a$代入$R = E\\{xx^{T}\\}$，得：\n$$\n{R = E\\{Φaa^{T}Φ^{T}\\}=Φ(E\\{aa^{T}\\})Φ^{T}}\n$$\n\n要求**系数向量a**的各个**不同分量**应**统计独立**，即应使$(a_{1},a_{2}, \\ldots{}, a_{j}, \\ldots{},a_{n})$满足如下关系：**(没搞懂)**\n$$\nE(a_{j}a_{k}) = \\left\\{ \\begin{matrix}\n\\lambda_{j} & \\text{if}\\mspace{6mu} j = k \\\\\n0 & \\text{if}\\mspace{6mu} j \\neq k \\\\\n\\end{matrix} \\right.\\\n$$\n写成矩阵形式，应使：$E\\{a a^{T}\\} =D_{λ}$，其中$D_{λ}$为对角形矩阵，其互相关成分均为0，即:\n$$\nD_{\\lambda} = \\begin{bmatrix}\n\\lambda_{1} & 0 & \\cdots & \\cdots & 0 \\\\\n0 & \\ddots & 0 & \\cdots & 0 \\\\\n0 & & \\lambda_{j} & & 0 \\\\\n0 & \\cdots & 0 & \\ddots & 0 \\\\\n0 & \\cdots & \\cdots & 0 & \\lambda_{n} \\\\\n\\end{bmatrix}\n$$\n则：$R =\\Phi D_{λ}Φ^{T}$\n\n由于$\\Phi$中的各个向量$\\varphi_j$都**相互归一正交有性质**（$\\Phi^T \\Phi=\\Phi^{-1}\\Phi=I$）**$\\Phi$是正交矩阵？**，故有：\n$$\n{RΦ=ΦD_{λ}Φ^{T}Φ=ΦD_{λ}}\n$$\n其中，$\\varphi_j$向量对应为：$R\\varphi_j=λ_j\\varphi_j$\n\n可以看出，**$λ_j$是x的自相关矩阵R的特征值，$\\varphi_j$是对应的特征向量。**因为R是实对称矩阵，其不同特征值对应的特征向量应**正交(向量之间的夹角为90度)**，即：\n$$\n\\varphi_{j}^{T}\\varphi_{k} = \\left\\{ \\begin{matrix}\n1 & \\text{if}\\mspace{6mu} j = k \\\\\n0 & \\text{if}\\mspace{6mu} j \\neq k \\\\\n\\end{matrix} \\right.\\\n$$\n由式$x = \\sum_{j = 1}^{n}{a_{j}\\varphi_{j}} = \\Phi a,\\quad T_{1} \\leq t \\leq T_{2}$，**K-L展开式系数应为**：\n$$\na = \\Phi^{T}x\n$$\n**结论：正交向量集$\\Phi$是样本的自相关矩阵$R = E\\{xx^{T}\\}$的特征向量构成的集合。**如果选择$\\Phi$的维度是$D\\times K$即只选择K个特征向量去展开来逼近原来的样本，**则应该选择特征值前K大的的K个特征向量来组成。**\n\n这段推导没有搞懂，还是模式识别书上的展开后去前n项来逼近原始向量之后求原向量与逼近向量之间的均方误差最小，然后在等式约束下使用拉格朗日发来求极值，解得系数是是$\\Phi$的特征值好理解。\n\n#### K-L展示式系数的计算步骤\n\n1.  求随机向量x的自相关矩阵：$R = E\\{xx^{T}\\}$\n2. 求出矩阵R的特征值$λ_j$和对应的特征向量$\\varphi_j，j = 1,2,\\ldots{},n$，得矩阵：$\\Phi = (\\varphi_{1},\\varphi_{2},\\cdots,\\varphi_{n})$\n3. 计算展开式系数：$a = \\Phi^{T}x$\n\n### 按K-L展开式选择特征 \n\nK-L展开式用于特征选择相当于一种**线性变换**。 \n\n若从n个特征向量中取出m个组成变换矩阵$\\Phi$，即$\\Phi=(\\Phi_1,\\Phi_2,\\ldots{\\Phi_m})\\quad m<n$  得到的$\\Phi$矩阵的维度是$n\\times m$,样本向量x是n为向量，则通过$a = \\Phi^{T}x$得到的系数向量是m维度，**系数向量就是降维后得到的新向量。**\n\n#### 问题\n\n选取变换矩阵$\\Phi$ 后，让降维后得到的**新向量a在最小均方误差条件下接近原来的向量x**。（不是直接用a与x取比较的，因为维度都不同，是让a乘以变换矩阵去逼近x。换句话说，x是被其自相关矩阵展开的）\n\n对于$x = \\sum_{j = 1}^{n}{a_{j}\\varphi_{j}}$，现仅取m项，对略去的系数项用预先选定的常数b代替，此时对x的估计值为：\n$$\n\\hat{x} = \\sum_{j = 1}^{m}{a_{j}\\varphi_{j}} + \\sum_{j = m + 1}^{n}{b\\varphi_{j}}\n$$\n则产生的误差为：\n$$\n\\Delta x = x - \\hat{x} = \\sum_{j = m + 1}^{n}{(a_{j} - b)\\varphi_{j}}\n$$\n则$\\Delta x$的均方误差为：(**为什么引入了期望**)(**为什么没有了$\\varphi_j$**)\n$$\n\\overline{\\varepsilon^{2}} = E\\{||\\Delta x||\\}^{2} = \\sum_{j = m + 1}^{n}{\\{ E(a_{j} - b)^{2}\\}}\n$$\n要使$\\overline{\\varepsilon^{2}}$最小，对b的选择应满足：\n$$\n\\frac{\\partial}{\\partial b}\\lbrack E(a_{j} - b)^{2}\\rbrack = \\frac{\\partial}{\\partial b}\\lbrack E(a_{j}^{2} - 2a_{j}b + b^{2})\\rbrack = - 2\\lbrack E(a_{j}) - b\\rbrack = 0\n$$\n因此，$b =E{[}a_{j}{]}$，即**对省略掉的a中的分量，应使用它们的数学期望来代替**，此时的误差为：\n$$\n\\begin{equation}\n\\begin{split}\n{\\overline{\\varepsilon^{2}} = \\sum_{j = m + 1}^{n}{E\\lbrack(a_{j} - E\\{ a_{j}\\})^{2}\\rbrack }\\\\\n=\\sum_{j = m + 1}^{n}{\\varphi_{j}^{T}E\\lbrack(x - E\\{ x\\})(x - E\\{ x\\})^{T}\\rbrack\\varphi_{j}}}= { \\sum_{j = m + 1}^{n}{\\varphi_{j}^{T}C_{x}}\\varphi_{j}}\\\\\n\\end{split}\n\\end{equation}\n$$\n其中，$C_{x}$为x的协方差矩阵。**（第二步怎么推出来的？）**\n\n设$λ_{j}$为$C_{x}$的第j个特征值，$\\varphi_{j}$是与$λ_{j}$对应的特征向量，则$C_{x}\\varphi_{j} = \\lambda_{j}\\varphi_{j}$由于$\\varphi_{j}^{T}\\varphi_{j} = 1$,从而$\\varphi_{j}^{T}C_{x}\\varphi_{j} = \\lambda_{j}$因此:\n$$\n\\overline{\\varepsilon^{2}} = \\sum_{j = m + 1}^{n}{\\varphi_{j}^{T}C_{x}}\\varphi_{j} = \\sum_{j = m + 1}^{n}\\lambda_{j}\n$$\n由此可以看出，$λ_{j}$值越小，误差也越小。**（这里的特征值与自相关矩阵的特征值不同？，所以原来的自相关矩阵的特征应该选择大的。）**\n\n### 结论\n\n按照最小均方差的准则来选择特征，应使得$E[a_j]=0$**为什么?**。因为$E[a]=E[\\Phi^Tx]=\\Phi^TE[x]$,所以应使的$E[x]=0$。因此在K-L变换之前，需要先将**其均值作为新坐标轴的原点**，采用协方差矩阵C或自相关矩阵R来计算特征值。如果**$E[x] ≠0$**，则只能得到**“次最佳**”的结果。 \n\n为了使误差尽可能小，**选择的特征向量对应的特征值要是最大的**。\n\nK-L变换是在**均方误差最小的意义下**获得数据压缩（**降维**）的**最佳变换**，且不受模式分布的限制。 整个变换使的整个**模式分布结构尽可能保持不变**。\n\n通过K-L变换能获得互不相关的新特征。 主**成分分析出发点是变换得到的新特征的方差最大**，从而保证原始样本在改维特征上的差异更大，从而更好的区分。PCA使用的变换矩阵是样本的协方差矩阵$C_x=E[(x-E[x])(x-E[x]^T)]$，因此当**样本集的均值为0**即$[E[x]=0]$，或者**对样本进行去均值处理**的时候，**K-L变换就与PCA等价**了。\n\n需要指出的是，采用K-L变换作为模式分类的**特征提取**时，要**特别注意保留不同类别的模式分类鉴别信息**，仅单纯考虑尽可能代表原来模式的主成分，有时并不一定有利于分类的鉴别。 （**这里不同类别的模式分类鉴别信息是什么？）**\n\n","source":"_posts/2019-12-28-特征选择和特征提取.md","raw":"---\ntitle: 特征选择和特征提取\ndate: 2019-12-28 14:19:43\ncategories: 机器学习\ntags:\n- 特征提取\n- 降维\n- 距离矩阵\ncopyright: true\n---\n\n# 特征选择和特征提取\n\n## 意义\n\n1. 降低维度，后续的分类器设计更容易计算，可以加快速度\n2. 消除特征之间可能存在的相关性，减少与分类无关的信息（理解成降噪？），从而更好的分类。\n\n<!--more-->\n\n## 类别可分性质的度量\n\n### 距离\n\n1. 点到点之间的距离\n\n   欧式距离：\n   $$\n   D(a, b) = || a – b ||\n   $$\n   平方形式（向量转置相乘，点积的形式）：\n   $$\n   D^{2}(a,b) = (a - b)^{T}(a - b) = \\sum_{k = 1}^{n}{(a_{k} - b_{k})^{2}}\n   $$\n   其中a和b为n维向量，其第k个特征分别是$a_k$和$b_k$。 **各自对应的特征维度差的平方之和。**\n\n2. 点到点集之间的距离\n\n   在n维空间中，点x到点$a^{(i)}$之间的距离平方为：\n   $$\n   D^{2}(x,a^{(i)}) = \\sum_{k = 1}^{n}{(x_{k} - a_{k}^{(i)})^{2}}\n   $$\n   因此x到有K个点组合的均方距离，就是到每个点均方距离相加之后取均值。\n   $$\n   \\overline{D^{2}(x,\\{ a^{(i)}\\})} = \\frac{1}{K}\\sum_{i = 1}^{K}{D^{2}(x,a^{(i)}) =}\\frac{1}{K}\\sum_{i = 1}^{K}\\left\\{ \\sum_{k = 1}^{n}{(x_{k} - a_{k}^{(i)})^{2}} \\right\\}\n   $$\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### 类内距离\n\n   **类中每个点到其他点的均方距离累加之后求均值**\n\n   n维空间中同一类内各模式样本点集$\\{a^{(i)}\\}_{i=1,2,\\ldots{},K}$，其内部各点的均方距离为$\\overline{D^{2}(\\{ a^{(j)}\\},\\{ a^{(i)}\\})}$，其中$i,j = 1,2,\\ldots,K,i \\neq j$，即：\n$$\n   \\overline{D^{2}(\\{ a^{(j)}\\},\\{ a^{(i)}\\})} = \\frac{1}{K}\\sum_{j = 1}^{K}\\left\\lbrack \\frac{1}{K - 1}\\sum_{\\begin{matrix}\n    i = 1 \\\\\n    i \\neq j \\\\\n   \\end{matrix}}^{K}{\\sum_{k = 1}^{n}{(a_{k}^{(j)} - a_{k}^{(i)})^{2}}} \\right\\rbrack\n$$\n   每个点到其他点的平方距离求和，**三层循环**（点j，点i，维度k）\n\n   可证明：\n$$\n   \\overline{D^{2}} = 2\\sum_{k = 1}^{n}\\sigma_{k}^{2}\n$$\n   其中$\\sigma_{k}^{2}$为样本集合$a^{(i)}$在第k个分量上的无偏方差，即：\n$$\n   \\sigma_{k}^{2} = \\frac{1}{K - 1}\\sum_{i = 1}^{K}{(a_{k}^{(i)} - \\overline{a_{k}})^{2}}\n$$\n   其中$\\overline{a_{k}} = \\frac{1}{K}\\sum_{i = 1}^{K}a_{k}^{(i)}$为$a^{(i)}$在第k个分量方向上的均值。\n\n   **无偏估计除以的是K-1，把数据集合用一个完整的$K \\times N$矩阵来理解，就可以很方便的对应这些距离公式，均值，方差的计算了。公式可以不用管。**\n\n#### 类间距离\n\n   **两类样本均值质心的均方距离**\n\n   常用两类样本各自质心间的距离作为类间距离，并假设两类样本出现的概率相等，则：\n$$\n   D^{2} = \\sum_{k = 1}^{n}{(m_{1_{k}} -}m_{2_{k}})^{2}\n$$\n   其中 $m_1$ 和 $m_2$ 为两类模式样本集各自的均值向量， $m_{1k}$ 和$m_{1k}$为 两个均值向量的第k个特征分量，n为维数。\n\n### 散布矩阵\n\n不管类内还是类间都涉及到与均值向量之差的向量乘以其转置。\n\n#### 类内散布矩阵\n\n**每个样本向量减去均值向量后乘以结果的转置(矩阵)，*然后将得到的矩阵再相加***\n\n考虑一类内模式点集$\\{ a^{(i)}\\}_{i = 1,2,\\ldots,K}$，其类内散布矩阵为：\n$$\nS_w = \\sum_{i = 1}^{K}\\{(a^{(i)} - m)(a^{(i)} - m)^{T}\\}\n$$\n其中m是样本集合的**均值向量**\n$$\nm = \\frac{1}{K}\\sum_{i = 1}^{K}a{(i)}\n$$\n对属于同一类的模式样本，**类内散布矩阵表示各样本点围绕其均值周围的散布情况**。\n\n#### 类间散布矩阵\n\n**两个质心之差形成的向量与其转置相乘而形成的矩阵**，类比与类内散布矩阵，**类内**是每个样本向量减去该类的均值向量，是**所有样本向量**都要参与。\n$$\nS_{b2} = (m_{1} - m_{2})(m_{1} - m_{2})^{T}\n$$\n对三个以上的类别，类间散布矩阵常写成：\n$$\nS_{b} = \\sum_{i = 1}^{c}{P(\\omega_{i})}(m_{i} - m_{0})(m_{i} - m_{0})^{T}\n$$\n其中，$m_{0}$为多类模式（如共有c类）分布的总体均值向量，即：\n$$\nm_{0} = E\\{ x\\} = \\sum_{i = 1}^{c}{P(\\omega_{i})m_{i}},\\quad\\forall\\omega_{i},\\mspace{6mu} i = 1,2,\\ldots,c\n$$\n**用质心来代表每一类，多类模式引入概率来取得总体所有样本均值。**计算的形式与类内的很相似了，$m_0$对应着类内中一个类的均值向量，每个质心对应这类内中的一个样本向量。\n\n### 多类模式集散布矩阵 \n\n多类情况的**类内散布矩阵**，可写成**各类的类内散布矩阵的先验概率的加权和**，即：\n$$\nS_{w} = \\sum_{i = 1}^{c}{P(\\omega_{i})E\\{}(x - m_{i})(x - m_{i})^{T}|\\omega_{i}\\} = \\sum_{i = 1}^{c}{P(\\omega_{i})C_{i}}\n$$\n其中$C_{i}$是第i类的协方差矩阵。E是求期望，也就是每个样本的矩阵计算完了之后相加还要除以样本数目N或者N-1（N-1是无偏估计）。\n\n**协方差(两个变量各自与各自均值的差相乘)：**\n$$\nCov(X,Y)=E[(X-m_X)(Y-m_Y)]=E[XY]-E[X]\\times E[Y]\n$$\n协方差矩阵是不同维度之间的相关性的表达，一个d维的样本也能建立协方差矩阵尺度为$d\\times d$, 所以一个类的协方差矩阵是每个样本的协方差矩阵相加后取**均值**得到的。\n\n有时，用多类模式**总体分布的散布矩阵**来反映其**可分性**，即：\n$$\nS_{t} = E\\{(x - m_{0})(x - m_{0})^{T}\\},\\quad x \\in \\forall\\omega_{i},\\mspace{6mu} i = 1,2,\\ldots,c\n$$\n其中，$m_{0}$为多类模式分布的总体均值向量。\n\n可以证明：$S_{t} = S_{w} +S_{b}$，即**总体散布矩阵是各类类内散布矩阵与类间散布矩阵之和。**\n\n## 特征选择\n\n在尽量不降低分类精度的前提下，选择更少的特诊来进行分类。\n\n### 独立特征的选择准则 \n\n**不同类**的均值向量（**质心点**）之间的**距离最大**，而**同一类**的样本向量的方差之和最小（与其**质心**的**距离较近**）。用一个比值来作为度量标准。\n\n假设个特征之间统计独立，那么对**每个特征分量都去计算那个标准**，就能够知道每个特征对样本可分性的贡献了。\n\n对于$ω_{i}$和$ω_{j}$两类训练样本，假设其均值向量为$m_{i}$和$m_{j}$，其k维方向的分量为$m_{ik}$和$m_{jk}$，方差为$\\sigma_{\\text{ik}}^{2}$和$\\sigma_{\\text{jk}}^{2}$，定义可分性准则函数(也就是那个标准)：\n$$\nG_{k} = \\frac{(m_{\\text{ik}} - m_{\\text{jk}})^{2}}{\\sigma_{\\text{ik}}^{2} + \\sigma_{\\text{jk}}^{2}},\\;\\;k = 1,2,\\ldots,n\n$$\n则$G_{K}$为正值。$G_{K}$值越大，表示测度值的第k个分量对分离$ω_{i}$和$ω_{j}$两类越有效。将$\\{G_{K},k=1,2,\\ldots{},n\\}$按大小排队，选出最大的m个对应的测度值作为分类特征，即达到特征选择的目的。\n\n### 一般特征的散布矩阵准则\n\n回顾类内与类间散布矩阵：\n\n多类类内散布矩阵：\n$$\nS_{w} = \\sum_{i = 1}^{c}{P(\\omega_{i})E\\{}(x - m_{i})(x - m_{i})^{T}|\\omega_{i}\\}\n$$\n 多类类间散布矩阵：\n$$\nS_{b} = \\sum_{i = 1}^{c}{P(\\omega_{i})}(m_{i} - m_{0})(m_{i} - m_{0})^{T}\n$$\n直观上，**类间离散度越大且类内离散度越小**，则可分性越好。因此，可推导出散布矩阵准则采用如下形式： (**矩阵的逆类比于除法**)\n\n行列式形式：$J_{1} = \\det(S_{w}^{- 1}S_{b}) = \\prod_{i}^{}\\lambda_{i}$\n\n迹形式：$J_{2} = tr(S_{w}^{- 1}S_{b}) = \\sum_{i}^{}\\lambda_{i}$\n\n其中，$λ_{i}$是矩阵$S_{w}^{- 1}S_{b}$的特征值。使$J_{1}$或$J_{2}$**最大**的子集可作为选择的分类特征。\n\n## 离散K-L变换 \n\n前面讨论的**直接删去**一些特征的做法**不理想**，因为一般来说，原来的n个数据各自在不同程度上反映了识别对象的某些特征，简单地删去某些特征可能会丢失较多的有用信息 。\n\n将样本看成是对应维度D维随机向量的一次采样，对D维向量*x*用一个完备的**正交归一向量系**进行**展开**（理解成用一组正交的基向量来表示）。或者是对D维特征进行**正交变换**，用变换后的维度中选择少数的几个特征，这几个少数的特征**尽可能多地反映各类模式之间的差异**，而这些特征间**又尽可能相互独立 。**\n\n### 展开式的形式\n\n设一连续的随机实函数x(t)，$T_{1} \\leq t \\leq T_{2}$，则x(t)可用已知的**正交函数集**$φ_{j}(t),j=1,2,\\ldots{\\infty}$的**线性组合来展开**，即公式1：\n$$\n\\begin{split}\nx(t) &= a_{1}\\varphi_{1}(t) + a_{2}\\varphi_{2}(t) + \\cdots + a_{j}\\varphi_{j}(t) + \\cdots\\\\\n&=\\sum_{j=1}a_j\\varphi_j(t),\\qquad T_1\\le t \\le T_2 \\qquad (1)\\\\\n\\end{split}\n$$\n\n式中，$a_{j}$为展开式的随机系数，$φ_{j}(t)$为一连续的正交函数，它应满足：\n$$\n\\int_{T_{1}}^{T_{2}}{\\varphi_{n}^{(t)}{\\tilde{\\varphi}}_{m}(t)dt = \\left\\{ \\begin{matrix}\n1, & \\text{if}\\mspace{6mu} m = n \\\\\n0 & \\text{if}\\mspace{6mu} m \\neq n \\\\\n\\end{matrix} \\right.\\ }\n$$\n其中${\\tilde{\\varphi}}_{m}(t)$为$φ_{m}(t)$的共轭复数式。\n\n将上式写成离散的正交函数形式，使连续随机函数x(t)和连续正交函数$φ_{j}(t)$在区间$T_{1} \\leq t \\leq T_{2}$内被等间隔采样为n个离散点，**用采n个点的样本，来描绘原来的函数**即：\n$$\nx(t) \\rightarrow \\{ x(1),x(2),\\cdots,x(n)\\}\\\\\n\\varphi_{j}(t) \\rightarrow \\{\\varphi_{j}(1),\\varphi_{j}(2),\\cdots,\\varphi_{j}(n)\\}\n$$\n写成向量形式：\n$$\n\\begin{split}\nx &= (x(1),x(2),\\cdots,x(n))^{T}\\\\\n\\varphi_{j}& = (\\varphi_{j}(1),\\varphi_{j}(2),\\cdots,\\varphi_{j}(n))^{T},\\mspace{6mu} j = 1,2,\\cdots,n\n\\end{split}\n$$\n**每一个正交函数都要对应的平行采样**，而不是一个函数采一个时刻的样。\n\n将公式(1)**取n项近似**(可以理解成逼近)，并写成离散展开式：\n$$\nx = \\sum_{j = 1}^{n}{a_{j}\\varphi_{j}} = \\Phi a,\\quad T_{1} \\leq t \\leq T_{2} \\qquad(2)\n$$\n\n其中，a为展开式中随机系数的向量形式，即：$a = (a_{1}, a_{2}, \\ldots{},a_{j}, \\ldots{},a_{n})^{T}$\n\n$\\Phi$为n x n维矩阵，即：\n$$\n\\Phi = (\\varphi_{1},\\varphi_{2},\\cdots,\\varphi_{n}) = \\begin{bmatrix}\n\\varphi_{1}(1) & \\varphi_{2}(1) & \\cdots & \\varphi_{n}(1) \\\\\n\\varphi_{1}(2) & \\varphi_{2}(2) & \\cdots & \\varphi_{n}(2) \\\\\n\\cdots & \\cdots & \\cdots & \\cdots \\\\\n\\varphi_{1}(n) & \\varphi_{2}(n) & \\cdots & \\varphi_{n}(n) \\\\\n\\end{bmatrix}\n$$\n其中，每一列为正交函数集中的一个函数，小括号内的序号为正交函数的采样点次序。因此，$\\Phi$实质上是由$φ_{j}$向量组成的正交变换矩阵，它将x变换成a。**不应该是a变换成x吗，x变成a应该是用逆矩阵来变换的？**\n\n对于**每一类正交函数是相同**的，但是每一类的**展开系数向量则不同**\n\n### 展开式的性质\n\n#### 正交向量集$\\varphi_j$的确定\n\nK-L展开式的根本性质是**将随机向量x展开为另一组正交向量$\\varphi_j$的线性和**，且其展开式系数$a_j$（即系数向量a的各个分量）具有不同的性质。\n\n设随机向量x的总体**自相关矩阵**为$R = E\\{xx^{T}\\}$。由$x = \\sum_{j = 1}^{n}{a_{j}\\varphi_{j}} = \\Phi a,\\quad T_{1} \\leq t \\leq T_{2}$将$x=\\Phi a$代入$R = E\\{xx^{T}\\}$，得：\n$$\n{R = E\\{Φaa^{T}Φ^{T}\\}=Φ(E\\{aa^{T}\\})Φ^{T}}\n$$\n\n要求**系数向量a**的各个**不同分量**应**统计独立**，即应使$(a_{1},a_{2}, \\ldots{}, a_{j}, \\ldots{},a_{n})$满足如下关系：**(没搞懂)**\n$$\nE(a_{j}a_{k}) = \\left\\{ \\begin{matrix}\n\\lambda_{j} & \\text{if}\\mspace{6mu} j = k \\\\\n0 & \\text{if}\\mspace{6mu} j \\neq k \\\\\n\\end{matrix} \\right.\\\n$$\n写成矩阵形式，应使：$E\\{a a^{T}\\} =D_{λ}$，其中$D_{λ}$为对角形矩阵，其互相关成分均为0，即:\n$$\nD_{\\lambda} = \\begin{bmatrix}\n\\lambda_{1} & 0 & \\cdots & \\cdots & 0 \\\\\n0 & \\ddots & 0 & \\cdots & 0 \\\\\n0 & & \\lambda_{j} & & 0 \\\\\n0 & \\cdots & 0 & \\ddots & 0 \\\\\n0 & \\cdots & \\cdots & 0 & \\lambda_{n} \\\\\n\\end{bmatrix}\n$$\n则：$R =\\Phi D_{λ}Φ^{T}$\n\n由于$\\Phi$中的各个向量$\\varphi_j$都**相互归一正交有性质**（$\\Phi^T \\Phi=\\Phi^{-1}\\Phi=I$）**$\\Phi$是正交矩阵？**，故有：\n$$\n{RΦ=ΦD_{λ}Φ^{T}Φ=ΦD_{λ}}\n$$\n其中，$\\varphi_j$向量对应为：$R\\varphi_j=λ_j\\varphi_j$\n\n可以看出，**$λ_j$是x的自相关矩阵R的特征值，$\\varphi_j$是对应的特征向量。**因为R是实对称矩阵，其不同特征值对应的特征向量应**正交(向量之间的夹角为90度)**，即：\n$$\n\\varphi_{j}^{T}\\varphi_{k} = \\left\\{ \\begin{matrix}\n1 & \\text{if}\\mspace{6mu} j = k \\\\\n0 & \\text{if}\\mspace{6mu} j \\neq k \\\\\n\\end{matrix} \\right.\\\n$$\n由式$x = \\sum_{j = 1}^{n}{a_{j}\\varphi_{j}} = \\Phi a,\\quad T_{1} \\leq t \\leq T_{2}$，**K-L展开式系数应为**：\n$$\na = \\Phi^{T}x\n$$\n**结论：正交向量集$\\Phi$是样本的自相关矩阵$R = E\\{xx^{T}\\}$的特征向量构成的集合。**如果选择$\\Phi$的维度是$D\\times K$即只选择K个特征向量去展开来逼近原来的样本，**则应该选择特征值前K大的的K个特征向量来组成。**\n\n这段推导没有搞懂，还是模式识别书上的展开后去前n项来逼近原始向量之后求原向量与逼近向量之间的均方误差最小，然后在等式约束下使用拉格朗日发来求极值，解得系数是是$\\Phi$的特征值好理解。\n\n#### K-L展示式系数的计算步骤\n\n1.  求随机向量x的自相关矩阵：$R = E\\{xx^{T}\\}$\n2. 求出矩阵R的特征值$λ_j$和对应的特征向量$\\varphi_j，j = 1,2,\\ldots{},n$，得矩阵：$\\Phi = (\\varphi_{1},\\varphi_{2},\\cdots,\\varphi_{n})$\n3. 计算展开式系数：$a = \\Phi^{T}x$\n\n### 按K-L展开式选择特征 \n\nK-L展开式用于特征选择相当于一种**线性变换**。 \n\n若从n个特征向量中取出m个组成变换矩阵$\\Phi$，即$\\Phi=(\\Phi_1,\\Phi_2,\\ldots{\\Phi_m})\\quad m<n$  得到的$\\Phi$矩阵的维度是$n\\times m$,样本向量x是n为向量，则通过$a = \\Phi^{T}x$得到的系数向量是m维度，**系数向量就是降维后得到的新向量。**\n\n#### 问题\n\n选取变换矩阵$\\Phi$ 后，让降维后得到的**新向量a在最小均方误差条件下接近原来的向量x**。（不是直接用a与x取比较的，因为维度都不同，是让a乘以变换矩阵去逼近x。换句话说，x是被其自相关矩阵展开的）\n\n对于$x = \\sum_{j = 1}^{n}{a_{j}\\varphi_{j}}$，现仅取m项，对略去的系数项用预先选定的常数b代替，此时对x的估计值为：\n$$\n\\hat{x} = \\sum_{j = 1}^{m}{a_{j}\\varphi_{j}} + \\sum_{j = m + 1}^{n}{b\\varphi_{j}}\n$$\n则产生的误差为：\n$$\n\\Delta x = x - \\hat{x} = \\sum_{j = m + 1}^{n}{(a_{j} - b)\\varphi_{j}}\n$$\n则$\\Delta x$的均方误差为：(**为什么引入了期望**)(**为什么没有了$\\varphi_j$**)\n$$\n\\overline{\\varepsilon^{2}} = E\\{||\\Delta x||\\}^{2} = \\sum_{j = m + 1}^{n}{\\{ E(a_{j} - b)^{2}\\}}\n$$\n要使$\\overline{\\varepsilon^{2}}$最小，对b的选择应满足：\n$$\n\\frac{\\partial}{\\partial b}\\lbrack E(a_{j} - b)^{2}\\rbrack = \\frac{\\partial}{\\partial b}\\lbrack E(a_{j}^{2} - 2a_{j}b + b^{2})\\rbrack = - 2\\lbrack E(a_{j}) - b\\rbrack = 0\n$$\n因此，$b =E{[}a_{j}{]}$，即**对省略掉的a中的分量，应使用它们的数学期望来代替**，此时的误差为：\n$$\n\\begin{equation}\n\\begin{split}\n{\\overline{\\varepsilon^{2}} = \\sum_{j = m + 1}^{n}{E\\lbrack(a_{j} - E\\{ a_{j}\\})^{2}\\rbrack }\\\\\n=\\sum_{j = m + 1}^{n}{\\varphi_{j}^{T}E\\lbrack(x - E\\{ x\\})(x - E\\{ x\\})^{T}\\rbrack\\varphi_{j}}}= { \\sum_{j = m + 1}^{n}{\\varphi_{j}^{T}C_{x}}\\varphi_{j}}\\\\\n\\end{split}\n\\end{equation}\n$$\n其中，$C_{x}$为x的协方差矩阵。**（第二步怎么推出来的？）**\n\n设$λ_{j}$为$C_{x}$的第j个特征值，$\\varphi_{j}$是与$λ_{j}$对应的特征向量，则$C_{x}\\varphi_{j} = \\lambda_{j}\\varphi_{j}$由于$\\varphi_{j}^{T}\\varphi_{j} = 1$,从而$\\varphi_{j}^{T}C_{x}\\varphi_{j} = \\lambda_{j}$因此:\n$$\n\\overline{\\varepsilon^{2}} = \\sum_{j = m + 1}^{n}{\\varphi_{j}^{T}C_{x}}\\varphi_{j} = \\sum_{j = m + 1}^{n}\\lambda_{j}\n$$\n由此可以看出，$λ_{j}$值越小，误差也越小。**（这里的特征值与自相关矩阵的特征值不同？，所以原来的自相关矩阵的特征应该选择大的。）**\n\n### 结论\n\n按照最小均方差的准则来选择特征，应使得$E[a_j]=0$**为什么?**。因为$E[a]=E[\\Phi^Tx]=\\Phi^TE[x]$,所以应使的$E[x]=0$。因此在K-L变换之前，需要先将**其均值作为新坐标轴的原点**，采用协方差矩阵C或自相关矩阵R来计算特征值。如果**$E[x] ≠0$**，则只能得到**“次最佳**”的结果。 \n\n为了使误差尽可能小，**选择的特征向量对应的特征值要是最大的**。\n\nK-L变换是在**均方误差最小的意义下**获得数据压缩（**降维**）的**最佳变换**，且不受模式分布的限制。 整个变换使的整个**模式分布结构尽可能保持不变**。\n\n通过K-L变换能获得互不相关的新特征。 主**成分分析出发点是变换得到的新特征的方差最大**，从而保证原始样本在改维特征上的差异更大，从而更好的区分。PCA使用的变换矩阵是样本的协方差矩阵$C_x=E[(x-E[x])(x-E[x]^T)]$，因此当**样本集的均值为0**即$[E[x]=0]$，或者**对样本进行去均值处理**的时候，**K-L变换就与PCA等价**了。\n\n需要指出的是，采用K-L变换作为模式分类的**特征提取**时，要**特别注意保留不同类别的模式分类鉴别信息**，仅单纯考虑尽可能代表原来模式的主成分，有时并不一定有利于分类的鉴别。 （**这里不同类别的模式分类鉴别信息是什么？）**\n\n","slug":"2019-12-28-特征选择和特征提取","published":1,"updated":"2019-12-29T06:13:49.230Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6he13zf002pdstzyalchkf0","content":"<h1 id=\"特征选择和特征提取\"><a href=\"#特征选择和特征提取\" class=\"headerlink\" title=\"特征选择和特征提取\"></a>特征选择和特征提取</h1><h2 id=\"意义\"><a href=\"#意义\" class=\"headerlink\" title=\"意义\"></a>意义</h2><ol>\n<li>降低维度，后续的分类器设计更容易计算，可以加快速度</li>\n<li>消除特征之间可能存在的相关性，减少与分类无关的信息（理解成降噪？），从而更好的分类。</li>\n</ol>\n<a id=\"more\"></a>\n<h2 id=\"类别可分性质的度量\"><a href=\"#类别可分性质的度量\" class=\"headerlink\" title=\"类别可分性质的度量\"></a>类别可分性质的度量</h2><h3 id=\"距离\"><a href=\"#距离\" class=\"headerlink\" title=\"距离\"></a>距离</h3><ol>\n<li><p>点到点之间的距离</p>\n<p>欧式距离：</p>\n<script type=\"math/tex; mode=display\">\nD(a, b) = || a – b ||</script><p>平方形式（向量转置相乘，点积的形式）：</p>\n<script type=\"math/tex; mode=display\">\nD^{2}(a,b) = (a - b)^{T}(a - b) = \\sum_{k = 1}^{n}{(a_{k} - b_{k})^{2}}</script><p>其中a和b为n维向量，其第k个特征分别是$a_k$和$b_k$。 <strong>各自对应的特征维度差的平方之和。</strong></p>\n</li>\n<li><p>点到点集之间的距离</p>\n<p>在n维空间中，点x到点$a^{(i)}$之间的距离平方为：</p>\n<script type=\"math/tex; mode=display\">\nD^{2}(x,a^{(i)}) = \\sum_{k = 1}^{n}{(x_{k} - a_{k}^{(i)})^{2}}</script><p>因此x到有K个点组合的均方距离，就是到每个点均方距离相加之后取均值。</p>\n<script type=\"math/tex; mode=display\">\n\\overline{D^{2}(x,\\{ a^{(i)}\\})} = \\frac{1}{K}\\sum_{i = 1}^{K}{D^{2}(x,a^{(i)}) =}\\frac{1}{K}\\sum_{i = 1}^{K}\\left\\{ \\sum_{k = 1}^{n}{(x_{k} - a_{k}^{(i)})^{2}} \\right\\}</script></li>\n</ol>\n<h4 id=\"类内距离\"><a href=\"#类内距离\" class=\"headerlink\" title=\"类内距离\"></a>类内距离</h4><p>   <strong>类中每个点到其他点的均方距离累加之后求均值</strong></p>\n<p>   n维空间中同一类内各模式样本点集$\\{a^{(i)}\\}_{i=1,2,\\ldots{},K}$，其内部各点的均方距离为$\\overline{D^{2}(\\{ a^{(j)}\\},\\{ a^{(i)}\\})}$，其中$i,j = 1,2,\\ldots,K,i \\neq j$，即：</p>\n<script type=\"math/tex; mode=display\">\n   \\overline{D^{2}(\\{ a^{(j)}\\},\\{ a^{(i)}\\})} = \\frac{1}{K}\\sum_{j = 1}^{K}\\left\\lbrack \\frac{1}{K - 1}\\sum_{\\begin{matrix}\n    i = 1 \\\\\n    i \\neq j \\\\\n   \\end{matrix}}^{K}{\\sum_{k = 1}^{n}{(a_{k}^{(j)} - a_{k}^{(i)})^{2}}} \\right\\rbrack</script><p>   每个点到其他点的平方距离求和，<strong>三层循环</strong>（点j，点i，维度k）</p>\n<p>   可证明：</p>\n<script type=\"math/tex; mode=display\">\n   \\overline{D^{2}} = 2\\sum_{k = 1}^{n}\\sigma_{k}^{2}</script><p>   其中$\\sigma_{k}^{2}$为样本集合$a^{(i)}$在第k个分量上的无偏方差，即：</p>\n<script type=\"math/tex; mode=display\">\n   \\sigma_{k}^{2} = \\frac{1}{K - 1}\\sum_{i = 1}^{K}{(a_{k}^{(i)} - \\overline{a_{k}})^{2}}</script><p>   其中$\\overline{a_{k}} = \\frac{1}{K}\\sum_{i = 1}^{K}a_{k}^{(i)}$为$a^{(i)}$在第k个分量方向上的均值。</p>\n<p>   <strong>无偏估计除以的是K-1，把数据集合用一个完整的$K \\times N$矩阵来理解，就可以很方便的对应这些距离公式，均值，方差的计算了。公式可以不用管。</strong></p>\n<h4 id=\"类间距离\"><a href=\"#类间距离\" class=\"headerlink\" title=\"类间距离\"></a>类间距离</h4><p>   <strong>两类样本均值质心的均方距离</strong></p>\n<p>   常用两类样本各自质心间的距离作为类间距离，并假设两类样本出现的概率相等，则：</p>\n<script type=\"math/tex; mode=display\">\n   D^{2} = \\sum_{k = 1}^{n}{(m_{1_{k}} -}m_{2_{k}})^{2}</script><p>   其中 $m_1$ 和 $m_2$ 为两类模式样本集各自的均值向量， $m_{1k}$ 和$m_{1k}$为 两个均值向量的第k个特征分量，n为维数。</p>\n<h3 id=\"散布矩阵\"><a href=\"#散布矩阵\" class=\"headerlink\" title=\"散布矩阵\"></a>散布矩阵</h3><p>不管类内还是类间都涉及到与均值向量之差的向量乘以其转置。</p>\n<h4 id=\"类内散布矩阵\"><a href=\"#类内散布矩阵\" class=\"headerlink\" title=\"类内散布矩阵\"></a>类内散布矩阵</h4><p><strong>每个样本向量减去均值向量后乘以结果的转置(矩阵)，<em>然后将得到的矩阵再相加</em></strong></p>\n<p>考虑一类内模式点集$\\{ a^{(i)}\\}_{i = 1,2,\\ldots,K}$，其类内散布矩阵为：</p>\n<script type=\"math/tex; mode=display\">\nS_w = \\sum_{i = 1}^{K}\\{(a^{(i)} - m)(a^{(i)} - m)^{T}\\}</script><p>其中m是样本集合的<strong>均值向量</strong></p>\n<script type=\"math/tex; mode=display\">\nm = \\frac{1}{K}\\sum_{i = 1}^{K}a{(i)}</script><p>对属于同一类的模式样本，<strong>类内散布矩阵表示各样本点围绕其均值周围的散布情况</strong>。</p>\n<h4 id=\"类间散布矩阵\"><a href=\"#类间散布矩阵\" class=\"headerlink\" title=\"类间散布矩阵\"></a>类间散布矩阵</h4><p><strong>两个质心之差形成的向量与其转置相乘而形成的矩阵</strong>，类比与类内散布矩阵，<strong>类内</strong>是每个样本向量减去该类的均值向量，是<strong>所有样本向量</strong>都要参与。</p>\n<script type=\"math/tex; mode=display\">\nS_{b2} = (m_{1} - m_{2})(m_{1} - m_{2})^{T}</script><p>对三个以上的类别，类间散布矩阵常写成：</p>\n<script type=\"math/tex; mode=display\">\nS_{b} = \\sum_{i = 1}^{c}{P(\\omega_{i})}(m_{i} - m_{0})(m_{i} - m_{0})^{T}</script><p>其中，$m_{0}$为多类模式（如共有c类）分布的总体均值向量，即：</p>\n<script type=\"math/tex; mode=display\">\nm_{0} = E\\{ x\\} = \\sum_{i = 1}^{c}{P(\\omega_{i})m_{i}},\\quad\\forall\\omega_{i},\\mspace{6mu} i = 1,2,\\ldots,c</script><p><strong>用质心来代表每一类，多类模式引入概率来取得总体所有样本均值。</strong>计算的形式与类内的很相似了，$m_0$对应着类内中一个类的均值向量，每个质心对应这类内中的一个样本向量。</p>\n<h3 id=\"多类模式集散布矩阵\"><a href=\"#多类模式集散布矩阵\" class=\"headerlink\" title=\"多类模式集散布矩阵\"></a>多类模式集散布矩阵</h3><p>多类情况的<strong>类内散布矩阵</strong>，可写成<strong>各类的类内散布矩阵的先验概率的加权和</strong>，即：</p>\n<script type=\"math/tex; mode=display\">\nS_{w} = \\sum_{i = 1}^{c}{P(\\omega_{i})E\\{}(x - m_{i})(x - m_{i})^{T}|\\omega_{i}\\} = \\sum_{i = 1}^{c}{P(\\omega_{i})C_{i}}</script><p>其中$C_{i}$是第i类的协方差矩阵。E是求期望，也就是每个样本的矩阵计算完了之后相加还要除以样本数目N或者N-1（N-1是无偏估计）。</p>\n<p><strong>协方差(两个变量各自与各自均值的差相乘)：</strong></p>\n<script type=\"math/tex; mode=display\">\nCov(X,Y)=E[(X-m_X)(Y-m_Y)]=E[XY]-E[X]\\times E[Y]</script><p>协方差矩阵是不同维度之间的相关性的表达，一个d维的样本也能建立协方差矩阵尺度为$d\\times d$, 所以一个类的协方差矩阵是每个样本的协方差矩阵相加后取<strong>均值</strong>得到的。</p>\n<p>有时，用多类模式<strong>总体分布的散布矩阵</strong>来反映其<strong>可分性</strong>，即：</p>\n<script type=\"math/tex; mode=display\">\nS_{t} = E\\{(x - m_{0})(x - m_{0})^{T}\\},\\quad x \\in \\forall\\omega_{i},\\mspace{6mu} i = 1,2,\\ldots,c</script><p>其中，$m_{0}$为多类模式分布的总体均值向量。</p>\n<p>可以证明：$S_{t} = S_{w} +S_{b}$，即<strong>总体散布矩阵是各类类内散布矩阵与类间散布矩阵之和。</strong></p>\n<h2 id=\"特征选择\"><a href=\"#特征选择\" class=\"headerlink\" title=\"特征选择\"></a>特征选择</h2><p>在尽量不降低分类精度的前提下，选择更少的特诊来进行分类。</p>\n<h3 id=\"独立特征的选择准则\"><a href=\"#独立特征的选择准则\" class=\"headerlink\" title=\"独立特征的选择准则\"></a>独立特征的选择准则</h3><p><strong>不同类</strong>的均值向量（<strong>质心点</strong>）之间的<strong>距离最大</strong>，而<strong>同一类</strong>的样本向量的方差之和最小（与其<strong>质心</strong>的<strong>距离较近</strong>）。用一个比值来作为度量标准。</p>\n<p>假设个特征之间统计独立，那么对<strong>每个特征分量都去计算那个标准</strong>，就能够知道每个特征对样本可分性的贡献了。</p>\n<p>对于$ω_{i}$和$ω_{j}$两类训练样本，假设其均值向量为$m_{i}$和$m_{j}$，其k维方向的分量为$m_{ik}$和$m_{jk}$，方差为$\\sigma_{\\text{ik}}^{2}$和$\\sigma_{\\text{jk}}^{2}$，定义可分性准则函数(也就是那个标准)：</p>\n<script type=\"math/tex; mode=display\">\nG_{k} = \\frac{(m_{\\text{ik}} - m_{\\text{jk}})^{2}}{\\sigma_{\\text{ik}}^{2} + \\sigma_{\\text{jk}}^{2}},\\;\\;k = 1,2,\\ldots,n</script><p>则$G_{K}$为正值。$G_{K}$值越大，表示测度值的第k个分量对分离$ω_{i}$和$ω_{j}$两类越有效。将$\\{G_{K},k=1,2,\\ldots{},n\\}$按大小排队，选出最大的m个对应的测度值作为分类特征，即达到特征选择的目的。</p>\n<h3 id=\"一般特征的散布矩阵准则\"><a href=\"#一般特征的散布矩阵准则\" class=\"headerlink\" title=\"一般特征的散布矩阵准则\"></a>一般特征的散布矩阵准则</h3><p>回顾类内与类间散布矩阵：</p>\n<p>多类类内散布矩阵：</p>\n<script type=\"math/tex; mode=display\">\nS_{w} = \\sum_{i = 1}^{c}{P(\\omega_{i})E\\{}(x - m_{i})(x - m_{i})^{T}|\\omega_{i}\\}</script><p> 多类类间散布矩阵：</p>\n<script type=\"math/tex; mode=display\">\nS_{b} = \\sum_{i = 1}^{c}{P(\\omega_{i})}(m_{i} - m_{0})(m_{i} - m_{0})^{T}</script><p>直观上，<strong>类间离散度越大且类内离散度越小</strong>，则可分性越好。因此，可推导出散布矩阵准则采用如下形式： (<strong>矩阵的逆类比于除法</strong>)</p>\n<p>行列式形式：$J_{1} = \\det(S_{w}^{- 1}S_{b}) = \\prod_{i}^{}\\lambda_{i}$</p>\n<p>迹形式：$J_{2} = tr(S_{w}^{- 1}S_{b}) = \\sum_{i}^{}\\lambda_{i}$</p>\n<p>其中，$λ_{i}$是矩阵$S_{w}^{- 1}S_{b}$的特征值。使$J_{1}$或$J_{2}$<strong>最大</strong>的子集可作为选择的分类特征。</p>\n<h2 id=\"离散K-L变换\"><a href=\"#离散K-L变换\" class=\"headerlink\" title=\"离散K-L变换\"></a>离散K-L变换</h2><p>前面讨论的<strong>直接删去</strong>一些特征的做法<strong>不理想</strong>，因为一般来说，原来的n个数据各自在不同程度上反映了识别对象的某些特征，简单地删去某些特征可能会丢失较多的有用信息 。</p>\n<p>将样本看成是对应维度D维随机向量的一次采样，对D维向量<em>x</em>用一个完备的<strong>正交归一向量系</strong>进行<strong>展开</strong>（理解成用一组正交的基向量来表示）。或者是对D维特征进行<strong>正交变换</strong>，用变换后的维度中选择少数的几个特征，这几个少数的特征<strong>尽可能多地反映各类模式之间的差异</strong>，而这些特征间<strong>又尽可能相互独立 。</strong></p>\n<h3 id=\"展开式的形式\"><a href=\"#展开式的形式\" class=\"headerlink\" title=\"展开式的形式\"></a>展开式的形式</h3><p>设一连续的随机实函数x(t)，$T_{1} \\leq t \\leq T_{2}$，则x(t)可用已知的<strong>正交函数集</strong>$φ_{j}(t),j=1,2,\\ldots{\\infty}$的<strong>线性组合来展开</strong>，即公式1：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{split}\nx(t) &= a_{1}\\varphi_{1}(t) + a_{2}\\varphi_{2}(t) + \\cdots + a_{j}\\varphi_{j}(t) + \\cdots\\\\\n&=\\sum_{j=1}a_j\\varphi_j(t),\\qquad T_1\\le t \\le T_2 \\qquad (1)\\\\\n\\end{split}</script><p>式中，$a_{j}$为展开式的随机系数，$φ_{j}(t)$为一连续的正交函数，它应满足：</p>\n<script type=\"math/tex; mode=display\">\n\\int_{T_{1}}^{T_{2}}{\\varphi_{n}^{(t)}{\\tilde{\\varphi}}_{m}(t)dt = \\left\\{ \\begin{matrix}\n1, & \\text{if}\\mspace{6mu} m = n \\\\\n0 & \\text{if}\\mspace{6mu} m \\neq n \\\\\n\\end{matrix} \\right.\\ }</script><p>其中${\\tilde{\\varphi}}_{m}(t)$为$φ_{m}(t)$的共轭复数式。</p>\n<p>将上式写成离散的正交函数形式，使连续随机函数x(t)和连续正交函数$φ_{j}(t)$在区间$T_{1} \\leq t \\leq T_{2}$内被等间隔采样为n个离散点，<strong>用采n个点的样本，来描绘原来的函数</strong>即：</p>\n<script type=\"math/tex; mode=display\">\nx(t) \\rightarrow \\{ x(1),x(2),\\cdots,x(n)\\}\\\\\n\\varphi_{j}(t) \\rightarrow \\{\\varphi_{j}(1),\\varphi_{j}(2),\\cdots,\\varphi_{j}(n)\\}</script><p>写成向量形式：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{split}\nx &= (x(1),x(2),\\cdots,x(n))^{T}\\\\\n\\varphi_{j}& = (\\varphi_{j}(1),\\varphi_{j}(2),\\cdots,\\varphi_{j}(n))^{T},\\mspace{6mu} j = 1,2,\\cdots,n\n\\end{split}</script><p><strong>每一个正交函数都要对应的平行采样</strong>，而不是一个函数采一个时刻的样。</p>\n<p>将公式(1)<strong>取n项近似</strong>(可以理解成逼近)，并写成离散展开式：</p>\n<script type=\"math/tex; mode=display\">\nx = \\sum_{j = 1}^{n}{a_{j}\\varphi_{j}} = \\Phi a,\\quad T_{1} \\leq t \\leq T_{2} \\qquad(2)</script><p>其中，a为展开式中随机系数的向量形式，即：$a = (a_{1}, a_{2}, \\ldots{},a_{j}, \\ldots{},a_{n})^{T}$</p>\n<p>$\\Phi$为n x n维矩阵，即：</p>\n<script type=\"math/tex; mode=display\">\n\\Phi = (\\varphi_{1},\\varphi_{2},\\cdots,\\varphi_{n}) = \\begin{bmatrix}\n\\varphi_{1}(1) & \\varphi_{2}(1) & \\cdots & \\varphi_{n}(1) \\\\\n\\varphi_{1}(2) & \\varphi_{2}(2) & \\cdots & \\varphi_{n}(2) \\\\\n\\cdots & \\cdots & \\cdots & \\cdots \\\\\n\\varphi_{1}(n) & \\varphi_{2}(n) & \\cdots & \\varphi_{n}(n) \\\\\n\\end{bmatrix}</script><p>其中，每一列为正交函数集中的一个函数，小括号内的序号为正交函数的采样点次序。因此，$\\Phi$实质上是由$φ_{j}$向量组成的正交变换矩阵，它将x变换成a。<strong>不应该是a变换成x吗，x变成a应该是用逆矩阵来变换的？</strong></p>\n<p>对于<strong>每一类正交函数是相同</strong>的，但是每一类的<strong>展开系数向量则不同</strong></p>\n<h3 id=\"展开式的性质\"><a href=\"#展开式的性质\" class=\"headerlink\" title=\"展开式的性质\"></a>展开式的性质</h3><h4 id=\"正交向量集-varphi-j-的确定\"><a href=\"#正交向量集-varphi-j-的确定\" class=\"headerlink\" title=\"正交向量集$\\varphi_j$的确定\"></a>正交向量集$\\varphi_j$的确定</h4><p>K-L展开式的根本性质是<strong>将随机向量x展开为另一组正交向量$\\varphi_j$的线性和</strong>，且其展开式系数$a_j$（即系数向量a的各个分量）具有不同的性质。</p>\n<p>设随机向量x的总体<strong>自相关矩阵</strong>为$R = E\\{xx^{T}\\}$。由$x = \\sum_{j = 1}^{n}{a_{j}\\varphi_{j}} = \\Phi a,\\quad T_{1} \\leq t \\leq T_{2}$将$x=\\Phi a$代入$R = E\\{xx^{T}\\}$，得：</p>\n<script type=\"math/tex; mode=display\">\n{R = E\\{Φaa^{T}Φ^{T}\\}=Φ(E\\{aa^{T}\\})Φ^{T}}</script><p>要求<strong>系数向量a</strong>的各个<strong>不同分量</strong>应<strong>统计独立</strong>，即应使$(a_{1},a_{2}, \\ldots{}, a_{j}, \\ldots{},a_{n})$满足如下关系：<strong>(没搞懂)</strong></p>\n<script type=\"math/tex; mode=display\">\nE(a_{j}a_{k}) = \\left\\{ \\begin{matrix}\n\\lambda_{j} & \\text{if}\\mspace{6mu} j = k \\\\\n0 & \\text{if}\\mspace{6mu} j \\neq k \\\\\n\\end{matrix} \\right.\\</script><p>写成矩阵形式，应使：$E\\{a a^{T}\\} =D_{λ}$，其中$D_{λ}$为对角形矩阵，其互相关成分均为0，即:</p>\n<script type=\"math/tex; mode=display\">\nD_{\\lambda} = \\begin{bmatrix}\n\\lambda_{1} & 0 & \\cdots & \\cdots & 0 \\\\\n0 & \\ddots & 0 & \\cdots & 0 \\\\\n0 & & \\lambda_{j} & & 0 \\\\\n0 & \\cdots & 0 & \\ddots & 0 \\\\\n0 & \\cdots & \\cdots & 0 & \\lambda_{n} \\\\\n\\end{bmatrix}</script><p>则：$R =\\Phi D_{λ}Φ^{T}$</p>\n<p>由于$\\Phi$中的各个向量$\\varphi_j$都<strong>相互归一正交有性质</strong>（$\\Phi^T \\Phi=\\Phi^{-1}\\Phi=I$）<strong>$\\Phi$是正交矩阵？</strong>，故有：</p>\n<script type=\"math/tex; mode=display\">\n{RΦ=ΦD_{λ}Φ^{T}Φ=ΦD_{λ}}</script><p>其中，$\\varphi_j$向量对应为：$R\\varphi_j=λ_j\\varphi_j$</p>\n<p>可以看出，<strong>$λ_j$是x的自相关矩阵R的特征值，$\\varphi_j$是对应的特征向量。</strong>因为R是实对称矩阵，其不同特征值对应的特征向量应<strong>正交(向量之间的夹角为90度)</strong>，即：</p>\n<script type=\"math/tex; mode=display\">\n\\varphi_{j}^{T}\\varphi_{k} = \\left\\{ \\begin{matrix}\n1 & \\text{if}\\mspace{6mu} j = k \\\\\n0 & \\text{if}\\mspace{6mu} j \\neq k \\\\\n\\end{matrix} \\right.\\</script><p>由式$x = \\sum_{j = 1}^{n}{a_{j}\\varphi_{j}} = \\Phi a,\\quad T_{1} \\leq t \\leq T_{2}$，<strong>K-L展开式系数应为</strong>：</p>\n<script type=\"math/tex; mode=display\">\na = \\Phi^{T}x</script><p><strong>结论：正交向量集$\\Phi$是样本的自相关矩阵$R = E\\{xx^{T}\\}$的特征向量构成的集合。</strong>如果选择$\\Phi$的维度是$D\\times K$即只选择K个特征向量去展开来逼近原来的样本，<strong>则应该选择特征值前K大的的K个特征向量来组成。</strong></p>\n<p>这段推导没有搞懂，还是模式识别书上的展开后去前n项来逼近原始向量之后求原向量与逼近向量之间的均方误差最小，然后在等式约束下使用拉格朗日发来求极值，解得系数是是$\\Phi$的特征值好理解。</p>\n<h4 id=\"K-L展示式系数的计算步骤\"><a href=\"#K-L展示式系数的计算步骤\" class=\"headerlink\" title=\"K-L展示式系数的计算步骤\"></a>K-L展示式系数的计算步骤</h4><ol>\n<li>求随机向量x的自相关矩阵：$R = E\\{xx^{T}\\}$</li>\n<li>求出矩阵R的特征值$λ_j$和对应的特征向量$\\varphi_j，j = 1,2,\\ldots{},n$，得矩阵：$\\Phi = (\\varphi_{1},\\varphi_{2},\\cdots,\\varphi_{n})$</li>\n<li>计算展开式系数：$a = \\Phi^{T}x$</li>\n</ol>\n<h3 id=\"按K-L展开式选择特征\"><a href=\"#按K-L展开式选择特征\" class=\"headerlink\" title=\"按K-L展开式选择特征\"></a>按K-L展开式选择特征</h3><p>K-L展开式用于特征选择相当于一种<strong>线性变换</strong>。 </p>\n<p>若从n个特征向量中取出m个组成变换矩阵$\\Phi$，即$\\Phi=(\\Phi_1,\\Phi_2,\\ldots{\\Phi_m})\\quad m&lt;n$  得到的$\\Phi$矩阵的维度是$n\\times m$,样本向量x是n为向量，则通过$a = \\Phi^{T}x$得到的系数向量是m维度，<strong>系数向量就是降维后得到的新向量。</strong></p>\n<h4 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h4><p>选取变换矩阵$\\Phi$ 后，让降维后得到的<strong>新向量a在最小均方误差条件下接近原来的向量x</strong>。（不是直接用a与x取比较的，因为维度都不同，是让a乘以变换矩阵去逼近x。换句话说，x是被其自相关矩阵展开的）</p>\n<p>对于$x = \\sum_{j = 1}^{n}{a_{j}\\varphi_{j}}$，现仅取m项，对略去的系数项用预先选定的常数b代替，此时对x的估计值为：</p>\n<script type=\"math/tex; mode=display\">\n\\hat{x} = \\sum_{j = 1}^{m}{a_{j}\\varphi_{j}} + \\sum_{j = m + 1}^{n}{b\\varphi_{j}}</script><p>则产生的误差为：</p>\n<script type=\"math/tex; mode=display\">\n\\Delta x = x - \\hat{x} = \\sum_{j = m + 1}^{n}{(a_{j} - b)\\varphi_{j}}</script><p>则$\\Delta x$的均方误差为：(<strong>为什么引入了期望</strong>)(<strong>为什么没有了$\\varphi_j$</strong>)</p>\n<script type=\"math/tex; mode=display\">\n\\overline{\\varepsilon^{2}} = E\\{||\\Delta x||\\}^{2} = \\sum_{j = m + 1}^{n}{\\{ E(a_{j} - b)^{2}\\}}</script><p>要使$\\overline{\\varepsilon^{2}}$最小，对b的选择应满足：</p>\n<script type=\"math/tex; mode=display\">\n\\frac{\\partial}{\\partial b}\\lbrack E(a_{j} - b)^{2}\\rbrack = \\frac{\\partial}{\\partial b}\\lbrack E(a_{j}^{2} - 2a_{j}b + b^{2})\\rbrack = - 2\\lbrack E(a_{j}) - b\\rbrack = 0</script><p>因此，$b =E{[}a_{j}{]}$，即<strong>对省略掉的a中的分量，应使用它们的数学期望来代替</strong>，此时的误差为：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\begin{split}\n{\\overline{\\varepsilon^{2}} = \\sum_{j = m + 1}^{n}{E\\lbrack(a_{j} - E\\{ a_{j}\\})^{2}\\rbrack }\\\\\n=\\sum_{j = m + 1}^{n}{\\varphi_{j}^{T}E\\lbrack(x - E\\{ x\\})(x - E\\{ x\\})^{T}\\rbrack\\varphi_{j}}}= { \\sum_{j = m + 1}^{n}{\\varphi_{j}^{T}C_{x}}\\varphi_{j}}\\\\\n\\end{split}\n\\end{equation}</script><p>其中，$C_{x}$为x的协方差矩阵。<strong>（第二步怎么推出来的？）</strong></p>\n<p>设$λ_{j}$为$C_{x}$的第j个特征值，$\\varphi_{j}$是与$λ_{j}$对应的特征向量，则$C_{x}\\varphi_{j} = \\lambda_{j}\\varphi_{j}$由于$\\varphi_{j}^{T}\\varphi_{j} = 1$,从而$\\varphi_{j}^{T}C_{x}\\varphi_{j} = \\lambda_{j}$因此:</p>\n<script type=\"math/tex; mode=display\">\n\\overline{\\varepsilon^{2}} = \\sum_{j = m + 1}^{n}{\\varphi_{j}^{T}C_{x}}\\varphi_{j} = \\sum_{j = m + 1}^{n}\\lambda_{j}</script><p>由此可以看出，$λ_{j}$值越小，误差也越小。<strong>（这里的特征值与自相关矩阵的特征值不同？，所以原来的自相关矩阵的特征应该选择大的。）</strong></p>\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p>按照最小均方差的准则来选择特征，应使得$E[a_j]=0$<strong>为什么?</strong>。因为$E[a]=E[\\Phi^Tx]=\\Phi^TE[x]$,所以应使的$E[x]=0$。因此在K-L变换之前，需要先将<strong>其均值作为新坐标轴的原点</strong>，采用协方差矩阵C或自相关矩阵R来计算特征值。如果<strong>$E[x] ≠0$</strong>，则只能得到<strong>“次最佳</strong>”的结果。 </p>\n<p>为了使误差尽可能小，<strong>选择的特征向量对应的特征值要是最大的</strong>。</p>\n<p>K-L变换是在<strong>均方误差最小的意义下</strong>获得数据压缩（<strong>降维</strong>）的<strong>最佳变换</strong>，且不受模式分布的限制。 整个变换使的整个<strong>模式分布结构尽可能保持不变</strong>。</p>\n<p>通过K-L变换能获得互不相关的新特征。 主<strong>成分分析出发点是变换得到的新特征的方差最大</strong>，从而保证原始样本在改维特征上的差异更大，从而更好的区分。PCA使用的变换矩阵是样本的协方差矩阵$C_x=E[(x-E[x])(x-E[x]^T)]$，因此当<strong>样本集的均值为0</strong>即$[E[x]=0]$，或者<strong>对样本进行去均值处理</strong>的时候，<strong>K-L变换就与PCA等价</strong>了。</p>\n<p>需要指出的是，采用K-L变换作为模式分类的<strong>特征提取</strong>时，要<strong>特别注意保留不同类别的模式分类鉴别信息</strong>，仅单纯考虑尽可能代表原来模式的主成分，有时并不一定有利于分类的鉴别。 （<strong>这里不同类别的模式分类鉴别信息是什么？）</strong></p>\n","site":{"data":{}},"length":8944,"excerpt":"<h1 id=\"特征选择和特征提取\"><a href=\"#特征选择和特征提取\" class=\"headerlink\" title=\"特征选择和特征提取\"></a>特征选择和特征提取</h1><h2 id=\"意义\"><a href=\"#意义\" class=\"headerlink\" title=\"意义\"></a>意义</h2><ol>\n<li>降低维度，后续的分类器设计更容易计算，可以加快速度</li>\n<li>消除特征之间可能存在的相关性，减少与分类无关的信息（理解成降噪？），从而更好的分类。</li>\n</ol>","more":"<h2 id=\"类别可分性质的度量\"><a href=\"#类别可分性质的度量\" class=\"headerlink\" title=\"类别可分性质的度量\"></a>类别可分性质的度量</h2><h3 id=\"距离\"><a href=\"#距离\" class=\"headerlink\" title=\"距离\"></a>距离</h3><ol>\n<li><p>点到点之间的距离</p>\n<p>欧式距离：</p>\n<script type=\"math/tex; mode=display\">\nD(a, b) = || a – b ||</script><p>平方形式（向量转置相乘，点积的形式）：</p>\n<script type=\"math/tex; mode=display\">\nD^{2}(a,b) = (a - b)^{T}(a - b) = \\sum_{k = 1}^{n}{(a_{k} - b_{k})^{2}}</script><p>其中a和b为n维向量，其第k个特征分别是$a_k$和$b_k$。 <strong>各自对应的特征维度差的平方之和。</strong></p>\n</li>\n<li><p>点到点集之间的距离</p>\n<p>在n维空间中，点x到点$a^{(i)}$之间的距离平方为：</p>\n<script type=\"math/tex; mode=display\">\nD^{2}(x,a^{(i)}) = \\sum_{k = 1}^{n}{(x_{k} - a_{k}^{(i)})^{2}}</script><p>因此x到有K个点组合的均方距离，就是到每个点均方距离相加之后取均值。</p>\n<script type=\"math/tex; mode=display\">\n\\overline{D^{2}(x,\\{ a^{(i)}\\})} = \\frac{1}{K}\\sum_{i = 1}^{K}{D^{2}(x,a^{(i)}) =}\\frac{1}{K}\\sum_{i = 1}^{K}\\left\\{ \\sum_{k = 1}^{n}{(x_{k} - a_{k}^{(i)})^{2}} \\right\\}</script></li>\n</ol>\n<h4 id=\"类内距离\"><a href=\"#类内距离\" class=\"headerlink\" title=\"类内距离\"></a>类内距离</h4><p>   <strong>类中每个点到其他点的均方距离累加之后求均值</strong></p>\n<p>   n维空间中同一类内各模式样本点集$\\{a^{(i)}\\}_{i=1,2,\\ldots{},K}$，其内部各点的均方距离为$\\overline{D^{2}(\\{ a^{(j)}\\},\\{ a^{(i)}\\})}$，其中$i,j = 1,2,\\ldots,K,i \\neq j$，即：</p>\n<script type=\"math/tex; mode=display\">\n   \\overline{D^{2}(\\{ a^{(j)}\\},\\{ a^{(i)}\\})} = \\frac{1}{K}\\sum_{j = 1}^{K}\\left\\lbrack \\frac{1}{K - 1}\\sum_{\\begin{matrix}\n    i = 1 \\\\\n    i \\neq j \\\\\n   \\end{matrix}}^{K}{\\sum_{k = 1}^{n}{(a_{k}^{(j)} - a_{k}^{(i)})^{2}}} \\right\\rbrack</script><p>   每个点到其他点的平方距离求和，<strong>三层循环</strong>（点j，点i，维度k）</p>\n<p>   可证明：</p>\n<script type=\"math/tex; mode=display\">\n   \\overline{D^{2}} = 2\\sum_{k = 1}^{n}\\sigma_{k}^{2}</script><p>   其中$\\sigma_{k}^{2}$为样本集合$a^{(i)}$在第k个分量上的无偏方差，即：</p>\n<script type=\"math/tex; mode=display\">\n   \\sigma_{k}^{2} = \\frac{1}{K - 1}\\sum_{i = 1}^{K}{(a_{k}^{(i)} - \\overline{a_{k}})^{2}}</script><p>   其中$\\overline{a_{k}} = \\frac{1}{K}\\sum_{i = 1}^{K}a_{k}^{(i)}$为$a^{(i)}$在第k个分量方向上的均值。</p>\n<p>   <strong>无偏估计除以的是K-1，把数据集合用一个完整的$K \\times N$矩阵来理解，就可以很方便的对应这些距离公式，均值，方差的计算了。公式可以不用管。</strong></p>\n<h4 id=\"类间距离\"><a href=\"#类间距离\" class=\"headerlink\" title=\"类间距离\"></a>类间距离</h4><p>   <strong>两类样本均值质心的均方距离</strong></p>\n<p>   常用两类样本各自质心间的距离作为类间距离，并假设两类样本出现的概率相等，则：</p>\n<script type=\"math/tex; mode=display\">\n   D^{2} = \\sum_{k = 1}^{n}{(m_{1_{k}} -}m_{2_{k}})^{2}</script><p>   其中 $m_1$ 和 $m_2$ 为两类模式样本集各自的均值向量， $m_{1k}$ 和$m_{1k}$为 两个均值向量的第k个特征分量，n为维数。</p>\n<h3 id=\"散布矩阵\"><a href=\"#散布矩阵\" class=\"headerlink\" title=\"散布矩阵\"></a>散布矩阵</h3><p>不管类内还是类间都涉及到与均值向量之差的向量乘以其转置。</p>\n<h4 id=\"类内散布矩阵\"><a href=\"#类内散布矩阵\" class=\"headerlink\" title=\"类内散布矩阵\"></a>类内散布矩阵</h4><p><strong>每个样本向量减去均值向量后乘以结果的转置(矩阵)，<em>然后将得到的矩阵再相加</em></strong></p>\n<p>考虑一类内模式点集$\\{ a^{(i)}\\}_{i = 1,2,\\ldots,K}$，其类内散布矩阵为：</p>\n<script type=\"math/tex; mode=display\">\nS_w = \\sum_{i = 1}^{K}\\{(a^{(i)} - m)(a^{(i)} - m)^{T}\\}</script><p>其中m是样本集合的<strong>均值向量</strong></p>\n<script type=\"math/tex; mode=display\">\nm = \\frac{1}{K}\\sum_{i = 1}^{K}a{(i)}</script><p>对属于同一类的模式样本，<strong>类内散布矩阵表示各样本点围绕其均值周围的散布情况</strong>。</p>\n<h4 id=\"类间散布矩阵\"><a href=\"#类间散布矩阵\" class=\"headerlink\" title=\"类间散布矩阵\"></a>类间散布矩阵</h4><p><strong>两个质心之差形成的向量与其转置相乘而形成的矩阵</strong>，类比与类内散布矩阵，<strong>类内</strong>是每个样本向量减去该类的均值向量，是<strong>所有样本向量</strong>都要参与。</p>\n<script type=\"math/tex; mode=display\">\nS_{b2} = (m_{1} - m_{2})(m_{1} - m_{2})^{T}</script><p>对三个以上的类别，类间散布矩阵常写成：</p>\n<script type=\"math/tex; mode=display\">\nS_{b} = \\sum_{i = 1}^{c}{P(\\omega_{i})}(m_{i} - m_{0})(m_{i} - m_{0})^{T}</script><p>其中，$m_{0}$为多类模式（如共有c类）分布的总体均值向量，即：</p>\n<script type=\"math/tex; mode=display\">\nm_{0} = E\\{ x\\} = \\sum_{i = 1}^{c}{P(\\omega_{i})m_{i}},\\quad\\forall\\omega_{i},\\mspace{6mu} i = 1,2,\\ldots,c</script><p><strong>用质心来代表每一类，多类模式引入概率来取得总体所有样本均值。</strong>计算的形式与类内的很相似了，$m_0$对应着类内中一个类的均值向量，每个质心对应这类内中的一个样本向量。</p>\n<h3 id=\"多类模式集散布矩阵\"><a href=\"#多类模式集散布矩阵\" class=\"headerlink\" title=\"多类模式集散布矩阵\"></a>多类模式集散布矩阵</h3><p>多类情况的<strong>类内散布矩阵</strong>，可写成<strong>各类的类内散布矩阵的先验概率的加权和</strong>，即：</p>\n<script type=\"math/tex; mode=display\">\nS_{w} = \\sum_{i = 1}^{c}{P(\\omega_{i})E\\{}(x - m_{i})(x - m_{i})^{T}|\\omega_{i}\\} = \\sum_{i = 1}^{c}{P(\\omega_{i})C_{i}}</script><p>其中$C_{i}$是第i类的协方差矩阵。E是求期望，也就是每个样本的矩阵计算完了之后相加还要除以样本数目N或者N-1（N-1是无偏估计）。</p>\n<p><strong>协方差(两个变量各自与各自均值的差相乘)：</strong></p>\n<script type=\"math/tex; mode=display\">\nCov(X,Y)=E[(X-m_X)(Y-m_Y)]=E[XY]-E[X]\\times E[Y]</script><p>协方差矩阵是不同维度之间的相关性的表达，一个d维的样本也能建立协方差矩阵尺度为$d\\times d$, 所以一个类的协方差矩阵是每个样本的协方差矩阵相加后取<strong>均值</strong>得到的。</p>\n<p>有时，用多类模式<strong>总体分布的散布矩阵</strong>来反映其<strong>可分性</strong>，即：</p>\n<script type=\"math/tex; mode=display\">\nS_{t} = E\\{(x - m_{0})(x - m_{0})^{T}\\},\\quad x \\in \\forall\\omega_{i},\\mspace{6mu} i = 1,2,\\ldots,c</script><p>其中，$m_{0}$为多类模式分布的总体均值向量。</p>\n<p>可以证明：$S_{t} = S_{w} +S_{b}$，即<strong>总体散布矩阵是各类类内散布矩阵与类间散布矩阵之和。</strong></p>\n<h2 id=\"特征选择\"><a href=\"#特征选择\" class=\"headerlink\" title=\"特征选择\"></a>特征选择</h2><p>在尽量不降低分类精度的前提下，选择更少的特诊来进行分类。</p>\n<h3 id=\"独立特征的选择准则\"><a href=\"#独立特征的选择准则\" class=\"headerlink\" title=\"独立特征的选择准则\"></a>独立特征的选择准则</h3><p><strong>不同类</strong>的均值向量（<strong>质心点</strong>）之间的<strong>距离最大</strong>，而<strong>同一类</strong>的样本向量的方差之和最小（与其<strong>质心</strong>的<strong>距离较近</strong>）。用一个比值来作为度量标准。</p>\n<p>假设个特征之间统计独立，那么对<strong>每个特征分量都去计算那个标准</strong>，就能够知道每个特征对样本可分性的贡献了。</p>\n<p>对于$ω_{i}$和$ω_{j}$两类训练样本，假设其均值向量为$m_{i}$和$m_{j}$，其k维方向的分量为$m_{ik}$和$m_{jk}$，方差为$\\sigma_{\\text{ik}}^{2}$和$\\sigma_{\\text{jk}}^{2}$，定义可分性准则函数(也就是那个标准)：</p>\n<script type=\"math/tex; mode=display\">\nG_{k} = \\frac{(m_{\\text{ik}} - m_{\\text{jk}})^{2}}{\\sigma_{\\text{ik}}^{2} + \\sigma_{\\text{jk}}^{2}},\\;\\;k = 1,2,\\ldots,n</script><p>则$G_{K}$为正值。$G_{K}$值越大，表示测度值的第k个分量对分离$ω_{i}$和$ω_{j}$两类越有效。将$\\{G_{K},k=1,2,\\ldots{},n\\}$按大小排队，选出最大的m个对应的测度值作为分类特征，即达到特征选择的目的。</p>\n<h3 id=\"一般特征的散布矩阵准则\"><a href=\"#一般特征的散布矩阵准则\" class=\"headerlink\" title=\"一般特征的散布矩阵准则\"></a>一般特征的散布矩阵准则</h3><p>回顾类内与类间散布矩阵：</p>\n<p>多类类内散布矩阵：</p>\n<script type=\"math/tex; mode=display\">\nS_{w} = \\sum_{i = 1}^{c}{P(\\omega_{i})E\\{}(x - m_{i})(x - m_{i})^{T}|\\omega_{i}\\}</script><p> 多类类间散布矩阵：</p>\n<script type=\"math/tex; mode=display\">\nS_{b} = \\sum_{i = 1}^{c}{P(\\omega_{i})}(m_{i} - m_{0})(m_{i} - m_{0})^{T}</script><p>直观上，<strong>类间离散度越大且类内离散度越小</strong>，则可分性越好。因此，可推导出散布矩阵准则采用如下形式： (<strong>矩阵的逆类比于除法</strong>)</p>\n<p>行列式形式：$J_{1} = \\det(S_{w}^{- 1}S_{b}) = \\prod_{i}^{}\\lambda_{i}$</p>\n<p>迹形式：$J_{2} = tr(S_{w}^{- 1}S_{b}) = \\sum_{i}^{}\\lambda_{i}$</p>\n<p>其中，$λ_{i}$是矩阵$S_{w}^{- 1}S_{b}$的特征值。使$J_{1}$或$J_{2}$<strong>最大</strong>的子集可作为选择的分类特征。</p>\n<h2 id=\"离散K-L变换\"><a href=\"#离散K-L变换\" class=\"headerlink\" title=\"离散K-L变换\"></a>离散K-L变换</h2><p>前面讨论的<strong>直接删去</strong>一些特征的做法<strong>不理想</strong>，因为一般来说，原来的n个数据各自在不同程度上反映了识别对象的某些特征，简单地删去某些特征可能会丢失较多的有用信息 。</p>\n<p>将样本看成是对应维度D维随机向量的一次采样，对D维向量<em>x</em>用一个完备的<strong>正交归一向量系</strong>进行<strong>展开</strong>（理解成用一组正交的基向量来表示）。或者是对D维特征进行<strong>正交变换</strong>，用变换后的维度中选择少数的几个特征，这几个少数的特征<strong>尽可能多地反映各类模式之间的差异</strong>，而这些特征间<strong>又尽可能相互独立 。</strong></p>\n<h3 id=\"展开式的形式\"><a href=\"#展开式的形式\" class=\"headerlink\" title=\"展开式的形式\"></a>展开式的形式</h3><p>设一连续的随机实函数x(t)，$T_{1} \\leq t \\leq T_{2}$，则x(t)可用已知的<strong>正交函数集</strong>$φ_{j}(t),j=1,2,\\ldots{\\infty}$的<strong>线性组合来展开</strong>，即公式1：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{split}\nx(t) &= a_{1}\\varphi_{1}(t) + a_{2}\\varphi_{2}(t) + \\cdots + a_{j}\\varphi_{j}(t) + \\cdots\\\\\n&=\\sum_{j=1}a_j\\varphi_j(t),\\qquad T_1\\le t \\le T_2 \\qquad (1)\\\\\n\\end{split}</script><p>式中，$a_{j}$为展开式的随机系数，$φ_{j}(t)$为一连续的正交函数，它应满足：</p>\n<script type=\"math/tex; mode=display\">\n\\int_{T_{1}}^{T_{2}}{\\varphi_{n}^{(t)}{\\tilde{\\varphi}}_{m}(t)dt = \\left\\{ \\begin{matrix}\n1, & \\text{if}\\mspace{6mu} m = n \\\\\n0 & \\text{if}\\mspace{6mu} m \\neq n \\\\\n\\end{matrix} \\right.\\ }</script><p>其中${\\tilde{\\varphi}}_{m}(t)$为$φ_{m}(t)$的共轭复数式。</p>\n<p>将上式写成离散的正交函数形式，使连续随机函数x(t)和连续正交函数$φ_{j}(t)$在区间$T_{1} \\leq t \\leq T_{2}$内被等间隔采样为n个离散点，<strong>用采n个点的样本，来描绘原来的函数</strong>即：</p>\n<script type=\"math/tex; mode=display\">\nx(t) \\rightarrow \\{ x(1),x(2),\\cdots,x(n)\\}\\\\\n\\varphi_{j}(t) \\rightarrow \\{\\varphi_{j}(1),\\varphi_{j}(2),\\cdots,\\varphi_{j}(n)\\}</script><p>写成向量形式：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{split}\nx &= (x(1),x(2),\\cdots,x(n))^{T}\\\\\n\\varphi_{j}& = (\\varphi_{j}(1),\\varphi_{j}(2),\\cdots,\\varphi_{j}(n))^{T},\\mspace{6mu} j = 1,2,\\cdots,n\n\\end{split}</script><p><strong>每一个正交函数都要对应的平行采样</strong>，而不是一个函数采一个时刻的样。</p>\n<p>将公式(1)<strong>取n项近似</strong>(可以理解成逼近)，并写成离散展开式：</p>\n<script type=\"math/tex; mode=display\">\nx = \\sum_{j = 1}^{n}{a_{j}\\varphi_{j}} = \\Phi a,\\quad T_{1} \\leq t \\leq T_{2} \\qquad(2)</script><p>其中，a为展开式中随机系数的向量形式，即：$a = (a_{1}, a_{2}, \\ldots{},a_{j}, \\ldots{},a_{n})^{T}$</p>\n<p>$\\Phi$为n x n维矩阵，即：</p>\n<script type=\"math/tex; mode=display\">\n\\Phi = (\\varphi_{1},\\varphi_{2},\\cdots,\\varphi_{n}) = \\begin{bmatrix}\n\\varphi_{1}(1) & \\varphi_{2}(1) & \\cdots & \\varphi_{n}(1) \\\\\n\\varphi_{1}(2) & \\varphi_{2}(2) & \\cdots & \\varphi_{n}(2) \\\\\n\\cdots & \\cdots & \\cdots & \\cdots \\\\\n\\varphi_{1}(n) & \\varphi_{2}(n) & \\cdots & \\varphi_{n}(n) \\\\\n\\end{bmatrix}</script><p>其中，每一列为正交函数集中的一个函数，小括号内的序号为正交函数的采样点次序。因此，$\\Phi$实质上是由$φ_{j}$向量组成的正交变换矩阵，它将x变换成a。<strong>不应该是a变换成x吗，x变成a应该是用逆矩阵来变换的？</strong></p>\n<p>对于<strong>每一类正交函数是相同</strong>的，但是每一类的<strong>展开系数向量则不同</strong></p>\n<h3 id=\"展开式的性质\"><a href=\"#展开式的性质\" class=\"headerlink\" title=\"展开式的性质\"></a>展开式的性质</h3><h4 id=\"正交向量集-varphi-j-的确定\"><a href=\"#正交向量集-varphi-j-的确定\" class=\"headerlink\" title=\"正交向量集$\\varphi_j$的确定\"></a>正交向量集$\\varphi_j$的确定</h4><p>K-L展开式的根本性质是<strong>将随机向量x展开为另一组正交向量$\\varphi_j$的线性和</strong>，且其展开式系数$a_j$（即系数向量a的各个分量）具有不同的性质。</p>\n<p>设随机向量x的总体<strong>自相关矩阵</strong>为$R = E\\{xx^{T}\\}$。由$x = \\sum_{j = 1}^{n}{a_{j}\\varphi_{j}} = \\Phi a,\\quad T_{1} \\leq t \\leq T_{2}$将$x=\\Phi a$代入$R = E\\{xx^{T}\\}$，得：</p>\n<script type=\"math/tex; mode=display\">\n{R = E\\{Φaa^{T}Φ^{T}\\}=Φ(E\\{aa^{T}\\})Φ^{T}}</script><p>要求<strong>系数向量a</strong>的各个<strong>不同分量</strong>应<strong>统计独立</strong>，即应使$(a_{1},a_{2}, \\ldots{}, a_{j}, \\ldots{},a_{n})$满足如下关系：<strong>(没搞懂)</strong></p>\n<script type=\"math/tex; mode=display\">\nE(a_{j}a_{k}) = \\left\\{ \\begin{matrix}\n\\lambda_{j} & \\text{if}\\mspace{6mu} j = k \\\\\n0 & \\text{if}\\mspace{6mu} j \\neq k \\\\\n\\end{matrix} \\right.\\</script><p>写成矩阵形式，应使：$E\\{a a^{T}\\} =D_{λ}$，其中$D_{λ}$为对角形矩阵，其互相关成分均为0，即:</p>\n<script type=\"math/tex; mode=display\">\nD_{\\lambda} = \\begin{bmatrix}\n\\lambda_{1} & 0 & \\cdots & \\cdots & 0 \\\\\n0 & \\ddots & 0 & \\cdots & 0 \\\\\n0 & & \\lambda_{j} & & 0 \\\\\n0 & \\cdots & 0 & \\ddots & 0 \\\\\n0 & \\cdots & \\cdots & 0 & \\lambda_{n} \\\\\n\\end{bmatrix}</script><p>则：$R =\\Phi D_{λ}Φ^{T}$</p>\n<p>由于$\\Phi$中的各个向量$\\varphi_j$都<strong>相互归一正交有性质</strong>（$\\Phi^T \\Phi=\\Phi^{-1}\\Phi=I$）<strong>$\\Phi$是正交矩阵？</strong>，故有：</p>\n<script type=\"math/tex; mode=display\">\n{RΦ=ΦD_{λ}Φ^{T}Φ=ΦD_{λ}}</script><p>其中，$\\varphi_j$向量对应为：$R\\varphi_j=λ_j\\varphi_j$</p>\n<p>可以看出，<strong>$λ_j$是x的自相关矩阵R的特征值，$\\varphi_j$是对应的特征向量。</strong>因为R是实对称矩阵，其不同特征值对应的特征向量应<strong>正交(向量之间的夹角为90度)</strong>，即：</p>\n<script type=\"math/tex; mode=display\">\n\\varphi_{j}^{T}\\varphi_{k} = \\left\\{ \\begin{matrix}\n1 & \\text{if}\\mspace{6mu} j = k \\\\\n0 & \\text{if}\\mspace{6mu} j \\neq k \\\\\n\\end{matrix} \\right.\\</script><p>由式$x = \\sum_{j = 1}^{n}{a_{j}\\varphi_{j}} = \\Phi a,\\quad T_{1} \\leq t \\leq T_{2}$，<strong>K-L展开式系数应为</strong>：</p>\n<script type=\"math/tex; mode=display\">\na = \\Phi^{T}x</script><p><strong>结论：正交向量集$\\Phi$是样本的自相关矩阵$R = E\\{xx^{T}\\}$的特征向量构成的集合。</strong>如果选择$\\Phi$的维度是$D\\times K$即只选择K个特征向量去展开来逼近原来的样本，<strong>则应该选择特征值前K大的的K个特征向量来组成。</strong></p>\n<p>这段推导没有搞懂，还是模式识别书上的展开后去前n项来逼近原始向量之后求原向量与逼近向量之间的均方误差最小，然后在等式约束下使用拉格朗日发来求极值，解得系数是是$\\Phi$的特征值好理解。</p>\n<h4 id=\"K-L展示式系数的计算步骤\"><a href=\"#K-L展示式系数的计算步骤\" class=\"headerlink\" title=\"K-L展示式系数的计算步骤\"></a>K-L展示式系数的计算步骤</h4><ol>\n<li>求随机向量x的自相关矩阵：$R = E\\{xx^{T}\\}$</li>\n<li>求出矩阵R的特征值$λ_j$和对应的特征向量$\\varphi_j，j = 1,2,\\ldots{},n$，得矩阵：$\\Phi = (\\varphi_{1},\\varphi_{2},\\cdots,\\varphi_{n})$</li>\n<li>计算展开式系数：$a = \\Phi^{T}x$</li>\n</ol>\n<h3 id=\"按K-L展开式选择特征\"><a href=\"#按K-L展开式选择特征\" class=\"headerlink\" title=\"按K-L展开式选择特征\"></a>按K-L展开式选择特征</h3><p>K-L展开式用于特征选择相当于一种<strong>线性变换</strong>。 </p>\n<p>若从n个特征向量中取出m个组成变换矩阵$\\Phi$，即$\\Phi=(\\Phi_1,\\Phi_2,\\ldots{\\Phi_m})\\quad m&lt;n$  得到的$\\Phi$矩阵的维度是$n\\times m$,样本向量x是n为向量，则通过$a = \\Phi^{T}x$得到的系数向量是m维度，<strong>系数向量就是降维后得到的新向量。</strong></p>\n<h4 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h4><p>选取变换矩阵$\\Phi$ 后，让降维后得到的<strong>新向量a在最小均方误差条件下接近原来的向量x</strong>。（不是直接用a与x取比较的，因为维度都不同，是让a乘以变换矩阵去逼近x。换句话说，x是被其自相关矩阵展开的）</p>\n<p>对于$x = \\sum_{j = 1}^{n}{a_{j}\\varphi_{j}}$，现仅取m项，对略去的系数项用预先选定的常数b代替，此时对x的估计值为：</p>\n<script type=\"math/tex; mode=display\">\n\\hat{x} = \\sum_{j = 1}^{m}{a_{j}\\varphi_{j}} + \\sum_{j = m + 1}^{n}{b\\varphi_{j}}</script><p>则产生的误差为：</p>\n<script type=\"math/tex; mode=display\">\n\\Delta x = x - \\hat{x} = \\sum_{j = m + 1}^{n}{(a_{j} - b)\\varphi_{j}}</script><p>则$\\Delta x$的均方误差为：(<strong>为什么引入了期望</strong>)(<strong>为什么没有了$\\varphi_j$</strong>)</p>\n<script type=\"math/tex; mode=display\">\n\\overline{\\varepsilon^{2}} = E\\{||\\Delta x||\\}^{2} = \\sum_{j = m + 1}^{n}{\\{ E(a_{j} - b)^{2}\\}}</script><p>要使$\\overline{\\varepsilon^{2}}$最小，对b的选择应满足：</p>\n<script type=\"math/tex; mode=display\">\n\\frac{\\partial}{\\partial b}\\lbrack E(a_{j} - b)^{2}\\rbrack = \\frac{\\partial}{\\partial b}\\lbrack E(a_{j}^{2} - 2a_{j}b + b^{2})\\rbrack = - 2\\lbrack E(a_{j}) - b\\rbrack = 0</script><p>因此，$b =E{[}a_{j}{]}$，即<strong>对省略掉的a中的分量，应使用它们的数学期望来代替</strong>，此时的误差为：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\begin{split}\n{\\overline{\\varepsilon^{2}} = \\sum_{j = m + 1}^{n}{E\\lbrack(a_{j} - E\\{ a_{j}\\})^{2}\\rbrack }\\\\\n=\\sum_{j = m + 1}^{n}{\\varphi_{j}^{T}E\\lbrack(x - E\\{ x\\})(x - E\\{ x\\})^{T}\\rbrack\\varphi_{j}}}= { \\sum_{j = m + 1}^{n}{\\varphi_{j}^{T}C_{x}}\\varphi_{j}}\\\\\n\\end{split}\n\\end{equation}</script><p>其中，$C_{x}$为x的协方差矩阵。<strong>（第二步怎么推出来的？）</strong></p>\n<p>设$λ_{j}$为$C_{x}$的第j个特征值，$\\varphi_{j}$是与$λ_{j}$对应的特征向量，则$C_{x}\\varphi_{j} = \\lambda_{j}\\varphi_{j}$由于$\\varphi_{j}^{T}\\varphi_{j} = 1$,从而$\\varphi_{j}^{T}C_{x}\\varphi_{j} = \\lambda_{j}$因此:</p>\n<script type=\"math/tex; mode=display\">\n\\overline{\\varepsilon^{2}} = \\sum_{j = m + 1}^{n}{\\varphi_{j}^{T}C_{x}}\\varphi_{j} = \\sum_{j = m + 1}^{n}\\lambda_{j}</script><p>由此可以看出，$λ_{j}$值越小，误差也越小。<strong>（这里的特征值与自相关矩阵的特征值不同？，所以原来的自相关矩阵的特征应该选择大的。）</strong></p>\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p>按照最小均方差的准则来选择特征，应使得$E[a_j]=0$<strong>为什么?</strong>。因为$E[a]=E[\\Phi^Tx]=\\Phi^TE[x]$,所以应使的$E[x]=0$。因此在K-L变换之前，需要先将<strong>其均值作为新坐标轴的原点</strong>，采用协方差矩阵C或自相关矩阵R来计算特征值。如果<strong>$E[x] ≠0$</strong>，则只能得到<strong>“次最佳</strong>”的结果。 </p>\n<p>为了使误差尽可能小，<strong>选择的特征向量对应的特征值要是最大的</strong>。</p>\n<p>K-L变换是在<strong>均方误差最小的意义下</strong>获得数据压缩（<strong>降维</strong>）的<strong>最佳变换</strong>，且不受模式分布的限制。 整个变换使的整个<strong>模式分布结构尽可能保持不变</strong>。</p>\n<p>通过K-L变换能获得互不相关的新特征。 主<strong>成分分析出发点是变换得到的新特征的方差最大</strong>，从而保证原始样本在改维特征上的差异更大，从而更好的区分。PCA使用的变换矩阵是样本的协方差矩阵$C_x=E[(x-E[x])(x-E[x]^T)]$，因此当<strong>样本集的均值为0</strong>即$[E[x]=0]$，或者<strong>对样本进行去均值处理</strong>的时候，<strong>K-L变换就与PCA等价</strong>了。</p>\n<p>需要指出的是，采用K-L变换作为模式分类的<strong>特征提取</strong>时，要<strong>特别注意保留不同类别的模式分类鉴别信息</strong>，仅单纯考虑尽可能代表原来模式的主成分，有时并不一定有利于分类的鉴别。 （<strong>这里不同类别的模式分类鉴别信息是什么？）</strong></p>"},{"title":"leetcode 543 Diameter of Binary Tree","date":"2020-01-06T11:08:33.000Z","copyright":true,"_content":"\n# leetcode 543 Diameter of Binary Tree \n\n[题目来源，](<https://leetcode.com/problems/diameter-of-binary-tree/> )需要求解一颗二叉树的最大路径的长度，第一次做出来了，第二次没有做对，所以记录下。\n\n<!--more-->\n\n## 思路\n\n首先观察到问题的输入是一颗二叉树，其左右子节点仍然是一个二叉树，属于可以分解成子问题的数据结构，不是求解最优解，所以很自然的想到分治的方法。\n\n对于每一个节点而言，经过该节点的最长路径分为两种情况：\n\n1. 不经过其父节点，是左节点的最长深度+右节点的最长深度\n2. 经过其父节点，且经过其左右子节点中拥有最大深度的一个子节点\n\n第二种情况对于该节点的父节点而言，是第一种情况，因此对于输入的二叉树而言，更新最大深度只存在第一种情况就是某一节点的左节点最大深度与右节点的最大深度相加，因此每个节点需要返回其左右子节点中拥有最大深度的一个子节点。这样从得到叶子节点这个最小的子问题的解开始，就可以不断向上叠加，得到每一个节点的解，最终得到原始问题的解了。\n\n所以这里的子问题应该是**左右子节点的最长深度**，而不是左右子节点的最长路径，因为每个节点只能经过一次，也就是对于父节点而言，**只能选择左边或者右边的一条路径**，不能左右两边都同时选择。我第二次做错就是因为理解成子问题是每个子节点对应的最大路径长度了。\n\n用分治的三个过程来表示为：\n\n- **划分**：将输入的二叉树划分为左子树L，与右子树R，两个子树仍然是二叉树。\n- **治理**：将L和R分别递归调用函数求得两个子树的最大深度。\n- **合并**：将左子树与右子树的最大深度相加来更新当前的最大路径值，之后返回该子树两个子节点中最大深度最大的深度值。\n\n因为子问题**没有直接返回最大路径长度**，所以需要选择一个全局变量来存储递归返回时的最大路径长度。同时需要注意让**NULL节点返回-1**而不是0，计算长度的时候通过+1来表示路径长度。\n\n## 复杂度\n\n用T(n)表示对于一个拥有n个节点的二叉树寻找最大路径长度所需要的时间，T(n)最复杂的情况是二叉树是一棵完全二叉树。对最复杂的情况进行分析有$T(n)=2T(\\lfloor\\frac{n}{2}\\rfloor)+C$\n$$\n\\begin{equation}\\nonumber\n\\begin{split}\nT(n)&=2T[{\\lfloor\\frac{n}{2}\\rfloor]+C}\\\\\n&=2^2T[{\\lfloor\\frac{n}{2^2}\\rfloor]+C+2C}\\\\\n&=2^3T[{\\lfloor\\frac{n}{2^3}\\rfloor]+C+2C+2C}\\\\\n\\dots\\\\\n&=2^kT[{\\lfloor\\frac{n}{2^k}\\rfloor]+(2k-1)C}\\\\\n\\end{split} \n\\end{equation}\n$$\n每次分解后规模变为左右两个子树，因此下降到$\\lfloor\\frac{n}{2}\\rfloor$,而每次比较左右两个子树最大深度与更新最大路径长度所需的时间为常数C。设当第k次的时候下降到规模为1的叶子节点，因此有$\\frac{n}{2^k}=1$推出$k=\\log_2n$所以有$T(n)=n+(2\\log_2n-1)C=O(n)$,所以时间复杂度为O(n)。\n\n## 代码\n\n代码如下，[源码链接](<https://github.com/BraveY/Coding/blob/master/leetcode/diameter-of-binary-tree.cc> )。\n\n```cc\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    int ans = 0;\n    int diameterOfBinaryTree(TreeNode* root) {\n        LP(root);\n        return ans;\n    }\nprivate:\n    int LP(TreeNode* root){\n        if(!root) return -1;\n        //求左节点的最大深度与右节点的最大深度，根节点到子节点还有长度1，所以都需要加上1\n        int l = LP(root->left)+1;\n        int r = LP(root->right)+1;\n        ans = max(ans, l+r);\n        return max(l,r);\n    }\n};\n```\n\n","source":"_posts/2020-01-06-leetcode-543-Diameter-of-Binary-Tree.md","raw":"---\ntitle: leetcode 543 Diameter of Binary Tree\ndate: 2020-01-06 19:08:33\ncategories: 题解\ntags:\n- 分治\n- 二叉树\n- leetcode\ncopyright: true\n---\n\n# leetcode 543 Diameter of Binary Tree \n\n[题目来源，](<https://leetcode.com/problems/diameter-of-binary-tree/> )需要求解一颗二叉树的最大路径的长度，第一次做出来了，第二次没有做对，所以记录下。\n\n<!--more-->\n\n## 思路\n\n首先观察到问题的输入是一颗二叉树，其左右子节点仍然是一个二叉树，属于可以分解成子问题的数据结构，不是求解最优解，所以很自然的想到分治的方法。\n\n对于每一个节点而言，经过该节点的最长路径分为两种情况：\n\n1. 不经过其父节点，是左节点的最长深度+右节点的最长深度\n2. 经过其父节点，且经过其左右子节点中拥有最大深度的一个子节点\n\n第二种情况对于该节点的父节点而言，是第一种情况，因此对于输入的二叉树而言，更新最大深度只存在第一种情况就是某一节点的左节点最大深度与右节点的最大深度相加，因此每个节点需要返回其左右子节点中拥有最大深度的一个子节点。这样从得到叶子节点这个最小的子问题的解开始，就可以不断向上叠加，得到每一个节点的解，最终得到原始问题的解了。\n\n所以这里的子问题应该是**左右子节点的最长深度**，而不是左右子节点的最长路径，因为每个节点只能经过一次，也就是对于父节点而言，**只能选择左边或者右边的一条路径**，不能左右两边都同时选择。我第二次做错就是因为理解成子问题是每个子节点对应的最大路径长度了。\n\n用分治的三个过程来表示为：\n\n- **划分**：将输入的二叉树划分为左子树L，与右子树R，两个子树仍然是二叉树。\n- **治理**：将L和R分别递归调用函数求得两个子树的最大深度。\n- **合并**：将左子树与右子树的最大深度相加来更新当前的最大路径值，之后返回该子树两个子节点中最大深度最大的深度值。\n\n因为子问题**没有直接返回最大路径长度**，所以需要选择一个全局变量来存储递归返回时的最大路径长度。同时需要注意让**NULL节点返回-1**而不是0，计算长度的时候通过+1来表示路径长度。\n\n## 复杂度\n\n用T(n)表示对于一个拥有n个节点的二叉树寻找最大路径长度所需要的时间，T(n)最复杂的情况是二叉树是一棵完全二叉树。对最复杂的情况进行分析有$T(n)=2T(\\lfloor\\frac{n}{2}\\rfloor)+C$\n$$\n\\begin{equation}\\nonumber\n\\begin{split}\nT(n)&=2T[{\\lfloor\\frac{n}{2}\\rfloor]+C}\\\\\n&=2^2T[{\\lfloor\\frac{n}{2^2}\\rfloor]+C+2C}\\\\\n&=2^3T[{\\lfloor\\frac{n}{2^3}\\rfloor]+C+2C+2C}\\\\\n\\dots\\\\\n&=2^kT[{\\lfloor\\frac{n}{2^k}\\rfloor]+(2k-1)C}\\\\\n\\end{split} \n\\end{equation}\n$$\n每次分解后规模变为左右两个子树，因此下降到$\\lfloor\\frac{n}{2}\\rfloor$,而每次比较左右两个子树最大深度与更新最大路径长度所需的时间为常数C。设当第k次的时候下降到规模为1的叶子节点，因此有$\\frac{n}{2^k}=1$推出$k=\\log_2n$所以有$T(n)=n+(2\\log_2n-1)C=O(n)$,所以时间复杂度为O(n)。\n\n## 代码\n\n代码如下，[源码链接](<https://github.com/BraveY/Coding/blob/master/leetcode/diameter-of-binary-tree.cc> )。\n\n```cc\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    int ans = 0;\n    int diameterOfBinaryTree(TreeNode* root) {\n        LP(root);\n        return ans;\n    }\nprivate:\n    int LP(TreeNode* root){\n        if(!root) return -1;\n        //求左节点的最大深度与右节点的最大深度，根节点到子节点还有长度1，所以都需要加上1\n        int l = LP(root->left)+1;\n        int r = LP(root->right)+1;\n        ans = max(ans, l+r);\n        return max(l,r);\n    }\n};\n```\n\n","slug":"2020-01-06-leetcode-543-Diameter-of-Binary-Tree","published":1,"updated":"2020-02-07T13:30:43.619Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6he13zg002sdstzulne5rnb","content":"<h1 id=\"leetcode-543-Diameter-of-Binary-Tree\"><a href=\"#leetcode-543-Diameter-of-Binary-Tree\" class=\"headerlink\" title=\"leetcode 543 Diameter of Binary Tree\"></a>leetcode 543 Diameter of Binary Tree</h1><p><a href=\"https://leetcode.com/problems/diameter-of-binary-tree/\" target=\"_blank\" rel=\"noopener\">题目来源，</a>需要求解一颗二叉树的最大路径的长度，第一次做出来了，第二次没有做对，所以记录下。</p>\n<a id=\"more\"></a>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>首先观察到问题的输入是一颗二叉树，其左右子节点仍然是一个二叉树，属于可以分解成子问题的数据结构，不是求解最优解，所以很自然的想到分治的方法。</p>\n<p>对于每一个节点而言，经过该节点的最长路径分为两种情况：</p>\n<ol>\n<li>不经过其父节点，是左节点的最长深度+右节点的最长深度</li>\n<li>经过其父节点，且经过其左右子节点中拥有最大深度的一个子节点</li>\n</ol>\n<p>第二种情况对于该节点的父节点而言，是第一种情况，因此对于输入的二叉树而言，更新最大深度只存在第一种情况就是某一节点的左节点最大深度与右节点的最大深度相加，因此每个节点需要返回其左右子节点中拥有最大深度的一个子节点。这样从得到叶子节点这个最小的子问题的解开始，就可以不断向上叠加，得到每一个节点的解，最终得到原始问题的解了。</p>\n<p>所以这里的子问题应该是<strong>左右子节点的最长深度</strong>，而不是左右子节点的最长路径，因为每个节点只能经过一次，也就是对于父节点而言，<strong>只能选择左边或者右边的一条路径</strong>，不能左右两边都同时选择。我第二次做错就是因为理解成子问题是每个子节点对应的最大路径长度了。</p>\n<p>用分治的三个过程来表示为：</p>\n<ul>\n<li><strong>划分</strong>：将输入的二叉树划分为左子树L，与右子树R，两个子树仍然是二叉树。</li>\n<li><strong>治理</strong>：将L和R分别递归调用函数求得两个子树的最大深度。</li>\n<li><strong>合并</strong>：将左子树与右子树的最大深度相加来更新当前的最大路径值，之后返回该子树两个子节点中最大深度最大的深度值。</li>\n</ul>\n<p>因为子问题<strong>没有直接返回最大路径长度</strong>，所以需要选择一个全局变量来存储递归返回时的最大路径长度。同时需要注意让<strong>NULL节点返回-1</strong>而不是0，计算长度的时候通过+1来表示路径长度。</p>\n<h2 id=\"复杂度\"><a href=\"#复杂度\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h2><p>用T(n)表示对于一个拥有n个节点的二叉树寻找最大路径长度所需要的时间，T(n)最复杂的情况是二叉树是一棵完全二叉树。对最复杂的情况进行分析有$T(n)=2T(\\lfloor\\frac{n}{2}\\rfloor)+C$</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\\nonumber\n\\begin{split}\nT(n)&=2T[{\\lfloor\\frac{n}{2}\\rfloor]+C}\\\\\n&=2^2T[{\\lfloor\\frac{n}{2^2}\\rfloor]+C+2C}\\\\\n&=2^3T[{\\lfloor\\frac{n}{2^3}\\rfloor]+C+2C+2C}\\\\\n\\dots\\\\\n&=2^kT[{\\lfloor\\frac{n}{2^k}\\rfloor]+(2k-1)C}\\\\\n\\end{split} \n\\end{equation}</script><p>每次分解后规模变为左右两个子树，因此下降到$\\lfloor\\frac{n}{2}\\rfloor$,而每次比较左右两个子树最大深度与更新最大路径长度所需的时间为常数C。设当第k次的时候下降到规模为1的叶子节点，因此有$\\frac{n}{2^k}=1$推出$k=\\log_2n$所以有$T(n)=n+(2\\log_2n-1)C=O(n)$,所以时间复杂度为O(n)。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>代码如下，<a href=\"https://github.com/BraveY/Coding/blob/master/leetcode/diameter-of-binary-tree.cc\" target=\"_blank\" rel=\"noopener\">源码链接</a>。</p>\n<figure class=\"highlight cc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">diameterOfBinaryTree</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        LP(root);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">LP</span><span class=\"params\">(TreeNode* root)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!root) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"comment\">//求左节点的最大深度与右节点的最大深度，根节点到子节点还有长度1，所以都需要加上1</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = LP(root-&gt;left)+<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> r = LP(root-&gt;right)+<span class=\"number\">1</span>;</span><br><span class=\"line\">        ans = max(ans, l+r);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max(l,r);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"length":1779,"excerpt":"<h1 id=\"leetcode-543-Diameter-of-Binary-Tree\"><a href=\"#leetcode-543-Diameter-of-Binary-Tree\" class=\"headerlink\" title=\"leetcode 543 Diameter of Binary Tree\"></a>leetcode 543 Diameter of Binary Tree</h1><p><a href=\"https://leetcode.com/problems/diameter-of-binary-tree/\" target=\"_blank\" rel=\"noopener\">题目来源，</a>需要求解一颗二叉树的最大路径的长度，第一次做出来了，第二次没有做对，所以记录下。</p>","more":"<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>首先观察到问题的输入是一颗二叉树，其左右子节点仍然是一个二叉树，属于可以分解成子问题的数据结构，不是求解最优解，所以很自然的想到分治的方法。</p>\n<p>对于每一个节点而言，经过该节点的最长路径分为两种情况：</p>\n<ol>\n<li>不经过其父节点，是左节点的最长深度+右节点的最长深度</li>\n<li>经过其父节点，且经过其左右子节点中拥有最大深度的一个子节点</li>\n</ol>\n<p>第二种情况对于该节点的父节点而言，是第一种情况，因此对于输入的二叉树而言，更新最大深度只存在第一种情况就是某一节点的左节点最大深度与右节点的最大深度相加，因此每个节点需要返回其左右子节点中拥有最大深度的一个子节点。这样从得到叶子节点这个最小的子问题的解开始，就可以不断向上叠加，得到每一个节点的解，最终得到原始问题的解了。</p>\n<p>所以这里的子问题应该是<strong>左右子节点的最长深度</strong>，而不是左右子节点的最长路径，因为每个节点只能经过一次，也就是对于父节点而言，<strong>只能选择左边或者右边的一条路径</strong>，不能左右两边都同时选择。我第二次做错就是因为理解成子问题是每个子节点对应的最大路径长度了。</p>\n<p>用分治的三个过程来表示为：</p>\n<ul>\n<li><strong>划分</strong>：将输入的二叉树划分为左子树L，与右子树R，两个子树仍然是二叉树。</li>\n<li><strong>治理</strong>：将L和R分别递归调用函数求得两个子树的最大深度。</li>\n<li><strong>合并</strong>：将左子树与右子树的最大深度相加来更新当前的最大路径值，之后返回该子树两个子节点中最大深度最大的深度值。</li>\n</ul>\n<p>因为子问题<strong>没有直接返回最大路径长度</strong>，所以需要选择一个全局变量来存储递归返回时的最大路径长度。同时需要注意让<strong>NULL节点返回-1</strong>而不是0，计算长度的时候通过+1来表示路径长度。</p>\n<h2 id=\"复杂度\"><a href=\"#复杂度\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h2><p>用T(n)表示对于一个拥有n个节点的二叉树寻找最大路径长度所需要的时间，T(n)最复杂的情况是二叉树是一棵完全二叉树。对最复杂的情况进行分析有$T(n)=2T(\\lfloor\\frac{n}{2}\\rfloor)+C$</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\\nonumber\n\\begin{split}\nT(n)&=2T[{\\lfloor\\frac{n}{2}\\rfloor]+C}\\\\\n&=2^2T[{\\lfloor\\frac{n}{2^2}\\rfloor]+C+2C}\\\\\n&=2^3T[{\\lfloor\\frac{n}{2^3}\\rfloor]+C+2C+2C}\\\\\n\\dots\\\\\n&=2^kT[{\\lfloor\\frac{n}{2^k}\\rfloor]+(2k-1)C}\\\\\n\\end{split} \n\\end{equation}</script><p>每次分解后规模变为左右两个子树，因此下降到$\\lfloor\\frac{n}{2}\\rfloor$,而每次比较左右两个子树最大深度与更新最大路径长度所需的时间为常数C。设当第k次的时候下降到规模为1的叶子节点，因此有$\\frac{n}{2^k}=1$推出$k=\\log_2n$所以有$T(n)=n+(2\\log_2n-1)C=O(n)$,所以时间复杂度为O(n)。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>代码如下，<a href=\"https://github.com/BraveY/Coding/blob/master/leetcode/diameter-of-binary-tree.cc\" target=\"_blank\" rel=\"noopener\">源码链接</a>。</p>\n<figure class=\"highlight cc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">diameterOfBinaryTree</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        LP(root);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">LP</span><span class=\"params\">(TreeNode* root)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!root) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"comment\">//求左节点的最大深度与右节点的最大深度，根节点到子节点还有长度1，所以都需要加上1</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = LP(root-&gt;left)+<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> r = LP(root-&gt;right)+<span class=\"number\">1</span>;</span><br><span class=\"line\">        ans = max(ans, l+r);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max(l,r);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"c++拾遗","date":"2020-02-05T00:46:58.000Z","copyright":true,"_content":"\n# c++拾遗\n\n## 虚函数和纯虚函数\n\n虚函数：virtual void fun (){...........};定义后了可以实现，并且主要是为了子类会对这个函数进行重写，从而实现多态性。声明一个基类指针对象，但指向子类实例对象，这样如果基类是虚函数，则可以根据指向的子类的不同而实现不同的方法。不使用虚函数的话，将无法使用子类重写过的函数。\n\n纯虚函数：virtual +函数+ =0 。只声明，不会在基类完成定义，需要在子类中定义实现的方法。\n\n<!--more-->\n\n----\n\n## 重写和重载\n\n**重载**：\n\n- 相同的范围（同一个作用域中）比如同一个类中\n- 函数的名字相同\n- 函数的参数不同\n- virtual可有可无\n- 返回值可以不同（不能仅只有返回值不同，否则编译器无法分辨调用的是哪一个函数）\n\n**重写覆盖**：\n\n- 不同范围 （基类与子类）\n- 名字相同\n- 参数相同\n- 基类函数必须有virtual\n\n**重写隐藏**：\n\n- 不同范围\n- 名字相同\n- 参数不同\n- virtual可有可无\n\n\n## 结构体和类的区别\n\n**结构体** ：使用struct声明，可以包含构造函数，常数，字段，方法，属性，索引器，运算符和嵌套类型等，不过，结构是值类型。\n\n区别：类的成员默认是私有的，而结构体的成员则是公有的。\n\n## explicit关键字\n\n`explicit`的作用是用来声明类构造函数是显式调用的，禁止隐式调用。所以只用于修饰单参构造函数。因为无参构造函数和多参构造函数本身就是显式调用的。\n\n隐式转换：`A a=True` ; (原来的的构造函数是`A(bool para){}`)  这样的隐式转换使代码的可读性变差。使用`explicit` 后调用构造函数则必须使用 `A a(True)`这种显式方式来调用。\n\n##构造函数初始化列表\n\n`compressed_sparse_row_graph(const ProcessGroup& pg = ProcessGroup())`\n    `: m_process_group(pg), m_distribution(parallel::block(pg, 0)) {} //fun():使用初始化列表进行初始`\n\n构造函数为`compressed_sparse_row_graph()`在（）里面申明pg，然后在：后面使用pg来对`m_process_group`和`m_distribution()`进行初始化。\n\n## const 引用形参\n\n使用const来修饰引用参数，无法通过修改形参来改变实参。\n\n`const int &r = a`  无法通过r这个引用去修改a的值。 \n\n## STL容器\n\n### 容器：\n\n即是数据结构，类似于Python的pandas的DataFrame等。Python自带的dict，list、tuple等。数据结构不止是简单的array。\n\n### 顺序容器\n\n- vector   后部插入/删除，直接访问 \n- deque  前/后部插入/删除，直接访问 \n- list：双向链表，任意位置插入/删除 \n\n### 关联容器\n\n- set：快速查找，无重复元素\n- multiset：快速查找，可有重复元素\n- map : 一对一映射，无重复元素，基于关键字查找 类似python的dict \n- multmap:一对一映射，可有重复元素，基于关键字查找\n\n## 文件流\n\n头文件：`<fstream>` 包含三个类：\n\n- `ofstream` :文件写操作，从内存写入存储设备 output\n- `ifstream` ： 文件读操作，从存储设备读的内存中 input\n- `fstream`   :读写操作  \n\n## memset()\n\n需要包含的头文件是<string.h>\n\n作用是在一段内存块中填充某个给定的值，它对较大的结构体或数组进行清零操作的一种最快方法。\n\n`memset(struct/array,value,size)` 最后一个参数是填充对象的前size个元素\n\n## str 的find_first_of() 和substr\n\n`find_first_of(char,begin_pos)` 从begin_pos开始寻找第一个char\n\n`string_obj.substr(int begin_pos, int len)` 截取begin_pos开始长度为len的子字符串。\n\n## 指针常量和常量指针\n\n常量指针(const pointer)：\n\n​\t指针是一个常量指向的地址是常量不能变，而地址存储的值可以改变。 \n\n​\t申明` int *const p` \n\n​\t从右往左读，const 限定p对象是一个常量，而常量的具体类型则是是一个指向int类型的指针\n\n​\t从右往左读，遇到p就替换成“p is a ”遇到*就替换成“point to”   读作p is a const pointer point to int \n\n指向常量的指针 (pointer to const )\n\n​\t指针是一个变量，指向的类型是常量.\n\n​\t申明`int const *p` 或者`const int *p`分别读作：p is a point to int const. 与 p is a point to const int. ","source":"_posts/2020-02-05-c++拾遗.md","raw":"---\ntitle: c++拾遗\ndate: 2020-02-05 08:46:58\ncategories: 编程语言\ntags:\n- c++\n- 指针\ncopyright: true\n---\n\n# c++拾遗\n\n## 虚函数和纯虚函数\n\n虚函数：virtual void fun (){...........};定义后了可以实现，并且主要是为了子类会对这个函数进行重写，从而实现多态性。声明一个基类指针对象，但指向子类实例对象，这样如果基类是虚函数，则可以根据指向的子类的不同而实现不同的方法。不使用虚函数的话，将无法使用子类重写过的函数。\n\n纯虚函数：virtual +函数+ =0 。只声明，不会在基类完成定义，需要在子类中定义实现的方法。\n\n<!--more-->\n\n----\n\n## 重写和重载\n\n**重载**：\n\n- 相同的范围（同一个作用域中）比如同一个类中\n- 函数的名字相同\n- 函数的参数不同\n- virtual可有可无\n- 返回值可以不同（不能仅只有返回值不同，否则编译器无法分辨调用的是哪一个函数）\n\n**重写覆盖**：\n\n- 不同范围 （基类与子类）\n- 名字相同\n- 参数相同\n- 基类函数必须有virtual\n\n**重写隐藏**：\n\n- 不同范围\n- 名字相同\n- 参数不同\n- virtual可有可无\n\n\n## 结构体和类的区别\n\n**结构体** ：使用struct声明，可以包含构造函数，常数，字段，方法，属性，索引器，运算符和嵌套类型等，不过，结构是值类型。\n\n区别：类的成员默认是私有的，而结构体的成员则是公有的。\n\n## explicit关键字\n\n`explicit`的作用是用来声明类构造函数是显式调用的，禁止隐式调用。所以只用于修饰单参构造函数。因为无参构造函数和多参构造函数本身就是显式调用的。\n\n隐式转换：`A a=True` ; (原来的的构造函数是`A(bool para){}`)  这样的隐式转换使代码的可读性变差。使用`explicit` 后调用构造函数则必须使用 `A a(True)`这种显式方式来调用。\n\n##构造函数初始化列表\n\n`compressed_sparse_row_graph(const ProcessGroup& pg = ProcessGroup())`\n    `: m_process_group(pg), m_distribution(parallel::block(pg, 0)) {} //fun():使用初始化列表进行初始`\n\n构造函数为`compressed_sparse_row_graph()`在（）里面申明pg，然后在：后面使用pg来对`m_process_group`和`m_distribution()`进行初始化。\n\n## const 引用形参\n\n使用const来修饰引用参数，无法通过修改形参来改变实参。\n\n`const int &r = a`  无法通过r这个引用去修改a的值。 \n\n## STL容器\n\n### 容器：\n\n即是数据结构，类似于Python的pandas的DataFrame等。Python自带的dict，list、tuple等。数据结构不止是简单的array。\n\n### 顺序容器\n\n- vector   后部插入/删除，直接访问 \n- deque  前/后部插入/删除，直接访问 \n- list：双向链表，任意位置插入/删除 \n\n### 关联容器\n\n- set：快速查找，无重复元素\n- multiset：快速查找，可有重复元素\n- map : 一对一映射，无重复元素，基于关键字查找 类似python的dict \n- multmap:一对一映射，可有重复元素，基于关键字查找\n\n## 文件流\n\n头文件：`<fstream>` 包含三个类：\n\n- `ofstream` :文件写操作，从内存写入存储设备 output\n- `ifstream` ： 文件读操作，从存储设备读的内存中 input\n- `fstream`   :读写操作  \n\n## memset()\n\n需要包含的头文件是<string.h>\n\n作用是在一段内存块中填充某个给定的值，它对较大的结构体或数组进行清零操作的一种最快方法。\n\n`memset(struct/array,value,size)` 最后一个参数是填充对象的前size个元素\n\n## str 的find_first_of() 和substr\n\n`find_first_of(char,begin_pos)` 从begin_pos开始寻找第一个char\n\n`string_obj.substr(int begin_pos, int len)` 截取begin_pos开始长度为len的子字符串。\n\n## 指针常量和常量指针\n\n常量指针(const pointer)：\n\n​\t指针是一个常量指向的地址是常量不能变，而地址存储的值可以改变。 \n\n​\t申明` int *const p` \n\n​\t从右往左读，const 限定p对象是一个常量，而常量的具体类型则是是一个指向int类型的指针\n\n​\t从右往左读，遇到p就替换成“p is a ”遇到*就替换成“point to”   读作p is a const pointer point to int \n\n指向常量的指针 (pointer to const )\n\n​\t指针是一个变量，指向的类型是常量.\n\n​\t申明`int const *p` 或者`const int *p`分别读作：p is a point to int const. 与 p is a point to const int. ","slug":"2020-02-05-c++拾遗","published":1,"updated":"2020-02-05T06:49:58.759Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6he13zi002vdstz1xdevs99","content":"<h1 id=\"c-拾遗\"><a href=\"#c-拾遗\" class=\"headerlink\" title=\"c++拾遗\"></a>c++拾遗</h1><h2 id=\"虚函数和纯虚函数\"><a href=\"#虚函数和纯虚函数\" class=\"headerlink\" title=\"虚函数和纯虚函数\"></a>虚函数和纯虚函数</h2><p>虚函数：virtual void fun (){………..};定义后了可以实现，并且主要是为了子类会对这个函数进行重写，从而实现多态性。声明一个基类指针对象，但指向子类实例对象，这样如果基类是虚函数，则可以根据指向的子类的不同而实现不同的方法。不使用虚函数的话，将无法使用子类重写过的函数。</p>\n<p>纯虚函数：virtual +函数+ =0 。只声明，不会在基类完成定义，需要在子类中定义实现的方法。</p>\n<a id=\"more\"></a>\n<hr>\n<h2 id=\"重写和重载\"><a href=\"#重写和重载\" class=\"headerlink\" title=\"重写和重载\"></a>重写和重载</h2><p><strong>重载</strong>：</p>\n<ul>\n<li>相同的范围（同一个作用域中）比如同一个类中</li>\n<li>函数的名字相同</li>\n<li>函数的参数不同</li>\n<li>virtual可有可无</li>\n<li>返回值可以不同（不能仅只有返回值不同，否则编译器无法分辨调用的是哪一个函数）</li>\n</ul>\n<p><strong>重写覆盖</strong>：</p>\n<ul>\n<li>不同范围 （基类与子类）</li>\n<li>名字相同</li>\n<li>参数相同</li>\n<li>基类函数必须有virtual</li>\n</ul>\n<p><strong>重写隐藏</strong>：</p>\n<ul>\n<li>不同范围</li>\n<li>名字相同</li>\n<li>参数不同</li>\n<li>virtual可有可无</li>\n</ul>\n<h2 id=\"结构体和类的区别\"><a href=\"#结构体和类的区别\" class=\"headerlink\" title=\"结构体和类的区别\"></a>结构体和类的区别</h2><p><strong>结构体</strong> ：使用struct声明，可以包含构造函数，常数，字段，方法，属性，索引器，运算符和嵌套类型等，不过，结构是值类型。</p>\n<p>区别：类的成员默认是私有的，而结构体的成员则是公有的。</p>\n<h2 id=\"explicit关键字\"><a href=\"#explicit关键字\" class=\"headerlink\" title=\"explicit关键字\"></a>explicit关键字</h2><p><code>explicit</code>的作用是用来声明类构造函数是显式调用的，禁止隐式调用。所以只用于修饰单参构造函数。因为无参构造函数和多参构造函数本身就是显式调用的。</p>\n<p>隐式转换：<code>A a=True</code> ; (原来的的构造函数是<code>A(bool para){}</code>)  这样的隐式转换使代码的可读性变差。使用<code>explicit</code> 后调用构造函数则必须使用 <code>A a(True)</code>这种显式方式来调用。</p>\n<h2 id=\"构造函数初始化列表\"><a href=\"#构造函数初始化列表\" class=\"headerlink\" title=\"构造函数初始化列表\"></a>构造函数初始化列表</h2><p><code>compressed_sparse_row_graph(const ProcessGroup&amp; pg = ProcessGroup())</code><br>    <code>: m_process_group(pg), m_distribution(parallel::block(pg, 0)) {} //fun():使用初始化列表进行初始</code></p>\n<p>构造函数为<code>compressed_sparse_row_graph()</code>在（）里面申明pg，然后在：后面使用pg来对<code>m_process_group</code>和<code>m_distribution()</code>进行初始化。</p>\n<h2 id=\"const-引用形参\"><a href=\"#const-引用形参\" class=\"headerlink\" title=\"const 引用形参\"></a>const 引用形参</h2><p>使用const来修饰引用参数，无法通过修改形参来改变实参。</p>\n<p><code>const int &amp;r = a</code>  无法通过r这个引用去修改a的值。 </p>\n<h2 id=\"STL容器\"><a href=\"#STL容器\" class=\"headerlink\" title=\"STL容器\"></a>STL容器</h2><h3 id=\"容器：\"><a href=\"#容器：\" class=\"headerlink\" title=\"容器：\"></a>容器：</h3><p>即是数据结构，类似于Python的pandas的DataFrame等。Python自带的dict，list、tuple等。数据结构不止是简单的array。</p>\n<h3 id=\"顺序容器\"><a href=\"#顺序容器\" class=\"headerlink\" title=\"顺序容器\"></a>顺序容器</h3><ul>\n<li>vector   后部插入/删除，直接访问 </li>\n<li>deque  前/后部插入/删除，直接访问 </li>\n<li>list：双向链表，任意位置插入/删除 </li>\n</ul>\n<h3 id=\"关联容器\"><a href=\"#关联容器\" class=\"headerlink\" title=\"关联容器\"></a>关联容器</h3><ul>\n<li>set：快速查找，无重复元素</li>\n<li>multiset：快速查找，可有重复元素</li>\n<li>map : 一对一映射，无重复元素，基于关键字查找 类似python的dict </li>\n<li>multmap:一对一映射，可有重复元素，基于关键字查找</li>\n</ul>\n<h2 id=\"文件流\"><a href=\"#文件流\" class=\"headerlink\" title=\"文件流\"></a>文件流</h2><p>头文件：<code>&lt;fstream&gt;</code> 包含三个类：</p>\n<ul>\n<li><code>ofstream</code> :文件写操作，从内存写入存储设备 output</li>\n<li><code>ifstream</code> ： 文件读操作，从存储设备读的内存中 input</li>\n<li><code>fstream</code>   :读写操作  </li>\n</ul>\n<h2 id=\"memset\"><a href=\"#memset\" class=\"headerlink\" title=\"memset()\"></a>memset()</h2><p>需要包含的头文件是<string.h></string.h></p>\n<p>作用是在一段内存块中填充某个给定的值，它对较大的结构体或数组进行清零操作的一种最快方法。</p>\n<p><code>memset(struct/array,value,size)</code> 最后一个参数是填充对象的前size个元素</p>\n<h2 id=\"str-的find-first-of-和substr\"><a href=\"#str-的find-first-of-和substr\" class=\"headerlink\" title=\"str 的find_first_of() 和substr\"></a>str 的find_first_of() 和substr</h2><p><code>find_first_of(char,begin_pos)</code> 从begin_pos开始寻找第一个char</p>\n<p><code>string_obj.substr(int begin_pos, int len)</code> 截取begin_pos开始长度为len的子字符串。</p>\n<h2 id=\"指针常量和常量指针\"><a href=\"#指针常量和常量指针\" class=\"headerlink\" title=\"指针常量和常量指针\"></a>指针常量和常量指针</h2><p>常量指针(const pointer)：</p>\n<p>​    指针是一个常量指向的地址是常量不能变，而地址存储的值可以改变。 </p>\n<p>​    申明<code>int *const p</code> </p>\n<p>​    从右往左读，const 限定p对象是一个常量，而常量的具体类型则是是一个指向int类型的指针</p>\n<p>​    从右往左读，遇到p就替换成“p is a ”遇到*就替换成“point to”   读作p is a const pointer point to int </p>\n<p>指向常量的指针 (pointer to const )</p>\n<p>​    指针是一个变量，指向的类型是常量.</p>\n<p>​    申明<code>int const *p</code> 或者<code>const int *p</code>分别读作：p is a point to int const. 与 p is a point to const int. </p>\n","site":{"data":{}},"length":1847,"excerpt":"<h1 id=\"c-拾遗\"><a href=\"#c-拾遗\" class=\"headerlink\" title=\"c++拾遗\"></a>c++拾遗</h1><h2 id=\"虚函数和纯虚函数\"><a href=\"#虚函数和纯虚函数\" class=\"headerlink\" title=\"虚函数和纯虚函数\"></a>虚函数和纯虚函数</h2><p>虚函数：virtual void fun (){………..};定义后了可以实现，并且主要是为了子类会对这个函数进行重写，从而实现多态性。声明一个基类指针对象，但指向子类实例对象，这样如果基类是虚函数，则可以根据指向的子类的不同而实现不同的方法。不使用虚函数的话，将无法使用子类重写过的函数。</p>\n<p>纯虚函数：virtual +函数+ =0 。只声明，不会在基类完成定义，需要在子类中定义实现的方法。</p>","more":"<hr>\n<h2 id=\"重写和重载\"><a href=\"#重写和重载\" class=\"headerlink\" title=\"重写和重载\"></a>重写和重载</h2><p><strong>重载</strong>：</p>\n<ul>\n<li>相同的范围（同一个作用域中）比如同一个类中</li>\n<li>函数的名字相同</li>\n<li>函数的参数不同</li>\n<li>virtual可有可无</li>\n<li>返回值可以不同（不能仅只有返回值不同，否则编译器无法分辨调用的是哪一个函数）</li>\n</ul>\n<p><strong>重写覆盖</strong>：</p>\n<ul>\n<li>不同范围 （基类与子类）</li>\n<li>名字相同</li>\n<li>参数相同</li>\n<li>基类函数必须有virtual</li>\n</ul>\n<p><strong>重写隐藏</strong>：</p>\n<ul>\n<li>不同范围</li>\n<li>名字相同</li>\n<li>参数不同</li>\n<li>virtual可有可无</li>\n</ul>\n<h2 id=\"结构体和类的区别\"><a href=\"#结构体和类的区别\" class=\"headerlink\" title=\"结构体和类的区别\"></a>结构体和类的区别</h2><p><strong>结构体</strong> ：使用struct声明，可以包含构造函数，常数，字段，方法，属性，索引器，运算符和嵌套类型等，不过，结构是值类型。</p>\n<p>区别：类的成员默认是私有的，而结构体的成员则是公有的。</p>\n<h2 id=\"explicit关键字\"><a href=\"#explicit关键字\" class=\"headerlink\" title=\"explicit关键字\"></a>explicit关键字</h2><p><code>explicit</code>的作用是用来声明类构造函数是显式调用的，禁止隐式调用。所以只用于修饰单参构造函数。因为无参构造函数和多参构造函数本身就是显式调用的。</p>\n<p>隐式转换：<code>A a=True</code> ; (原来的的构造函数是<code>A(bool para){}</code>)  这样的隐式转换使代码的可读性变差。使用<code>explicit</code> 后调用构造函数则必须使用 <code>A a(True)</code>这种显式方式来调用。</p>\n<h2 id=\"构造函数初始化列表\"><a href=\"#构造函数初始化列表\" class=\"headerlink\" title=\"构造函数初始化列表\"></a>构造函数初始化列表</h2><p><code>compressed_sparse_row_graph(const ProcessGroup&amp; pg = ProcessGroup())</code><br>    <code>: m_process_group(pg), m_distribution(parallel::block(pg, 0)) {} //fun():使用初始化列表进行初始</code></p>\n<p>构造函数为<code>compressed_sparse_row_graph()</code>在（）里面申明pg，然后在：后面使用pg来对<code>m_process_group</code>和<code>m_distribution()</code>进行初始化。</p>\n<h2 id=\"const-引用形参\"><a href=\"#const-引用形参\" class=\"headerlink\" title=\"const 引用形参\"></a>const 引用形参</h2><p>使用const来修饰引用参数，无法通过修改形参来改变实参。</p>\n<p><code>const int &amp;r = a</code>  无法通过r这个引用去修改a的值。 </p>\n<h2 id=\"STL容器\"><a href=\"#STL容器\" class=\"headerlink\" title=\"STL容器\"></a>STL容器</h2><h3 id=\"容器：\"><a href=\"#容器：\" class=\"headerlink\" title=\"容器：\"></a>容器：</h3><p>即是数据结构，类似于Python的pandas的DataFrame等。Python自带的dict，list、tuple等。数据结构不止是简单的array。</p>\n<h3 id=\"顺序容器\"><a href=\"#顺序容器\" class=\"headerlink\" title=\"顺序容器\"></a>顺序容器</h3><ul>\n<li>vector   后部插入/删除，直接访问 </li>\n<li>deque  前/后部插入/删除，直接访问 </li>\n<li>list：双向链表，任意位置插入/删除 </li>\n</ul>\n<h3 id=\"关联容器\"><a href=\"#关联容器\" class=\"headerlink\" title=\"关联容器\"></a>关联容器</h3><ul>\n<li>set：快速查找，无重复元素</li>\n<li>multiset：快速查找，可有重复元素</li>\n<li>map : 一对一映射，无重复元素，基于关键字查找 类似python的dict </li>\n<li>multmap:一对一映射，可有重复元素，基于关键字查找</li>\n</ul>\n<h2 id=\"文件流\"><a href=\"#文件流\" class=\"headerlink\" title=\"文件流\"></a>文件流</h2><p>头文件：<code>&lt;fstream&gt;</code> 包含三个类：</p>\n<ul>\n<li><code>ofstream</code> :文件写操作，从内存写入存储设备 output</li>\n<li><code>ifstream</code> ： 文件读操作，从存储设备读的内存中 input</li>\n<li><code>fstream</code>   :读写操作  </li>\n</ul>\n<h2 id=\"memset\"><a href=\"#memset\" class=\"headerlink\" title=\"memset()\"></a>memset()</h2><p>需要包含的头文件是<string.h></string.h></p>\n<p>作用是在一段内存块中填充某个给定的值，它对较大的结构体或数组进行清零操作的一种最快方法。</p>\n<p><code>memset(struct/array,value,size)</code> 最后一个参数是填充对象的前size个元素</p>\n<h2 id=\"str-的find-first-of-和substr\"><a href=\"#str-的find-first-of-和substr\" class=\"headerlink\" title=\"str 的find_first_of() 和substr\"></a>str 的find_first_of() 和substr</h2><p><code>find_first_of(char,begin_pos)</code> 从begin_pos开始寻找第一个char</p>\n<p><code>string_obj.substr(int begin_pos, int len)</code> 截取begin_pos开始长度为len的子字符串。</p>\n<h2 id=\"指针常量和常量指针\"><a href=\"#指针常量和常量指针\" class=\"headerlink\" title=\"指针常量和常量指针\"></a>指针常量和常量指针</h2><p>常量指针(const pointer)：</p>\n<p>​    指针是一个常量指向的地址是常量不能变，而地址存储的值可以改变。 </p>\n<p>​    申明<code>int *const p</code> </p>\n<p>​    从右往左读，const 限定p对象是一个常量，而常量的具体类型则是是一个指向int类型的指针</p>\n<p>​    从右往左读，遇到p就替换成“p is a ”遇到*就替换成“point to”   读作p is a const pointer point to int </p>\n<p>指向常量的指针 (pointer to const )</p>\n<p>​    指针是一个变量，指向的类型是常量.</p>\n<p>​    申明<code>int const *p</code> 或者<code>const int *p</code>分别读作：p is a point to int const. 与 p is a point to const int. </p>"},{"title":"leetcode 53 Maximum Subarray","date":"2020-01-29T06:33:50.000Z","copyright":true,"_content":"\n# leetcode 53 Maximum Subarray\n\n[题目来源](<https://leetcode.com/problems/maximum-subarray/> )。题意要求给出一个数组中拥有最大和的连续子数组。\n\n<!--more-->\n\n## 思路\n\n### 枚举\n\n最简单的思路，连续的数组，只要枚举出所有的头和尾的索引对，然后计算这些所有枚举对中的和，然后输出这些和之中的最大和就可以了。\n\n### 复杂度\n\n因为总共有$1+2+3...+n=\\frac{n(n+1)}{2}$ 对，然后每个对需要花费O(n)的时间去求和，因此总共的时间复杂度为$O(n^3)$.\n\n### 分治\n\n观察的输入的数据是数组，数组是典型的可分的数据结构，因此可以考虑使用分治法。首先定义子问题为：长度为n的数组$A[0...n-1]$的连续子数组的最大和。从中间元素$A[\\frac{n}{2}]$划分成左右两个数组，变成左边$L[0...\\frac{n}{2}]$与右边$R[\\frac{n}{2}+1...n-1]$两个子问题。划分成两个自问题后，考虑最大和的连续数组要么在左边数组，要么在右边数组，还有一种情况是连续数组横跨中间的元素，即占了左边的一部分，又占了右边的一部分。这种交叉的情况，就是左边数组必须以中间元素$A[\\frac{n}{2}]$为结尾的最大连续数组和，与右边必须以$A[\\frac{n}{2}+1]$为开始的最大连续数组和。这种交叉的情况只能通过左右两边分别遍历来得到结果。这种情况的分析与493[逆序对的计数](<https://bravey.github.io/2019-10-07-%E9%80%86%E5%BA%8F%E5%AF%B9%E7%9A%84%E8%AE%A1%E6%95%B0.html> )的分支情况很相似。\n\n**Divide** 将输入数组A划分为左边A[0, n/2] 与右边A[n/2+1, n-1]两个数组 \n\n**Conquer** 对左边与右边的子数组递归调用求解\n\n**Merge **遍历求交叉的情况，然后与左边和右边的最大连续和三者比较求得最大值并返回\n\n一个形象的[参考](<https://github.com/azl397985856/leetcode/blob/master/problems/53.maximum-sum-subarray-cn.md> )图示：\n\n![](https://github.com/azl397985856/leetcode/raw/master/assets/problems/53.maximum-sum-subarray-divideconquer.png)\n\n\n\n#### 复杂度\n\n与暴力求解需要遍历$n^2$个索引对相比，分治法只需要遍历递归树的深度$log(n)$次。\n\n将规模为n的问题分解成两个两个n2n2 的子问题问题，同时对两个子问题进行合并的复杂度为O(n)，所以有递推公式： \n$$\nT(n)=\\left\\{\n  \\begin{array}{**lr**}  \n             1 &  n=1\\\\\\\\  \n             2T(\\frac{n}{2})+O(n)\n             \\end{array}  \n\\right.\n$$\n根据主定理有最后的复杂度为O(nlog(n))  \n\n### 动态规划\n\n观察题意，求解的是最大这种求最优的问题，然后问题又可分，因此可以考虑动态规划的方法。动态规划最重要的就是最优子结构的定义。我当时做的思路就是把最优子结构定义为分治的子问题：长度为n的数组的最大和用OPT[n-1]表示。然后考虑最后一个末尾元素是否在连续数组中来考虑，考虑状态OPT[n-1]是怎么从OPT[n-2]来转移的。从这个思路就会陷入一种困难的情况，因为去除最后一个元素A[n-1]后，OPT[n-1]与OPT[n-2]状态转移不是max(OPT[n-1],OPT[n-2]+A[n-1])。因为要求连续，所以可能要加上前面其他的元素。比如以[1,-3, 4]来举例，4如果在连续数组中，并不是OPT[1,-3]+4，而是OPT[1,-3]+(-3)+4。\n\n从前面这种思路可以得到一个启发，如果要使用OPT[n-2]+A[n-1]来表示状态的转移，需要限定OPT[n-1]为第n-1个元素必须参与到连续数组中。所以定义最优子结构OPT[n]为：**第n个元素一定参与的连续数组最大和。**这个时候就可以使用max(OPT[n-1],OPT[n-2]+A[n-1])来进行状态转移，这个max(OPT[n-1],OPT[n-2]+A[n-1])的状态转移方程也可以用一个if语句来判断，如果OPT[n-2]为负数就不用加上A[n-1],因为加上一个负数只会使得连续和变小。\n\n根据这个子结构的定义，对于样例[-2 1 -3 4 -1 2 1 -5 4]，其对应的状态数组OPT为：[-2 1 -2 4 3 5 6 1 5]。即对于第2个元素-3，以其结尾的连续数组中，最大和为-2。这个子结构并不是对应问题的原始解，原始解是对应的OPT数组截止目前的最大值。即：maxSum[n-1]=max(OPT[n-1],maxSum[n-1])。\n\n[参考](<https://github.com/azl397985856/leetcode/blob/master/problems/53.maximum-sum-subarray-cn.md> )图示:\n\n![](https://github.com/azl397985856/leetcode/raw/master/assets/problems/53.maximum-sum-subarray-dp.png)\n\n#### 复杂度\n\n因为只需要遍历一遍就可以把OPT数组给填充好，所有时间复杂度为O(n)，因为每次状态转移只依赖于前面一个状态，所以可以只使用O(1)的空间。\n\n## 代码\n\n源码文件在[github](<https://github.com/BraveY/Coding/blob/master/leetcode/53maximum-subarray.cpp> )上。\n\n### 分治\n\n使用坐标索引来传递。\n\n```cc\n/*\nDC解法\nRuntime: 948 ms, faster than 5.13% of C++ online submissions for Maximum\nSubarray. Memory Usage: 9.6 MB, less than 5.88% of C++ online submissions for\nMaximum Subarray. Maximum Subarray. 时间复杂度O(nlogn),空间复杂度O(1)/O(logn)\n */\nclass Solution3 {\n public:\n  int maxSubArray(vector<int>& nums) {\n    int n = nums.size();\n    if (0 == n) return INT_MIN;\n    if (1 == n) return nums[0];\n    return helper(nums, 0, n - 1);\n  }\n\n private:\n  int helper(vector<int>& nums, int lo, int hi) {\n    if (lo >= hi) return nums[lo];\n    int mid = lo + (hi - lo) / 2;\n    int left = helper(nums, lo, mid);\n    int left_max = nums[mid];\n    int left_sum = 0;\n    for (int i = mid; i >= 0; i--) {\n      left_sum += nums[i];\n      left_max = max(left_sum, left_max);\n    }\n    int right = helper(nums, mid + 1, hi);\n    int right_max = nums[mid + 1];\n    int right_sum = 0;\n    for (int i = mid + 1; i <= hi; i++) {\n      right_sum += nums[i];\n      right_max = max(right_sum, right_max);\n    }\n    int cross = right_max + left_max;\n    int max_all = max(max(left, right), cross);\n    return max_all;\n  }\n};\n```\n\n### 动态规划\n\n第一种使用一维数组\n\n```cc\n/*\nDP解法\nRuntime: 8 ms, faster than 72.96% of C++ online submissions for Maximum\nSubarray. Memory Usage: 9.4 MB, less than 18.63% of C++ online submissions for\nMaximum Subarray.\n时间复杂度O(n),空间复杂度O(n)\n */\nclass Solution1 {\n public:\n  int maxSubArray(vector<int>& nums) {\n    int n = nums.size();\n    int ans = nums[0];\n    std::vector<int> opt(n, INT_MIN);\n    for (int i = 1; i < n; i++) {\n      opt[i] = opt[i - 1] > 0 ? nums[i] + opt[i - 1] : nums[i];\n      ans = max(opt[i], ans);\n    }\n    return ans;\n  }\n\n private:\n};\n```\n\n第二种不使用一维数组\n\n```cc\n/*\nDP解法\nRuntime: 4 ms, faster than 98.48% of C++ online submissions for Maximum\nSubarray. Memory Usage: 9.3 MB, less than 74.51% of C++ online submissions for\nMaximum Subarray. 时间复杂度O(n),空间复杂度O(1)\n */\nclass Solution2 {\n public:\n  int maxSubArray(vector<int>& nums) {\n    int n = nums.size();\n    int ans = nums[0];\n    int opt = nums[0];\n    for (int i = 1; i < n; i++) {\n      opt = opt > 0 ? nums[i] + opt : nums[i];\n      ans = max(opt, ans);\n    }\n    return ans;\n  }\n\n private:\n};\n```\n\n\n\n## 参考\n\nazl397985856的题解以及文中图示的参考[链接](https://github.com/azl397985856/leetcode/blob/master/problems/53.maximum-sum-subarray-cn.md)\n\n[花花leetcode](<https://www.youtube.com/watch?v=7J5rs56JBs8&feature=youtu.be> ) 53题题解 ","source":"_posts/2020-01-29-leetcode-53-Maximum-Subarray.md","raw":"---\ntitle: leetcode 53 Maximum Subarray\ndate: 2020-01-29 14:33:50\ncategories: 题解\ntags:\n- leetcode\n- 动态规划\n- 分治\ncopyright: true\n---\n\n# leetcode 53 Maximum Subarray\n\n[题目来源](<https://leetcode.com/problems/maximum-subarray/> )。题意要求给出一个数组中拥有最大和的连续子数组。\n\n<!--more-->\n\n## 思路\n\n### 枚举\n\n最简单的思路，连续的数组，只要枚举出所有的头和尾的索引对，然后计算这些所有枚举对中的和，然后输出这些和之中的最大和就可以了。\n\n### 复杂度\n\n因为总共有$1+2+3...+n=\\frac{n(n+1)}{2}$ 对，然后每个对需要花费O(n)的时间去求和，因此总共的时间复杂度为$O(n^3)$.\n\n### 分治\n\n观察的输入的数据是数组，数组是典型的可分的数据结构，因此可以考虑使用分治法。首先定义子问题为：长度为n的数组$A[0...n-1]$的连续子数组的最大和。从中间元素$A[\\frac{n}{2}]$划分成左右两个数组，变成左边$L[0...\\frac{n}{2}]$与右边$R[\\frac{n}{2}+1...n-1]$两个子问题。划分成两个自问题后，考虑最大和的连续数组要么在左边数组，要么在右边数组，还有一种情况是连续数组横跨中间的元素，即占了左边的一部分，又占了右边的一部分。这种交叉的情况，就是左边数组必须以中间元素$A[\\frac{n}{2}]$为结尾的最大连续数组和，与右边必须以$A[\\frac{n}{2}+1]$为开始的最大连续数组和。这种交叉的情况只能通过左右两边分别遍历来得到结果。这种情况的分析与493[逆序对的计数](<https://bravey.github.io/2019-10-07-%E9%80%86%E5%BA%8F%E5%AF%B9%E7%9A%84%E8%AE%A1%E6%95%B0.html> )的分支情况很相似。\n\n**Divide** 将输入数组A划分为左边A[0, n/2] 与右边A[n/2+1, n-1]两个数组 \n\n**Conquer** 对左边与右边的子数组递归调用求解\n\n**Merge **遍历求交叉的情况，然后与左边和右边的最大连续和三者比较求得最大值并返回\n\n一个形象的[参考](<https://github.com/azl397985856/leetcode/blob/master/problems/53.maximum-sum-subarray-cn.md> )图示：\n\n![](https://github.com/azl397985856/leetcode/raw/master/assets/problems/53.maximum-sum-subarray-divideconquer.png)\n\n\n\n#### 复杂度\n\n与暴力求解需要遍历$n^2$个索引对相比，分治法只需要遍历递归树的深度$log(n)$次。\n\n将规模为n的问题分解成两个两个n2n2 的子问题问题，同时对两个子问题进行合并的复杂度为O(n)，所以有递推公式： \n$$\nT(n)=\\left\\{\n  \\begin{array}{**lr**}  \n             1 &  n=1\\\\\\\\  \n             2T(\\frac{n}{2})+O(n)\n             \\end{array}  \n\\right.\n$$\n根据主定理有最后的复杂度为O(nlog(n))  \n\n### 动态规划\n\n观察题意，求解的是最大这种求最优的问题，然后问题又可分，因此可以考虑动态规划的方法。动态规划最重要的就是最优子结构的定义。我当时做的思路就是把最优子结构定义为分治的子问题：长度为n的数组的最大和用OPT[n-1]表示。然后考虑最后一个末尾元素是否在连续数组中来考虑，考虑状态OPT[n-1]是怎么从OPT[n-2]来转移的。从这个思路就会陷入一种困难的情况，因为去除最后一个元素A[n-1]后，OPT[n-1]与OPT[n-2]状态转移不是max(OPT[n-1],OPT[n-2]+A[n-1])。因为要求连续，所以可能要加上前面其他的元素。比如以[1,-3, 4]来举例，4如果在连续数组中，并不是OPT[1,-3]+4，而是OPT[1,-3]+(-3)+4。\n\n从前面这种思路可以得到一个启发，如果要使用OPT[n-2]+A[n-1]来表示状态的转移，需要限定OPT[n-1]为第n-1个元素必须参与到连续数组中。所以定义最优子结构OPT[n]为：**第n个元素一定参与的连续数组最大和。**这个时候就可以使用max(OPT[n-1],OPT[n-2]+A[n-1])来进行状态转移，这个max(OPT[n-1],OPT[n-2]+A[n-1])的状态转移方程也可以用一个if语句来判断，如果OPT[n-2]为负数就不用加上A[n-1],因为加上一个负数只会使得连续和变小。\n\n根据这个子结构的定义，对于样例[-2 1 -3 4 -1 2 1 -5 4]，其对应的状态数组OPT为：[-2 1 -2 4 3 5 6 1 5]。即对于第2个元素-3，以其结尾的连续数组中，最大和为-2。这个子结构并不是对应问题的原始解，原始解是对应的OPT数组截止目前的最大值。即：maxSum[n-1]=max(OPT[n-1],maxSum[n-1])。\n\n[参考](<https://github.com/azl397985856/leetcode/blob/master/problems/53.maximum-sum-subarray-cn.md> )图示:\n\n![](https://github.com/azl397985856/leetcode/raw/master/assets/problems/53.maximum-sum-subarray-dp.png)\n\n#### 复杂度\n\n因为只需要遍历一遍就可以把OPT数组给填充好，所有时间复杂度为O(n)，因为每次状态转移只依赖于前面一个状态，所以可以只使用O(1)的空间。\n\n## 代码\n\n源码文件在[github](<https://github.com/BraveY/Coding/blob/master/leetcode/53maximum-subarray.cpp> )上。\n\n### 分治\n\n使用坐标索引来传递。\n\n```cc\n/*\nDC解法\nRuntime: 948 ms, faster than 5.13% of C++ online submissions for Maximum\nSubarray. Memory Usage: 9.6 MB, less than 5.88% of C++ online submissions for\nMaximum Subarray. Maximum Subarray. 时间复杂度O(nlogn),空间复杂度O(1)/O(logn)\n */\nclass Solution3 {\n public:\n  int maxSubArray(vector<int>& nums) {\n    int n = nums.size();\n    if (0 == n) return INT_MIN;\n    if (1 == n) return nums[0];\n    return helper(nums, 0, n - 1);\n  }\n\n private:\n  int helper(vector<int>& nums, int lo, int hi) {\n    if (lo >= hi) return nums[lo];\n    int mid = lo + (hi - lo) / 2;\n    int left = helper(nums, lo, mid);\n    int left_max = nums[mid];\n    int left_sum = 0;\n    for (int i = mid; i >= 0; i--) {\n      left_sum += nums[i];\n      left_max = max(left_sum, left_max);\n    }\n    int right = helper(nums, mid + 1, hi);\n    int right_max = nums[mid + 1];\n    int right_sum = 0;\n    for (int i = mid + 1; i <= hi; i++) {\n      right_sum += nums[i];\n      right_max = max(right_sum, right_max);\n    }\n    int cross = right_max + left_max;\n    int max_all = max(max(left, right), cross);\n    return max_all;\n  }\n};\n```\n\n### 动态规划\n\n第一种使用一维数组\n\n```cc\n/*\nDP解法\nRuntime: 8 ms, faster than 72.96% of C++ online submissions for Maximum\nSubarray. Memory Usage: 9.4 MB, less than 18.63% of C++ online submissions for\nMaximum Subarray.\n时间复杂度O(n),空间复杂度O(n)\n */\nclass Solution1 {\n public:\n  int maxSubArray(vector<int>& nums) {\n    int n = nums.size();\n    int ans = nums[0];\n    std::vector<int> opt(n, INT_MIN);\n    for (int i = 1; i < n; i++) {\n      opt[i] = opt[i - 1] > 0 ? nums[i] + opt[i - 1] : nums[i];\n      ans = max(opt[i], ans);\n    }\n    return ans;\n  }\n\n private:\n};\n```\n\n第二种不使用一维数组\n\n```cc\n/*\nDP解法\nRuntime: 4 ms, faster than 98.48% of C++ online submissions for Maximum\nSubarray. Memory Usage: 9.3 MB, less than 74.51% of C++ online submissions for\nMaximum Subarray. 时间复杂度O(n),空间复杂度O(1)\n */\nclass Solution2 {\n public:\n  int maxSubArray(vector<int>& nums) {\n    int n = nums.size();\n    int ans = nums[0];\n    int opt = nums[0];\n    for (int i = 1; i < n; i++) {\n      opt = opt > 0 ? nums[i] + opt : nums[i];\n      ans = max(opt, ans);\n    }\n    return ans;\n  }\n\n private:\n};\n```\n\n\n\n## 参考\n\nazl397985856的题解以及文中图示的参考[链接](https://github.com/azl397985856/leetcode/blob/master/problems/53.maximum-sum-subarray-cn.md)\n\n[花花leetcode](<https://www.youtube.com/watch?v=7J5rs56JBs8&feature=youtu.be> ) 53题题解 ","slug":"2020-01-29-leetcode-53-Maximum-Subarray","published":1,"updated":"2020-02-07T14:03:01.482Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6he13zj002ydstzzqptt46d","content":"<h1 id=\"leetcode-53-Maximum-Subarray\"><a href=\"#leetcode-53-Maximum-Subarray\" class=\"headerlink\" title=\"leetcode 53 Maximum Subarray\"></a>leetcode 53 Maximum Subarray</h1><p><a href=\"https://leetcode.com/problems/maximum-subarray/\" target=\"_blank\" rel=\"noopener\">题目来源</a>。题意要求给出一个数组中拥有最大和的连续子数组。</p>\n<a id=\"more\"></a>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><h3 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h3><p>最简单的思路，连续的数组，只要枚举出所有的头和尾的索引对，然后计算这些所有枚举对中的和，然后输出这些和之中的最大和就可以了。</p>\n<h3 id=\"复杂度\"><a href=\"#复杂度\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h3><p>因为总共有$1+2+3…+n=\\frac{n(n+1)}{2}$ 对，然后每个对需要花费O(n)的时间去求和，因此总共的时间复杂度为$O(n^3)$.</p>\n<h3 id=\"分治\"><a href=\"#分治\" class=\"headerlink\" title=\"分治\"></a>分治</h3><p>观察的输入的数据是数组，数组是典型的可分的数据结构，因此可以考虑使用分治法。首先定义子问题为：长度为n的数组$A[0…n-1]$的连续子数组的最大和。从中间元素$A[\\frac{n}{2}]$划分成左右两个数组，变成左边$L[0…\\frac{n}{2}]$与右边$R[\\frac{n}{2}+1…n-1]$两个子问题。划分成两个自问题后，考虑最大和的连续数组要么在左边数组，要么在右边数组，还有一种情况是连续数组横跨中间的元素，即占了左边的一部分，又占了右边的一部分。这种交叉的情况，就是左边数组必须以中间元素$A[\\frac{n}{2}]$为结尾的最大连续数组和，与右边必须以$A[\\frac{n}{2}+1]$为开始的最大连续数组和。这种交叉的情况只能通过左右两边分别遍历来得到结果。这种情况的分析与493<a href=\"https://bravey.github.io/2019-10-07-%E9%80%86%E5%BA%8F%E5%AF%B9%E7%9A%84%E8%AE%A1%E6%95%B0.html\">逆序对的计数</a>的分支情况很相似。</p>\n<p><strong>Divide</strong> 将输入数组A划分为左边A[0, n/2] 与右边A[n/2+1, n-1]两个数组 </p>\n<p><strong>Conquer</strong> 对左边与右边的子数组递归调用求解</p>\n<p><strong>Merge </strong>遍历求交叉的情况，然后与左边和右边的最大连续和三者比较求得最大值并返回</p>\n<p>一个形象的<a href=\"https://github.com/azl397985856/leetcode/blob/master/problems/53.maximum-sum-subarray-cn.md\" target=\"_blank\" rel=\"noopener\">参考</a>图示：</p>\n<p><img src=\"https://github.com/azl397985856/leetcode/raw/master/assets/problems/53.maximum-sum-subarray-divideconquer.png\" alt=\"\"></p>\n<h4 id=\"复杂度-1\"><a href=\"#复杂度-1\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h4><p>与暴力求解需要遍历$n^2$个索引对相比，分治法只需要遍历递归树的深度$log(n)$次。</p>\n<p>将规模为n的问题分解成两个两个n2n2 的子问题问题，同时对两个子问题进行合并的复杂度为O(n)，所以有递推公式： </p>\n<script type=\"math/tex; mode=display\">\nT(n)=\\left\\{\n  \\begin{array}{**lr**}  \n             1 &  n=1\\\\\\\\  \n             2T(\\frac{n}{2})+O(n)\n             \\end{array}  \n\\right.</script><p>根据主定理有最后的复杂度为O(nlog(n))  </p>\n<h3 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h3><p>观察题意，求解的是最大这种求最优的问题，然后问题又可分，因此可以考虑动态规划的方法。动态规划最重要的就是最优子结构的定义。我当时做的思路就是把最优子结构定义为分治的子问题：长度为n的数组的最大和用OPT[n-1]表示。然后考虑最后一个末尾元素是否在连续数组中来考虑，考虑状态OPT[n-1]是怎么从OPT[n-2]来转移的。从这个思路就会陷入一种困难的情况，因为去除最后一个元素A[n-1]后，OPT[n-1]与OPT[n-2]状态转移不是max(OPT[n-1],OPT[n-2]+A[n-1])。因为要求连续，所以可能要加上前面其他的元素。比如以[1,-3, 4]来举例，4如果在连续数组中，并不是OPT[1,-3]+4，而是OPT[1,-3]+(-3)+4。</p>\n<p>从前面这种思路可以得到一个启发，如果要使用OPT[n-2]+A[n-1]来表示状态的转移，需要限定OPT[n-1]为第n-1个元素必须参与到连续数组中。所以定义最优子结构OPT[n]为：<strong>第n个元素一定参与的连续数组最大和。</strong>这个时候就可以使用max(OPT[n-1],OPT[n-2]+A[n-1])来进行状态转移，这个max(OPT[n-1],OPT[n-2]+A[n-1])的状态转移方程也可以用一个if语句来判断，如果OPT[n-2]为负数就不用加上A[n-1],因为加上一个负数只会使得连续和变小。</p>\n<p>根据这个子结构的定义，对于样例[-2 1 -3 4 -1 2 1 -5 4]，其对应的状态数组OPT为：[-2 1 -2 4 3 5 6 1 5]。即对于第2个元素-3，以其结尾的连续数组中，最大和为-2。这个子结构并不是对应问题的原始解，原始解是对应的OPT数组截止目前的最大值。即：maxSum[n-1]=max(OPT[n-1],maxSum[n-1])。</p>\n<p><a href=\"https://github.com/azl397985856/leetcode/blob/master/problems/53.maximum-sum-subarray-cn.md\" target=\"_blank\" rel=\"noopener\">参考</a>图示:</p>\n<p><img src=\"https://github.com/azl397985856/leetcode/raw/master/assets/problems/53.maximum-sum-subarray-dp.png\" alt=\"\"></p>\n<h4 id=\"复杂度-2\"><a href=\"#复杂度-2\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h4><p>因为只需要遍历一遍就可以把OPT数组给填充好，所有时间复杂度为O(n)，因为每次状态转移只依赖于前面一个状态，所以可以只使用O(1)的空间。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>源码文件在<a href=\"https://github.com/BraveY/Coding/blob/master/leetcode/53maximum-subarray.cpp\" target=\"_blank\" rel=\"noopener\">github</a>上。</p>\n<h3 id=\"分治-1\"><a href=\"#分治-1\" class=\"headerlink\" title=\"分治\"></a>分治</h3><p>使用坐标索引来传递。</p>\n<figure class=\"highlight cc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">DC解法</span></span><br><span class=\"line\"><span class=\"comment\">Runtime: 948 ms, faster than 5.13% of C++ online submissions for Maximum</span></span><br><span class=\"line\"><span class=\"comment\">Subarray. Memory Usage: 9.6 MB, less than 5.88% of C++ online submissions for</span></span><br><span class=\"line\"><span class=\"comment\">Maximum Subarray. Maximum Subarray. 时间复杂度O(nlogn),空间复杂度O(1)/O(logn)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution3</span> &#123;</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxSubArray</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = nums.size();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"number\">0</span> == n) <span class=\"keyword\">return</span> INT_MIN;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"number\">1</span> == n) <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> helper(nums, <span class=\"number\">0</span>, n - <span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">private</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">helper</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lo &gt;= hi) <span class=\"keyword\">return</span> nums[lo];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = lo + (hi - lo) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> left = helper(nums, lo, mid);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> left_max = nums[mid];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> left_sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = mid; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">      left_sum += nums[i];</span><br><span class=\"line\">      left_max = max(left_sum, left_max);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> right = helper(nums, mid + <span class=\"number\">1</span>, hi);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> right_max = nums[mid + <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> right_sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = mid + <span class=\"number\">1</span>; i &lt;= hi; i++) &#123;</span><br><span class=\"line\">      right_sum += nums[i];</span><br><span class=\"line\">      right_max = max(right_sum, right_max);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cross = right_max + left_max;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> max_all = max(max(left, right), cross);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max_all;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"动态规划-1\"><a href=\"#动态规划-1\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h3><p>第一种使用一维数组</p>\n<figure class=\"highlight cc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">DP解法</span></span><br><span class=\"line\"><span class=\"comment\">Runtime: 8 ms, faster than 72.96% of C++ online submissions for Maximum</span></span><br><span class=\"line\"><span class=\"comment\">Subarray. Memory Usage: 9.4 MB, less than 18.63% of C++ online submissions for</span></span><br><span class=\"line\"><span class=\"comment\">Maximum Subarray.</span></span><br><span class=\"line\"><span class=\"comment\">时间复杂度O(n),空间复杂度O(n)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution1</span> &#123;</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxSubArray</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = nums.size();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; opt(n, INT_MIN);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">      opt[i] = opt[i - <span class=\"number\">1</span>] &gt; <span class=\"number\">0</span> ? nums[i] + opt[i - <span class=\"number\">1</span>] : nums[i];</span><br><span class=\"line\">      ans = max(opt[i], ans);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">private</span>:</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>第二种不使用一维数组</p>\n<figure class=\"highlight cc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">DP解法</span></span><br><span class=\"line\"><span class=\"comment\">Runtime: 4 ms, faster than 98.48% of C++ online submissions for Maximum</span></span><br><span class=\"line\"><span class=\"comment\">Subarray. Memory Usage: 9.3 MB, less than 74.51% of C++ online submissions for</span></span><br><span class=\"line\"><span class=\"comment\">Maximum Subarray. 时间复杂度O(n),空间复杂度O(1)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution2</span> &#123;</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxSubArray</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = nums.size();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> opt = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">      opt = opt &gt; <span class=\"number\">0</span> ? nums[i] + opt : nums[i];</span><br><span class=\"line\">      ans = max(opt, ans);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">private</span>:</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>azl397985856的题解以及文中图示的参考<a href=\"https://github.com/azl397985856/leetcode/blob/master/problems/53.maximum-sum-subarray-cn.md\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n<p><a href=\"https://www.youtube.com/watch?v=7J5rs56JBs8&amp;feature=youtu.be\" target=\"_blank\" rel=\"noopener\">花花leetcode</a> 53题题解 </p>\n","site":{"data":{}},"length":3684,"excerpt":"<h1 id=\"leetcode-53-Maximum-Subarray\"><a href=\"#leetcode-53-Maximum-Subarray\" class=\"headerlink\" title=\"leetcode 53 Maximum Subarray\"></a>leetcode 53 Maximum Subarray</h1><p><a href=\"https://leetcode.com/problems/maximum-subarray/\" target=\"_blank\" rel=\"noopener\">题目来源</a>。题意要求给出一个数组中拥有最大和的连续子数组。</p>","more":"<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><h3 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h3><p>最简单的思路，连续的数组，只要枚举出所有的头和尾的索引对，然后计算这些所有枚举对中的和，然后输出这些和之中的最大和就可以了。</p>\n<h3 id=\"复杂度\"><a href=\"#复杂度\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h3><p>因为总共有$1+2+3…+n=\\frac{n(n+1)}{2}$ 对，然后每个对需要花费O(n)的时间去求和，因此总共的时间复杂度为$O(n^3)$.</p>\n<h3 id=\"分治\"><a href=\"#分治\" class=\"headerlink\" title=\"分治\"></a>分治</h3><p>观察的输入的数据是数组，数组是典型的可分的数据结构，因此可以考虑使用分治法。首先定义子问题为：长度为n的数组$A[0…n-1]$的连续子数组的最大和。从中间元素$A[\\frac{n}{2}]$划分成左右两个数组，变成左边$L[0…\\frac{n}{2}]$与右边$R[\\frac{n}{2}+1…n-1]$两个子问题。划分成两个自问题后，考虑最大和的连续数组要么在左边数组，要么在右边数组，还有一种情况是连续数组横跨中间的元素，即占了左边的一部分，又占了右边的一部分。这种交叉的情况，就是左边数组必须以中间元素$A[\\frac{n}{2}]$为结尾的最大连续数组和，与右边必须以$A[\\frac{n}{2}+1]$为开始的最大连续数组和。这种交叉的情况只能通过左右两边分别遍历来得到结果。这种情况的分析与493<a href=\"https://bravey.github.io/2019-10-07-%E9%80%86%E5%BA%8F%E5%AF%B9%E7%9A%84%E8%AE%A1%E6%95%B0.html\">逆序对的计数</a>的分支情况很相似。</p>\n<p><strong>Divide</strong> 将输入数组A划分为左边A[0, n/2] 与右边A[n/2+1, n-1]两个数组 </p>\n<p><strong>Conquer</strong> 对左边与右边的子数组递归调用求解</p>\n<p><strong>Merge </strong>遍历求交叉的情况，然后与左边和右边的最大连续和三者比较求得最大值并返回</p>\n<p>一个形象的<a href=\"https://github.com/azl397985856/leetcode/blob/master/problems/53.maximum-sum-subarray-cn.md\" target=\"_blank\" rel=\"noopener\">参考</a>图示：</p>\n<p><img src=\"https://github.com/azl397985856/leetcode/raw/master/assets/problems/53.maximum-sum-subarray-divideconquer.png\" alt=\"\"></p>\n<h4 id=\"复杂度-1\"><a href=\"#复杂度-1\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h4><p>与暴力求解需要遍历$n^2$个索引对相比，分治法只需要遍历递归树的深度$log(n)$次。</p>\n<p>将规模为n的问题分解成两个两个n2n2 的子问题问题，同时对两个子问题进行合并的复杂度为O(n)，所以有递推公式： </p>\n<script type=\"math/tex; mode=display\">\nT(n)=\\left\\{\n  \\begin{array}{**lr**}  \n             1 &  n=1\\\\\\\\  \n             2T(\\frac{n}{2})+O(n)\n             \\end{array}  \n\\right.</script><p>根据主定理有最后的复杂度为O(nlog(n))  </p>\n<h3 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h3><p>观察题意，求解的是最大这种求最优的问题，然后问题又可分，因此可以考虑动态规划的方法。动态规划最重要的就是最优子结构的定义。我当时做的思路就是把最优子结构定义为分治的子问题：长度为n的数组的最大和用OPT[n-1]表示。然后考虑最后一个末尾元素是否在连续数组中来考虑，考虑状态OPT[n-1]是怎么从OPT[n-2]来转移的。从这个思路就会陷入一种困难的情况，因为去除最后一个元素A[n-1]后，OPT[n-1]与OPT[n-2]状态转移不是max(OPT[n-1],OPT[n-2]+A[n-1])。因为要求连续，所以可能要加上前面其他的元素。比如以[1,-3, 4]来举例，4如果在连续数组中，并不是OPT[1,-3]+4，而是OPT[1,-3]+(-3)+4。</p>\n<p>从前面这种思路可以得到一个启发，如果要使用OPT[n-2]+A[n-1]来表示状态的转移，需要限定OPT[n-1]为第n-1个元素必须参与到连续数组中。所以定义最优子结构OPT[n]为：<strong>第n个元素一定参与的连续数组最大和。</strong>这个时候就可以使用max(OPT[n-1],OPT[n-2]+A[n-1])来进行状态转移，这个max(OPT[n-1],OPT[n-2]+A[n-1])的状态转移方程也可以用一个if语句来判断，如果OPT[n-2]为负数就不用加上A[n-1],因为加上一个负数只会使得连续和变小。</p>\n<p>根据这个子结构的定义，对于样例[-2 1 -3 4 -1 2 1 -5 4]，其对应的状态数组OPT为：[-2 1 -2 4 3 5 6 1 5]。即对于第2个元素-3，以其结尾的连续数组中，最大和为-2。这个子结构并不是对应问题的原始解，原始解是对应的OPT数组截止目前的最大值。即：maxSum[n-1]=max(OPT[n-1],maxSum[n-1])。</p>\n<p><a href=\"https://github.com/azl397985856/leetcode/blob/master/problems/53.maximum-sum-subarray-cn.md\" target=\"_blank\" rel=\"noopener\">参考</a>图示:</p>\n<p><img src=\"https://github.com/azl397985856/leetcode/raw/master/assets/problems/53.maximum-sum-subarray-dp.png\" alt=\"\"></p>\n<h4 id=\"复杂度-2\"><a href=\"#复杂度-2\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h4><p>因为只需要遍历一遍就可以把OPT数组给填充好，所有时间复杂度为O(n)，因为每次状态转移只依赖于前面一个状态，所以可以只使用O(1)的空间。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>源码文件在<a href=\"https://github.com/BraveY/Coding/blob/master/leetcode/53maximum-subarray.cpp\" target=\"_blank\" rel=\"noopener\">github</a>上。</p>\n<h3 id=\"分治-1\"><a href=\"#分治-1\" class=\"headerlink\" title=\"分治\"></a>分治</h3><p>使用坐标索引来传递。</p>\n<figure class=\"highlight cc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">DC解法</span></span><br><span class=\"line\"><span class=\"comment\">Runtime: 948 ms, faster than 5.13% of C++ online submissions for Maximum</span></span><br><span class=\"line\"><span class=\"comment\">Subarray. Memory Usage: 9.6 MB, less than 5.88% of C++ online submissions for</span></span><br><span class=\"line\"><span class=\"comment\">Maximum Subarray. Maximum Subarray. 时间复杂度O(nlogn),空间复杂度O(1)/O(logn)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution3</span> &#123;</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxSubArray</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = nums.size();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"number\">0</span> == n) <span class=\"keyword\">return</span> INT_MIN;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"number\">1</span> == n) <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> helper(nums, <span class=\"number\">0</span>, n - <span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">private</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">helper</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lo &gt;= hi) <span class=\"keyword\">return</span> nums[lo];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = lo + (hi - lo) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> left = helper(nums, lo, mid);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> left_max = nums[mid];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> left_sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = mid; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">      left_sum += nums[i];</span><br><span class=\"line\">      left_max = max(left_sum, left_max);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> right = helper(nums, mid + <span class=\"number\">1</span>, hi);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> right_max = nums[mid + <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> right_sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = mid + <span class=\"number\">1</span>; i &lt;= hi; i++) &#123;</span><br><span class=\"line\">      right_sum += nums[i];</span><br><span class=\"line\">      right_max = max(right_sum, right_max);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cross = right_max + left_max;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> max_all = max(max(left, right), cross);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max_all;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"动态规划-1\"><a href=\"#动态规划-1\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h3><p>第一种使用一维数组</p>\n<figure class=\"highlight cc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">DP解法</span></span><br><span class=\"line\"><span class=\"comment\">Runtime: 8 ms, faster than 72.96% of C++ online submissions for Maximum</span></span><br><span class=\"line\"><span class=\"comment\">Subarray. Memory Usage: 9.4 MB, less than 18.63% of C++ online submissions for</span></span><br><span class=\"line\"><span class=\"comment\">Maximum Subarray.</span></span><br><span class=\"line\"><span class=\"comment\">时间复杂度O(n),空间复杂度O(n)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution1</span> &#123;</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxSubArray</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = nums.size();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; opt(n, INT_MIN);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">      opt[i] = opt[i - <span class=\"number\">1</span>] &gt; <span class=\"number\">0</span> ? nums[i] + opt[i - <span class=\"number\">1</span>] : nums[i];</span><br><span class=\"line\">      ans = max(opt[i], ans);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">private</span>:</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>第二种不使用一维数组</p>\n<figure class=\"highlight cc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">DP解法</span></span><br><span class=\"line\"><span class=\"comment\">Runtime: 4 ms, faster than 98.48% of C++ online submissions for Maximum</span></span><br><span class=\"line\"><span class=\"comment\">Subarray. Memory Usage: 9.3 MB, less than 74.51% of C++ online submissions for</span></span><br><span class=\"line\"><span class=\"comment\">Maximum Subarray. 时间复杂度O(n),空间复杂度O(1)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution2</span> &#123;</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxSubArray</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = nums.size();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> opt = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">      opt = opt &gt; <span class=\"number\">0</span> ? nums[i] + opt : nums[i];</span><br><span class=\"line\">      ans = max(opt, ans);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">private</span>:</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>azl397985856的题解以及文中图示的参考<a href=\"https://github.com/azl397985856/leetcode/blob/master/problems/53.maximum-sum-subarray-cn.md\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n<p><a href=\"https://www.youtube.com/watch?v=7J5rs56JBs8&amp;feature=youtu.be\" target=\"_blank\" rel=\"noopener\">花花leetcode</a> 53题题解 </p>"},{"title":"Linux命令学习之wc","date":"2018-07-09T13:12:11.000Z","copyright":true,"_content":"\n# Linux 命令学习wc命令\n\n## `wc`命令 \n\n<!--more-->\n\n1. 作用：Word Count 功能为统计指定文件中的字节数、字数、行数，并将统计结果显示输出。 \n2. 格式：\n   - `wc [option] filepath`\n3. 参数\n   - `-c` 统计字节数\n   - `-l` 统计行数\n   - `-m` 统计字符数 标志不能与 -c 标志一起使用。 \n   - `-w` 统计字（单词word）数。一个字被定义为由空白、跳格或换行字符分隔的字符串 \n   - `-L`  打印最长行的长度。 \n   - `-help` 显示帮助信息 \n   - `--version` 显示版本信息 \n4. 参考网址：http://www.cnblogs.com/peida/archive/2012/12/18/2822758.html\n\n","source":"_posts/Linux 命令 学习.md","raw":"---\ntitle: Linux命令学习之wc\ndate: 2018-07-9 21:12:11\ncategories: Linux\ntags: \n- Linux\n- command\ncopyright: true\n---\n\n# Linux 命令学习wc命令\n\n## `wc`命令 \n\n<!--more-->\n\n1. 作用：Word Count 功能为统计指定文件中的字节数、字数、行数，并将统计结果显示输出。 \n2. 格式：\n   - `wc [option] filepath`\n3. 参数\n   - `-c` 统计字节数\n   - `-l` 统计行数\n   - `-m` 统计字符数 标志不能与 -c 标志一起使用。 \n   - `-w` 统计字（单词word）数。一个字被定义为由空白、跳格或换行字符分隔的字符串 \n   - `-L`  打印最长行的长度。 \n   - `-help` 显示帮助信息 \n   - `--version` 显示版本信息 \n4. 参考网址：http://www.cnblogs.com/peida/archive/2012/12/18/2822758.html\n\n","slug":"Linux 命令 学习","published":1,"updated":"2019-11-08T13:16:33.020Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6he13zl0032dstzji057qo2","content":"<h1 id=\"Linux-命令学习wc命令\"><a href=\"#Linux-命令学习wc命令\" class=\"headerlink\" title=\"Linux 命令学习wc命令\"></a>Linux 命令学习wc命令</h1><h2 id=\"wc命令\"><a href=\"#wc命令\" class=\"headerlink\" title=\"wc命令\"></a><code>wc</code>命令</h2><a id=\"more\"></a>\n<ol>\n<li>作用：Word Count 功能为统计指定文件中的字节数、字数、行数，并将统计结果显示输出。 </li>\n<li>格式：<ul>\n<li><code>wc [option] filepath</code></li>\n</ul>\n</li>\n<li>参数<ul>\n<li><code>-c</code> 统计字节数</li>\n<li><code>-l</code> 统计行数</li>\n<li><code>-m</code> 统计字符数 标志不能与 -c 标志一起使用。 </li>\n<li><code>-w</code> 统计字（单词word）数。一个字被定义为由空白、跳格或换行字符分隔的字符串 </li>\n<li><code>-L</code>  打印最长行的长度。 </li>\n<li><code>-help</code> 显示帮助信息 </li>\n<li><code>--version</code> 显示版本信息 </li>\n</ul>\n</li>\n<li>参考网址：<a href=\"http://www.cnblogs.com/peida/archive/2012/12/18/2822758.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/peida/archive/2012/12/18/2822758.html</a></li>\n</ol>\n","site":{"data":{}},"length":259,"excerpt":"<h1 id=\"Linux-命令学习wc命令\"><a href=\"#Linux-命令学习wc命令\" class=\"headerlink\" title=\"Linux 命令学习wc命令\"></a>Linux 命令学习wc命令</h1><h2 id=\"wc命令\"><a href=\"#wc命令\" class=\"headerlink\" title=\"wc命令\"></a><code>wc</code>命令</h2>","more":"<ol>\n<li>作用：Word Count 功能为统计指定文件中的字节数、字数、行数，并将统计结果显示输出。 </li>\n<li>格式：<ul>\n<li><code>wc [option] filepath</code></li>\n</ul>\n</li>\n<li>参数<ul>\n<li><code>-c</code> 统计字节数</li>\n<li><code>-l</code> 统计行数</li>\n<li><code>-m</code> 统计字符数 标志不能与 -c 标志一起使用。 </li>\n<li><code>-w</code> 统计字（单词word）数。一个字被定义为由空白、跳格或换行字符分隔的字符串 </li>\n<li><code>-L</code>  打印最长行的长度。 </li>\n<li><code>-help</code> 显示帮助信息 </li>\n<li><code>--version</code> 显示版本信息 </li>\n</ul>\n</li>\n<li>参考网址：<a href=\"http://www.cnblogs.com/peida/archive/2012/12/18/2822758.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/peida/archive/2012/12/18/2822758.html</a></li>\n</ol>"},{"title":"ceph 部署文档","date":"2018-04-17T09:36:03.000Z","copyright":true,"_content":"\n# ceph 部署文档\n\n<!--more-->\n\n------\n\n# 1.配置所有节点\n\n## 创建ceph用户\n\n## 安装配置NTP\n\n1. `systemctl enable ntp`  ubuntu 14.04不可用，感觉已经安装过了，因此跳过。\n\n## 配置hosts文件\n\n`172.16.1.93 object1`\n`172.16.1.94 object2`\n`172.16.1.95 object3`\n`172.16.1.66 object4`\n`172.16.1.92 controller`\n\n------\n\n# 2. 配置ssh服务器\n\n修改ssh的配置文件\n\nHost controller\n        Hostname gd92\n        User cephuser\nHost object1\n        Hostname gd93\n        User cephuser\nHost object2\n        Hostname hw101\n        User cephuser\nHost object3\n        Hostname gd95\n        User cephuser\nHost object4\n        Hostname gd66\n        User cephuser\n\n生成密钥并拷贝到4个osd节点上，无需拷贝到controller节点\n\n------\n\n# 3.安装ceph\n\n主要参考链接：这些链接的操作大都一致，部分的顺序会有变化。\n\nhttps://linux.cn/article-8182-1.html#4_10238\n\nhttps://blog.csdn.net/styshoo/article/details/55471132\n\nhttps://blog.csdn.net/styshoo/article/details/58572816\n\n## 部署监控节点出现的问题\n\n`ceph-deploy mon create-initial`\n\n1. ` ceph-mon --cluster ceph --mkfs -i gd92 --keyring /var/lib/ceph/tmp/ceph-gd92.mon.keyring`\n\n   问题：ceph.conf的配置文件中的`public network=172.16.1.92/24` 掩码前面多打了空格\n\n   修改后重新执行命令，并加上`--overwrite-conf` \n\n2. [info]Running command: ceph --cluster=ceph --admin-daemon /var/run/ceph/ceph-mon.controller.asok mon_status\n\n   `admin_socket: exception getting command descriptions: [Errno 2] No such file or directory`\n\n   似乎是ceph -deploy 的问题，或者是ubuntu14.04的问题。教程是ubuntu16.04的\n\n   此问题非hostname 不对应\n\n   非conf 不同步导致。--overwrtie-conf  无作用。\n\n   解决办法：按照14.04方法重新安装ceph-deploy\n\n## 部署osd节点出现的问题\n\n1. 使用`ceph-deploy disk list ceph-osd1 ceph-osd2 ceph-osd3`检查磁盘可用性时报错，使用`ceph-deploy osd prepare ceph-osd1:/dev/sdb ceph-osd2:/dev/sdb ceph-osd3:/dev/sdb` 在数据盘上面准备时也报错\n   Running command: fdisk -l  File \"/usr/lib/python2.7/distpackages/ceph_deploy/util/decorators.py\", line 69, in newfunc \n   问题：未知\n   解决办法：将osd节点的数据目录放在指定目录，不用整个数据盘\n2. 最后部署后集群状况是health -ok，但是4osds，有3个osd up，一个osd down\n   问题：down掉的节点磁盘有问题。\n   解决办法：先卸载磁盘，重新格式化，挂载，重新激活osd节点\n\n## 部署rgw节点出现的问题\n\n1. 显示rgw进程在工作，但是使用：http://controller:7480 显示拒绝连接。并且新建S3账号，测试时未返回正确结果。\n\n   问题：未知\n\n   尝试方法：重新部署\n\n   解决办法：重新部署后最开始将端口设置为80，发现可以创建s3账号，但是无法正确测试，显示创建bucket出错，查看rgw的log，发现端口被占用，无法打开，后面重新设置端口为7480问题解决，测试均正确。","source":"_posts/ceph部署文档.md","raw":"---\ntitle: ceph 部署文档\ndate: 2018-04-17 17:36:03\ncategories: deploy\ntags: ceph\ncopyright: true\n---\n\n# ceph 部署文档\n\n<!--more-->\n\n------\n\n# 1.配置所有节点\n\n## 创建ceph用户\n\n## 安装配置NTP\n\n1. `systemctl enable ntp`  ubuntu 14.04不可用，感觉已经安装过了，因此跳过。\n\n## 配置hosts文件\n\n`172.16.1.93 object1`\n`172.16.1.94 object2`\n`172.16.1.95 object3`\n`172.16.1.66 object4`\n`172.16.1.92 controller`\n\n------\n\n# 2. 配置ssh服务器\n\n修改ssh的配置文件\n\nHost controller\n        Hostname gd92\n        User cephuser\nHost object1\n        Hostname gd93\n        User cephuser\nHost object2\n        Hostname hw101\n        User cephuser\nHost object3\n        Hostname gd95\n        User cephuser\nHost object4\n        Hostname gd66\n        User cephuser\n\n生成密钥并拷贝到4个osd节点上，无需拷贝到controller节点\n\n------\n\n# 3.安装ceph\n\n主要参考链接：这些链接的操作大都一致，部分的顺序会有变化。\n\nhttps://linux.cn/article-8182-1.html#4_10238\n\nhttps://blog.csdn.net/styshoo/article/details/55471132\n\nhttps://blog.csdn.net/styshoo/article/details/58572816\n\n## 部署监控节点出现的问题\n\n`ceph-deploy mon create-initial`\n\n1. ` ceph-mon --cluster ceph --mkfs -i gd92 --keyring /var/lib/ceph/tmp/ceph-gd92.mon.keyring`\n\n   问题：ceph.conf的配置文件中的`public network=172.16.1.92/24` 掩码前面多打了空格\n\n   修改后重新执行命令，并加上`--overwrite-conf` \n\n2. [info]Running command: ceph --cluster=ceph --admin-daemon /var/run/ceph/ceph-mon.controller.asok mon_status\n\n   `admin_socket: exception getting command descriptions: [Errno 2] No such file or directory`\n\n   似乎是ceph -deploy 的问题，或者是ubuntu14.04的问题。教程是ubuntu16.04的\n\n   此问题非hostname 不对应\n\n   非conf 不同步导致。--overwrtie-conf  无作用。\n\n   解决办法：按照14.04方法重新安装ceph-deploy\n\n## 部署osd节点出现的问题\n\n1. 使用`ceph-deploy disk list ceph-osd1 ceph-osd2 ceph-osd3`检查磁盘可用性时报错，使用`ceph-deploy osd prepare ceph-osd1:/dev/sdb ceph-osd2:/dev/sdb ceph-osd3:/dev/sdb` 在数据盘上面准备时也报错\n   Running command: fdisk -l  File \"/usr/lib/python2.7/distpackages/ceph_deploy/util/decorators.py\", line 69, in newfunc \n   问题：未知\n   解决办法：将osd节点的数据目录放在指定目录，不用整个数据盘\n2. 最后部署后集群状况是health -ok，但是4osds，有3个osd up，一个osd down\n   问题：down掉的节点磁盘有问题。\n   解决办法：先卸载磁盘，重新格式化，挂载，重新激活osd节点\n\n## 部署rgw节点出现的问题\n\n1. 显示rgw进程在工作，但是使用：http://controller:7480 显示拒绝连接。并且新建S3账号，测试时未返回正确结果。\n\n   问题：未知\n\n   尝试方法：重新部署\n\n   解决办法：重新部署后最开始将端口设置为80，发现可以创建s3账号，但是无法正确测试，显示创建bucket出错，查看rgw的log，发现端口被占用，无法打开，后面重新设置端口为7480问题解决，测试均正确。","slug":"ceph部署文档","published":1,"updated":"2019-11-08T13:11:43.727Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6he13zo0036dstzfa8q11kl","content":"<h1 id=\"ceph-部署文档\"><a href=\"#ceph-部署文档\" class=\"headerlink\" title=\"ceph 部署文档\"></a>ceph 部署文档</h1><a id=\"more\"></a>\n<hr>\n<h1 id=\"1-配置所有节点\"><a href=\"#1-配置所有节点\" class=\"headerlink\" title=\"1.配置所有节点\"></a>1.配置所有节点</h1><h2 id=\"创建ceph用户\"><a href=\"#创建ceph用户\" class=\"headerlink\" title=\"创建ceph用户\"></a>创建ceph用户</h2><h2 id=\"安装配置NTP\"><a href=\"#安装配置NTP\" class=\"headerlink\" title=\"安装配置NTP\"></a>安装配置NTP</h2><ol>\n<li><code>systemctl enable ntp</code>  ubuntu 14.04不可用，感觉已经安装过了，因此跳过。</li>\n</ol>\n<h2 id=\"配置hosts文件\"><a href=\"#配置hosts文件\" class=\"headerlink\" title=\"配置hosts文件\"></a>配置hosts文件</h2><p><code>172.16.1.93 object1</code><br><code>172.16.1.94 object2</code><br><code>172.16.1.95 object3</code><br><code>172.16.1.66 object4</code><br><code>172.16.1.92 controller</code></p>\n<hr>\n<h1 id=\"2-配置ssh服务器\"><a href=\"#2-配置ssh服务器\" class=\"headerlink\" title=\"2. 配置ssh服务器\"></a>2. 配置ssh服务器</h1><p>修改ssh的配置文件</p>\n<p>Host controller<br>        Hostname gd92<br>        User cephuser<br>Host object1<br>        Hostname gd93<br>        User cephuser<br>Host object2<br>        Hostname hw101<br>        User cephuser<br>Host object3<br>        Hostname gd95<br>        User cephuser<br>Host object4<br>        Hostname gd66<br>        User cephuser</p>\n<p>生成密钥并拷贝到4个osd节点上，无需拷贝到controller节点</p>\n<hr>\n<h1 id=\"3-安装ceph\"><a href=\"#3-安装ceph\" class=\"headerlink\" title=\"3.安装ceph\"></a>3.安装ceph</h1><p>主要参考链接：这些链接的操作大都一致，部分的顺序会有变化。</p>\n<p><a href=\"https://linux.cn/article-8182-1.html#4_10238\" target=\"_blank\" rel=\"noopener\">https://linux.cn/article-8182-1.html#4_10238</a></p>\n<p><a href=\"https://blog.csdn.net/styshoo/article/details/55471132\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/styshoo/article/details/55471132</a></p>\n<p><a href=\"https://blog.csdn.net/styshoo/article/details/58572816\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/styshoo/article/details/58572816</a></p>\n<h2 id=\"部署监控节点出现的问题\"><a href=\"#部署监控节点出现的问题\" class=\"headerlink\" title=\"部署监控节点出现的问题\"></a>部署监控节点出现的问题</h2><p><code>ceph-deploy mon create-initial</code></p>\n<ol>\n<li><p><code>ceph-mon --cluster ceph --mkfs -i gd92 --keyring /var/lib/ceph/tmp/ceph-gd92.mon.keyring</code></p>\n<p>问题：ceph.conf的配置文件中的<code>public network=172.16.1.92/24</code> 掩码前面多打了空格</p>\n<p>修改后重新执行命令，并加上<code>--overwrite-conf</code> </p>\n</li>\n<li><p>[info]Running command: ceph —cluster=ceph —admin-daemon /var/run/ceph/ceph-mon.controller.asok mon_status</p>\n<p><code>admin_socket: exception getting command descriptions: [Errno 2] No such file or directory</code></p>\n<p>似乎是ceph -deploy 的问题，或者是ubuntu14.04的问题。教程是ubuntu16.04的</p>\n<p>此问题非hostname 不对应</p>\n<p>非conf 不同步导致。—overwrtie-conf  无作用。</p>\n<p>解决办法：按照14.04方法重新安装ceph-deploy</p>\n</li>\n</ol>\n<h2 id=\"部署osd节点出现的问题\"><a href=\"#部署osd节点出现的问题\" class=\"headerlink\" title=\"部署osd节点出现的问题\"></a>部署osd节点出现的问题</h2><ol>\n<li>使用<code>ceph-deploy disk list ceph-osd1 ceph-osd2 ceph-osd3</code>检查磁盘可用性时报错，使用<code>ceph-deploy osd prepare ceph-osd1:/dev/sdb ceph-osd2:/dev/sdb ceph-osd3:/dev/sdb</code> 在数据盘上面准备时也报错<br>Running command: fdisk -l  File “/usr/lib/python2.7/distpackages/ceph_deploy/util/decorators.py”, line 69, in newfunc<br>问题：未知<br>解决办法：将osd节点的数据目录放在指定目录，不用整个数据盘</li>\n<li>最后部署后集群状况是health -ok，但是4osds，有3个osd up，一个osd down<br>问题：down掉的节点磁盘有问题。<br>解决办法：先卸载磁盘，重新格式化，挂载，重新激活osd节点</li>\n</ol>\n<h2 id=\"部署rgw节点出现的问题\"><a href=\"#部署rgw节点出现的问题\" class=\"headerlink\" title=\"部署rgw节点出现的问题\"></a>部署rgw节点出现的问题</h2><ol>\n<li><p>显示rgw进程在工作，但是使用：<a href=\"http://controller:7480\" target=\"_blank\" rel=\"noopener\">http://controller:7480</a> 显示拒绝连接。并且新建S3账号，测试时未返回正确结果。</p>\n<p>问题：未知</p>\n<p>尝试方法：重新部署</p>\n<p>解决办法：重新部署后最开始将端口设置为80，发现可以创建s3账号，但是无法正确测试，显示创建bucket出错，查看rgw的log，发现端口被占用，无法打开，后面重新设置端口为7480问题解决，测试均正确。</p>\n</li>\n</ol>\n","site":{"data":{}},"length":1696,"excerpt":"<h1 id=\"ceph-部署文档\"><a href=\"#ceph-部署文档\" class=\"headerlink\" title=\"ceph 部署文档\"></a>ceph 部署文档</h1>","more":"<hr>\n<h1 id=\"1-配置所有节点\"><a href=\"#1-配置所有节点\" class=\"headerlink\" title=\"1.配置所有节点\"></a>1.配置所有节点</h1><h2 id=\"创建ceph用户\"><a href=\"#创建ceph用户\" class=\"headerlink\" title=\"创建ceph用户\"></a>创建ceph用户</h2><h2 id=\"安装配置NTP\"><a href=\"#安装配置NTP\" class=\"headerlink\" title=\"安装配置NTP\"></a>安装配置NTP</h2><ol>\n<li><code>systemctl enable ntp</code>  ubuntu 14.04不可用，感觉已经安装过了，因此跳过。</li>\n</ol>\n<h2 id=\"配置hosts文件\"><a href=\"#配置hosts文件\" class=\"headerlink\" title=\"配置hosts文件\"></a>配置hosts文件</h2><p><code>172.16.1.93 object1</code><br><code>172.16.1.94 object2</code><br><code>172.16.1.95 object3</code><br><code>172.16.1.66 object4</code><br><code>172.16.1.92 controller</code></p>\n<hr>\n<h1 id=\"2-配置ssh服务器\"><a href=\"#2-配置ssh服务器\" class=\"headerlink\" title=\"2. 配置ssh服务器\"></a>2. 配置ssh服务器</h1><p>修改ssh的配置文件</p>\n<p>Host controller<br>        Hostname gd92<br>        User cephuser<br>Host object1<br>        Hostname gd93<br>        User cephuser<br>Host object2<br>        Hostname hw101<br>        User cephuser<br>Host object3<br>        Hostname gd95<br>        User cephuser<br>Host object4<br>        Hostname gd66<br>        User cephuser</p>\n<p>生成密钥并拷贝到4个osd节点上，无需拷贝到controller节点</p>\n<hr>\n<h1 id=\"3-安装ceph\"><a href=\"#3-安装ceph\" class=\"headerlink\" title=\"3.安装ceph\"></a>3.安装ceph</h1><p>主要参考链接：这些链接的操作大都一致，部分的顺序会有变化。</p>\n<p><a href=\"https://linux.cn/article-8182-1.html#4_10238\" target=\"_blank\" rel=\"noopener\">https://linux.cn/article-8182-1.html#4_10238</a></p>\n<p><a href=\"https://blog.csdn.net/styshoo/article/details/55471132\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/styshoo/article/details/55471132</a></p>\n<p><a href=\"https://blog.csdn.net/styshoo/article/details/58572816\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/styshoo/article/details/58572816</a></p>\n<h2 id=\"部署监控节点出现的问题\"><a href=\"#部署监控节点出现的问题\" class=\"headerlink\" title=\"部署监控节点出现的问题\"></a>部署监控节点出现的问题</h2><p><code>ceph-deploy mon create-initial</code></p>\n<ol>\n<li><p><code>ceph-mon --cluster ceph --mkfs -i gd92 --keyring /var/lib/ceph/tmp/ceph-gd92.mon.keyring</code></p>\n<p>问题：ceph.conf的配置文件中的<code>public network=172.16.1.92/24</code> 掩码前面多打了空格</p>\n<p>修改后重新执行命令，并加上<code>--overwrite-conf</code> </p>\n</li>\n<li><p>[info]Running command: ceph —cluster=ceph —admin-daemon /var/run/ceph/ceph-mon.controller.asok mon_status</p>\n<p><code>admin_socket: exception getting command descriptions: [Errno 2] No such file or directory</code></p>\n<p>似乎是ceph -deploy 的问题，或者是ubuntu14.04的问题。教程是ubuntu16.04的</p>\n<p>此问题非hostname 不对应</p>\n<p>非conf 不同步导致。—overwrtie-conf  无作用。</p>\n<p>解决办法：按照14.04方法重新安装ceph-deploy</p>\n</li>\n</ol>\n<h2 id=\"部署osd节点出现的问题\"><a href=\"#部署osd节点出现的问题\" class=\"headerlink\" title=\"部署osd节点出现的问题\"></a>部署osd节点出现的问题</h2><ol>\n<li>使用<code>ceph-deploy disk list ceph-osd1 ceph-osd2 ceph-osd3</code>检查磁盘可用性时报错，使用<code>ceph-deploy osd prepare ceph-osd1:/dev/sdb ceph-osd2:/dev/sdb ceph-osd3:/dev/sdb</code> 在数据盘上面准备时也报错<br>Running command: fdisk -l  File “/usr/lib/python2.7/distpackages/ceph_deploy/util/decorators.py”, line 69, in newfunc<br>问题：未知<br>解决办法：将osd节点的数据目录放在指定目录，不用整个数据盘</li>\n<li>最后部署后集群状况是health -ok，但是4osds，有3个osd up，一个osd down<br>问题：down掉的节点磁盘有问题。<br>解决办法：先卸载磁盘，重新格式化，挂载，重新激活osd节点</li>\n</ol>\n<h2 id=\"部署rgw节点出现的问题\"><a href=\"#部署rgw节点出现的问题\" class=\"headerlink\" title=\"部署rgw节点出现的问题\"></a>部署rgw节点出现的问题</h2><ol>\n<li><p>显示rgw进程在工作，但是使用：<a href=\"http://controller:7480\" target=\"_blank\" rel=\"noopener\">http://controller:7480</a> 显示拒绝连接。并且新建S3账号，测试时未返回正确结果。</p>\n<p>问题：未知</p>\n<p>尝试方法：重新部署</p>\n<p>解决办法：重新部署后最开始将端口设置为80，发现可以创建s3账号，但是无法正确测试，显示创建bucket出错，查看rgw的log，发现端口被占用，无法打开，后面重新设置端口为7480问题解决，测试均正确。</p>\n</li>\n</ol>"},{"title":"BigdataBench deploy","date":"2018-06-23T08:55:45.000Z","copyright":true,"_content":"\n# Bigdatabench 4.0 MPI版本 安装\n\n<!--more-->\n\n官网上面的指南BigDataBench User Manual有一些错误。\n\n本机环境：\n\n​\tCentos 6.9\n\n​\tgcc (GCC) 4.8.2 20140120 (Red Hat 4.8.2-15)\n\n​\tg++ (GCC) 4.8.2 20140120 (Red Hat 4.8.2-15)\n\n## mpi的安装\n\n这部分网上资料很多，而Manual中有一点错误\n\n1. 需要保证c 编译器 如gcc c++ 编译器 如：g++\n\n2. 基础安装\n\n   1. 从官网下载安装包解压\n\n   - `wget http://www.mpich.org/static/downloads/3.2.1/mpich-3.2.1.tar.gz `  从官网下载安装包\n   - `tar -zxvf mpich-3.2.1.tar.gz `  解压\n   - `cd mpich-3.2.1`\n\n   1. 配置安装目录   本机安装在mpich-install目录下\n\n   - `./configure –prefix=/home/mpich-install 2>&1 | tee c.txt    ` 手册中&被错写为$了 `2>&1 | tee c.txt` 表示将输出的标准出错信息重定向到c.txt中。\n\n   1. build\n\n   - `make 2>&1 | tee m.txt `\n\n   1. 安装\n\n   - `make install 2>&1 | tee mi.txt `\n\n   1. 将安装目录添加到PATH 环境变量中\n\n   - `vim ~/.bashrc`\n   - `export PATH=$PATH:/home/mpich-install/bin` 在最后一行添加\n   - `source ~/.bashrc` 重启生效\n\n3. 检查\n\n   1. 检查路径\n      - `which mpicc` \n      - `which mpic++`\n\n4. 验证 \n\n   在mpich的安装包目录下有提供例子程序运行\n\n   1. `cd mpich-3.2.1/examples`\n   2. `mpicc cpi.c -o cpi` 编译cpi.c程序求pi值\n   3. `mpirun -n 4 ./cpi` 使用4个进程 注意`./`否则报错找不到文件\n\n   如果是集群环境在每个节点将mpich安装在相同的路径然后编辑一个machine_file （里面是各个节点的host）然后`mpirun -f machine_file -n 3 ./cpi` 在集群上并行运行\n\n## boost 安装\n\nboost当前最新版本是：1.67 但是BigdataBench用的是1.43版本推荐安装这个旧版本\n\n1. `wget https://sourceforge.net/projects/boost/files/boost/1.43.0/boost_1_43_0.tar.gz/download` \n\n2. 若下载下来的文件名为：downloads 则使用mv命令重命名在当前文件目录下:\n\n   `mv downloads boost_1_43_0.tar.gz  `  \n\n3. 解压`tar -zxvf boost_1_43_0.tar.gz`  之后`cd boost_1_43_0`\n\n4. `sh bootstrap.sh`  执行这个命令运行脚本后会多出很多配置文件\n\n5. 使用mpi,这一步骤很重要否则后续cmake时会提示找不到：boost_mpi\n\n   1. 对低版本的boost \n\n      1. `which mpic++` 找mpich的目录\n\n      2. `vim tools/build/v2/user-config.jam`\n\n      3. 在最后添加： using mpi:后面是mpich的目录\n\n         `#MPI config`\n\n         `using mpi : /usr/lib64/mpich/bin/mpic++ ;`\n\n   2. 对高版本的boost直接在boost_1_67_0目录下修改project-config.jam即可\n\n6. ` ./bjam` 进行编译\n\n7. `./bjam install` 这一步是必需的但在手册中没有表明。\n\n## BigdataBench的配置\n\n进入BigDataBench的安装根目录：\n\n1. ` vim conf.properties` 添加$JAVA_HOME， $MPI_HOME ，$BigdataBench_HOMEMPI的路径\n2. `sh prepar.sh` \n\n至此安装理论上已经成功。但仍然遇到了其他问题\n\n## Perminsion denied问题\n\n最开始的安装包是从windows下面考过去的结果生成cc的数据后无法运行执行脚本\n\n![](BigdataBench-deploy\\runcc.png)\n\n原因是此时的run_connectedComponents已经不是可执行文件了（不是绿色的）需要`chmod a+x run_connectedComponents`来将文件的权限修改为可执行文件权限（修改后变为绿色）\n\n后面wget下载后解压配置之后直接就是可执行文件！\n\n## ldd 程序 动态链接库缺失\n\n` [root@hw073 ConnectedComponent]# ldd run_connectedComponents`\n`linux-vdso.so.1 =>  (0x00007ffdfc8d4000)`\n`librt.so.1 => /lib64/librt.so.1 (0x0000003156e00000)`\n`libpthread.so.0 => /lib64/libpthread.so.0 (0x0000003156a00000)`\n\n`libboost_serialization-mt.so.1.43.0 => not found`\n`libboost_filesystem-mt.so.1.43.0 => not found`\n`libboost_system-mt.so.1.43.0 => not found`\n`libstdc++.so.6 => /usr/lib64/libstdc++.so.6 (0x0000003162200000)`\n`libm.so.6 => /lib64/libm.so.6 (0x0000003157200000)`\n`libgcc_s.so.1 => /lib64/libgcc_s.so.1 (0x0000003161a00000)`\n`libc.so.6 => /lib64/libc.so.6 (0x0000003156600000)`\n`/lib64/ld-linux-x86-64.so.2 (0x0000003155e00000)`\n\n最开始以为是没有指定LD_LIBRARY_PATH ，因为明明有这个文件的，后面使用find / -name 命令发现还是找不到，仔细一看ldd 的信息，发现上述文件都多了个-mt\n\n解决办法： 在boost安装时的库。本机：`/usr/local/lib` 有着及其相似的3个文件`libboost_filesystem.so.1.43.0` 、`libboost_filesystem.so.1.43.0` ，`libboost_system.so.1.43.0` 均少了个-mt，因此将上述三个文件均拷贝一份命名为上述缺少的动态库文件。\n\n`cd /usr/local/lib` #切换到对应的目录下\n\n`cp libboost_system.so.1.43.0 libboost_system-mt.so.1.43.0 ` #拷贝为对应的文件名","source":"_posts/BigdataBench-deploy.md","raw":"---\ntitle: BigdataBench deploy\ndate: 2018-06-23 16:55:45\ncategories: deploy\ntags: bigdatabench\ncopyright: true\n---\n\n# Bigdatabench 4.0 MPI版本 安装\n\n<!--more-->\n\n官网上面的指南BigDataBench User Manual有一些错误。\n\n本机环境：\n\n​\tCentos 6.9\n\n​\tgcc (GCC) 4.8.2 20140120 (Red Hat 4.8.2-15)\n\n​\tg++ (GCC) 4.8.2 20140120 (Red Hat 4.8.2-15)\n\n## mpi的安装\n\n这部分网上资料很多，而Manual中有一点错误\n\n1. 需要保证c 编译器 如gcc c++ 编译器 如：g++\n\n2. 基础安装\n\n   1. 从官网下载安装包解压\n\n   - `wget http://www.mpich.org/static/downloads/3.2.1/mpich-3.2.1.tar.gz `  从官网下载安装包\n   - `tar -zxvf mpich-3.2.1.tar.gz `  解压\n   - `cd mpich-3.2.1`\n\n   1. 配置安装目录   本机安装在mpich-install目录下\n\n   - `./configure –prefix=/home/mpich-install 2>&1 | tee c.txt    ` 手册中&被错写为$了 `2>&1 | tee c.txt` 表示将输出的标准出错信息重定向到c.txt中。\n\n   1. build\n\n   - `make 2>&1 | tee m.txt `\n\n   1. 安装\n\n   - `make install 2>&1 | tee mi.txt `\n\n   1. 将安装目录添加到PATH 环境变量中\n\n   - `vim ~/.bashrc`\n   - `export PATH=$PATH:/home/mpich-install/bin` 在最后一行添加\n   - `source ~/.bashrc` 重启生效\n\n3. 检查\n\n   1. 检查路径\n      - `which mpicc` \n      - `which mpic++`\n\n4. 验证 \n\n   在mpich的安装包目录下有提供例子程序运行\n\n   1. `cd mpich-3.2.1/examples`\n   2. `mpicc cpi.c -o cpi` 编译cpi.c程序求pi值\n   3. `mpirun -n 4 ./cpi` 使用4个进程 注意`./`否则报错找不到文件\n\n   如果是集群环境在每个节点将mpich安装在相同的路径然后编辑一个machine_file （里面是各个节点的host）然后`mpirun -f machine_file -n 3 ./cpi` 在集群上并行运行\n\n## boost 安装\n\nboost当前最新版本是：1.67 但是BigdataBench用的是1.43版本推荐安装这个旧版本\n\n1. `wget https://sourceforge.net/projects/boost/files/boost/1.43.0/boost_1_43_0.tar.gz/download` \n\n2. 若下载下来的文件名为：downloads 则使用mv命令重命名在当前文件目录下:\n\n   `mv downloads boost_1_43_0.tar.gz  `  \n\n3. 解压`tar -zxvf boost_1_43_0.tar.gz`  之后`cd boost_1_43_0`\n\n4. `sh bootstrap.sh`  执行这个命令运行脚本后会多出很多配置文件\n\n5. 使用mpi,这一步骤很重要否则后续cmake时会提示找不到：boost_mpi\n\n   1. 对低版本的boost \n\n      1. `which mpic++` 找mpich的目录\n\n      2. `vim tools/build/v2/user-config.jam`\n\n      3. 在最后添加： using mpi:后面是mpich的目录\n\n         `#MPI config`\n\n         `using mpi : /usr/lib64/mpich/bin/mpic++ ;`\n\n   2. 对高版本的boost直接在boost_1_67_0目录下修改project-config.jam即可\n\n6. ` ./bjam` 进行编译\n\n7. `./bjam install` 这一步是必需的但在手册中没有表明。\n\n## BigdataBench的配置\n\n进入BigDataBench的安装根目录：\n\n1. ` vim conf.properties` 添加$JAVA_HOME， $MPI_HOME ，$BigdataBench_HOMEMPI的路径\n2. `sh prepar.sh` \n\n至此安装理论上已经成功。但仍然遇到了其他问题\n\n## Perminsion denied问题\n\n最开始的安装包是从windows下面考过去的结果生成cc的数据后无法运行执行脚本\n\n![](BigdataBench-deploy\\runcc.png)\n\n原因是此时的run_connectedComponents已经不是可执行文件了（不是绿色的）需要`chmod a+x run_connectedComponents`来将文件的权限修改为可执行文件权限（修改后变为绿色）\n\n后面wget下载后解压配置之后直接就是可执行文件！\n\n## ldd 程序 动态链接库缺失\n\n` [root@hw073 ConnectedComponent]# ldd run_connectedComponents`\n`linux-vdso.so.1 =>  (0x00007ffdfc8d4000)`\n`librt.so.1 => /lib64/librt.so.1 (0x0000003156e00000)`\n`libpthread.so.0 => /lib64/libpthread.so.0 (0x0000003156a00000)`\n\n`libboost_serialization-mt.so.1.43.0 => not found`\n`libboost_filesystem-mt.so.1.43.0 => not found`\n`libboost_system-mt.so.1.43.0 => not found`\n`libstdc++.so.6 => /usr/lib64/libstdc++.so.6 (0x0000003162200000)`\n`libm.so.6 => /lib64/libm.so.6 (0x0000003157200000)`\n`libgcc_s.so.1 => /lib64/libgcc_s.so.1 (0x0000003161a00000)`\n`libc.so.6 => /lib64/libc.so.6 (0x0000003156600000)`\n`/lib64/ld-linux-x86-64.so.2 (0x0000003155e00000)`\n\n最开始以为是没有指定LD_LIBRARY_PATH ，因为明明有这个文件的，后面使用find / -name 命令发现还是找不到，仔细一看ldd 的信息，发现上述文件都多了个-mt\n\n解决办法： 在boost安装时的库。本机：`/usr/local/lib` 有着及其相似的3个文件`libboost_filesystem.so.1.43.0` 、`libboost_filesystem.so.1.43.0` ，`libboost_system.so.1.43.0` 均少了个-mt，因此将上述三个文件均拷贝一份命名为上述缺少的动态库文件。\n\n`cd /usr/local/lib` #切换到对应的目录下\n\n`cp libboost_system.so.1.43.0 libboost_system-mt.so.1.43.0 ` #拷贝为对应的文件名","slug":"BigdataBench-deploy","published":1,"updated":"2019-11-08T13:11:52.787Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6he13zp0039dstz50e3vlb8","content":"<h1 id=\"Bigdatabench-4-0-MPI版本-安装\"><a href=\"#Bigdatabench-4-0-MPI版本-安装\" class=\"headerlink\" title=\"Bigdatabench 4.0 MPI版本 安装\"></a>Bigdatabench 4.0 MPI版本 安装</h1><a id=\"more\"></a>\n<p>官网上面的指南BigDataBench User Manual有一些错误。</p>\n<p>本机环境：</p>\n<p>​    Centos 6.9</p>\n<p>​    gcc (GCC) 4.8.2 20140120 (Red Hat 4.8.2-15)</p>\n<p>​    g++ (GCC) 4.8.2 20140120 (Red Hat 4.8.2-15)</p>\n<h2 id=\"mpi的安装\"><a href=\"#mpi的安装\" class=\"headerlink\" title=\"mpi的安装\"></a>mpi的安装</h2><p>这部分网上资料很多，而Manual中有一点错误</p>\n<ol>\n<li><p>需要保证c 编译器 如gcc c++ 编译器 如：g++</p>\n</li>\n<li><p>基础安装</p>\n<ol>\n<li>从官网下载安装包解压</li>\n</ol>\n<ul>\n<li><code>wget http://www.mpich.org/static/downloads/3.2.1/mpich-3.2.1.tar.gz</code>  从官网下载安装包</li>\n<li><code>tar -zxvf mpich-3.2.1.tar.gz</code>  解压</li>\n<li><code>cd mpich-3.2.1</code></li>\n</ul>\n<ol>\n<li>配置安装目录   本机安装在mpich-install目录下</li>\n</ol>\n<ul>\n<li><code>./configure –prefix=/home/mpich-install 2&gt;&amp;1 | tee c.txt</code> 手册中&amp;被错写为$了 <code>2&gt;&amp;1 | tee c.txt</code> 表示将输出的标准出错信息重定向到c.txt中。</li>\n</ul>\n<ol>\n<li>build</li>\n</ol>\n<ul>\n<li><code>make 2&gt;&amp;1 | tee m.txt</code></li>\n</ul>\n<ol>\n<li>安装</li>\n</ol>\n<ul>\n<li><code>make install 2&gt;&amp;1 | tee mi.txt</code></li>\n</ul>\n<ol>\n<li>将安装目录添加到PATH 环境变量中</li>\n</ol>\n<ul>\n<li><code>vim ~/.bashrc</code></li>\n<li><code>export PATH=$PATH:/home/mpich-install/bin</code> 在最后一行添加</li>\n<li><code>source ~/.bashrc</code> 重启生效</li>\n</ul>\n</li>\n<li><p>检查</p>\n<ol>\n<li>检查路径<ul>\n<li><code>which mpicc</code> </li>\n<li><code>which mpic++</code></li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>验证 </p>\n<p>在mpich的安装包目录下有提供例子程序运行</p>\n<ol>\n<li><code>cd mpich-3.2.1/examples</code></li>\n<li><code>mpicc cpi.c -o cpi</code> 编译cpi.c程序求pi值</li>\n<li><code>mpirun -n 4 ./cpi</code> 使用4个进程 注意<code>./</code>否则报错找不到文件</li>\n</ol>\n<p>如果是集群环境在每个节点将mpich安装在相同的路径然后编辑一个machine_file （里面是各个节点的host）然后<code>mpirun -f machine_file -n 3 ./cpi</code> 在集群上并行运行</p>\n</li>\n</ol>\n<h2 id=\"boost-安装\"><a href=\"#boost-安装\" class=\"headerlink\" title=\"boost 安装\"></a>boost 安装</h2><p>boost当前最新版本是：1.67 但是BigdataBench用的是1.43版本推荐安装这个旧版本</p>\n<ol>\n<li><p><code>wget https://sourceforge.net/projects/boost/files/boost/1.43.0/boost_1_43_0.tar.gz/download</code> </p>\n</li>\n<li><p>若下载下来的文件名为：downloads 则使用mv命令重命名在当前文件目录下:</p>\n<p><code>mv downloads boost_1_43_0.tar.gz</code>  </p>\n</li>\n<li><p>解压<code>tar -zxvf boost_1_43_0.tar.gz</code>  之后<code>cd boost_1_43_0</code></p>\n</li>\n<li><p><code>sh bootstrap.sh</code>  执行这个命令运行脚本后会多出很多配置文件</p>\n</li>\n<li><p>使用mpi,这一步骤很重要否则后续cmake时会提示找不到：boost_mpi</p>\n<ol>\n<li><p>对低版本的boost </p>\n<ol>\n<li><p><code>which mpic++</code> 找mpich的目录</p>\n</li>\n<li><p><code>vim tools/build/v2/user-config.jam</code></p>\n</li>\n<li><p>在最后添加： using mpi:后面是mpich的目录</p>\n<p><code>#MPI config</code></p>\n<p><code>using mpi : /usr/lib64/mpich/bin/mpic++ ;</code></p>\n</li>\n</ol>\n</li>\n<li><p>对高版本的boost直接在boost_1_67_0目录下修改project-config.jam即可</p>\n</li>\n</ol>\n</li>\n<li><p><code>./bjam</code> 进行编译</p>\n</li>\n<li><p><code>./bjam install</code> 这一步是必需的但在手册中没有表明。</p>\n</li>\n</ol>\n<h2 id=\"BigdataBench的配置\"><a href=\"#BigdataBench的配置\" class=\"headerlink\" title=\"BigdataBench的配置\"></a>BigdataBench的配置</h2><p>进入BigDataBench的安装根目录：</p>\n<ol>\n<li><code>vim conf.properties</code> 添加$JAVA_HOME， $MPI_HOME ，$BigdataBench_HOMEMPI的路径</li>\n<li><code>sh prepar.sh</code> </li>\n</ol>\n<p>至此安装理论上已经成功。但仍然遇到了其他问题</p>\n<h2 id=\"Perminsion-denied问题\"><a href=\"#Perminsion-denied问题\" class=\"headerlink\" title=\"Perminsion denied问题\"></a>Perminsion denied问题</h2><p>最开始的安装包是从windows下面考过去的结果生成cc的数据后无法运行执行脚本</p>\n<p><img src=\"BigdataBench-deploy\\runcc.png\" alt=\"\"></p>\n<p>原因是此时的run_connectedComponents已经不是可执行文件了（不是绿色的）需要<code>chmod a+x run_connectedComponents</code>来将文件的权限修改为可执行文件权限（修改后变为绿色）</p>\n<p>后面wget下载后解压配置之后直接就是可执行文件！</p>\n<h2 id=\"ldd-程序-动态链接库缺失\"><a href=\"#ldd-程序-动态链接库缺失\" class=\"headerlink\" title=\"ldd 程序 动态链接库缺失\"></a>ldd 程序 动态链接库缺失</h2><p><code>[root@hw073 ConnectedComponent]# ldd run_connectedComponents</code><br><code>linux-vdso.so.1 =&gt;  (0x00007ffdfc8d4000)</code><br><code>librt.so.1 =&gt; /lib64/librt.so.1 (0x0000003156e00000)</code><br><code>libpthread.so.0 =&gt; /lib64/libpthread.so.0 (0x0000003156a00000)</code></p>\n<p><code>libboost_serialization-mt.so.1.43.0 =&gt; not found</code><br><code>libboost_filesystem-mt.so.1.43.0 =&gt; not found</code><br><code>libboost_system-mt.so.1.43.0 =&gt; not found</code><br><code>libstdc++.so.6 =&gt; /usr/lib64/libstdc++.so.6 (0x0000003162200000)</code><br><code>libm.so.6 =&gt; /lib64/libm.so.6 (0x0000003157200000)</code><br><code>libgcc_s.so.1 =&gt; /lib64/libgcc_s.so.1 (0x0000003161a00000)</code><br><code>libc.so.6 =&gt; /lib64/libc.so.6 (0x0000003156600000)</code><br><code>/lib64/ld-linux-x86-64.so.2 (0x0000003155e00000)</code></p>\n<p>最开始以为是没有指定LD_LIBRARY_PATH ，因为明明有这个文件的，后面使用find / -name 命令发现还是找不到，仔细一看ldd 的信息，发现上述文件都多了个-mt</p>\n<p>解决办法： 在boost安装时的库。本机：<code>/usr/local/lib</code> 有着及其相似的3个文件<code>libboost_filesystem.so.1.43.0</code> 、<code>libboost_filesystem.so.1.43.0</code> ，<code>libboost_system.so.1.43.0</code> 均少了个-mt，因此将上述三个文件均拷贝一份命名为上述缺少的动态库文件。</p>\n<p><code>cd /usr/local/lib</code> #切换到对应的目录下</p>\n<p><code>cp libboost_system.so.1.43.0 libboost_system-mt.so.1.43.0</code> #拷贝为对应的文件名</p>\n","site":{"data":{}},"length":2708,"excerpt":"<h1 id=\"Bigdatabench-4-0-MPI版本-安装\"><a href=\"#Bigdatabench-4-0-MPI版本-安装\" class=\"headerlink\" title=\"Bigdatabench 4.0 MPI版本 安装\"></a>Bigdatabench 4.0 MPI版本 安装</h1>","more":"<p>官网上面的指南BigDataBench User Manual有一些错误。</p>\n<p>本机环境：</p>\n<p>​    Centos 6.9</p>\n<p>​    gcc (GCC) 4.8.2 20140120 (Red Hat 4.8.2-15)</p>\n<p>​    g++ (GCC) 4.8.2 20140120 (Red Hat 4.8.2-15)</p>\n<h2 id=\"mpi的安装\"><a href=\"#mpi的安装\" class=\"headerlink\" title=\"mpi的安装\"></a>mpi的安装</h2><p>这部分网上资料很多，而Manual中有一点错误</p>\n<ol>\n<li><p>需要保证c 编译器 如gcc c++ 编译器 如：g++</p>\n</li>\n<li><p>基础安装</p>\n<ol>\n<li>从官网下载安装包解压</li>\n</ol>\n<ul>\n<li><code>wget http://www.mpich.org/static/downloads/3.2.1/mpich-3.2.1.tar.gz</code>  从官网下载安装包</li>\n<li><code>tar -zxvf mpich-3.2.1.tar.gz</code>  解压</li>\n<li><code>cd mpich-3.2.1</code></li>\n</ul>\n<ol>\n<li>配置安装目录   本机安装在mpich-install目录下</li>\n</ol>\n<ul>\n<li><code>./configure –prefix=/home/mpich-install 2&gt;&amp;1 | tee c.txt</code> 手册中&amp;被错写为$了 <code>2&gt;&amp;1 | tee c.txt</code> 表示将输出的标准出错信息重定向到c.txt中。</li>\n</ul>\n<ol>\n<li>build</li>\n</ol>\n<ul>\n<li><code>make 2&gt;&amp;1 | tee m.txt</code></li>\n</ul>\n<ol>\n<li>安装</li>\n</ol>\n<ul>\n<li><code>make install 2&gt;&amp;1 | tee mi.txt</code></li>\n</ul>\n<ol>\n<li>将安装目录添加到PATH 环境变量中</li>\n</ol>\n<ul>\n<li><code>vim ~/.bashrc</code></li>\n<li><code>export PATH=$PATH:/home/mpich-install/bin</code> 在最后一行添加</li>\n<li><code>source ~/.bashrc</code> 重启生效</li>\n</ul>\n</li>\n<li><p>检查</p>\n<ol>\n<li>检查路径<ul>\n<li><code>which mpicc</code> </li>\n<li><code>which mpic++</code></li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>验证 </p>\n<p>在mpich的安装包目录下有提供例子程序运行</p>\n<ol>\n<li><code>cd mpich-3.2.1/examples</code></li>\n<li><code>mpicc cpi.c -o cpi</code> 编译cpi.c程序求pi值</li>\n<li><code>mpirun -n 4 ./cpi</code> 使用4个进程 注意<code>./</code>否则报错找不到文件</li>\n</ol>\n<p>如果是集群环境在每个节点将mpich安装在相同的路径然后编辑一个machine_file （里面是各个节点的host）然后<code>mpirun -f machine_file -n 3 ./cpi</code> 在集群上并行运行</p>\n</li>\n</ol>\n<h2 id=\"boost-安装\"><a href=\"#boost-安装\" class=\"headerlink\" title=\"boost 安装\"></a>boost 安装</h2><p>boost当前最新版本是：1.67 但是BigdataBench用的是1.43版本推荐安装这个旧版本</p>\n<ol>\n<li><p><code>wget https://sourceforge.net/projects/boost/files/boost/1.43.0/boost_1_43_0.tar.gz/download</code> </p>\n</li>\n<li><p>若下载下来的文件名为：downloads 则使用mv命令重命名在当前文件目录下:</p>\n<p><code>mv downloads boost_1_43_0.tar.gz</code>  </p>\n</li>\n<li><p>解压<code>tar -zxvf boost_1_43_0.tar.gz</code>  之后<code>cd boost_1_43_0</code></p>\n</li>\n<li><p><code>sh bootstrap.sh</code>  执行这个命令运行脚本后会多出很多配置文件</p>\n</li>\n<li><p>使用mpi,这一步骤很重要否则后续cmake时会提示找不到：boost_mpi</p>\n<ol>\n<li><p>对低版本的boost </p>\n<ol>\n<li><p><code>which mpic++</code> 找mpich的目录</p>\n</li>\n<li><p><code>vim tools/build/v2/user-config.jam</code></p>\n</li>\n<li><p>在最后添加： using mpi:后面是mpich的目录</p>\n<p><code>#MPI config</code></p>\n<p><code>using mpi : /usr/lib64/mpich/bin/mpic++ ;</code></p>\n</li>\n</ol>\n</li>\n<li><p>对高版本的boost直接在boost_1_67_0目录下修改project-config.jam即可</p>\n</li>\n</ol>\n</li>\n<li><p><code>./bjam</code> 进行编译</p>\n</li>\n<li><p><code>./bjam install</code> 这一步是必需的但在手册中没有表明。</p>\n</li>\n</ol>\n<h2 id=\"BigdataBench的配置\"><a href=\"#BigdataBench的配置\" class=\"headerlink\" title=\"BigdataBench的配置\"></a>BigdataBench的配置</h2><p>进入BigDataBench的安装根目录：</p>\n<ol>\n<li><code>vim conf.properties</code> 添加$JAVA_HOME， $MPI_HOME ，$BigdataBench_HOMEMPI的路径</li>\n<li><code>sh prepar.sh</code> </li>\n</ol>\n<p>至此安装理论上已经成功。但仍然遇到了其他问题</p>\n<h2 id=\"Perminsion-denied问题\"><a href=\"#Perminsion-denied问题\" class=\"headerlink\" title=\"Perminsion denied问题\"></a>Perminsion denied问题</h2><p>最开始的安装包是从windows下面考过去的结果生成cc的数据后无法运行执行脚本</p>\n<p><img src=\"BigdataBench-deploy\\runcc.png\" alt=\"\"></p>\n<p>原因是此时的run_connectedComponents已经不是可执行文件了（不是绿色的）需要<code>chmod a+x run_connectedComponents</code>来将文件的权限修改为可执行文件权限（修改后变为绿色）</p>\n<p>后面wget下载后解压配置之后直接就是可执行文件！</p>\n<h2 id=\"ldd-程序-动态链接库缺失\"><a href=\"#ldd-程序-动态链接库缺失\" class=\"headerlink\" title=\"ldd 程序 动态链接库缺失\"></a>ldd 程序 动态链接库缺失</h2><p><code>[root@hw073 ConnectedComponent]# ldd run_connectedComponents</code><br><code>linux-vdso.so.1 =&gt;  (0x00007ffdfc8d4000)</code><br><code>librt.so.1 =&gt; /lib64/librt.so.1 (0x0000003156e00000)</code><br><code>libpthread.so.0 =&gt; /lib64/libpthread.so.0 (0x0000003156a00000)</code></p>\n<p><code>libboost_serialization-mt.so.1.43.0 =&gt; not found</code><br><code>libboost_filesystem-mt.so.1.43.0 =&gt; not found</code><br><code>libboost_system-mt.so.1.43.0 =&gt; not found</code><br><code>libstdc++.so.6 =&gt; /usr/lib64/libstdc++.so.6 (0x0000003162200000)</code><br><code>libm.so.6 =&gt; /lib64/libm.so.6 (0x0000003157200000)</code><br><code>libgcc_s.so.1 =&gt; /lib64/libgcc_s.so.1 (0x0000003161a00000)</code><br><code>libc.so.6 =&gt; /lib64/libc.so.6 (0x0000003156600000)</code><br><code>/lib64/ld-linux-x86-64.so.2 (0x0000003155e00000)</code></p>\n<p>最开始以为是没有指定LD_LIBRARY_PATH ，因为明明有这个文件的，后面使用find / -name 命令发现还是找不到，仔细一看ldd 的信息，发现上述文件都多了个-mt</p>\n<p>解决办法： 在boost安装时的库。本机：<code>/usr/local/lib</code> 有着及其相似的3个文件<code>libboost_filesystem.so.1.43.0</code> 、<code>libboost_filesystem.so.1.43.0</code> ，<code>libboost_system.so.1.43.0</code> 均少了个-mt，因此将上述三个文件均拷贝一份命名为上述缺少的动态库文件。</p>\n<p><code>cd /usr/local/lib</code> #切换到对应的目录下</p>\n<p><code>cp libboost_system.so.1.43.0 libboost_system-mt.so.1.43.0</code> #拷贝为对应的文件名</p>"},{"title":"apt-get install失败","date":"2019-03-10T08:23:20.000Z","copyright":true,"_content":"\n## apt-get install失败\n\n<!--more-->\n\n### 第一阶段\n\n1. 使用perf 报错 内核无法找到perf\n\n   ```\n   root@hw103:/home/yky/redis-5.0.3# perf \n   WARNING: perf not found for kernel 4.15.0-45\n   \n     You may need to install the following packages for this specific kernel:\n       linux-tools-4.15.0-45-generic\n       linux-cloud-tools-4.15.0-45-generic\n   \n     You may also want to install one of the following packages to keep up to date:\n       linux-tools-generic\n       linux-cloud-tools-generic\n   ```\n\n   \n\n2. 安装此内核的通用工具时错误\n\n   ```\n   root@hw103:/home/yky/redis-5.0.3# apt-get install  linux-tools-4.15.0-45-generic\n   Reading package lists... Done\n   Building dependency tree       \n   Reading state information... Done\n   You might want to run 'apt-get -f install' to correct these:\n   The following packages have unmet dependencies:\n    console-setup : Depends: keyboard-configuration (= 1.178ubuntu2.7) but 1.108ubuntu15.3 is to be installed\n    console-setup-linux : Depends: keyboard-configuration (= 1.178ubuntu2.7) but 1.108ubuntu15.3 is to be installed\n                          Breaks: keyboard-configuration (< 1.138) but 1.108ubuntu15.3 is to be installed\n    linux-tools-4.15.0-45-generic : Depends: linux-tools-4.15.0-45 but it is not going to be installed\n   E: Unmet dependencies. Try 'apt-get -f install' with no packages (or specify a solution).\n   ```\n\n3. 使用apt-get -f install 时报错\n\n   ```\n   update-rc.d: error: insserv rejected the script header\n   dpkg: error processing archive /var/cache/apt/archives/keyboard-configuration_1.178ubuntu2.7_all.deb (--unpack):\n    subprocess new pre-installation script returned error exit status 1\n   dpkg-query: warning: files list file for package 'keyboard-configuration' missing; assuming package has no files currently installed\n   dpkg-query: warning: files list file for package 'keyboard-configuration' missing; assuming package has no files currently installed\n   dpkg-query: warning: files list file for package 'keyboard-configuration' missing; assuming package has no files currently installed\n   Errors were encountered while processing:\n    /var/cache/apt/archives/keyboard-configuration_1.178ubuntu2.7_all.deb\n   E: Sub-process /usr/bin/dpkg returned an error code (1)\n   ```\n\n   问题综述：\n\n   1. `apt-get install lib`时报错 Unmet dependencies\n   2. `apt-get install -f ` 时报错Sub-process /usr/bin/dpkg returned an error code (1)\n\n\n4. 第一阶段解决办法\n\n   在/var/lib/dpkg/目录下有个info文件 ，然后文件中没有keyboard-configuration的相关文件但是有info的备份info_backup  ，这里面有相关的文件，于是将keyboard-configuration的所有相关文件都拷贝到了/var/lib/dpkg/info 中。\n\n   在info_backup目录下执行如下命令拷贝\n\n   `cp keyboard-configuration.* ../info`\n\n   随后再次执行安装内核通用工具 报错为第二阶段\n\n### 第二阶段\n\n1. 安装此内核的通用工具时时报错：\n\n   ``` \n   insserv: Starting redis depends on plymouth and therefore on system facility `$all' which can not be true!\n   insserv: exiting now without changing boot order!\n   update-rc.d: error: insserv rejected the script header\n   dpkg: error processing package avahi-daemon (--configure):\n    subprocess installed post-installation script returned error exit status 1\n   No apport report written because MaxReports is reached already\n                                                                 No apport report written because MaxReports is reached already\n                                                                                                                               dpkg: dependency problems prevent configuration o\n   f avahi-utils: avahi-utils depends on avahi-daemon; however:\n     Package avahi-daemon is not configured yet.\n   \n   dpkg: error processing package avahi-utils (--configure):\n    dependency problems - leaving unconfigured\n   Setting up unattended-upgrades (1.1ubuntu1.18.04.9) ...\n   dpkg: error processing package unattended-upgrades (--configure):\n    subprocess installed post-installation script returned error exit status 10\n   No apport report written because MaxReports is reached already\n                                                                 Setting up linux-tools-4.15.0-45 (4.15.0-45.48) ...\n   Setting up linux-tools-4.15.0-45-generic (4.15.0-45.48) ...\n   Processing triggers for initramfs-tools (0.122ubuntu8.14) ...\n   Errors were encountered while processing:\n    udev\n    snapd\n    ubuntu-core-launcher\n    kmod\n    ubuntu-drivers-common\n    whoopsie\n    openssh-server\n    ssh\n    avahi-daemon\n    avahi-utils\n    unattended-upgrades\n   E: Sub-process /usr/bin/dpkg returned an error code (1)\n   ```\n\n2. 解决办法：/var/lib/dpkg/info 目录下将上述出现问题的模块的postinst文件重命名。\n\n   在/var/lib/dpkg/info 下写了个脚本\n\n   solution.sh\n\n   ```\n   #!/bin/bash\n   for pack in $(cat module.txt)\n   do \n       mv \"$pack\".postinst \"$pack\".postinst.bak\n   done\n   ```\n\n   其中module.txt的内容为\n\n   ```\n    udev\n    snapd\n    ubuntu-core-launcher\n    kmod\n    ubuntu-drivers-common\n    whoopsie\n    openssh-server\n    ssh\n    avahi-daemon\n    avahi-utils\n    unattended-upgrades\n   ```\n\n3. 执行脚本后 使用`sudo apt-get upgrade` 进行更新\n\n4. 参考：\n\n   1. https://www.codelast.com/%E5%8E%9F%E5%88%9B-%E8%A7%A3%E5%86%B3ubuntu-%E6%97%A0%E6%B3%95%E7%94%A8-apt-get-install-%E5%AE%89%E8%A3%85%E4%BB%BB%E4%BD%95%E8%BD%AF%E4%BB%B6dpkg-error-processing-package-xxx%E7%9A%84%E9%97%AE/\n   2. https://askubuntu.com/questions/949760/dpkg-warning-files-list-file-for-package-missing","source":"_posts/apt-get install 失败.md","raw":"---\ntitle: apt-get install失败\ndate: 2019-03-10 16:23:20\ncategories: Linux\ntags: \n- Linux \n- 运维\ncopyright: true\n---\n\n## apt-get install失败\n\n<!--more-->\n\n### 第一阶段\n\n1. 使用perf 报错 内核无法找到perf\n\n   ```\n   root@hw103:/home/yky/redis-5.0.3# perf \n   WARNING: perf not found for kernel 4.15.0-45\n   \n     You may need to install the following packages for this specific kernel:\n       linux-tools-4.15.0-45-generic\n       linux-cloud-tools-4.15.0-45-generic\n   \n     You may also want to install one of the following packages to keep up to date:\n       linux-tools-generic\n       linux-cloud-tools-generic\n   ```\n\n   \n\n2. 安装此内核的通用工具时错误\n\n   ```\n   root@hw103:/home/yky/redis-5.0.3# apt-get install  linux-tools-4.15.0-45-generic\n   Reading package lists... Done\n   Building dependency tree       \n   Reading state information... Done\n   You might want to run 'apt-get -f install' to correct these:\n   The following packages have unmet dependencies:\n    console-setup : Depends: keyboard-configuration (= 1.178ubuntu2.7) but 1.108ubuntu15.3 is to be installed\n    console-setup-linux : Depends: keyboard-configuration (= 1.178ubuntu2.7) but 1.108ubuntu15.3 is to be installed\n                          Breaks: keyboard-configuration (< 1.138) but 1.108ubuntu15.3 is to be installed\n    linux-tools-4.15.0-45-generic : Depends: linux-tools-4.15.0-45 but it is not going to be installed\n   E: Unmet dependencies. Try 'apt-get -f install' with no packages (or specify a solution).\n   ```\n\n3. 使用apt-get -f install 时报错\n\n   ```\n   update-rc.d: error: insserv rejected the script header\n   dpkg: error processing archive /var/cache/apt/archives/keyboard-configuration_1.178ubuntu2.7_all.deb (--unpack):\n    subprocess new pre-installation script returned error exit status 1\n   dpkg-query: warning: files list file for package 'keyboard-configuration' missing; assuming package has no files currently installed\n   dpkg-query: warning: files list file for package 'keyboard-configuration' missing; assuming package has no files currently installed\n   dpkg-query: warning: files list file for package 'keyboard-configuration' missing; assuming package has no files currently installed\n   Errors were encountered while processing:\n    /var/cache/apt/archives/keyboard-configuration_1.178ubuntu2.7_all.deb\n   E: Sub-process /usr/bin/dpkg returned an error code (1)\n   ```\n\n   问题综述：\n\n   1. `apt-get install lib`时报错 Unmet dependencies\n   2. `apt-get install -f ` 时报错Sub-process /usr/bin/dpkg returned an error code (1)\n\n\n4. 第一阶段解决办法\n\n   在/var/lib/dpkg/目录下有个info文件 ，然后文件中没有keyboard-configuration的相关文件但是有info的备份info_backup  ，这里面有相关的文件，于是将keyboard-configuration的所有相关文件都拷贝到了/var/lib/dpkg/info 中。\n\n   在info_backup目录下执行如下命令拷贝\n\n   `cp keyboard-configuration.* ../info`\n\n   随后再次执行安装内核通用工具 报错为第二阶段\n\n### 第二阶段\n\n1. 安装此内核的通用工具时时报错：\n\n   ``` \n   insserv: Starting redis depends on plymouth and therefore on system facility `$all' which can not be true!\n   insserv: exiting now without changing boot order!\n   update-rc.d: error: insserv rejected the script header\n   dpkg: error processing package avahi-daemon (--configure):\n    subprocess installed post-installation script returned error exit status 1\n   No apport report written because MaxReports is reached already\n                                                                 No apport report written because MaxReports is reached already\n                                                                                                                               dpkg: dependency problems prevent configuration o\n   f avahi-utils: avahi-utils depends on avahi-daemon; however:\n     Package avahi-daemon is not configured yet.\n   \n   dpkg: error processing package avahi-utils (--configure):\n    dependency problems - leaving unconfigured\n   Setting up unattended-upgrades (1.1ubuntu1.18.04.9) ...\n   dpkg: error processing package unattended-upgrades (--configure):\n    subprocess installed post-installation script returned error exit status 10\n   No apport report written because MaxReports is reached already\n                                                                 Setting up linux-tools-4.15.0-45 (4.15.0-45.48) ...\n   Setting up linux-tools-4.15.0-45-generic (4.15.0-45.48) ...\n   Processing triggers for initramfs-tools (0.122ubuntu8.14) ...\n   Errors were encountered while processing:\n    udev\n    snapd\n    ubuntu-core-launcher\n    kmod\n    ubuntu-drivers-common\n    whoopsie\n    openssh-server\n    ssh\n    avahi-daemon\n    avahi-utils\n    unattended-upgrades\n   E: Sub-process /usr/bin/dpkg returned an error code (1)\n   ```\n\n2. 解决办法：/var/lib/dpkg/info 目录下将上述出现问题的模块的postinst文件重命名。\n\n   在/var/lib/dpkg/info 下写了个脚本\n\n   solution.sh\n\n   ```\n   #!/bin/bash\n   for pack in $(cat module.txt)\n   do \n       mv \"$pack\".postinst \"$pack\".postinst.bak\n   done\n   ```\n\n   其中module.txt的内容为\n\n   ```\n    udev\n    snapd\n    ubuntu-core-launcher\n    kmod\n    ubuntu-drivers-common\n    whoopsie\n    openssh-server\n    ssh\n    avahi-daemon\n    avahi-utils\n    unattended-upgrades\n   ```\n\n3. 执行脚本后 使用`sudo apt-get upgrade` 进行更新\n\n4. 参考：\n\n   1. https://www.codelast.com/%E5%8E%9F%E5%88%9B-%E8%A7%A3%E5%86%B3ubuntu-%E6%97%A0%E6%B3%95%E7%94%A8-apt-get-install-%E5%AE%89%E8%A3%85%E4%BB%BB%E4%BD%95%E8%BD%AF%E4%BB%B6dpkg-error-processing-package-xxx%E7%9A%84%E9%97%AE/\n   2. https://askubuntu.com/questions/949760/dpkg-warning-files-list-file-for-package-missing","slug":"apt-get install 失败","published":1,"updated":"2019-11-08T13:16:54.015Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6he13zq003cdstzesg9dot6","content":"<h2 id=\"apt-get-install失败\"><a href=\"#apt-get-install失败\" class=\"headerlink\" title=\"apt-get install失败\"></a>apt-get install失败</h2><a id=\"more\"></a>\n<h3 id=\"第一阶段\"><a href=\"#第一阶段\" class=\"headerlink\" title=\"第一阶段\"></a>第一阶段</h3><ol>\n<li><p>使用perf 报错 内核无法找到perf</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@hw103:/home/yky/redis-5.0.3# perf </span><br><span class=\"line\">WARNING: perf not found for kernel 4.15.0-45</span><br><span class=\"line\"></span><br><span class=\"line\">  You may need to install the following packages for this specific kernel:</span><br><span class=\"line\">    linux-tools-4.15.0-45-generic</span><br><span class=\"line\">    linux-cloud-tools-4.15.0-45-generic</span><br><span class=\"line\"></span><br><span class=\"line\">  You may also want to install one of the following packages to keep up to date:</span><br><span class=\"line\">    linux-tools-generic</span><br><span class=\"line\">    linux-cloud-tools-generic</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol>\n<li><p>安装此内核的通用工具时错误</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@hw103:/home/yky/redis-5.0.3# apt-get install  linux-tools-4.15.0-45-generic</span><br><span class=\"line\">Reading package lists... Done</span><br><span class=\"line\">Building dependency tree       </span><br><span class=\"line\">Reading state information... Done</span><br><span class=\"line\">You might want to run &apos;apt-get -f install&apos; to correct these:</span><br><span class=\"line\">The following packages have unmet dependencies:</span><br><span class=\"line\"> console-setup : Depends: keyboard-configuration (= 1.178ubuntu2.7) but 1.108ubuntu15.3 is to be installed</span><br><span class=\"line\"> console-setup-linux : Depends: keyboard-configuration (= 1.178ubuntu2.7) but 1.108ubuntu15.3 is to be installed</span><br><span class=\"line\">                       Breaks: keyboard-configuration (&lt; 1.138) but 1.108ubuntu15.3 is to be installed</span><br><span class=\"line\"> linux-tools-4.15.0-45-generic : Depends: linux-tools-4.15.0-45 but it is not going to be installed</span><br><span class=\"line\">E: Unmet dependencies. Try &apos;apt-get -f install&apos; with no packages (or specify a solution).</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用apt-get -f install 时报错</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">update-rc.d: error: insserv rejected the script header</span><br><span class=\"line\">dpkg: error processing archive /var/cache/apt/archives/keyboard-configuration_1.178ubuntu2.7_all.deb (--unpack):</span><br><span class=\"line\"> subprocess new pre-installation script returned error exit status 1</span><br><span class=\"line\">dpkg-query: warning: files list file for package &apos;keyboard-configuration&apos; missing; assuming package has no files currently installed</span><br><span class=\"line\">dpkg-query: warning: files list file for package &apos;keyboard-configuration&apos; missing; assuming package has no files currently installed</span><br><span class=\"line\">dpkg-query: warning: files list file for package &apos;keyboard-configuration&apos; missing; assuming package has no files currently installed</span><br><span class=\"line\">Errors were encountered while processing:</span><br><span class=\"line\"> /var/cache/apt/archives/keyboard-configuration_1.178ubuntu2.7_all.deb</span><br><span class=\"line\">E: Sub-process /usr/bin/dpkg returned an error code (1)</span><br></pre></td></tr></table></figure>\n<p>问题综述：</p>\n<ol>\n<li><code>apt-get install lib</code>时报错 Unmet dependencies</li>\n<li><code>apt-get install -f</code> 时报错Sub-process /usr/bin/dpkg returned an error code (1)</li>\n</ol>\n</li>\n</ol>\n<ol>\n<li><p>第一阶段解决办法</p>\n<p>在/var/lib/dpkg/目录下有个info文件 ，然后文件中没有keyboard-configuration的相关文件但是有info的备份info_backup  ，这里面有相关的文件，于是将keyboard-configuration的所有相关文件都拷贝到了/var/lib/dpkg/info 中。</p>\n<p>在info_backup目录下执行如下命令拷贝</p>\n<p><code>cp keyboard-configuration.* ../info</code></p>\n<p>随后再次执行安装内核通用工具 报错为第二阶段</p>\n</li>\n</ol>\n<h3 id=\"第二阶段\"><a href=\"#第二阶段\" class=\"headerlink\" title=\"第二阶段\"></a>第二阶段</h3><ol>\n<li><p>安装此内核的通用工具时时报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">insserv: Starting redis depends on plymouth and therefore on system facility `$all&apos; which can not be true!</span><br><span class=\"line\">insserv: exiting now without changing boot order!</span><br><span class=\"line\">update-rc.d: error: insserv rejected the script header</span><br><span class=\"line\">dpkg: error processing package avahi-daemon (--configure):</span><br><span class=\"line\"> subprocess installed post-installation script returned error exit status 1</span><br><span class=\"line\">No apport report written because MaxReports is reached already</span><br><span class=\"line\">                                                              No apport report written because MaxReports is reached already</span><br><span class=\"line\">                                                                                                                            dpkg: dependency problems prevent configuration o</span><br><span class=\"line\">f avahi-utils: avahi-utils depends on avahi-daemon; however:</span><br><span class=\"line\">  Package avahi-daemon is not configured yet.</span><br><span class=\"line\"></span><br><span class=\"line\">dpkg: error processing package avahi-utils (--configure):</span><br><span class=\"line\"> dependency problems - leaving unconfigured</span><br><span class=\"line\">Setting up unattended-upgrades (1.1ubuntu1.18.04.9) ...</span><br><span class=\"line\">dpkg: error processing package unattended-upgrades (--configure):</span><br><span class=\"line\"> subprocess installed post-installation script returned error exit status 10</span><br><span class=\"line\">No apport report written because MaxReports is reached already</span><br><span class=\"line\">                                                              Setting up linux-tools-4.15.0-45 (4.15.0-45.48) ...</span><br><span class=\"line\">Setting up linux-tools-4.15.0-45-generic (4.15.0-45.48) ...</span><br><span class=\"line\">Processing triggers for initramfs-tools (0.122ubuntu8.14) ...</span><br><span class=\"line\">Errors were encountered while processing:</span><br><span class=\"line\"> udev</span><br><span class=\"line\"> snapd</span><br><span class=\"line\"> ubuntu-core-launcher</span><br><span class=\"line\"> kmod</span><br><span class=\"line\"> ubuntu-drivers-common</span><br><span class=\"line\"> whoopsie</span><br><span class=\"line\"> openssh-server</span><br><span class=\"line\"> ssh</span><br><span class=\"line\"> avahi-daemon</span><br><span class=\"line\"> avahi-utils</span><br><span class=\"line\"> unattended-upgrades</span><br><span class=\"line\">E: Sub-process /usr/bin/dpkg returned an error code (1)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>解决办法：/var/lib/dpkg/info 目录下将上述出现问题的模块的postinst文件重命名。</p>\n<p>在/var/lib/dpkg/info 下写了个脚本</p>\n<p>solution.sh</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">for pack in $(cat module.txt)</span><br><span class=\"line\">do </span><br><span class=\"line\">    mv &quot;$pack&quot;.postinst &quot;$pack&quot;.postinst.bak</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n<p>其中module.txt的内容为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">udev</span><br><span class=\"line\">snapd</span><br><span class=\"line\">ubuntu-core-launcher</span><br><span class=\"line\">kmod</span><br><span class=\"line\">ubuntu-drivers-common</span><br><span class=\"line\">whoopsie</span><br><span class=\"line\">openssh-server</span><br><span class=\"line\">ssh</span><br><span class=\"line\">avahi-daemon</span><br><span class=\"line\">avahi-utils</span><br><span class=\"line\">unattended-upgrades</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>执行脚本后 使用<code>sudo apt-get upgrade</code> 进行更新</p>\n</li>\n<li><p>参考：</p>\n<ol>\n<li><a href=\"https://www.codelast.com/%E5%8E%9F%E5%88%9B-%E8%A7%A3%E5%86%B3ubuntu-%E6%97%A0%E6%B3%95%E7%94%A8-apt-get-install-%E5%AE%89%E8%A3%85%E4%BB%BB%E4%BD%95%E8%BD%AF%E4%BB%B6dpkg-error-processing-package-xxx%E7%9A%84%E9%97%AE/\" target=\"_blank\" rel=\"noopener\">https://www.codelast.com/%E5%8E%9F%E5%88%9B-%E8%A7%A3%E5%86%B3ubuntu-%E6%97%A0%E6%B3%95%E7%94%A8-apt-get-install-%E5%AE%89%E8%A3%85%E4%BB%BB%E4%BD%95%E8%BD%AF%E4%BB%B6dpkg-error-processing-package-xxx%E7%9A%84%E9%97%AE/</a></li>\n<li><a href=\"https://askubuntu.com/questions/949760/dpkg-warning-files-list-file-for-package-missing\" target=\"_blank\" rel=\"noopener\">https://askubuntu.com/questions/949760/dpkg-warning-files-list-file-for-package-missing</a></li>\n</ol>\n</li>\n</ol>\n","site":{"data":{}},"length":4190,"excerpt":"<h2 id=\"apt-get-install失败\"><a href=\"#apt-get-install失败\" class=\"headerlink\" title=\"apt-get install失败\"></a>apt-get install失败</h2>","more":"<h3 id=\"第一阶段\"><a href=\"#第一阶段\" class=\"headerlink\" title=\"第一阶段\"></a>第一阶段</h3><ol>\n<li><p>使用perf 报错 内核无法找到perf</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@hw103:/home/yky/redis-5.0.3# perf </span><br><span class=\"line\">WARNING: perf not found for kernel 4.15.0-45</span><br><span class=\"line\"></span><br><span class=\"line\">  You may need to install the following packages for this specific kernel:</span><br><span class=\"line\">    linux-tools-4.15.0-45-generic</span><br><span class=\"line\">    linux-cloud-tools-4.15.0-45-generic</span><br><span class=\"line\"></span><br><span class=\"line\">  You may also want to install one of the following packages to keep up to date:</span><br><span class=\"line\">    linux-tools-generic</span><br><span class=\"line\">    linux-cloud-tools-generic</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol>\n<li><p>安装此内核的通用工具时错误</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@hw103:/home/yky/redis-5.0.3# apt-get install  linux-tools-4.15.0-45-generic</span><br><span class=\"line\">Reading package lists... Done</span><br><span class=\"line\">Building dependency tree       </span><br><span class=\"line\">Reading state information... Done</span><br><span class=\"line\">You might want to run &apos;apt-get -f install&apos; to correct these:</span><br><span class=\"line\">The following packages have unmet dependencies:</span><br><span class=\"line\"> console-setup : Depends: keyboard-configuration (= 1.178ubuntu2.7) but 1.108ubuntu15.3 is to be installed</span><br><span class=\"line\"> console-setup-linux : Depends: keyboard-configuration (= 1.178ubuntu2.7) but 1.108ubuntu15.3 is to be installed</span><br><span class=\"line\">                       Breaks: keyboard-configuration (&lt; 1.138) but 1.108ubuntu15.3 is to be installed</span><br><span class=\"line\"> linux-tools-4.15.0-45-generic : Depends: linux-tools-4.15.0-45 but it is not going to be installed</span><br><span class=\"line\">E: Unmet dependencies. Try &apos;apt-get -f install&apos; with no packages (or specify a solution).</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用apt-get -f install 时报错</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">update-rc.d: error: insserv rejected the script header</span><br><span class=\"line\">dpkg: error processing archive /var/cache/apt/archives/keyboard-configuration_1.178ubuntu2.7_all.deb (--unpack):</span><br><span class=\"line\"> subprocess new pre-installation script returned error exit status 1</span><br><span class=\"line\">dpkg-query: warning: files list file for package &apos;keyboard-configuration&apos; missing; assuming package has no files currently installed</span><br><span class=\"line\">dpkg-query: warning: files list file for package &apos;keyboard-configuration&apos; missing; assuming package has no files currently installed</span><br><span class=\"line\">dpkg-query: warning: files list file for package &apos;keyboard-configuration&apos; missing; assuming package has no files currently installed</span><br><span class=\"line\">Errors were encountered while processing:</span><br><span class=\"line\"> /var/cache/apt/archives/keyboard-configuration_1.178ubuntu2.7_all.deb</span><br><span class=\"line\">E: Sub-process /usr/bin/dpkg returned an error code (1)</span><br></pre></td></tr></table></figure>\n<p>问题综述：</p>\n<ol>\n<li><code>apt-get install lib</code>时报错 Unmet dependencies</li>\n<li><code>apt-get install -f</code> 时报错Sub-process /usr/bin/dpkg returned an error code (1)</li>\n</ol>\n</li>\n</ol>\n<ol>\n<li><p>第一阶段解决办法</p>\n<p>在/var/lib/dpkg/目录下有个info文件 ，然后文件中没有keyboard-configuration的相关文件但是有info的备份info_backup  ，这里面有相关的文件，于是将keyboard-configuration的所有相关文件都拷贝到了/var/lib/dpkg/info 中。</p>\n<p>在info_backup目录下执行如下命令拷贝</p>\n<p><code>cp keyboard-configuration.* ../info</code></p>\n<p>随后再次执行安装内核通用工具 报错为第二阶段</p>\n</li>\n</ol>\n<h3 id=\"第二阶段\"><a href=\"#第二阶段\" class=\"headerlink\" title=\"第二阶段\"></a>第二阶段</h3><ol>\n<li><p>安装此内核的通用工具时时报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">insserv: Starting redis depends on plymouth and therefore on system facility `$all&apos; which can not be true!</span><br><span class=\"line\">insserv: exiting now without changing boot order!</span><br><span class=\"line\">update-rc.d: error: insserv rejected the script header</span><br><span class=\"line\">dpkg: error processing package avahi-daemon (--configure):</span><br><span class=\"line\"> subprocess installed post-installation script returned error exit status 1</span><br><span class=\"line\">No apport report written because MaxReports is reached already</span><br><span class=\"line\">                                                              No apport report written because MaxReports is reached already</span><br><span class=\"line\">                                                                                                                            dpkg: dependency problems prevent configuration o</span><br><span class=\"line\">f avahi-utils: avahi-utils depends on avahi-daemon; however:</span><br><span class=\"line\">  Package avahi-daemon is not configured yet.</span><br><span class=\"line\"></span><br><span class=\"line\">dpkg: error processing package avahi-utils (--configure):</span><br><span class=\"line\"> dependency problems - leaving unconfigured</span><br><span class=\"line\">Setting up unattended-upgrades (1.1ubuntu1.18.04.9) ...</span><br><span class=\"line\">dpkg: error processing package unattended-upgrades (--configure):</span><br><span class=\"line\"> subprocess installed post-installation script returned error exit status 10</span><br><span class=\"line\">No apport report written because MaxReports is reached already</span><br><span class=\"line\">                                                              Setting up linux-tools-4.15.0-45 (4.15.0-45.48) ...</span><br><span class=\"line\">Setting up linux-tools-4.15.0-45-generic (4.15.0-45.48) ...</span><br><span class=\"line\">Processing triggers for initramfs-tools (0.122ubuntu8.14) ...</span><br><span class=\"line\">Errors were encountered while processing:</span><br><span class=\"line\"> udev</span><br><span class=\"line\"> snapd</span><br><span class=\"line\"> ubuntu-core-launcher</span><br><span class=\"line\"> kmod</span><br><span class=\"line\"> ubuntu-drivers-common</span><br><span class=\"line\"> whoopsie</span><br><span class=\"line\"> openssh-server</span><br><span class=\"line\"> ssh</span><br><span class=\"line\"> avahi-daemon</span><br><span class=\"line\"> avahi-utils</span><br><span class=\"line\"> unattended-upgrades</span><br><span class=\"line\">E: Sub-process /usr/bin/dpkg returned an error code (1)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>解决办法：/var/lib/dpkg/info 目录下将上述出现问题的模块的postinst文件重命名。</p>\n<p>在/var/lib/dpkg/info 下写了个脚本</p>\n<p>solution.sh</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">for pack in $(cat module.txt)</span><br><span class=\"line\">do </span><br><span class=\"line\">    mv &quot;$pack&quot;.postinst &quot;$pack&quot;.postinst.bak</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n<p>其中module.txt的内容为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">udev</span><br><span class=\"line\">snapd</span><br><span class=\"line\">ubuntu-core-launcher</span><br><span class=\"line\">kmod</span><br><span class=\"line\">ubuntu-drivers-common</span><br><span class=\"line\">whoopsie</span><br><span class=\"line\">openssh-server</span><br><span class=\"line\">ssh</span><br><span class=\"line\">avahi-daemon</span><br><span class=\"line\">avahi-utils</span><br><span class=\"line\">unattended-upgrades</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>执行脚本后 使用<code>sudo apt-get upgrade</code> 进行更新</p>\n</li>\n<li><p>参考：</p>\n<ol>\n<li><a href=\"https://www.codelast.com/%E5%8E%9F%E5%88%9B-%E8%A7%A3%E5%86%B3ubuntu-%E6%97%A0%E6%B3%95%E7%94%A8-apt-get-install-%E5%AE%89%E8%A3%85%E4%BB%BB%E4%BD%95%E8%BD%AF%E4%BB%B6dpkg-error-processing-package-xxx%E7%9A%84%E9%97%AE/\" target=\"_blank\" rel=\"noopener\">https://www.codelast.com/%E5%8E%9F%E5%88%9B-%E8%A7%A3%E5%86%B3ubuntu-%E6%97%A0%E6%B3%95%E7%94%A8-apt-get-install-%E5%AE%89%E8%A3%85%E4%BB%BB%E4%BD%95%E8%BD%AF%E4%BB%B6dpkg-error-processing-package-xxx%E7%9A%84%E9%97%AE/</a></li>\n<li><a href=\"https://askubuntu.com/questions/949760/dpkg-warning-files-list-file-for-package-missing\" target=\"_blank\" rel=\"noopener\">https://askubuntu.com/questions/949760/dpkg-warning-files-list-file-for-package-missing</a></li>\n</ol>\n</li>\n</ol>"},{"title":"leetcode 300 Longest Increasing Subsequence","date":"2020-02-07T13:19:32.000Z","copyright":true,"_content":"\n# leetcode 300 Longest Increasing Subsequence\n\n[题目来源](<https://leetcode.com/problems/longest-increasing-subsequence/> )，需要求解数组中的升序子数组的最大长度。\n\n<!--more-->\n\n## 思路\n\n### 动态规划\n\n### 自己的思路\n\n输入是数组，求解的也是最优化问题，所以首先考虑动态规划。我自己的思路是使用背包问题的解法，从长度为n的数组A[0...n-1]中，选择数字构成增序子序列。背包的容量限制就是升序数列的最后一个元素，所以初始的限制是最大值，这样任意一个数字都是在升序的。\n\n所以定义最优子结构$opt[i][j]​$表示：前i个元素中，最大值不超过第nums[j]的最大长度。如果选了第i个元素那么状态为$opt[i-1][i]+1​$,不选的话状态从$opt[i-1][j]​$转移来。这样可以写出状态转移表达式：$opt[i][j]=max(opt[i-1][i]+1,opt[i-1][j])​$\n\n#### 复杂度\n\nc需要两层循环，所以为$O(n^2)$使用了二维数组所以空间复杂\n\n### 更优的方法\n\n将最优子结构定义为**必须以第i个数字结尾**nums[i]的最长增长子数组的长度，加上这个限制后就可以简单的根据选或者不选的原则来进行状态转移了。对第i个数字nums[i]，其最优结果是前面i个数组中每个数字nums[j]的结果加一的最大值。也就是对前面每个元素都遍历一遍来确定其能够达到的最大值。状态转移表达式为：$opt[i] = {opt[i],opt[j]+1} j<=i$,这时候的子结构的解并不是原始问题的解，要对opt数组求解最大值才能够得到原始问题的解。整个子问题的定义类似于[leetcode 53](<https://bravey.github.io/2020-01-29-leetcode-53-Maximum-Subarray.html> )的定义方法。\n\n#### 复杂度\n\n需要两层循环，所以时间复杂度为$O(n^2)$使用了一维数组所以空间复杂度$O(n)$\n\n### 记忆化递归\n\n递归的方法,可以做分治的思路去考虑。最开始的问题是要求解LIS[10,9,2,5,3,7,101,18],那么从最后一位元素18开始考虑，选择了18作为最后一个元素的时候，需要从末尾元素小于18的子数组中寻找答案。也就是\n$$\nLIS[10,9,2,5,3,7,101,18] = max(LIS[10,9,2,5,3,7]+1,LIS(10,9,2,5,3)+1,LIS[10,9,2,5]+1,LIS[10,9,2]+1,LIS[10,9]+1,LIS[10]+1)\n$$\n为了避免同样的子问题反复被计算，因此使用记忆化递归的方法，将每个子问题的答案记录在对应的数组元素中，递归的退出条件有个查表。\n\n依然需要两个循环，从数组由小到大进行计算。\n\n### 复杂度\n\n需要两层循环，所以时间复杂度为$O(n^2)$使用了一维数组所以空间复杂度$O(n)$\n\n### 二分查找\n\n思路是建立一个一维数组opt，按照顺序读入原来的数组元素nums[i]，使用二分查找寻找在opt数组中第一个大于等于它数字。如果大于等于nums[i]的第一个数字存在就更新这个数字为nums[i]，如果不存在就在opt末尾增加这个元素。遍历完后返回opt数组的长度作为答案，需要注意opt数组存储的值并不一定对应着真实的LIS。\n\n之所以这样做能够得到答案，是因为记录了遍历以来出现过的最大值的个数，相当于是把增长的波峰给记录了下来，相当于是打破记录的次数，而打破记录的值一定是增序的。\n\n### 复杂度\n\n二分查找，所以时间复杂度为$O(nlogn)$使用了一维数组所以空间复杂度$O(n)$\n\n## 代码\n\n完整代码文件在[github](<https://github.com/BraveY/Coding/blob/master/leetcode/300longest-increasing-subsequence.cpp> )上面。\n\n## 动态规划\n\n### 自己的\n\n```cc\n/*\nRuntime: 184 ms, faster than 5.32% of C++ online submissions for Longest\nIncreasing Subsequence. Memory Usage: 110.9 MB, less than 6.25% of C++ online\nsubmissions for Longest Increasing O(n^2) 时间和空间\n */\nclass Solution {\n public:\n  int lengthOfLIS(vector<int>& nums) {\n    nums.push_back(INT_MAX);\n    int n = nums.size();\n    vector<vector<int> > opt(n + 1, vector<int>(n + 1, 0));\n    for (int i = 1; i <= n - 1; i++) {\n      for (int j = 1; j <= n; j++) {\n        if (nums[i - 1] < nums[j - 1])\n          opt[i][j] = max(opt[i - 1][i] + 1, opt[i - 1][j]);\n        else\n          opt[i][j] = opt[i - 1][j];\n      }\n    }\n    return opt[n - 1][n];\n  }\n\n private:\n};\n```\n\n## 更优的\n\n```cc\nclass Solution3 {\n public:\n  int lengthOfLIS(vector<int>& nums) {\n    if (nums.empty()) return 0;\n    int n = nums.size();\n    auto opt = vector<int>(n, 1);\n    for (int i = 1; i < n; ++i)\n      for (int j = 0; j < i; ++j)\n        if (nums[i] > nums[j]) opt[i] = max(opt[i], opt[j] + 1);\n    return *max_element(opt.begin(), opt.end());\n  }\n};\n```\n\n## 记忆化递归\n\n```cc\nclass Solution2 {\n public:\n  int lengthOfLIS(vector<int>& nums) {\n    int n = nums.size();\n    if (n == 0) return 0;\n    memo = vector<int>(n, 0);\n    int ans = 0;\n    for (int i = 0; i < n; ++i) ans = max(ans, LIS(nums, i));\n    return ans;\n  }\n\n private:\n  vector<int> memo;\n  // length of LIS ends with nums[r]\n  int LIS(const vector<int>& nums, int r) {\n    if (r == 0) return 1;\n    if (memo[r] > 0)\n      return memo[r];  // 记忆化递归\n                       // 退出的条件还有个查表，如果已经计算过则直接返回\n    int ans = 1;\n    for (int i = 0; i < r; ++i)\n      if (nums[r] > nums[i]) ans = max(ans, LIS(nums, i) + 1);\n    memo[r] = ans;\n    return memo[r];\n  }\n};\n```\n\n## 二分查找\n\n```\n/*\nhttps://www.cnblogs.com/grandyang/p/4938187.html\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Longest\nIncreasing Subsequence. Memory Usage: 8.7 MB, less than 62.50% of C++ online\nsubmissions for Longest Increasing Subsequence.\n */\nclass Solution4 {\n public:\n  int lengthOfLIS(vector<int>& nums) {\n    if (nums.empty()) return 0;\n    vector<int> opt;\n    for (int i = 0; i < n; i++) {\n      int lo = 0, hi = opt.size();\n      while (lo < hi) {\n        int mid = lo + (hi - lo) / 2;\n        if (opt[mid] < nums[i])\n          lo = mid + 1;\n        else\n          hi = mid;\n      }\n      if (hi >= opt.size())\n        opt.push_back(nums[i]);\n      else\n        opt[hi] = nums[i];\n    }\n    return opt.size();\n  }\n};\n```\n\n## 参考\n\n[记忆化递归与更优的DP解法](<https://www.youtube.com/watch?v=7DKFpWnaxLI&feature=youtu.be> )\n\n[二分查找的解法](https://www.cnblogs.com/grandyang/p/4938187.html)","source":"_posts/2020-02-07-leetcode-300-Longest-Increasing-Subsequence.md","raw":"---\ntitle: leetcode 300 Longest Increasing Subsequence\ndate: 2020-02-07 21:19:32\ncategories: 题解\ntags:\n- 动态规划\n- 二分查找\ncopyright: true\n---\n\n# leetcode 300 Longest Increasing Subsequence\n\n[题目来源](<https://leetcode.com/problems/longest-increasing-subsequence/> )，需要求解数组中的升序子数组的最大长度。\n\n<!--more-->\n\n## 思路\n\n### 动态规划\n\n### 自己的思路\n\n输入是数组，求解的也是最优化问题，所以首先考虑动态规划。我自己的思路是使用背包问题的解法，从长度为n的数组A[0...n-1]中，选择数字构成增序子序列。背包的容量限制就是升序数列的最后一个元素，所以初始的限制是最大值，这样任意一个数字都是在升序的。\n\n所以定义最优子结构$opt[i][j]​$表示：前i个元素中，最大值不超过第nums[j]的最大长度。如果选了第i个元素那么状态为$opt[i-1][i]+1​$,不选的话状态从$opt[i-1][j]​$转移来。这样可以写出状态转移表达式：$opt[i][j]=max(opt[i-1][i]+1,opt[i-1][j])​$\n\n#### 复杂度\n\nc需要两层循环，所以为$O(n^2)$使用了二维数组所以空间复杂\n\n### 更优的方法\n\n将最优子结构定义为**必须以第i个数字结尾**nums[i]的最长增长子数组的长度，加上这个限制后就可以简单的根据选或者不选的原则来进行状态转移了。对第i个数字nums[i]，其最优结果是前面i个数组中每个数字nums[j]的结果加一的最大值。也就是对前面每个元素都遍历一遍来确定其能够达到的最大值。状态转移表达式为：$opt[i] = {opt[i],opt[j]+1} j<=i$,这时候的子结构的解并不是原始问题的解，要对opt数组求解最大值才能够得到原始问题的解。整个子问题的定义类似于[leetcode 53](<https://bravey.github.io/2020-01-29-leetcode-53-Maximum-Subarray.html> )的定义方法。\n\n#### 复杂度\n\n需要两层循环，所以时间复杂度为$O(n^2)$使用了一维数组所以空间复杂度$O(n)$\n\n### 记忆化递归\n\n递归的方法,可以做分治的思路去考虑。最开始的问题是要求解LIS[10,9,2,5,3,7,101,18],那么从最后一位元素18开始考虑，选择了18作为最后一个元素的时候，需要从末尾元素小于18的子数组中寻找答案。也就是\n$$\nLIS[10,9,2,5,3,7,101,18] = max(LIS[10,9,2,5,3,7]+1,LIS(10,9,2,5,3)+1,LIS[10,9,2,5]+1,LIS[10,9,2]+1,LIS[10,9]+1,LIS[10]+1)\n$$\n为了避免同样的子问题反复被计算，因此使用记忆化递归的方法，将每个子问题的答案记录在对应的数组元素中，递归的退出条件有个查表。\n\n依然需要两个循环，从数组由小到大进行计算。\n\n### 复杂度\n\n需要两层循环，所以时间复杂度为$O(n^2)$使用了一维数组所以空间复杂度$O(n)$\n\n### 二分查找\n\n思路是建立一个一维数组opt，按照顺序读入原来的数组元素nums[i]，使用二分查找寻找在opt数组中第一个大于等于它数字。如果大于等于nums[i]的第一个数字存在就更新这个数字为nums[i]，如果不存在就在opt末尾增加这个元素。遍历完后返回opt数组的长度作为答案，需要注意opt数组存储的值并不一定对应着真实的LIS。\n\n之所以这样做能够得到答案，是因为记录了遍历以来出现过的最大值的个数，相当于是把增长的波峰给记录了下来，相当于是打破记录的次数，而打破记录的值一定是增序的。\n\n### 复杂度\n\n二分查找，所以时间复杂度为$O(nlogn)$使用了一维数组所以空间复杂度$O(n)$\n\n## 代码\n\n完整代码文件在[github](<https://github.com/BraveY/Coding/blob/master/leetcode/300longest-increasing-subsequence.cpp> )上面。\n\n## 动态规划\n\n### 自己的\n\n```cc\n/*\nRuntime: 184 ms, faster than 5.32% of C++ online submissions for Longest\nIncreasing Subsequence. Memory Usage: 110.9 MB, less than 6.25% of C++ online\nsubmissions for Longest Increasing O(n^2) 时间和空间\n */\nclass Solution {\n public:\n  int lengthOfLIS(vector<int>& nums) {\n    nums.push_back(INT_MAX);\n    int n = nums.size();\n    vector<vector<int> > opt(n + 1, vector<int>(n + 1, 0));\n    for (int i = 1; i <= n - 1; i++) {\n      for (int j = 1; j <= n; j++) {\n        if (nums[i - 1] < nums[j - 1])\n          opt[i][j] = max(opt[i - 1][i] + 1, opt[i - 1][j]);\n        else\n          opt[i][j] = opt[i - 1][j];\n      }\n    }\n    return opt[n - 1][n];\n  }\n\n private:\n};\n```\n\n## 更优的\n\n```cc\nclass Solution3 {\n public:\n  int lengthOfLIS(vector<int>& nums) {\n    if (nums.empty()) return 0;\n    int n = nums.size();\n    auto opt = vector<int>(n, 1);\n    for (int i = 1; i < n; ++i)\n      for (int j = 0; j < i; ++j)\n        if (nums[i] > nums[j]) opt[i] = max(opt[i], opt[j] + 1);\n    return *max_element(opt.begin(), opt.end());\n  }\n};\n```\n\n## 记忆化递归\n\n```cc\nclass Solution2 {\n public:\n  int lengthOfLIS(vector<int>& nums) {\n    int n = nums.size();\n    if (n == 0) return 0;\n    memo = vector<int>(n, 0);\n    int ans = 0;\n    for (int i = 0; i < n; ++i) ans = max(ans, LIS(nums, i));\n    return ans;\n  }\n\n private:\n  vector<int> memo;\n  // length of LIS ends with nums[r]\n  int LIS(const vector<int>& nums, int r) {\n    if (r == 0) return 1;\n    if (memo[r] > 0)\n      return memo[r];  // 记忆化递归\n                       // 退出的条件还有个查表，如果已经计算过则直接返回\n    int ans = 1;\n    for (int i = 0; i < r; ++i)\n      if (nums[r] > nums[i]) ans = max(ans, LIS(nums, i) + 1);\n    memo[r] = ans;\n    return memo[r];\n  }\n};\n```\n\n## 二分查找\n\n```\n/*\nhttps://www.cnblogs.com/grandyang/p/4938187.html\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Longest\nIncreasing Subsequence. Memory Usage: 8.7 MB, less than 62.50% of C++ online\nsubmissions for Longest Increasing Subsequence.\n */\nclass Solution4 {\n public:\n  int lengthOfLIS(vector<int>& nums) {\n    if (nums.empty()) return 0;\n    vector<int> opt;\n    for (int i = 0; i < n; i++) {\n      int lo = 0, hi = opt.size();\n      while (lo < hi) {\n        int mid = lo + (hi - lo) / 2;\n        if (opt[mid] < nums[i])\n          lo = mid + 1;\n        else\n          hi = mid;\n      }\n      if (hi >= opt.size())\n        opt.push_back(nums[i]);\n      else\n        opt[hi] = nums[i];\n    }\n    return opt.size();\n  }\n};\n```\n\n## 参考\n\n[记忆化递归与更优的DP解法](<https://www.youtube.com/watch?v=7DKFpWnaxLI&feature=youtu.be> )\n\n[二分查找的解法](https://www.cnblogs.com/grandyang/p/4938187.html)","slug":"2020-02-07-leetcode-300-Longest-Increasing-Subsequence","published":1,"updated":"2020-02-09T15:10:26.907Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6he13zs003fdstzn82lndii","content":"<h1 id=\"leetcode-300-Longest-Increasing-Subsequence\"><a href=\"#leetcode-300-Longest-Increasing-Subsequence\" class=\"headerlink\" title=\"leetcode 300 Longest Increasing Subsequence\"></a>leetcode 300 Longest Increasing Subsequence</h1><p><a href=\"https://leetcode.com/problems/longest-increasing-subsequence/\" target=\"_blank\" rel=\"noopener\">题目来源</a>，需要求解数组中的升序子数组的最大长度。</p>\n<a id=\"more\"></a>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><h3 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h3><h3 id=\"自己的思路\"><a href=\"#自己的思路\" class=\"headerlink\" title=\"自己的思路\"></a>自己的思路</h3><p>输入是数组，求解的也是最优化问题，所以首先考虑动态规划。我自己的思路是使用背包问题的解法，从长度为n的数组A[0…n-1]中，选择数字构成增序子序列。背包的容量限制就是升序数列的最后一个元素，所以初始的限制是最大值，这样任意一个数字都是在升序的。</p>\n<p>所以定义最优子结构$opt[i][j]​$表示：前i个元素中，最大值不超过第nums[j]的最大长度。如果选了第i个元素那么状态为$opt[i-1][i]+1​$,不选的话状态从$opt[i-1][j]​$转移来。这样可以写出状态转移表达式：$opt[i][j]=max(opt[i-1][i]+1,opt[i-1][j])​$</p>\n<h4 id=\"复杂度\"><a href=\"#复杂度\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h4><p>c需要两层循环，所以为$O(n^2)$使用了二维数组所以空间复杂</p>\n<h3 id=\"更优的方法\"><a href=\"#更优的方法\" class=\"headerlink\" title=\"更优的方法\"></a>更优的方法</h3><p>将最优子结构定义为<strong>必须以第i个数字结尾</strong>nums[i]的最长增长子数组的长度，加上这个限制后就可以简单的根据选或者不选的原则来进行状态转移了。对第i个数字nums[i]，其最优结果是前面i个数组中每个数字nums[j]的结果加一的最大值。也就是对前面每个元素都遍历一遍来确定其能够达到的最大值。状态转移表达式为：$opt[i] = {opt[i],opt[j]+1} j&lt;=i$,这时候的子结构的解并不是原始问题的解，要对opt数组求解最大值才能够得到原始问题的解。整个子问题的定义类似于<a href=\"https://bravey.github.io/2020-01-29-leetcode-53-Maximum-Subarray.html\">leetcode 53</a>的定义方法。</p>\n<h4 id=\"复杂度-1\"><a href=\"#复杂度-1\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h4><p>需要两层循环，所以时间复杂度为$O(n^2)$使用了一维数组所以空间复杂度$O(n)$</p>\n<h3 id=\"记忆化递归\"><a href=\"#记忆化递归\" class=\"headerlink\" title=\"记忆化递归\"></a>记忆化递归</h3><p>递归的方法,可以做分治的思路去考虑。最开始的问题是要求解LIS[10,9,2,5,3,7,101,18],那么从最后一位元素18开始考虑，选择了18作为最后一个元素的时候，需要从末尾元素小于18的子数组中寻找答案。也就是</p>\n<script type=\"math/tex; mode=display\">\nLIS[10,9,2,5,3,7,101,18] = max(LIS[10,9,2,5,3,7]+1,LIS(10,9,2,5,3)+1,LIS[10,9,2,5]+1,LIS[10,9,2]+1,LIS[10,9]+1,LIS[10]+1)</script><p>为了避免同样的子问题反复被计算，因此使用记忆化递归的方法，将每个子问题的答案记录在对应的数组元素中，递归的退出条件有个查表。</p>\n<p>依然需要两个循环，从数组由小到大进行计算。</p>\n<h3 id=\"复杂度-2\"><a href=\"#复杂度-2\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h3><p>需要两层循环，所以时间复杂度为$O(n^2)$使用了一维数组所以空间复杂度$O(n)$</p>\n<h3 id=\"二分查找\"><a href=\"#二分查找\" class=\"headerlink\" title=\"二分查找\"></a>二分查找</h3><p>思路是建立一个一维数组opt，按照顺序读入原来的数组元素nums[i]，使用二分查找寻找在opt数组中第一个大于等于它数字。如果大于等于nums[i]的第一个数字存在就更新这个数字为nums[i]，如果不存在就在opt末尾增加这个元素。遍历完后返回opt数组的长度作为答案，需要注意opt数组存储的值并不一定对应着真实的LIS。</p>\n<p>之所以这样做能够得到答案，是因为记录了遍历以来出现过的最大值的个数，相当于是把增长的波峰给记录了下来，相当于是打破记录的次数，而打破记录的值一定是增序的。</p>\n<h3 id=\"复杂度-3\"><a href=\"#复杂度-3\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h3><p>二分查找，所以时间复杂度为$O(nlogn)$使用了一维数组所以空间复杂度$O(n)$</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>完整代码文件在<a href=\"https://github.com/BraveY/Coding/blob/master/leetcode/300longest-increasing-subsequence.cpp\" target=\"_blank\" rel=\"noopener\">github</a>上面。</p>\n<h2 id=\"动态规划-1\"><a href=\"#动态规划-1\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h2><h3 id=\"自己的\"><a href=\"#自己的\" class=\"headerlink\" title=\"自己的\"></a>自己的</h3><figure class=\"highlight cc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">Runtime: 184 ms, faster than 5.32% of C++ online submissions for Longest</span></span><br><span class=\"line\"><span class=\"comment\">Increasing Subsequence. Memory Usage: 110.9 MB, less than 6.25% of C++ online</span></span><br><span class=\"line\"><span class=\"comment\">submissions for Longest Increasing O(n^2) 时间和空间</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lengthOfLIS</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    nums.push_back(INT_MAX);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = nums.size();</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; opt(n + <span class=\"number\">1</span>, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;(n + <span class=\"number\">1</span>, <span class=\"number\">0</span>));</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[i - <span class=\"number\">1</span>] &lt; nums[j - <span class=\"number\">1</span>])</span><br><span class=\"line\">          opt[i][j] = max(opt[i - <span class=\"number\">1</span>][i] + <span class=\"number\">1</span>, opt[i - <span class=\"number\">1</span>][j]);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">          opt[i][j] = opt[i - <span class=\"number\">1</span>][j];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> opt[n - <span class=\"number\">1</span>][n];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">private</span>:</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"更优的\"><a href=\"#更优的\" class=\"headerlink\" title=\"更优的\"></a>更优的</h2><figure class=\"highlight cc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution3</span> &#123;</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lengthOfLIS</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums.empty()) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = nums.size();</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> opt = <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;(n, <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; ++i)</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; i; ++j)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[i] &gt; nums[j]) opt[i] = max(opt[i], opt[j] + <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *max_element(opt.begin(), opt.end());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"记忆化递归-1\"><a href=\"#记忆化递归-1\" class=\"headerlink\" title=\"记忆化递归\"></a>记忆化递归</h2><figure class=\"highlight cc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution2</span> &#123;</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lengthOfLIS</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = nums.size();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    memo = <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;(n, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) ans = max(ans, LIS(nums, i));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">private</span>:</span><br><span class=\"line\">  <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; memo;</span><br><span class=\"line\">  <span class=\"comment\">// length of LIS ends with nums[r]</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">LIS</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> r)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (r == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (memo[r] &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> memo[r];  <span class=\"comment\">// 记忆化递归</span></span><br><span class=\"line\">                       <span class=\"comment\">// 退出的条件还有个查表，如果已经计算过则直接返回</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; r; ++i)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (nums[r] &gt; nums[i]) ans = max(ans, LIS(nums, i) + <span class=\"number\">1</span>);</span><br><span class=\"line\">    memo[r] = ans;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> memo[r];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"二分查找-1\"><a href=\"#二分查找-1\" class=\"headerlink\" title=\"二分查找\"></a>二分查找</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\">https://www.cnblogs.com/grandyang/p/4938187.html</span><br><span class=\"line\">Runtime: 0 ms, faster than 100.00% of C++ online submissions for Longest</span><br><span class=\"line\">Increasing Subsequence. Memory Usage: 8.7 MB, less than 62.50% of C++ online</span><br><span class=\"line\">submissions for Longest Increasing Subsequence.</span><br><span class=\"line\"> */</span><br><span class=\"line\">class Solution4 &#123;</span><br><span class=\"line\"> public:</span><br><span class=\"line\">  int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class=\"line\">    if (nums.empty()) return 0;</span><br><span class=\"line\">    vector&lt;int&gt; opt;</span><br><span class=\"line\">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class=\"line\">      int lo = 0, hi = opt.size();</span><br><span class=\"line\">      while (lo &lt; hi) &#123;</span><br><span class=\"line\">        int mid = lo + (hi - lo) / 2;</span><br><span class=\"line\">        if (opt[mid] &lt; nums[i])</span><br><span class=\"line\">          lo = mid + 1;</span><br><span class=\"line\">        else</span><br><span class=\"line\">          hi = mid;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if (hi &gt;= opt.size())</span><br><span class=\"line\">        opt.push_back(nums[i]);</span><br><span class=\"line\">      else</span><br><span class=\"line\">        opt[hi] = nums[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return opt.size();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://www.youtube.com/watch?v=7DKFpWnaxLI&amp;feature=youtu.be\" target=\"_blank\" rel=\"noopener\">记忆化递归与更优的DP解法</a></p>\n<p><a href=\"https://www.cnblogs.com/grandyang/p/4938187.html\" target=\"_blank\" rel=\"noopener\">二分查找的解法</a></p>\n","site":{"data":{}},"length":3510,"excerpt":"<h1 id=\"leetcode-300-Longest-Increasing-Subsequence\"><a href=\"#leetcode-300-Longest-Increasing-Subsequence\" class=\"headerlink\" title=\"leetcode 300 Longest Increasing Subsequence\"></a>leetcode 300 Longest Increasing Subsequence</h1><p><a href=\"https://leetcode.com/problems/longest-increasing-subsequence/\" target=\"_blank\" rel=\"noopener\">题目来源</a>，需要求解数组中的升序子数组的最大长度。</p>","more":"<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><h3 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h3><h3 id=\"自己的思路\"><a href=\"#自己的思路\" class=\"headerlink\" title=\"自己的思路\"></a>自己的思路</h3><p>输入是数组，求解的也是最优化问题，所以首先考虑动态规划。我自己的思路是使用背包问题的解法，从长度为n的数组A[0…n-1]中，选择数字构成增序子序列。背包的容量限制就是升序数列的最后一个元素，所以初始的限制是最大值，这样任意一个数字都是在升序的。</p>\n<p>所以定义最优子结构$opt[i][j]​$表示：前i个元素中，最大值不超过第nums[j]的最大长度。如果选了第i个元素那么状态为$opt[i-1][i]+1​$,不选的话状态从$opt[i-1][j]​$转移来。这样可以写出状态转移表达式：$opt[i][j]=max(opt[i-1][i]+1,opt[i-1][j])​$</p>\n<h4 id=\"复杂度\"><a href=\"#复杂度\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h4><p>c需要两层循环，所以为$O(n^2)$使用了二维数组所以空间复杂</p>\n<h3 id=\"更优的方法\"><a href=\"#更优的方法\" class=\"headerlink\" title=\"更优的方法\"></a>更优的方法</h3><p>将最优子结构定义为<strong>必须以第i个数字结尾</strong>nums[i]的最长增长子数组的长度，加上这个限制后就可以简单的根据选或者不选的原则来进行状态转移了。对第i个数字nums[i]，其最优结果是前面i个数组中每个数字nums[j]的结果加一的最大值。也就是对前面每个元素都遍历一遍来确定其能够达到的最大值。状态转移表达式为：$opt[i] = {opt[i],opt[j]+1} j&lt;=i$,这时候的子结构的解并不是原始问题的解，要对opt数组求解最大值才能够得到原始问题的解。整个子问题的定义类似于<a href=\"https://bravey.github.io/2020-01-29-leetcode-53-Maximum-Subarray.html\">leetcode 53</a>的定义方法。</p>\n<h4 id=\"复杂度-1\"><a href=\"#复杂度-1\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h4><p>需要两层循环，所以时间复杂度为$O(n^2)$使用了一维数组所以空间复杂度$O(n)$</p>\n<h3 id=\"记忆化递归\"><a href=\"#记忆化递归\" class=\"headerlink\" title=\"记忆化递归\"></a>记忆化递归</h3><p>递归的方法,可以做分治的思路去考虑。最开始的问题是要求解LIS[10,9,2,5,3,7,101,18],那么从最后一位元素18开始考虑，选择了18作为最后一个元素的时候，需要从末尾元素小于18的子数组中寻找答案。也就是</p>\n<script type=\"math/tex; mode=display\">\nLIS[10,9,2,5,3,7,101,18] = max(LIS[10,9,2,5,3,7]+1,LIS(10,9,2,5,3)+1,LIS[10,9,2,5]+1,LIS[10,9,2]+1,LIS[10,9]+1,LIS[10]+1)</script><p>为了避免同样的子问题反复被计算，因此使用记忆化递归的方法，将每个子问题的答案记录在对应的数组元素中，递归的退出条件有个查表。</p>\n<p>依然需要两个循环，从数组由小到大进行计算。</p>\n<h3 id=\"复杂度-2\"><a href=\"#复杂度-2\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h3><p>需要两层循环，所以时间复杂度为$O(n^2)$使用了一维数组所以空间复杂度$O(n)$</p>\n<h3 id=\"二分查找\"><a href=\"#二分查找\" class=\"headerlink\" title=\"二分查找\"></a>二分查找</h3><p>思路是建立一个一维数组opt，按照顺序读入原来的数组元素nums[i]，使用二分查找寻找在opt数组中第一个大于等于它数字。如果大于等于nums[i]的第一个数字存在就更新这个数字为nums[i]，如果不存在就在opt末尾增加这个元素。遍历完后返回opt数组的长度作为答案，需要注意opt数组存储的值并不一定对应着真实的LIS。</p>\n<p>之所以这样做能够得到答案，是因为记录了遍历以来出现过的最大值的个数，相当于是把增长的波峰给记录了下来，相当于是打破记录的次数，而打破记录的值一定是增序的。</p>\n<h3 id=\"复杂度-3\"><a href=\"#复杂度-3\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h3><p>二分查找，所以时间复杂度为$O(nlogn)$使用了一维数组所以空间复杂度$O(n)$</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>完整代码文件在<a href=\"https://github.com/BraveY/Coding/blob/master/leetcode/300longest-increasing-subsequence.cpp\" target=\"_blank\" rel=\"noopener\">github</a>上面。</p>\n<h2 id=\"动态规划-1\"><a href=\"#动态规划-1\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h2><h3 id=\"自己的\"><a href=\"#自己的\" class=\"headerlink\" title=\"自己的\"></a>自己的</h3><figure class=\"highlight cc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">Runtime: 184 ms, faster than 5.32% of C++ online submissions for Longest</span></span><br><span class=\"line\"><span class=\"comment\">Increasing Subsequence. Memory Usage: 110.9 MB, less than 6.25% of C++ online</span></span><br><span class=\"line\"><span class=\"comment\">submissions for Longest Increasing O(n^2) 时间和空间</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lengthOfLIS</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    nums.push_back(INT_MAX);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = nums.size();</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; opt(n + <span class=\"number\">1</span>, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;(n + <span class=\"number\">1</span>, <span class=\"number\">0</span>));</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[i - <span class=\"number\">1</span>] &lt; nums[j - <span class=\"number\">1</span>])</span><br><span class=\"line\">          opt[i][j] = max(opt[i - <span class=\"number\">1</span>][i] + <span class=\"number\">1</span>, opt[i - <span class=\"number\">1</span>][j]);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">          opt[i][j] = opt[i - <span class=\"number\">1</span>][j];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> opt[n - <span class=\"number\">1</span>][n];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">private</span>:</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"更优的\"><a href=\"#更优的\" class=\"headerlink\" title=\"更优的\"></a>更优的</h2><figure class=\"highlight cc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution3</span> &#123;</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lengthOfLIS</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums.empty()) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = nums.size();</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> opt = <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;(n, <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; ++i)</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; i; ++j)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[i] &gt; nums[j]) opt[i] = max(opt[i], opt[j] + <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *max_element(opt.begin(), opt.end());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"记忆化递归-1\"><a href=\"#记忆化递归-1\" class=\"headerlink\" title=\"记忆化递归\"></a>记忆化递归</h2><figure class=\"highlight cc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution2</span> &#123;</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lengthOfLIS</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = nums.size();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    memo = <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;(n, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) ans = max(ans, LIS(nums, i));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">private</span>:</span><br><span class=\"line\">  <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; memo;</span><br><span class=\"line\">  <span class=\"comment\">// length of LIS ends with nums[r]</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">LIS</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> r)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (r == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (memo[r] &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> memo[r];  <span class=\"comment\">// 记忆化递归</span></span><br><span class=\"line\">                       <span class=\"comment\">// 退出的条件还有个查表，如果已经计算过则直接返回</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; r; ++i)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (nums[r] &gt; nums[i]) ans = max(ans, LIS(nums, i) + <span class=\"number\">1</span>);</span><br><span class=\"line\">    memo[r] = ans;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> memo[r];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"二分查找-1\"><a href=\"#二分查找-1\" class=\"headerlink\" title=\"二分查找\"></a>二分查找</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\">https://www.cnblogs.com/grandyang/p/4938187.html</span><br><span class=\"line\">Runtime: 0 ms, faster than 100.00% of C++ online submissions for Longest</span><br><span class=\"line\">Increasing Subsequence. Memory Usage: 8.7 MB, less than 62.50% of C++ online</span><br><span class=\"line\">submissions for Longest Increasing Subsequence.</span><br><span class=\"line\"> */</span><br><span class=\"line\">class Solution4 &#123;</span><br><span class=\"line\"> public:</span><br><span class=\"line\">  int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class=\"line\">    if (nums.empty()) return 0;</span><br><span class=\"line\">    vector&lt;int&gt; opt;</span><br><span class=\"line\">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class=\"line\">      int lo = 0, hi = opt.size();</span><br><span class=\"line\">      while (lo &lt; hi) &#123;</span><br><span class=\"line\">        int mid = lo + (hi - lo) / 2;</span><br><span class=\"line\">        if (opt[mid] &lt; nums[i])</span><br><span class=\"line\">          lo = mid + 1;</span><br><span class=\"line\">        else</span><br><span class=\"line\">          hi = mid;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if (hi &gt;= opt.size())</span><br><span class=\"line\">        opt.push_back(nums[i]);</span><br><span class=\"line\">      else</span><br><span class=\"line\">        opt[hi] = nums[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return opt.size();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://www.youtube.com/watch?v=7DKFpWnaxLI&amp;feature=youtu.be\" target=\"_blank\" rel=\"noopener\">记忆化递归与更优的DP解法</a></p>\n<p><a href=\"https://www.cnblogs.com/grandyang/p/4938187.html\" target=\"_blank\" rel=\"noopener\">二分查找的解法</a></p>"},{"title":"使用YCSB 评测redis性能","date":"2019-03-12T09:11:44.000Z","copyright":true,"_content":"\n# 使用YCSB 评测redis性能\n\nYCSB是雅虎推出的可以评测许多主流数据库性能的基准测试，其中包括Redis。\n\n<!--more-->\n\n## 安装YCSB\n\n1. 安装java和maven\n\n   1. 机子已经有了java，所以只用安装maven Ubuntu安装命令为：\n\n      `sudo apt-get install maven`\n\n2. 安装YCSB \n\n   ````\n   git clone http://github.com/brianfrankcooper/YCSB.git\n   cd YCSB\n   mvn -pl com.yahoo.ycsb:redis-binding -am clean package\n   ````\n\n   必须是gitclone的源码包才能执行mvn 命令。wget或者curl下来包是已经编译好了的无需执行mvn命令。\n\n3. `mvn -pl com.yahoo.ycsb:redis-binding -am clean package` 报错：\n\n   ````\n   [INFO] Scanning for projects...\n   [ERROR] [ERROR] Could not find the selected project in the reactor: com.yahoo.ycsb:redis-binding @ \n   [ERROR] Could not find the selected project in the reactor: com.yahoo.ycsb:redis-binding -> [Help 1]\n   [ERROR] \n   [ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.\n   [ERROR] Re-run Maven using the -X switch to enable full debug logging.\n   [ERROR] \n   [ERROR] For more information about the errors and possible solutions, please read the following articles:\n   [ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MavenExecutionException\n   ````\n\n原因：此命令是在gitclone后未编译的时候使用的。而我之前是下载的编译好的tar.gz包，解压后是已经编译好了的。所以再次执行编译的命令时会报错。\n\n## 使用YCSB\n\n将redis-server启动后开始使用YCSB\n\n### 设置数据库\n\n需要先创建`usertable`的表，因为YCSB客户端默认是对`usertable` 进行操作。Redis将数据存储在内存中，不需要相关操作。\n\n### 选择合适的DB interface\n\nYCSB的操作是通过DB interface来实现的。最基本的DB interface是`com.yahoo.ycsb.BasicDB`，会将输出输出到`System.out`里。可以通过继承DB interface来自定义DB interface，也可以使用原有的DB interface。Redis不需要此步操作。\n\n### 选择合适的负载\n\nYCSB提供了6种负载，负载在worloads目录下。详情见<https://github.com/brianfrankcooper/YCSB/wiki/Core-Workloads>\n\n1. **Workload A: Update heavy workload** 读写比例为： 50/50 混合负载 \n2. **Workload A: Update heavy workload** 读写比例为：95/5  读为主的负载\n3. **Workload C: Read only**  100% 的读  只读负载\n4. **Workload D: Read latest workload**  读取最近的数据负载\n5. **Workload E: Short ranges**  小范围的查询负载\n6. **Workload F: Read-modify-write** 读修改写负载\n\n自定义负载：参考<https://github.com/brianfrankcooper/YCSB/wiki/Implementing-New-Workloads>\n\n可以通过修改参数文件或者新建java类来实现\n\n需要注意的是YCSB的读写负载是针对哈希类型的数据而不是简单的字符串\n\n### 指定需要的运行参数\n\n主要是指定redis的ip ，端口，密码等。\n\n命令如下：\n\n```\n./bin/ycsb load redis -s -P workloads/workloada -p \"redis.host=127.0.0.1\" -p \"redis.port=6379\" > outputLoad.txt\n```\n\n`-s` : **status**.十秒打印一次状态\n\n### 加载负载\n\n命令如下：\n\n```\n./bin/ycsb load redis -s -P workloads/workloada > outputLoad.txt\n```\n\n### 运行负载\n\n命令如下：\n\n```\n./bin/ycsb run redis -s -P workloads/workloada > outputRun.txt\n```\n\n可以使用basic数据库来打印YCSB向数据库中写入的具体数据\n\n```\nbin/ycsb.sh load basic -P workloads/workloada\nbin/ycsb.sh run basic -P workloads/workloada\n```\n\n\n\n## 参考\n\nhttps://datawine.github.io/2018/12/11/YCSB%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/\n\nhttps://github.com/brianfrankcooper/YCSB/tree/master/redis  \n\n","source":"_posts/使用YCSB 评测redis性能.md","raw":"---\ntitle: 使用YCSB 评测redis性能\ndate: 2019-03-12 17:11:44\ncategories:\ntags:\n- redis\n- benchmark\ncopyright: true\n---\n\n# 使用YCSB 评测redis性能\n\nYCSB是雅虎推出的可以评测许多主流数据库性能的基准测试，其中包括Redis。\n\n<!--more-->\n\n## 安装YCSB\n\n1. 安装java和maven\n\n   1. 机子已经有了java，所以只用安装maven Ubuntu安装命令为：\n\n      `sudo apt-get install maven`\n\n2. 安装YCSB \n\n   ````\n   git clone http://github.com/brianfrankcooper/YCSB.git\n   cd YCSB\n   mvn -pl com.yahoo.ycsb:redis-binding -am clean package\n   ````\n\n   必须是gitclone的源码包才能执行mvn 命令。wget或者curl下来包是已经编译好了的无需执行mvn命令。\n\n3. `mvn -pl com.yahoo.ycsb:redis-binding -am clean package` 报错：\n\n   ````\n   [INFO] Scanning for projects...\n   [ERROR] [ERROR] Could not find the selected project in the reactor: com.yahoo.ycsb:redis-binding @ \n   [ERROR] Could not find the selected project in the reactor: com.yahoo.ycsb:redis-binding -> [Help 1]\n   [ERROR] \n   [ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.\n   [ERROR] Re-run Maven using the -X switch to enable full debug logging.\n   [ERROR] \n   [ERROR] For more information about the errors and possible solutions, please read the following articles:\n   [ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MavenExecutionException\n   ````\n\n原因：此命令是在gitclone后未编译的时候使用的。而我之前是下载的编译好的tar.gz包，解压后是已经编译好了的。所以再次执行编译的命令时会报错。\n\n## 使用YCSB\n\n将redis-server启动后开始使用YCSB\n\n### 设置数据库\n\n需要先创建`usertable`的表，因为YCSB客户端默认是对`usertable` 进行操作。Redis将数据存储在内存中，不需要相关操作。\n\n### 选择合适的DB interface\n\nYCSB的操作是通过DB interface来实现的。最基本的DB interface是`com.yahoo.ycsb.BasicDB`，会将输出输出到`System.out`里。可以通过继承DB interface来自定义DB interface，也可以使用原有的DB interface。Redis不需要此步操作。\n\n### 选择合适的负载\n\nYCSB提供了6种负载，负载在worloads目录下。详情见<https://github.com/brianfrankcooper/YCSB/wiki/Core-Workloads>\n\n1. **Workload A: Update heavy workload** 读写比例为： 50/50 混合负载 \n2. **Workload A: Update heavy workload** 读写比例为：95/5  读为主的负载\n3. **Workload C: Read only**  100% 的读  只读负载\n4. **Workload D: Read latest workload**  读取最近的数据负载\n5. **Workload E: Short ranges**  小范围的查询负载\n6. **Workload F: Read-modify-write** 读修改写负载\n\n自定义负载：参考<https://github.com/brianfrankcooper/YCSB/wiki/Implementing-New-Workloads>\n\n可以通过修改参数文件或者新建java类来实现\n\n需要注意的是YCSB的读写负载是针对哈希类型的数据而不是简单的字符串\n\n### 指定需要的运行参数\n\n主要是指定redis的ip ，端口，密码等。\n\n命令如下：\n\n```\n./bin/ycsb load redis -s -P workloads/workloada -p \"redis.host=127.0.0.1\" -p \"redis.port=6379\" > outputLoad.txt\n```\n\n`-s` : **status**.十秒打印一次状态\n\n### 加载负载\n\n命令如下：\n\n```\n./bin/ycsb load redis -s -P workloads/workloada > outputLoad.txt\n```\n\n### 运行负载\n\n命令如下：\n\n```\n./bin/ycsb run redis -s -P workloads/workloada > outputRun.txt\n```\n\n可以使用basic数据库来打印YCSB向数据库中写入的具体数据\n\n```\nbin/ycsb.sh load basic -P workloads/workloada\nbin/ycsb.sh run basic -P workloads/workloada\n```\n\n\n\n## 参考\n\nhttps://datawine.github.io/2018/12/11/YCSB%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/\n\nhttps://github.com/brianfrankcooper/YCSB/tree/master/redis  \n\n","slug":"使用YCSB 评测redis性能","published":1,"updated":"2019-11-08T13:16:04.265Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6he13zt003hdstzedfidjpe","content":"<h1 id=\"使用YCSB-评测redis性能\"><a href=\"#使用YCSB-评测redis性能\" class=\"headerlink\" title=\"使用YCSB 评测redis性能\"></a>使用YCSB 评测redis性能</h1><p>YCSB是雅虎推出的可以评测许多主流数据库性能的基准测试，其中包括Redis。</p>\n<a id=\"more\"></a>\n<h2 id=\"安装YCSB\"><a href=\"#安装YCSB\" class=\"headerlink\" title=\"安装YCSB\"></a>安装YCSB</h2><ol>\n<li><p>安装java和maven</p>\n<ol>\n<li><p>机子已经有了java，所以只用安装maven Ubuntu安装命令为：</p>\n<p><code>sudo apt-get install maven</code></p>\n</li>\n</ol>\n</li>\n<li><p>安装YCSB </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone http://github.com/brianfrankcooper/YCSB.git</span><br><span class=\"line\">cd YCSB</span><br><span class=\"line\">mvn -pl com.yahoo.ycsb:redis-binding -am clean package</span><br></pre></td></tr></table></figure>\n<p>必须是gitclone的源码包才能执行mvn 命令。wget或者curl下来包是已经编译好了的无需执行mvn命令。</p>\n</li>\n<li><p><code>mvn -pl com.yahoo.ycsb:redis-binding -am clean package</code> 报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[INFO] Scanning for projects...</span><br><span class=\"line\">[ERROR] [ERROR] Could not find the selected project in the reactor: com.yahoo.ycsb:redis-binding @ </span><br><span class=\"line\">[ERROR] Could not find the selected project in the reactor: com.yahoo.ycsb:redis-binding -&gt; [Help 1]</span><br><span class=\"line\">[ERROR] </span><br><span class=\"line\">[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.</span><br><span class=\"line\">[ERROR] Re-run Maven using the -X switch to enable full debug logging.</span><br><span class=\"line\">[ERROR] </span><br><span class=\"line\">[ERROR] For more information about the errors and possible solutions, please read the following articles:</span><br><span class=\"line\">[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MavenExecutionException</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>原因：此命令是在gitclone后未编译的时候使用的。而我之前是下载的编译好的tar.gz包，解压后是已经编译好了的。所以再次执行编译的命令时会报错。</p>\n<h2 id=\"使用YCSB\"><a href=\"#使用YCSB\" class=\"headerlink\" title=\"使用YCSB\"></a>使用YCSB</h2><p>将redis-server启动后开始使用YCSB</p>\n<h3 id=\"设置数据库\"><a href=\"#设置数据库\" class=\"headerlink\" title=\"设置数据库\"></a>设置数据库</h3><p>需要先创建<code>usertable</code>的表，因为YCSB客户端默认是对<code>usertable</code> 进行操作。Redis将数据存储在内存中，不需要相关操作。</p>\n<h3 id=\"选择合适的DB-interface\"><a href=\"#选择合适的DB-interface\" class=\"headerlink\" title=\"选择合适的DB interface\"></a>选择合适的DB interface</h3><p>YCSB的操作是通过DB interface来实现的。最基本的DB interface是<code>com.yahoo.ycsb.BasicDB</code>，会将输出输出到<code>System.out</code>里。可以通过继承DB interface来自定义DB interface，也可以使用原有的DB interface。Redis不需要此步操作。</p>\n<h3 id=\"选择合适的负载\"><a href=\"#选择合适的负载\" class=\"headerlink\" title=\"选择合适的负载\"></a>选择合适的负载</h3><p>YCSB提供了6种负载，负载在worloads目录下。详情见<a href=\"https://github.com/brianfrankcooper/YCSB/wiki/Core-Workloads\" target=\"_blank\" rel=\"noopener\">https://github.com/brianfrankcooper/YCSB/wiki/Core-Workloads</a></p>\n<ol>\n<li><strong>Workload A: Update heavy workload</strong> 读写比例为： 50/50 混合负载 </li>\n<li><strong>Workload A: Update heavy workload</strong> 读写比例为：95/5  读为主的负载</li>\n<li><strong>Workload C: Read only</strong>  100% 的读  只读负载</li>\n<li><strong>Workload D: Read latest workload</strong>  读取最近的数据负载</li>\n<li><strong>Workload E: Short ranges</strong>  小范围的查询负载</li>\n<li><strong>Workload F: Read-modify-write</strong> 读修改写负载</li>\n</ol>\n<p>自定义负载：参考<a href=\"https://github.com/brianfrankcooper/YCSB/wiki/Implementing-New-Workloads\" target=\"_blank\" rel=\"noopener\">https://github.com/brianfrankcooper/YCSB/wiki/Implementing-New-Workloads</a></p>\n<p>可以通过修改参数文件或者新建java类来实现</p>\n<p>需要注意的是YCSB的读写负载是针对哈希类型的数据而不是简单的字符串</p>\n<h3 id=\"指定需要的运行参数\"><a href=\"#指定需要的运行参数\" class=\"headerlink\" title=\"指定需要的运行参数\"></a>指定需要的运行参数</h3><p>主要是指定redis的ip ，端口，密码等。</p>\n<p>命令如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./bin/ycsb load redis -s -P workloads/workloada -p &quot;redis.host=127.0.0.1&quot; -p &quot;redis.port=6379&quot; &gt; outputLoad.txt</span><br></pre></td></tr></table></figure>\n<p><code>-s</code> : <strong>status</strong>.十秒打印一次状态</p>\n<h3 id=\"加载负载\"><a href=\"#加载负载\" class=\"headerlink\" title=\"加载负载\"></a>加载负载</h3><p>命令如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./bin/ycsb load redis -s -P workloads/workloada &gt; outputLoad.txt</span><br></pre></td></tr></table></figure>\n<h3 id=\"运行负载\"><a href=\"#运行负载\" class=\"headerlink\" title=\"运行负载\"></a>运行负载</h3><p>命令如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./bin/ycsb run redis -s -P workloads/workloada &gt; outputRun.txt</span><br></pre></td></tr></table></figure>\n<p>可以使用basic数据库来打印YCSB向数据库中写入的具体数据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bin/ycsb.sh load basic -P workloads/workloada</span><br><span class=\"line\">bin/ycsb.sh run basic -P workloads/workloada</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://datawine.github.io/2018/12/11/YCSB%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/\" target=\"_blank\" rel=\"noopener\">https://datawine.github.io/2018/12/11/YCSB%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/</a></p>\n<p><a href=\"https://github.com/brianfrankcooper/YCSB/tree/master/redis\" target=\"_blank\" rel=\"noopener\">https://github.com/brianfrankcooper/YCSB/tree/master/redis</a>  </p>\n","site":{"data":{}},"length":2243,"excerpt":"<h1 id=\"使用YCSB-评测redis性能\"><a href=\"#使用YCSB-评测redis性能\" class=\"headerlink\" title=\"使用YCSB 评测redis性能\"></a>使用YCSB 评测redis性能</h1><p>YCSB是雅虎推出的可以评测许多主流数据库性能的基准测试，其中包括Redis。</p>","more":"<h2 id=\"安装YCSB\"><a href=\"#安装YCSB\" class=\"headerlink\" title=\"安装YCSB\"></a>安装YCSB</h2><ol>\n<li><p>安装java和maven</p>\n<ol>\n<li><p>机子已经有了java，所以只用安装maven Ubuntu安装命令为：</p>\n<p><code>sudo apt-get install maven</code></p>\n</li>\n</ol>\n</li>\n<li><p>安装YCSB </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone http://github.com/brianfrankcooper/YCSB.git</span><br><span class=\"line\">cd YCSB</span><br><span class=\"line\">mvn -pl com.yahoo.ycsb:redis-binding -am clean package</span><br></pre></td></tr></table></figure>\n<p>必须是gitclone的源码包才能执行mvn 命令。wget或者curl下来包是已经编译好了的无需执行mvn命令。</p>\n</li>\n<li><p><code>mvn -pl com.yahoo.ycsb:redis-binding -am clean package</code> 报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[INFO] Scanning for projects...</span><br><span class=\"line\">[ERROR] [ERROR] Could not find the selected project in the reactor: com.yahoo.ycsb:redis-binding @ </span><br><span class=\"line\">[ERROR] Could not find the selected project in the reactor: com.yahoo.ycsb:redis-binding -&gt; [Help 1]</span><br><span class=\"line\">[ERROR] </span><br><span class=\"line\">[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.</span><br><span class=\"line\">[ERROR] Re-run Maven using the -X switch to enable full debug logging.</span><br><span class=\"line\">[ERROR] </span><br><span class=\"line\">[ERROR] For more information about the errors and possible solutions, please read the following articles:</span><br><span class=\"line\">[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MavenExecutionException</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>原因：此命令是在gitclone后未编译的时候使用的。而我之前是下载的编译好的tar.gz包，解压后是已经编译好了的。所以再次执行编译的命令时会报错。</p>\n<h2 id=\"使用YCSB\"><a href=\"#使用YCSB\" class=\"headerlink\" title=\"使用YCSB\"></a>使用YCSB</h2><p>将redis-server启动后开始使用YCSB</p>\n<h3 id=\"设置数据库\"><a href=\"#设置数据库\" class=\"headerlink\" title=\"设置数据库\"></a>设置数据库</h3><p>需要先创建<code>usertable</code>的表，因为YCSB客户端默认是对<code>usertable</code> 进行操作。Redis将数据存储在内存中，不需要相关操作。</p>\n<h3 id=\"选择合适的DB-interface\"><a href=\"#选择合适的DB-interface\" class=\"headerlink\" title=\"选择合适的DB interface\"></a>选择合适的DB interface</h3><p>YCSB的操作是通过DB interface来实现的。最基本的DB interface是<code>com.yahoo.ycsb.BasicDB</code>，会将输出输出到<code>System.out</code>里。可以通过继承DB interface来自定义DB interface，也可以使用原有的DB interface。Redis不需要此步操作。</p>\n<h3 id=\"选择合适的负载\"><a href=\"#选择合适的负载\" class=\"headerlink\" title=\"选择合适的负载\"></a>选择合适的负载</h3><p>YCSB提供了6种负载，负载在worloads目录下。详情见<a href=\"https://github.com/brianfrankcooper/YCSB/wiki/Core-Workloads\" target=\"_blank\" rel=\"noopener\">https://github.com/brianfrankcooper/YCSB/wiki/Core-Workloads</a></p>\n<ol>\n<li><strong>Workload A: Update heavy workload</strong> 读写比例为： 50/50 混合负载 </li>\n<li><strong>Workload A: Update heavy workload</strong> 读写比例为：95/5  读为主的负载</li>\n<li><strong>Workload C: Read only</strong>  100% 的读  只读负载</li>\n<li><strong>Workload D: Read latest workload</strong>  读取最近的数据负载</li>\n<li><strong>Workload E: Short ranges</strong>  小范围的查询负载</li>\n<li><strong>Workload F: Read-modify-write</strong> 读修改写负载</li>\n</ol>\n<p>自定义负载：参考<a href=\"https://github.com/brianfrankcooper/YCSB/wiki/Implementing-New-Workloads\" target=\"_blank\" rel=\"noopener\">https://github.com/brianfrankcooper/YCSB/wiki/Implementing-New-Workloads</a></p>\n<p>可以通过修改参数文件或者新建java类来实现</p>\n<p>需要注意的是YCSB的读写负载是针对哈希类型的数据而不是简单的字符串</p>\n<h3 id=\"指定需要的运行参数\"><a href=\"#指定需要的运行参数\" class=\"headerlink\" title=\"指定需要的运行参数\"></a>指定需要的运行参数</h3><p>主要是指定redis的ip ，端口，密码等。</p>\n<p>命令如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./bin/ycsb load redis -s -P workloads/workloada -p &quot;redis.host=127.0.0.1&quot; -p &quot;redis.port=6379&quot; &gt; outputLoad.txt</span><br></pre></td></tr></table></figure>\n<p><code>-s</code> : <strong>status</strong>.十秒打印一次状态</p>\n<h3 id=\"加载负载\"><a href=\"#加载负载\" class=\"headerlink\" title=\"加载负载\"></a>加载负载</h3><p>命令如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./bin/ycsb load redis -s -P workloads/workloada &gt; outputLoad.txt</span><br></pre></td></tr></table></figure>\n<h3 id=\"运行负载\"><a href=\"#运行负载\" class=\"headerlink\" title=\"运行负载\"></a>运行负载</h3><p>命令如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./bin/ycsb run redis -s -P workloads/workloada &gt; outputRun.txt</span><br></pre></td></tr></table></figure>\n<p>可以使用basic数据库来打印YCSB向数据库中写入的具体数据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bin/ycsb.sh load basic -P workloads/workloada</span><br><span class=\"line\">bin/ycsb.sh run basic -P workloads/workloada</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://datawine.github.io/2018/12/11/YCSB%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/\" target=\"_blank\" rel=\"noopener\">https://datawine.github.io/2018/12/11/YCSB%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/</a></p>\n<p><a href=\"https://github.com/brianfrankcooper/YCSB/tree/master/redis\" target=\"_blank\" rel=\"noopener\">https://github.com/brianfrankcooper/YCSB/tree/master/redis</a>  </p>"},{"title":"Make学习","date":"2018-10-09T14:51:57.000Z","copyright":true,"_content":"\n# make学习\n\n开始阅读redis源码，都说redis很简单，源码不多。但是源码包下载下来后却发现不知道从何处入手，有那么多文件和源码。后面查找资料才发现阅读源码的第一步就是阅读Makefile，项目如何构建和源码间的关联都写在了Makefile文件中。之前没有接触过Makefile，记录下Make的学习。\n\n<!--more-->\n\n## makefile的格式\n\n1. 概述\n\n   makefile 文件由一系列rules组成 rules的格式为：\n\n```\n<target> : <prerequisites> \n[tab]  <commands>\n```\n\n​\t\"目标\"是必需的，不可省略；\"前置条件\"和\"命令\"都是可选的，但是两者之中必须至少存在一个。 \n\n​\t每条规则就明确两件事：构建目标的前置条件是什么，以及如何构建。 \n\n2. target\n\n   一个目标（target）就构成一条规则。目标通常是文件名，指明Make命令所要构建的对象，比如上文的 a.txt 目标可以是一个文件名，也可以是多个文件名，之间用空格分隔。（make的时候指定文件名从而对该文件进行构建build）\n\n   除了文件名，目标还可以是某个操作的名字，这称为\"伪目标\"（phony target）。伪目标不生成文件，只执行命令。\n\n   比如：\n\n   ```\n   clean:\n         rm *.o\n   ```\n\n   此时执行`make clean` 命令则会进行`rm *.o` 的操作。\n\n   但是当存在clean这个文件时，那么这个命令不会执行。因为Make发现clean文件已经存在，就认为没有必要重新构建了，就不会执行指定的rm命令。\n\n   为了避免这种情况，可以明确声明clean是\"伪目标\"，写法如下。\n\n   ```\n   .PHONY: clean\n   clean:\n           rm *.o temp\n   ```\n\n   如果Make命令运行时没有指定目标，默认会执行Makefile文件的第一个目标。 \n\n3. prerequisites\n\n   前置条件通常是一组文件名，之间用空格分隔。它指定了\"目标\"是否重新构建的判断标准：只要有一个前置文件不存在，或者有过更新（前置文件的last-modification时间戳比目标的时间戳新），\"目标\"就需要重新构建。 \n\n   没有前置条件，就意味着它跟其他文件都无关，只要这个target文件还不存在 就需要执行命令构建\n\n   如果需要生成多个文件，往往采用下面的写法。 \n\n   `source: file1 file2 file3`  \n\n   无需加上命令，当三个文件不存在时，执行`make source`就会生成这三个文件。\n\n4. commands\n\n   命令（commands）表示如何更新目标文件，由一行或多行的Shell命令组成。它是构建\"目标\"的具体指令，它的运行结果通常就是生成目标文件。 \n\n   每行命令之前必须有一个tab键 \n\n   需要注意的是，每行命令在一个单独的shell中执行。这些Shell之间没有继承关系。\n\n   ```\n   var-lost:\n       export foo=bar\n       echo \"foo=[$$foo]\"\n   ```\n\n   上面代码执行后（`make var-lost`），取不到foo的值。因为两行命令在两个不同的进程执行。 \n\n   解决办法：\n\n    1. 命令写在同1行\n\n    2. 换行符前加反斜杠转义\n\n       ```\n       var-kept:\n           export foo=bar; \\\n           echo \"foo=[$$foo]\"\n       ```\n\n   \t3. 加上`.ONESHELL:`命令 \n\n       ```\n       .ONESHELL:\n       var-kept:\n           export foo=bar; \n           echo \"foo=[$$foo]\"\n       ```\n\n## makefile的语法\n\n1. 注释\n\n   井号（#）在Makefile中表示注释。 \n\n2. 回声（echoing）\n\n   正常情况下，make会打印每条命令，然后再执行，这就叫做回声（echoing）。\n\n   在命令的前面加上@，就可以关闭回声。 \n\n   由于在构建过程中，需要了解当前在执行哪条命令，所以通常只在注释和纯显示的echo命令前面加上@。 \n\n3. 通配符\n\n   由于在构建过程中，需要了解当前在执行哪条命令，所以通常只在注释和纯显示的echo命令前面加上@。 \n\n4. 模式匹配\n\n   Make命令允许对文件名，进行类似正则运算的匹配，主要用到的匹配符是%。比如，假定当前目录下有 f1.c 和 f2.c 两个源码文件，需要将它们编译为对应的对象文件。 \n\n   ```\n   %.o: %.c\n   ```\n\n   等同于\n\n   ```\n   f1.o: f1.c\n   f2.o: f2.c\n   ```\n\n   使用匹配符%，可以将大量同类型的文件，只用一条规则就完成构建。 \n\n5. 变量和赋值符\n\n   Makefile 允许使用等号自定义变量。 \n\n   ```\n   txt = Hello World\n   test:\n       @echo $(txt)\n   ```\n\n   上面代码中，变量 txt 等于 Hello World。调用时，变量需要放在 $( ) 之中 \n\n   调用Shell变量，需要在美元符号前，再加一个美元符号，这是因为Make命令会对美元符号转义。 \n\n6. 内置变量\n\n   Make命令提供一系列内置变量，比如，$(CC) 指向当前使用的编译器，$(MAKE) 指向当前使用的Make工具。这主要是为了跨平台的兼容性 gmake、cmake、dmake等等。\n\n   $(AR) ：函数库打包程序,将对应的gcc编译出来的obj文件打包成静态链接库程序。\n\n   ar可以集合许多文件，成为单一的备存文件。在备存文件中，所有成员文件皆保有原来的属性与权限。\n\n7. 自动变量\n\n   1. $@指代当前目标，就是Make命令当前构建的那个目标  target\n\n   2. $<指代第一个前置条件。比如，规则为 t: p1 p2，那么$< 就指代p1 \n\n   3. $？指代比目标更新的所有前置条件，之间以空格分隔。比如，规则为 t: p1 p2，其中 p2 的时间戳比 t 新，$?就指代p2。 \n\n   4. $^指代所有前置条件，之间以空格分隔。比如，规则为 t: p1 p2，那么 $^ 就指代 p1 p2 。 \n\n   5. $*指代匹配符 % 匹配的部分， 比如% 匹配 f1.txt 中的f1 ，$* 就表示 f1。 \n\n   6. $(@D) 和 $(@F)$(@D) 和 $(@F) 分别指向 $@ 的目录名和文件名。比如，$@是 src/input.c，那么$(@D) 的值为 src ，$(@F) 的值为 input.c。 \n\n   7. $(<D) 和 $(<F)\n\n      $(<D) 和 $(<F) 分别指向 $< 的目录名和文件名。\n\n8. 其他\n\n   1. `.DEFAULT：`表示找不到匹配规则时，就执行该recipe。  \n\n      ```\n      default:all\n      .DEFAULT:\n      \tcommands\n      ```\n\n      这里当执行`make default` 时会转到`make all` 因为default：all 这个target没有隐式规则。所以最后会执行commands。\n\n   2. 忽略命令的出错，可以在Makefile的命令行前加一个减号\"-\"(在Tab键之后)，标记为不管命令出不出错都认为是成功的。如：     \n\n      ```\n      clean:        \n      \t-(rm -f *.o )\n      ```\n\n   3. `include filename` 将filename中的内容导入，如果找不到会停止make， `-include filename` 则不会停止make。 \n\n## 几种等号\n\n= 是最基本的赋值\n:= 是覆盖之前的值\n?= 是如果没有被赋值过就赋予等号后面的值\n+= 是添加等号后面的值\n\n=与:= 的区别\n\n =：make会将整个makefile展开后，再决定变量的值。也就是说，变量的值将会是整个makefile中最后被指定的值。例子为：\n\n```makefile\n     x = foo\n     y = $(x) bar\n     x = xyz\n```\n\ny的值将会是 xyz bar ，而不是 foo bar 。因为展开后最终变成的是xyz\n\n:=表示变量的值决定于它在makefile中的位置，而不是整个makefile展开后的最终值。\n\n```makefile\n x := foo\n y := $(x) bar\n x := xyz\n```\n\ny的值将会是 foo bar ，而不是 xyz bar 了。\n\n## 参考资料：\n\n1. http://www.ruanyifeng.com/blog/2015/02/make.html\n2. https://gist.github.com/isaacs/62a2d1825d04437c6f08 makefile文件教程\n3. https://www.gnu.org/software/make/manual/make.html GNUmake手册\n4. <https://blog.csdn.net/shouso888/article/details/7226030> 等号解释\n\n","source":"_posts/make学习.md","raw":"---\ntitle: Make学习\ndate: 2018-10-09 22:51:57\ncategories: 编程语言\ntags:\n- make\ncopyright: true\n---\n\n# make学习\n\n开始阅读redis源码，都说redis很简单，源码不多。但是源码包下载下来后却发现不知道从何处入手，有那么多文件和源码。后面查找资料才发现阅读源码的第一步就是阅读Makefile，项目如何构建和源码间的关联都写在了Makefile文件中。之前没有接触过Makefile，记录下Make的学习。\n\n<!--more-->\n\n## makefile的格式\n\n1. 概述\n\n   makefile 文件由一系列rules组成 rules的格式为：\n\n```\n<target> : <prerequisites> \n[tab]  <commands>\n```\n\n​\t\"目标\"是必需的，不可省略；\"前置条件\"和\"命令\"都是可选的，但是两者之中必须至少存在一个。 \n\n​\t每条规则就明确两件事：构建目标的前置条件是什么，以及如何构建。 \n\n2. target\n\n   一个目标（target）就构成一条规则。目标通常是文件名，指明Make命令所要构建的对象，比如上文的 a.txt 目标可以是一个文件名，也可以是多个文件名，之间用空格分隔。（make的时候指定文件名从而对该文件进行构建build）\n\n   除了文件名，目标还可以是某个操作的名字，这称为\"伪目标\"（phony target）。伪目标不生成文件，只执行命令。\n\n   比如：\n\n   ```\n   clean:\n         rm *.o\n   ```\n\n   此时执行`make clean` 命令则会进行`rm *.o` 的操作。\n\n   但是当存在clean这个文件时，那么这个命令不会执行。因为Make发现clean文件已经存在，就认为没有必要重新构建了，就不会执行指定的rm命令。\n\n   为了避免这种情况，可以明确声明clean是\"伪目标\"，写法如下。\n\n   ```\n   .PHONY: clean\n   clean:\n           rm *.o temp\n   ```\n\n   如果Make命令运行时没有指定目标，默认会执行Makefile文件的第一个目标。 \n\n3. prerequisites\n\n   前置条件通常是一组文件名，之间用空格分隔。它指定了\"目标\"是否重新构建的判断标准：只要有一个前置文件不存在，或者有过更新（前置文件的last-modification时间戳比目标的时间戳新），\"目标\"就需要重新构建。 \n\n   没有前置条件，就意味着它跟其他文件都无关，只要这个target文件还不存在 就需要执行命令构建\n\n   如果需要生成多个文件，往往采用下面的写法。 \n\n   `source: file1 file2 file3`  \n\n   无需加上命令，当三个文件不存在时，执行`make source`就会生成这三个文件。\n\n4. commands\n\n   命令（commands）表示如何更新目标文件，由一行或多行的Shell命令组成。它是构建\"目标\"的具体指令，它的运行结果通常就是生成目标文件。 \n\n   每行命令之前必须有一个tab键 \n\n   需要注意的是，每行命令在一个单独的shell中执行。这些Shell之间没有继承关系。\n\n   ```\n   var-lost:\n       export foo=bar\n       echo \"foo=[$$foo]\"\n   ```\n\n   上面代码执行后（`make var-lost`），取不到foo的值。因为两行命令在两个不同的进程执行。 \n\n   解决办法：\n\n    1. 命令写在同1行\n\n    2. 换行符前加反斜杠转义\n\n       ```\n       var-kept:\n           export foo=bar; \\\n           echo \"foo=[$$foo]\"\n       ```\n\n   \t3. 加上`.ONESHELL:`命令 \n\n       ```\n       .ONESHELL:\n       var-kept:\n           export foo=bar; \n           echo \"foo=[$$foo]\"\n       ```\n\n## makefile的语法\n\n1. 注释\n\n   井号（#）在Makefile中表示注释。 \n\n2. 回声（echoing）\n\n   正常情况下，make会打印每条命令，然后再执行，这就叫做回声（echoing）。\n\n   在命令的前面加上@，就可以关闭回声。 \n\n   由于在构建过程中，需要了解当前在执行哪条命令，所以通常只在注释和纯显示的echo命令前面加上@。 \n\n3. 通配符\n\n   由于在构建过程中，需要了解当前在执行哪条命令，所以通常只在注释和纯显示的echo命令前面加上@。 \n\n4. 模式匹配\n\n   Make命令允许对文件名，进行类似正则运算的匹配，主要用到的匹配符是%。比如，假定当前目录下有 f1.c 和 f2.c 两个源码文件，需要将它们编译为对应的对象文件。 \n\n   ```\n   %.o: %.c\n   ```\n\n   等同于\n\n   ```\n   f1.o: f1.c\n   f2.o: f2.c\n   ```\n\n   使用匹配符%，可以将大量同类型的文件，只用一条规则就完成构建。 \n\n5. 变量和赋值符\n\n   Makefile 允许使用等号自定义变量。 \n\n   ```\n   txt = Hello World\n   test:\n       @echo $(txt)\n   ```\n\n   上面代码中，变量 txt 等于 Hello World。调用时，变量需要放在 $( ) 之中 \n\n   调用Shell变量，需要在美元符号前，再加一个美元符号，这是因为Make命令会对美元符号转义。 \n\n6. 内置变量\n\n   Make命令提供一系列内置变量，比如，$(CC) 指向当前使用的编译器，$(MAKE) 指向当前使用的Make工具。这主要是为了跨平台的兼容性 gmake、cmake、dmake等等。\n\n   $(AR) ：函数库打包程序,将对应的gcc编译出来的obj文件打包成静态链接库程序。\n\n   ar可以集合许多文件，成为单一的备存文件。在备存文件中，所有成员文件皆保有原来的属性与权限。\n\n7. 自动变量\n\n   1. $@指代当前目标，就是Make命令当前构建的那个目标  target\n\n   2. $<指代第一个前置条件。比如，规则为 t: p1 p2，那么$< 就指代p1 \n\n   3. $？指代比目标更新的所有前置条件，之间以空格分隔。比如，规则为 t: p1 p2，其中 p2 的时间戳比 t 新，$?就指代p2。 \n\n   4. $^指代所有前置条件，之间以空格分隔。比如，规则为 t: p1 p2，那么 $^ 就指代 p1 p2 。 \n\n   5. $*指代匹配符 % 匹配的部分， 比如% 匹配 f1.txt 中的f1 ，$* 就表示 f1。 \n\n   6. $(@D) 和 $(@F)$(@D) 和 $(@F) 分别指向 $@ 的目录名和文件名。比如，$@是 src/input.c，那么$(@D) 的值为 src ，$(@F) 的值为 input.c。 \n\n   7. $(<D) 和 $(<F)\n\n      $(<D) 和 $(<F) 分别指向 $< 的目录名和文件名。\n\n8. 其他\n\n   1. `.DEFAULT：`表示找不到匹配规则时，就执行该recipe。  \n\n      ```\n      default:all\n      .DEFAULT:\n      \tcommands\n      ```\n\n      这里当执行`make default` 时会转到`make all` 因为default：all 这个target没有隐式规则。所以最后会执行commands。\n\n   2. 忽略命令的出错，可以在Makefile的命令行前加一个减号\"-\"(在Tab键之后)，标记为不管命令出不出错都认为是成功的。如：     \n\n      ```\n      clean:        \n      \t-(rm -f *.o )\n      ```\n\n   3. `include filename` 将filename中的内容导入，如果找不到会停止make， `-include filename` 则不会停止make。 \n\n## 几种等号\n\n= 是最基本的赋值\n:= 是覆盖之前的值\n?= 是如果没有被赋值过就赋予等号后面的值\n+= 是添加等号后面的值\n\n=与:= 的区别\n\n =：make会将整个makefile展开后，再决定变量的值。也就是说，变量的值将会是整个makefile中最后被指定的值。例子为：\n\n```makefile\n     x = foo\n     y = $(x) bar\n     x = xyz\n```\n\ny的值将会是 xyz bar ，而不是 foo bar 。因为展开后最终变成的是xyz\n\n:=表示变量的值决定于它在makefile中的位置，而不是整个makefile展开后的最终值。\n\n```makefile\n x := foo\n y := $(x) bar\n x := xyz\n```\n\ny的值将会是 foo bar ，而不是 xyz bar 了。\n\n## 参考资料：\n\n1. http://www.ruanyifeng.com/blog/2015/02/make.html\n2. https://gist.github.com/isaacs/62a2d1825d04437c6f08 makefile文件教程\n3. https://www.gnu.org/software/make/manual/make.html GNUmake手册\n4. <https://blog.csdn.net/shouso888/article/details/7226030> 等号解释\n\n","slug":"make学习","published":1,"updated":"2019-11-08T13:13:13.283Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6he13zv003mdstzwg1ewf24","content":"<h1 id=\"make学习\"><a href=\"#make学习\" class=\"headerlink\" title=\"make学习\"></a>make学习</h1><p>开始阅读redis源码，都说redis很简单，源码不多。但是源码包下载下来后却发现不知道从何处入手，有那么多文件和源码。后面查找资料才发现阅读源码的第一步就是阅读Makefile，项目如何构建和源码间的关联都写在了Makefile文件中。之前没有接触过Makefile，记录下Make的学习。</p>\n<a id=\"more\"></a>\n<h2 id=\"makefile的格式\"><a href=\"#makefile的格式\" class=\"headerlink\" title=\"makefile的格式\"></a>makefile的格式</h2><ol>\n<li><p>概述</p>\n<p>makefile 文件由一系列rules组成 rules的格式为：</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;target&gt; : &lt;prerequisites&gt; </span><br><span class=\"line\">[tab]  &lt;commands&gt;</span><br></pre></td></tr></table></figure>\n<p>​    “目标”是必需的，不可省略；”前置条件”和”命令”都是可选的，但是两者之中必须至少存在一个。 </p>\n<p>​    每条规则就明确两件事：构建目标的前置条件是什么，以及如何构建。 </p>\n<ol>\n<li><p>target</p>\n<p>一个目标（target）就构成一条规则。目标通常是文件名，指明Make命令所要构建的对象，比如上文的 a.txt 目标可以是一个文件名，也可以是多个文件名，之间用空格分隔。（make的时候指定文件名从而对该文件进行构建build）</p>\n<p>除了文件名，目标还可以是某个操作的名字，这称为”伪目标”（phony target）。伪目标不生成文件，只执行命令。</p>\n<p>比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clean:</span><br><span class=\"line\">      rm *.o</span><br></pre></td></tr></table></figure>\n<p>此时执行<code>make clean</code> 命令则会进行<code>rm *.o</code> 的操作。</p>\n<p>但是当存在clean这个文件时，那么这个命令不会执行。因为Make发现clean文件已经存在，就认为没有必要重新构建了，就不会执行指定的rm命令。</p>\n<p>为了避免这种情况，可以明确声明clean是”伪目标”，写法如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.PHONY: clean</span><br><span class=\"line\">clean:</span><br><span class=\"line\">        rm *.o temp</span><br></pre></td></tr></table></figure>\n<p>如果Make命令运行时没有指定目标，默认会执行Makefile文件的第一个目标。 </p>\n</li>\n<li><p>prerequisites</p>\n<p>前置条件通常是一组文件名，之间用空格分隔。它指定了”目标”是否重新构建的判断标准：只要有一个前置文件不存在，或者有过更新（前置文件的last-modification时间戳比目标的时间戳新），”目标”就需要重新构建。 </p>\n<p>没有前置条件，就意味着它跟其他文件都无关，只要这个target文件还不存在 就需要执行命令构建</p>\n<p>如果需要生成多个文件，往往采用下面的写法。 </p>\n<p><code>source: file1 file2 file3</code>  </p>\n<p>无需加上命令，当三个文件不存在时，执行<code>make source</code>就会生成这三个文件。</p>\n</li>\n<li><p>commands</p>\n<p>命令（commands）表示如何更新目标文件，由一行或多行的Shell命令组成。它是构建”目标”的具体指令，它的运行结果通常就是生成目标文件。 </p>\n<p>每行命令之前必须有一个tab键 </p>\n<p>需要注意的是，每行命令在一个单独的shell中执行。这些Shell之间没有继承关系。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var-lost:</span><br><span class=\"line\">    export foo=bar</span><br><span class=\"line\">    echo &quot;foo=[$$foo]&quot;</span><br></pre></td></tr></table></figure>\n<p>上面代码执行后（<code>make var-lost</code>），取不到foo的值。因为两行命令在两个不同的进程执行。 </p>\n<p>解决办法：</p>\n<ol>\n<li><p>命令写在同1行</p>\n</li>\n<li><p>换行符前加反斜杠转义</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var-kept:</span><br><span class=\"line\">    export foo=bar; \\</span><br><span class=\"line\">    echo &quot;foo=[$$foo]&quot;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>加上<code>.ONESHELL:</code>命令 </li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.ONESHELL:</span><br><span class=\"line\">var-kept:</span><br><span class=\"line\">    export foo=bar; </span><br><span class=\"line\">    echo &quot;foo=[$$foo]&quot;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"makefile的语法\"><a href=\"#makefile的语法\" class=\"headerlink\" title=\"makefile的语法\"></a>makefile的语法</h2><ol>\n<li><p>注释</p>\n<p>井号（#）在Makefile中表示注释。 </p>\n</li>\n<li><p>回声（echoing）</p>\n<p>正常情况下，make会打印每条命令，然后再执行，这就叫做回声（echoing）。</p>\n<p>在命令的前面加上@，就可以关闭回声。 </p>\n<p>由于在构建过程中，需要了解当前在执行哪条命令，所以通常只在注释和纯显示的echo命令前面加上@。 </p>\n</li>\n<li><p>通配符</p>\n<p>由于在构建过程中，需要了解当前在执行哪条命令，所以通常只在注释和纯显示的echo命令前面加上@。 </p>\n</li>\n<li><p>模式匹配</p>\n<p>Make命令允许对文件名，进行类似正则运算的匹配，主要用到的匹配符是%。比如，假定当前目录下有 f1.c 和 f2.c 两个源码文件，需要将它们编译为对应的对象文件。 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%.o: %.c</span><br></pre></td></tr></table></figure>\n<p>等同于</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f1.o: f1.c</span><br><span class=\"line\">f2.o: f2.c</span><br></pre></td></tr></table></figure>\n<p>使用匹配符%，可以将大量同类型的文件，只用一条规则就完成构建。 </p>\n</li>\n<li><p>变量和赋值符</p>\n<p>Makefile 允许使用等号自定义变量。 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">txt = Hello World</span><br><span class=\"line\">test:</span><br><span class=\"line\">    @echo $(txt)</span><br></pre></td></tr></table></figure>\n<p>上面代码中，变量 txt 等于 Hello World。调用时，变量需要放在 $( ) 之中 </p>\n<p>调用Shell变量，需要在美元符号前，再加一个美元符号，这是因为Make命令会对美元符号转义。 </p>\n</li>\n<li><p>内置变量</p>\n<p>Make命令提供一系列内置变量，比如，$(CC) 指向当前使用的编译器，$(MAKE) 指向当前使用的Make工具。这主要是为了跨平台的兼容性 gmake、cmake、dmake等等。</p>\n<p>$(AR) ：函数库打包程序,将对应的gcc编译出来的obj文件打包成静态链接库程序。</p>\n<p>ar可以集合许多文件，成为单一的备存文件。在备存文件中，所有成员文件皆保有原来的属性与权限。</p>\n</li>\n<li><p>自动变量</p>\n<ol>\n<li><p>$@指代当前目标，就是Make命令当前构建的那个目标  target</p>\n</li>\n<li><p>$&lt;指代第一个前置条件。比如，规则为 t: p1 p2，那么$&lt; 就指代p1 </p>\n</li>\n<li><p>$？指代比目标更新的所有前置条件，之间以空格分隔。比如，规则为 t: p1 p2，其中 p2 的时间戳比 t 新，$?就指代p2。 </p>\n</li>\n<li><p>$^指代所有前置条件，之间以空格分隔。比如，规则为 t: p1 p2，那么 $^ 就指代 p1 p2 。 </p>\n</li>\n<li><p>$<em>指代匹配符 % 匹配的部分， 比如% 匹配 f1.txt 中的f1 ，$</em> 就表示 f1。 </p>\n</li>\n<li><p>$(@D) 和 $(@F)$(@D) 和 $(@F) 分别指向 $@ 的目录名和文件名。比如，$@是 src/input.c，那么$(@D) 的值为 src ，$(@F) 的值为 input.c。 </p>\n</li>\n<li><p>$(&lt;D) 和 $(&lt;F)</p>\n<p>$(&lt;D) 和 $(&lt;F) 分别指向 $&lt; 的目录名和文件名。</p>\n</li>\n</ol>\n</li>\n<li><p>其他</p>\n<ol>\n<li><p><code>.DEFAULT：</code>表示找不到匹配规则时，就执行该recipe。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">default:all</span><br><span class=\"line\">.DEFAULT:</span><br><span class=\"line\">\tcommands</span><br></pre></td></tr></table></figure>\n<p>这里当执行<code>make default</code> 时会转到<code>make all</code> 因为default：all 这个target没有隐式规则。所以最后会执行commands。</p>\n</li>\n<li><p>忽略命令的出错，可以在Makefile的命令行前加一个减号”-“(在Tab键之后)，标记为不管命令出不出错都认为是成功的。如：     </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clean:        </span><br><span class=\"line\">\t-(rm -f *.o )</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>include filename</code> 将filename中的内容导入，如果找不到会停止make， <code>-include filename</code> 则不会停止make。 </p>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"几种等号\"><a href=\"#几种等号\" class=\"headerlink\" title=\"几种等号\"></a>几种等号</h2><p>= 是最基本的赋值<br>:= 是覆盖之前的值<br>?= 是如果没有被赋值过就赋予等号后面的值<br>+= 是添加等号后面的值</p>\n<p>=与:= 的区别</p>\n<p> =：make会将整个makefile展开后，再决定变量的值。也就是说，变量的值将会是整个makefile中最后被指定的值。例子为：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = foo</span><br><span class=\"line\">y = <span class=\"variable\">$(x)</span> bar</span><br><span class=\"line\">x = xyz</span><br></pre></td></tr></table></figure>\n<p>y的值将会是 xyz bar ，而不是 foo bar 。因为展开后最终变成的是xyz</p>\n<p>:=表示变量的值决定于它在makefile中的位置，而不是整个makefile展开后的最终值。</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x := foo</span><br><span class=\"line\">y := <span class=\"variable\">$(x)</span> bar</span><br><span class=\"line\">x := xyz</span><br></pre></td></tr></table></figure>\n<p>y的值将会是 foo bar ，而不是 xyz bar 了。</p>\n<h2 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h2><ol>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/02/make.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2015/02/make.html</a></li>\n<li><a href=\"https://gist.github.com/isaacs/62a2d1825d04437c6f08\" target=\"_blank\" rel=\"noopener\">https://gist.github.com/isaacs/62a2d1825d04437c6f08</a> makefile文件教程</li>\n<li><a href=\"https://www.gnu.org/software/make/manual/make.html\" target=\"_blank\" rel=\"noopener\">https://www.gnu.org/software/make/manual/make.html</a> GNUmake手册</li>\n<li><a href=\"https://blog.csdn.net/shouso888/article/details/7226030\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/shouso888/article/details/7226030</a> 等号解释</li>\n</ol>\n","site":{"data":{}},"length":3190,"excerpt":"<h1 id=\"make学习\"><a href=\"#make学习\" class=\"headerlink\" title=\"make学习\"></a>make学习</h1><p>开始阅读redis源码，都说redis很简单，源码不多。但是源码包下载下来后却发现不知道从何处入手，有那么多文件和源码。后面查找资料才发现阅读源码的第一步就是阅读Makefile，项目如何构建和源码间的关联都写在了Makefile文件中。之前没有接触过Makefile，记录下Make的学习。</p>","more":"<h2 id=\"makefile的格式\"><a href=\"#makefile的格式\" class=\"headerlink\" title=\"makefile的格式\"></a>makefile的格式</h2><ol>\n<li><p>概述</p>\n<p>makefile 文件由一系列rules组成 rules的格式为：</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;target&gt; : &lt;prerequisites&gt; </span><br><span class=\"line\">[tab]  &lt;commands&gt;</span><br></pre></td></tr></table></figure>\n<p>​    “目标”是必需的，不可省略；”前置条件”和”命令”都是可选的，但是两者之中必须至少存在一个。 </p>\n<p>​    每条规则就明确两件事：构建目标的前置条件是什么，以及如何构建。 </p>\n<ol>\n<li><p>target</p>\n<p>一个目标（target）就构成一条规则。目标通常是文件名，指明Make命令所要构建的对象，比如上文的 a.txt 目标可以是一个文件名，也可以是多个文件名，之间用空格分隔。（make的时候指定文件名从而对该文件进行构建build）</p>\n<p>除了文件名，目标还可以是某个操作的名字，这称为”伪目标”（phony target）。伪目标不生成文件，只执行命令。</p>\n<p>比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clean:</span><br><span class=\"line\">      rm *.o</span><br></pre></td></tr></table></figure>\n<p>此时执行<code>make clean</code> 命令则会进行<code>rm *.o</code> 的操作。</p>\n<p>但是当存在clean这个文件时，那么这个命令不会执行。因为Make发现clean文件已经存在，就认为没有必要重新构建了，就不会执行指定的rm命令。</p>\n<p>为了避免这种情况，可以明确声明clean是”伪目标”，写法如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.PHONY: clean</span><br><span class=\"line\">clean:</span><br><span class=\"line\">        rm *.o temp</span><br></pre></td></tr></table></figure>\n<p>如果Make命令运行时没有指定目标，默认会执行Makefile文件的第一个目标。 </p>\n</li>\n<li><p>prerequisites</p>\n<p>前置条件通常是一组文件名，之间用空格分隔。它指定了”目标”是否重新构建的判断标准：只要有一个前置文件不存在，或者有过更新（前置文件的last-modification时间戳比目标的时间戳新），”目标”就需要重新构建。 </p>\n<p>没有前置条件，就意味着它跟其他文件都无关，只要这个target文件还不存在 就需要执行命令构建</p>\n<p>如果需要生成多个文件，往往采用下面的写法。 </p>\n<p><code>source: file1 file2 file3</code>  </p>\n<p>无需加上命令，当三个文件不存在时，执行<code>make source</code>就会生成这三个文件。</p>\n</li>\n<li><p>commands</p>\n<p>命令（commands）表示如何更新目标文件，由一行或多行的Shell命令组成。它是构建”目标”的具体指令，它的运行结果通常就是生成目标文件。 </p>\n<p>每行命令之前必须有一个tab键 </p>\n<p>需要注意的是，每行命令在一个单独的shell中执行。这些Shell之间没有继承关系。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var-lost:</span><br><span class=\"line\">    export foo=bar</span><br><span class=\"line\">    echo &quot;foo=[$$foo]&quot;</span><br></pre></td></tr></table></figure>\n<p>上面代码执行后（<code>make var-lost</code>），取不到foo的值。因为两行命令在两个不同的进程执行。 </p>\n<p>解决办法：</p>\n<ol>\n<li><p>命令写在同1行</p>\n</li>\n<li><p>换行符前加反斜杠转义</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var-kept:</span><br><span class=\"line\">    export foo=bar; \\</span><br><span class=\"line\">    echo &quot;foo=[$$foo]&quot;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>加上<code>.ONESHELL:</code>命令 </li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.ONESHELL:</span><br><span class=\"line\">var-kept:</span><br><span class=\"line\">    export foo=bar; </span><br><span class=\"line\">    echo &quot;foo=[$$foo]&quot;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"makefile的语法\"><a href=\"#makefile的语法\" class=\"headerlink\" title=\"makefile的语法\"></a>makefile的语法</h2><ol>\n<li><p>注释</p>\n<p>井号（#）在Makefile中表示注释。 </p>\n</li>\n<li><p>回声（echoing）</p>\n<p>正常情况下，make会打印每条命令，然后再执行，这就叫做回声（echoing）。</p>\n<p>在命令的前面加上@，就可以关闭回声。 </p>\n<p>由于在构建过程中，需要了解当前在执行哪条命令，所以通常只在注释和纯显示的echo命令前面加上@。 </p>\n</li>\n<li><p>通配符</p>\n<p>由于在构建过程中，需要了解当前在执行哪条命令，所以通常只在注释和纯显示的echo命令前面加上@。 </p>\n</li>\n<li><p>模式匹配</p>\n<p>Make命令允许对文件名，进行类似正则运算的匹配，主要用到的匹配符是%。比如，假定当前目录下有 f1.c 和 f2.c 两个源码文件，需要将它们编译为对应的对象文件。 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%.o: %.c</span><br></pre></td></tr></table></figure>\n<p>等同于</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f1.o: f1.c</span><br><span class=\"line\">f2.o: f2.c</span><br></pre></td></tr></table></figure>\n<p>使用匹配符%，可以将大量同类型的文件，只用一条规则就完成构建。 </p>\n</li>\n<li><p>变量和赋值符</p>\n<p>Makefile 允许使用等号自定义变量。 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">txt = Hello World</span><br><span class=\"line\">test:</span><br><span class=\"line\">    @echo $(txt)</span><br></pre></td></tr></table></figure>\n<p>上面代码中，变量 txt 等于 Hello World。调用时，变量需要放在 $( ) 之中 </p>\n<p>调用Shell变量，需要在美元符号前，再加一个美元符号，这是因为Make命令会对美元符号转义。 </p>\n</li>\n<li><p>内置变量</p>\n<p>Make命令提供一系列内置变量，比如，$(CC) 指向当前使用的编译器，$(MAKE) 指向当前使用的Make工具。这主要是为了跨平台的兼容性 gmake、cmake、dmake等等。</p>\n<p>$(AR) ：函数库打包程序,将对应的gcc编译出来的obj文件打包成静态链接库程序。</p>\n<p>ar可以集合许多文件，成为单一的备存文件。在备存文件中，所有成员文件皆保有原来的属性与权限。</p>\n</li>\n<li><p>自动变量</p>\n<ol>\n<li><p>$@指代当前目标，就是Make命令当前构建的那个目标  target</p>\n</li>\n<li><p>$&lt;指代第一个前置条件。比如，规则为 t: p1 p2，那么$&lt; 就指代p1 </p>\n</li>\n<li><p>$？指代比目标更新的所有前置条件，之间以空格分隔。比如，规则为 t: p1 p2，其中 p2 的时间戳比 t 新，$?就指代p2。 </p>\n</li>\n<li><p>$^指代所有前置条件，之间以空格分隔。比如，规则为 t: p1 p2，那么 $^ 就指代 p1 p2 。 </p>\n</li>\n<li><p>$<em>指代匹配符 % 匹配的部分， 比如% 匹配 f1.txt 中的f1 ，$</em> 就表示 f1。 </p>\n</li>\n<li><p>$(@D) 和 $(@F)$(@D) 和 $(@F) 分别指向 $@ 的目录名和文件名。比如，$@是 src/input.c，那么$(@D) 的值为 src ，$(@F) 的值为 input.c。 </p>\n</li>\n<li><p>$(&lt;D) 和 $(&lt;F)</p>\n<p>$(&lt;D) 和 $(&lt;F) 分别指向 $&lt; 的目录名和文件名。</p>\n</li>\n</ol>\n</li>\n<li><p>其他</p>\n<ol>\n<li><p><code>.DEFAULT：</code>表示找不到匹配规则时，就执行该recipe。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">default:all</span><br><span class=\"line\">.DEFAULT:</span><br><span class=\"line\">\tcommands</span><br></pre></td></tr></table></figure>\n<p>这里当执行<code>make default</code> 时会转到<code>make all</code> 因为default：all 这个target没有隐式规则。所以最后会执行commands。</p>\n</li>\n<li><p>忽略命令的出错，可以在Makefile的命令行前加一个减号”-“(在Tab键之后)，标记为不管命令出不出错都认为是成功的。如：     </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clean:        </span><br><span class=\"line\">\t-(rm -f *.o )</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>include filename</code> 将filename中的内容导入，如果找不到会停止make， <code>-include filename</code> 则不会停止make。 </p>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"几种等号\"><a href=\"#几种等号\" class=\"headerlink\" title=\"几种等号\"></a>几种等号</h2><p>= 是最基本的赋值<br>:= 是覆盖之前的值<br>?= 是如果没有被赋值过就赋予等号后面的值<br>+= 是添加等号后面的值</p>\n<p>=与:= 的区别</p>\n<p> =：make会将整个makefile展开后，再决定变量的值。也就是说，变量的值将会是整个makefile中最后被指定的值。例子为：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = foo</span><br><span class=\"line\">y = <span class=\"variable\">$(x)</span> bar</span><br><span class=\"line\">x = xyz</span><br></pre></td></tr></table></figure>\n<p>y的值将会是 xyz bar ，而不是 foo bar 。因为展开后最终变成的是xyz</p>\n<p>:=表示变量的值决定于它在makefile中的位置，而不是整个makefile展开后的最终值。</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x := foo</span><br><span class=\"line\">y := <span class=\"variable\">$(x)</span> bar</span><br><span class=\"line\">x := xyz</span><br></pre></td></tr></table></figure>\n<p>y的值将会是 foo bar ，而不是 xyz bar 了。</p>\n<h2 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h2><ol>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/02/make.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2015/02/make.html</a></li>\n<li><a href=\"https://gist.github.com/isaacs/62a2d1825d04437c6f08\" target=\"_blank\" rel=\"noopener\">https://gist.github.com/isaacs/62a2d1825d04437c6f08</a> makefile文件教程</li>\n<li><a href=\"https://www.gnu.org/software/make/manual/make.html\" target=\"_blank\" rel=\"noopener\">https://www.gnu.org/software/make/manual/make.html</a> GNUmake手册</li>\n<li><a href=\"https://blog.csdn.net/shouso888/article/details/7226030\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/shouso888/article/details/7226030</a> 等号解释</li>\n</ol>"},{"title":"ping 无法连接外网","date":"2019-03-15T05:51:47.000Z","copyright":true,"_content":"\n\n\n## ping 无法连接外网\n\n<!--more-->\n\n### 问题\n\nping外网ping不通\n\n```\nyky@hw076:~/tmux> ping www.baidu.com\nping: unknown host www.baidu.com\nyky@hw076:~/tmux> ping 8.8.8.8\nconnect: Network is unreachable\n```\n\nping内网可以ping通\n\n```\nhw076:~ # ping 172.18.11.114\nPING 172.18.11.114 (172.18.11.114) 56(84) bytes of data.\n64 bytes from 172.18.11.114: icmp_seq=1 ttl=64 time=0.193 ms\n64 bytes from 172.18.11.114: icmp_seq=2 ttl=64 time=0.216 ms\n64 bytes from 172.18.11.114: icmp_seq=3 ttl=64 time=0.207 ms\n64 bytes from 172.18.11.114: icmp_seq=4 ttl=64 time=0.200 ms\n^C\n--- 172.18.11.114 ping statistics ---\n4 packets transmitted, 4 received, 0% packet loss, time 2999ms\nrtt min/avg/max/mdev = 0.193/0.204/0.216/0.008 ms\n\n```\n\nifconfig信息为：\n\n```\nhw076:~ # ifconfig \neth0      Link encap:Ethernet  HWaddr 90:E2:BA:15:C9:C4  \n          inet addr:172.18.11.76  Bcast:192.168.1.255  Mask:255.255.0.0\n          inet6 addr: fe80::92e2:baff:fe15:c9c4/64 Scope:Link\n          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1\n          RX packets:9725797 errors:0 dropped:506 overruns:0 frame:0\n          TX packets:21023 errors:0 dropped:0 overruns:0 carrier:0\n          collisions:0 txqueuelen:1000 \n          RX bytes:598731249 (570.9 Mb)  TX bytes:2767270 (2.6 Mb)\n          Memory:fb480000-fb500000 \n\nlo        Link encap:Local Loopback  \n          inet addr:127.0.0.1  Mask:255.0.0.0\n          inet6 addr: ::1/128 Scope:Host\n          UP LOOPBACK RUNNING  MTU:65536  Metric:1\n          RX packets:276 errors:0 dropped:0 overruns:0 frame:0\n          TX packets:276 errors:0 dropped:0 overruns:0 carrier:0\n          collisions:0 txqueuelen:0 \n          RX bytes:25088 (24.5 Kb)  TX bytes:25088 (24.5 Kb)\n```\n\nroute显示路由信息如下：\n\n```\nhw076:/etc/netconfig.d # route\nKernel IP routing table\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\ndefault         *               0.0.0.0         UG    0      0        0 eth0\nloopback        *               255.0.0.0       U     0      0        0 lo\nlink-local      *               255.255.0.0     U     0      0        0 eth0\n172.18.0.0      *               255.255.0.0     U     0      0        0 eth0\n```\n\n原因是route没有配置网关，gateway是空着的。\n\n### 解决方法\n\n通过查看其他可以正常访问的节点的路由信息，得知网关节点为：172.18.0.254。因此增加默认网关节点配置。\n\n执行命令：\n\n```\nroute add default  gw 172.18.0.254\n```\n\n再次查看路由信息：\n\n```\nhw076:~ # route\nKernel IP routing table\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\ndefault         172.18.0.254    0.0.0.0         UG    0      0        0 eth0\nloopback        *               255.0.0.0       U     0      0        0 lo\nlink-local      *               255.255.0.0     U     0      0        0 eth0\n172.18.0.0      *               255.255.0.0     U     0      0        0 eth0\n```\n\n再次ping8.8.8.8显示正常，问题解决。","source":"_posts/ping 问题.md","raw":"---\ntitle: ping 无法连接外网\ndate: 2019-03-15 13:51:47\ncategories: Linux\ntags:\n- Linux\n- 运维\n- 网络问题\ncopyright: true\n---\n\n\n\n## ping 无法连接外网\n\n<!--more-->\n\n### 问题\n\nping外网ping不通\n\n```\nyky@hw076:~/tmux> ping www.baidu.com\nping: unknown host www.baidu.com\nyky@hw076:~/tmux> ping 8.8.8.8\nconnect: Network is unreachable\n```\n\nping内网可以ping通\n\n```\nhw076:~ # ping 172.18.11.114\nPING 172.18.11.114 (172.18.11.114) 56(84) bytes of data.\n64 bytes from 172.18.11.114: icmp_seq=1 ttl=64 time=0.193 ms\n64 bytes from 172.18.11.114: icmp_seq=2 ttl=64 time=0.216 ms\n64 bytes from 172.18.11.114: icmp_seq=3 ttl=64 time=0.207 ms\n64 bytes from 172.18.11.114: icmp_seq=4 ttl=64 time=0.200 ms\n^C\n--- 172.18.11.114 ping statistics ---\n4 packets transmitted, 4 received, 0% packet loss, time 2999ms\nrtt min/avg/max/mdev = 0.193/0.204/0.216/0.008 ms\n\n```\n\nifconfig信息为：\n\n```\nhw076:~ # ifconfig \neth0      Link encap:Ethernet  HWaddr 90:E2:BA:15:C9:C4  \n          inet addr:172.18.11.76  Bcast:192.168.1.255  Mask:255.255.0.0\n          inet6 addr: fe80::92e2:baff:fe15:c9c4/64 Scope:Link\n          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1\n          RX packets:9725797 errors:0 dropped:506 overruns:0 frame:0\n          TX packets:21023 errors:0 dropped:0 overruns:0 carrier:0\n          collisions:0 txqueuelen:1000 \n          RX bytes:598731249 (570.9 Mb)  TX bytes:2767270 (2.6 Mb)\n          Memory:fb480000-fb500000 \n\nlo        Link encap:Local Loopback  \n          inet addr:127.0.0.1  Mask:255.0.0.0\n          inet6 addr: ::1/128 Scope:Host\n          UP LOOPBACK RUNNING  MTU:65536  Metric:1\n          RX packets:276 errors:0 dropped:0 overruns:0 frame:0\n          TX packets:276 errors:0 dropped:0 overruns:0 carrier:0\n          collisions:0 txqueuelen:0 \n          RX bytes:25088 (24.5 Kb)  TX bytes:25088 (24.5 Kb)\n```\n\nroute显示路由信息如下：\n\n```\nhw076:/etc/netconfig.d # route\nKernel IP routing table\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\ndefault         *               0.0.0.0         UG    0      0        0 eth0\nloopback        *               255.0.0.0       U     0      0        0 lo\nlink-local      *               255.255.0.0     U     0      0        0 eth0\n172.18.0.0      *               255.255.0.0     U     0      0        0 eth0\n```\n\n原因是route没有配置网关，gateway是空着的。\n\n### 解决方法\n\n通过查看其他可以正常访问的节点的路由信息，得知网关节点为：172.18.0.254。因此增加默认网关节点配置。\n\n执行命令：\n\n```\nroute add default  gw 172.18.0.254\n```\n\n再次查看路由信息：\n\n```\nhw076:~ # route\nKernel IP routing table\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\ndefault         172.18.0.254    0.0.0.0         UG    0      0        0 eth0\nloopback        *               255.0.0.0       U     0      0        0 lo\nlink-local      *               255.255.0.0     U     0      0        0 eth0\n172.18.0.0      *               255.255.0.0     U     0      0        0 eth0\n```\n\n再次ping8.8.8.8显示正常，问题解决。","slug":"ping 问题","published":1,"updated":"2019-11-08T13:16:22.252Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6he13zw003pdstzbknx8w77","content":"<h2 id=\"ping-无法连接外网\"><a href=\"#ping-无法连接外网\" class=\"headerlink\" title=\"ping 无法连接外网\"></a>ping 无法连接外网</h2><a id=\"more\"></a>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>ping外网ping不通</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yky@hw076:~/tmux&gt; ping www.baidu.com</span><br><span class=\"line\">ping: unknown host www.baidu.com</span><br><span class=\"line\">yky@hw076:~/tmux&gt; ping 8.8.8.8</span><br><span class=\"line\">connect: Network is unreachable</span><br></pre></td></tr></table></figure>\n<p>ping内网可以ping通</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hw076:~ # ping 172.18.11.114</span><br><span class=\"line\">PING 172.18.11.114 (172.18.11.114) 56(84) bytes of data.</span><br><span class=\"line\">64 bytes from 172.18.11.114: icmp_seq=1 ttl=64 time=0.193 ms</span><br><span class=\"line\">64 bytes from 172.18.11.114: icmp_seq=2 ttl=64 time=0.216 ms</span><br><span class=\"line\">64 bytes from 172.18.11.114: icmp_seq=3 ttl=64 time=0.207 ms</span><br><span class=\"line\">64 bytes from 172.18.11.114: icmp_seq=4 ttl=64 time=0.200 ms</span><br><span class=\"line\">^C</span><br><span class=\"line\">--- 172.18.11.114 ping statistics ---</span><br><span class=\"line\">4 packets transmitted, 4 received, 0% packet loss, time 2999ms</span><br><span class=\"line\">rtt min/avg/max/mdev = 0.193/0.204/0.216/0.008 ms</span><br></pre></td></tr></table></figure>\n<p>ifconfig信息为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hw076:~ # ifconfig </span><br><span class=\"line\">eth0      Link encap:Ethernet  HWaddr 90:E2:BA:15:C9:C4  </span><br><span class=\"line\">          inet addr:172.18.11.76  Bcast:192.168.1.255  Mask:255.255.0.0</span><br><span class=\"line\">          inet6 addr: fe80::92e2:baff:fe15:c9c4/64 Scope:Link</span><br><span class=\"line\">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class=\"line\">          RX packets:9725797 errors:0 dropped:506 overruns:0 frame:0</span><br><span class=\"line\">          TX packets:21023 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class=\"line\">          collisions:0 txqueuelen:1000 </span><br><span class=\"line\">          RX bytes:598731249 (570.9 Mb)  TX bytes:2767270 (2.6 Mb)</span><br><span class=\"line\">          Memory:fb480000-fb500000 </span><br><span class=\"line\"></span><br><span class=\"line\">lo        Link encap:Local Loopback  </span><br><span class=\"line\">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class=\"line\">          inet6 addr: ::1/128 Scope:Host</span><br><span class=\"line\">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class=\"line\">          RX packets:276 errors:0 dropped:0 overruns:0 frame:0</span><br><span class=\"line\">          TX packets:276 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class=\"line\">          collisions:0 txqueuelen:0 </span><br><span class=\"line\">          RX bytes:25088 (24.5 Kb)  TX bytes:25088 (24.5 Kb)</span><br></pre></td></tr></table></figure>\n<p>route显示路由信息如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hw076:/etc/netconfig.d # route</span><br><span class=\"line\">Kernel IP routing table</span><br><span class=\"line\">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class=\"line\">default         *               0.0.0.0         UG    0      0        0 eth0</span><br><span class=\"line\">loopback        *               255.0.0.0       U     0      0        0 lo</span><br><span class=\"line\">link-local      *               255.255.0.0     U     0      0        0 eth0</span><br><span class=\"line\">172.18.0.0      *               255.255.0.0     U     0      0        0 eth0</span><br></pre></td></tr></table></figure>\n<p>原因是route没有配置网关，gateway是空着的。</p>\n<h3 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h3><p>通过查看其他可以正常访问的节点的路由信息，得知网关节点为：172.18.0.254。因此增加默认网关节点配置。</p>\n<p>执行命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">route add default  gw 172.18.0.254</span><br></pre></td></tr></table></figure>\n<p>再次查看路由信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hw076:~ # route</span><br><span class=\"line\">Kernel IP routing table</span><br><span class=\"line\">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class=\"line\">default         172.18.0.254    0.0.0.0         UG    0      0        0 eth0</span><br><span class=\"line\">loopback        *               255.0.0.0       U     0      0        0 lo</span><br><span class=\"line\">link-local      *               255.255.0.0     U     0      0        0 eth0</span><br><span class=\"line\">172.18.0.0      *               255.255.0.0     U     0      0        0 eth0</span><br></pre></td></tr></table></figure>\n<p>再次ping8.8.8.8显示正常，问题解决。</p>\n","site":{"data":{}},"length":1912,"excerpt":"<h2 id=\"ping-无法连接外网\"><a href=\"#ping-无法连接外网\" class=\"headerlink\" title=\"ping 无法连接外网\"></a>ping 无法连接外网</h2>","more":"<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>ping外网ping不通</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yky@hw076:~/tmux&gt; ping www.baidu.com</span><br><span class=\"line\">ping: unknown host www.baidu.com</span><br><span class=\"line\">yky@hw076:~/tmux&gt; ping 8.8.8.8</span><br><span class=\"line\">connect: Network is unreachable</span><br></pre></td></tr></table></figure>\n<p>ping内网可以ping通</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hw076:~ # ping 172.18.11.114</span><br><span class=\"line\">PING 172.18.11.114 (172.18.11.114) 56(84) bytes of data.</span><br><span class=\"line\">64 bytes from 172.18.11.114: icmp_seq=1 ttl=64 time=0.193 ms</span><br><span class=\"line\">64 bytes from 172.18.11.114: icmp_seq=2 ttl=64 time=0.216 ms</span><br><span class=\"line\">64 bytes from 172.18.11.114: icmp_seq=3 ttl=64 time=0.207 ms</span><br><span class=\"line\">64 bytes from 172.18.11.114: icmp_seq=4 ttl=64 time=0.200 ms</span><br><span class=\"line\">^C</span><br><span class=\"line\">--- 172.18.11.114 ping statistics ---</span><br><span class=\"line\">4 packets transmitted, 4 received, 0% packet loss, time 2999ms</span><br><span class=\"line\">rtt min/avg/max/mdev = 0.193/0.204/0.216/0.008 ms</span><br></pre></td></tr></table></figure>\n<p>ifconfig信息为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hw076:~ # ifconfig </span><br><span class=\"line\">eth0      Link encap:Ethernet  HWaddr 90:E2:BA:15:C9:C4  </span><br><span class=\"line\">          inet addr:172.18.11.76  Bcast:192.168.1.255  Mask:255.255.0.0</span><br><span class=\"line\">          inet6 addr: fe80::92e2:baff:fe15:c9c4/64 Scope:Link</span><br><span class=\"line\">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class=\"line\">          RX packets:9725797 errors:0 dropped:506 overruns:0 frame:0</span><br><span class=\"line\">          TX packets:21023 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class=\"line\">          collisions:0 txqueuelen:1000 </span><br><span class=\"line\">          RX bytes:598731249 (570.9 Mb)  TX bytes:2767270 (2.6 Mb)</span><br><span class=\"line\">          Memory:fb480000-fb500000 </span><br><span class=\"line\"></span><br><span class=\"line\">lo        Link encap:Local Loopback  </span><br><span class=\"line\">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class=\"line\">          inet6 addr: ::1/128 Scope:Host</span><br><span class=\"line\">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class=\"line\">          RX packets:276 errors:0 dropped:0 overruns:0 frame:0</span><br><span class=\"line\">          TX packets:276 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class=\"line\">          collisions:0 txqueuelen:0 </span><br><span class=\"line\">          RX bytes:25088 (24.5 Kb)  TX bytes:25088 (24.5 Kb)</span><br></pre></td></tr></table></figure>\n<p>route显示路由信息如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hw076:/etc/netconfig.d # route</span><br><span class=\"line\">Kernel IP routing table</span><br><span class=\"line\">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class=\"line\">default         *               0.0.0.0         UG    0      0        0 eth0</span><br><span class=\"line\">loopback        *               255.0.0.0       U     0      0        0 lo</span><br><span class=\"line\">link-local      *               255.255.0.0     U     0      0        0 eth0</span><br><span class=\"line\">172.18.0.0      *               255.255.0.0     U     0      0        0 eth0</span><br></pre></td></tr></table></figure>\n<p>原因是route没有配置网关，gateway是空着的。</p>\n<h3 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h3><p>通过查看其他可以正常访问的节点的路由信息，得知网关节点为：172.18.0.254。因此增加默认网关节点配置。</p>\n<p>执行命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">route add default  gw 172.18.0.254</span><br></pre></td></tr></table></figure>\n<p>再次查看路由信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hw076:~ # route</span><br><span class=\"line\">Kernel IP routing table</span><br><span class=\"line\">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class=\"line\">default         172.18.0.254    0.0.0.0         UG    0      0        0 eth0</span><br><span class=\"line\">loopback        *               255.0.0.0       U     0      0        0 lo</span><br><span class=\"line\">link-local      *               255.255.0.0     U     0      0        0 eth0</span><br><span class=\"line\">172.18.0.0      *               255.255.0.0     U     0      0        0 eth0</span><br></pre></td></tr></table></figure>\n<p>再次ping8.8.8.8显示正常，问题解决。</p>"},{"title":"tee命令解析","date":"2018-06-23T09:21:19.000Z","copyright":true,"_content":"\n# make 2>&1 | tee log.txt 命令解析\n\n在安装mpich 的时候遇到了很多这个命令，此处学习下这个命令：`2>&1 | tee log.txt` \n\n<!--more-->\n\n这个命令共有三个部分： `2>&1` `|`  `tee log.txt`\n\n## 2>&1\n\nshell中：最常使用的 FD (file descriptor) 大概有三个 \n\n0表示标准输入Standard Input (STDIN)  \n\n1表示标准输出Standard Output (STDOUT)  \n\n 2表示标准错误输出 Standard Error Output (STDERR)  \n\n'>' 默认为标准输出重定向 （类似于c++ 中的 >>？）\n\n在标准情况下, 这些FD分别跟如下设备关联 \n\nstdin(0): keyboard  键盘输入,并返回在前端   \n\nstdout(1): monitor  正确返回值 输出到前端   \n\nstderr(2): monitor 错误返回值 输出到前端  \n\n1>&2  正确返回值传递给2输出通道 &2表示2输出通道   如果此处错写成 1>2, 就表示把1输出重定向到文件2中  2>&1 错误返回值传递给1输出通道, 同样&1表示1输出通道.  \n\n## |管道\n\n管道的作用是提供一个通道，将上一个程序的标准输出重定向到下一个程序作为下一个程序的标准输入。 \n\n## tee log.txt\n\ntee从标准输入中读取，并将读入的内容写到标准输出以及文件中。  此处将数据读入并写入到log.txt中\n\n## 总结\n\n这个命令将标准错误输出重定向到标准输出，然后再将标准输出重定向到log.txt文件中\n\n常用于make 后面将log信息保存下来。","source":"_posts/tee命令解析.md","raw":"---\ntitle: tee命令解析\ndate: 2018-06-23 17:21:19\ncategories: Linux\ntags: \n- Linux\n- command\ncopyright: true\n---\n\n# make 2>&1 | tee log.txt 命令解析\n\n在安装mpich 的时候遇到了很多这个命令，此处学习下这个命令：`2>&1 | tee log.txt` \n\n<!--more-->\n\n这个命令共有三个部分： `2>&1` `|`  `tee log.txt`\n\n## 2>&1\n\nshell中：最常使用的 FD (file descriptor) 大概有三个 \n\n0表示标准输入Standard Input (STDIN)  \n\n1表示标准输出Standard Output (STDOUT)  \n\n 2表示标准错误输出 Standard Error Output (STDERR)  \n\n'>' 默认为标准输出重定向 （类似于c++ 中的 >>？）\n\n在标准情况下, 这些FD分别跟如下设备关联 \n\nstdin(0): keyboard  键盘输入,并返回在前端   \n\nstdout(1): monitor  正确返回值 输出到前端   \n\nstderr(2): monitor 错误返回值 输出到前端  \n\n1>&2  正确返回值传递给2输出通道 &2表示2输出通道   如果此处错写成 1>2, 就表示把1输出重定向到文件2中  2>&1 错误返回值传递给1输出通道, 同样&1表示1输出通道.  \n\n## |管道\n\n管道的作用是提供一个通道，将上一个程序的标准输出重定向到下一个程序作为下一个程序的标准输入。 \n\n## tee log.txt\n\ntee从标准输入中读取，并将读入的内容写到标准输出以及文件中。  此处将数据读入并写入到log.txt中\n\n## 总结\n\n这个命令将标准错误输出重定向到标准输出，然后再将标准输出重定向到log.txt文件中\n\n常用于make 后面将log信息保存下来。","slug":"tee命令解析","published":1,"updated":"2019-11-14T03:15:41.475Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6he1400003udstzj1uuzlwf","content":"<h1 id=\"make-2-gt-amp-1-tee-log-txt-命令解析\"><a href=\"#make-2-gt-amp-1-tee-log-txt-命令解析\" class=\"headerlink\" title=\"make 2&gt;&amp;1 | tee log.txt 命令解析\"></a>make 2&gt;&amp;1 | tee log.txt 命令解析</h1><p>在安装mpich 的时候遇到了很多这个命令，此处学习下这个命令：<code>2&gt;&amp;1 | tee log.txt</code> </p>\n<a id=\"more\"></a>\n<p>这个命令共有三个部分： <code>2&gt;&amp;1</code> <code>|</code>  <code>tee log.txt</code></p>\n<h2 id=\"2-gt-amp-1\"><a href=\"#2-gt-amp-1\" class=\"headerlink\" title=\"2&gt;&amp;1\"></a>2&gt;&amp;1</h2><p>shell中：最常使用的 FD (file descriptor) 大概有三个 </p>\n<p>0表示标准输入Standard Input (STDIN)  </p>\n<p>1表示标准输出Standard Output (STDOUT)  </p>\n<p> 2表示标准错误输出 Standard Error Output (STDERR)  </p>\n<p>‘&gt;’ 默认为标准输出重定向 （类似于c++ 中的 &gt;&gt;？）</p>\n<p>在标准情况下, 这些FD分别跟如下设备关联 </p>\n<p>stdin(0): keyboard  键盘输入,并返回在前端   </p>\n<p>stdout(1): monitor  正确返回值 输出到前端   </p>\n<p>stderr(2): monitor 错误返回值 输出到前端  </p>\n<p>1&gt;&amp;2  正确返回值传递给2输出通道 &amp;2表示2输出通道   如果此处错写成 1&gt;2, 就表示把1输出重定向到文件2中  2&gt;&amp;1 错误返回值传递给1输出通道, 同样&amp;1表示1输出通道.  </p>\n<h2 id=\"管道\"><a href=\"#管道\" class=\"headerlink\" title=\"|管道\"></a>|管道</h2><p>管道的作用是提供一个通道，将上一个程序的标准输出重定向到下一个程序作为下一个程序的标准输入。 </p>\n<h2 id=\"tee-log-txt\"><a href=\"#tee-log-txt\" class=\"headerlink\" title=\"tee log.txt\"></a>tee log.txt</h2><p>tee从标准输入中读取，并将读入的内容写到标准输出以及文件中。  此处将数据读入并写入到log.txt中</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>这个命令将标准错误输出重定向到标准输出，然后再将标准输出重定向到log.txt文件中</p>\n<p>常用于make 后面将log信息保存下来。</p>\n","site":{"data":{}},"length":671,"excerpt":"<h1 id=\"make-2-gt-amp-1-tee-log-txt-命令解析\"><a href=\"#make-2-gt-amp-1-tee-log-txt-命令解析\" class=\"headerlink\" title=\"make 2&gt;&amp;1 | tee log.txt 命令解析\"></a>make 2&gt;&amp;1 | tee log.txt 命令解析</h1><p>在安装mpich 的时候遇到了很多这个命令，此处学习下这个命令：<code>2&gt;&amp;1 | tee log.txt</code> </p>","more":"<p>这个命令共有三个部分： <code>2&gt;&amp;1</code> <code>|</code>  <code>tee log.txt</code></p>\n<h2 id=\"2-gt-amp-1\"><a href=\"#2-gt-amp-1\" class=\"headerlink\" title=\"2&gt;&amp;1\"></a>2&gt;&amp;1</h2><p>shell中：最常使用的 FD (file descriptor) 大概有三个 </p>\n<p>0表示标准输入Standard Input (STDIN)  </p>\n<p>1表示标准输出Standard Output (STDOUT)  </p>\n<p> 2表示标准错误输出 Standard Error Output (STDERR)  </p>\n<p>‘&gt;’ 默认为标准输出重定向 （类似于c++ 中的 &gt;&gt;？）</p>\n<p>在标准情况下, 这些FD分别跟如下设备关联 </p>\n<p>stdin(0): keyboard  键盘输入,并返回在前端   </p>\n<p>stdout(1): monitor  正确返回值 输出到前端   </p>\n<p>stderr(2): monitor 错误返回值 输出到前端  </p>\n<p>1&gt;&amp;2  正确返回值传递给2输出通道 &amp;2表示2输出通道   如果此处错写成 1&gt;2, 就表示把1输出重定向到文件2中  2&gt;&amp;1 错误返回值传递给1输出通道, 同样&amp;1表示1输出通道.  </p>\n<h2 id=\"管道\"><a href=\"#管道\" class=\"headerlink\" title=\"|管道\"></a>|管道</h2><p>管道的作用是提供一个通道，将上一个程序的标准输出重定向到下一个程序作为下一个程序的标准输入。 </p>\n<h2 id=\"tee-log-txt\"><a href=\"#tee-log-txt\" class=\"headerlink\" title=\"tee log.txt\"></a>tee log.txt</h2><p>tee从标准输入中读取，并将读入的内容写到标准输出以及文件中。  此处将数据读入并写入到log.txt中</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>这个命令将标准错误输出重定向到标准输出，然后再将标准输出重定向到log.txt文件中</p>\n<p>常用于make 后面将log信息保存下来。</p>"},{"title":"图计算常用算法","date":"2018-04-24T03:20:17.000Z","copyright":true,"_content":"\n# 图算法的典型操作\n\n关于一些常见图算法的调研与学习。\n\n<!--more-->\n\n## 常用图算法\n\n### PageRank\n\n1. 背景\t\n\n   1. 既考虑入链数量，又考虑了网页质量因素，二者相结合 数量与权重的结合\n   2. 算法与主题无关，因为PR值是根据图计算出来的\n\n2. 算法原理\n\n   1. 基本思想\n\n      A有链接指向B，表明A认为B比A重要。A将自身权重分配一部分给B。\n\n      $W(B)=W(A)/N$   W(A) 是A的PR值，W(B)是A 分配的权重，N是A的出链数\n\n   2. PageRank公式修正\n\n      存在出链为0的孤立网页，增加阻力系数q ，一般取q=0.85，其意义是用户有1-q的概率不点击此页面上面的所有链接。同时还有随机直接跳转的概率，如直接输入网址，点击书签等。完整公式如下：\n\n      ![](E:\\data\\ict\\docs\\page rank.png)\n\n### Connected component\n\n1. 定义\n   1. 连通分支：图中，某个子图的任意两点有边连接，而子图之间无边连接\n   2. 问题：cc是寻找连通分支的算法？？\n2. 通过BFS、DFS算法的便利就可以找到连通分支，每个白色节点开始的就是一个连通分支。\n3. 常见算法\n   1. DFS\n      1. 原理：访问某个顶点后只有当某个节点是叶结点后才会访问其余相邻节点。\n      2. 步骤：\n         1. 选择一个结点作为起始结点，标记为灰色\n         2. 从该节点的邻居结点中选择一个结点，标记为灰色，继续这个操作\n         3. 当选中的结点时叶子结点时，将其涂黑并返回到上一个父节点。\n         4. 重复2,3直到所有结点都被访问。\n   2. BFS   （DFS，BFS不是图的遍历算法吗）。\n      1. 原理：在进一步遍历中顶点之前，先访问当前结点的所有邻接结点。\n      2. 步骤：\n         1. 选择一个顶点作为起始节点，放入队列，标记为灰色，其余标记为白色\n         2. 寻找队列首部结点的所有邻居节点，将其放入队列中并标记为灰色，将队列首部结点出队，并标记为黑色  \n         3. 重复2步骤，直到队列中的节点全部为空。\n\n### SSSP (single-source shortest paths)\n\n1. 单独的起点与目标点之间最短路径的计算。起点固定，寻找与其他所有结点之间的最短路径。包括单源单汇，单源多汇\n2. 常见算法\n   1. Dijkstra\n      1. 步骤\n         1. 将所有顶点分成两个集合A、B，其中集合A表示已经求得从V0出发的最短路径的顶点集合，集合B为为待求解的顶点集合。初始时有A={V0}\n         2. 将集合A与集合B相连的边（A中的所有结点与B中所有的结点形成的边）按照从V0出发的最短权重和递增次序排序，取最短的边，将该条边在集合B中所对应的顶点加入到集合A中\n         3. 重复第二步，直至B为空集。\n      2. 总结：\n         1. 最短中的最短：每次迭代时比较的是当前状态下以V0为起点，A中顶点为中间点的到各顶点之间的最短路径权重，最后再选择在当前所有最短路径中路径最短的一个顶点加入A。也就是说每次加入A集合的点是最短路径中的最短。\n         2. 给定目标点，在每次迭代时，并不知道能否到达最后的目标点，所以把到所有结点的最短距离都算出来了。\n\n### Betweenness Centrality（中介中心性）\n\n1. 定义 ：中心性用来衡量节结点的重要性。Betweenness Centrality ：考虑的是该节点出现在其他两节点之间的最短路径上的比率。\n\n2. 思想：如果一个成员位于其他成员的多条最短路上，那么该成员就是核心成员，就具有较大的中介中心性。\n\n3. 步骤\n\n   其中![\\sigma_{st}](https://i2.wp.com/upload.wikimedia.org/math/b/b/7/bb79bd91213d03edf0c8fc04fbd51085.png)表示的是节点s和t之间的最短路径的数量，而![\\sigma_{st}(v)](https://i2.wp.com/upload.wikimedia.org/math/4/2/c/42c33f5f78864175f0d9c9af1c492f5d.png)是最短路径中经过节点v的数量。\n\n   1. 计算各个点对之间最短路径的长度和条数，用于计算pair-dependencies: δst(v) =σst(v)/σst\n\n      ![clip_image004](http://static.oschina.net/uploads/img/201305/11121047_IQnh.jpg)\n\n   2. 对于每个节点，累积属于自己的pair-dependencies\n\n   ![](https://i2.wp.com/upload.wikimedia.org/math/4/c/c/4cc6eaa2dce9d504feeed5bd88b96d73.png)\n\n### LBP算法(Local Binary Pattern, 局部二值模式)\n\n1. 定义：LBP是一种用来描述图像局部纹理特征的算子。\n\n   1. 原始的LBP算子定义为在3*3的窗口内，以窗口中心像素为阈值，将相邻的8个像素的灰度值与其进行比较，若周围像素值大于中心像素值，则该像素点的位置被标记为1，否则为0\n\n   ![img](http://hi.csdn.net/attachment/201104/13/0_1302700245WllL.gif)\n\n2. 作用是进行特征提取，而且，提取的特征是图像的纹理特征，并且，是局部的纹理特征.\n\n3. 改进版本\n\n   1. 原型LBP算子 \n   2. LBP等价模式\n\n### 最小生成树\n\n1. 定义：无环连通图，图中所有结点均参与，所有边的权重加起来最小。\n2. 算法\n   1. Prim算法  \n      1. 步骤：设N=(V,{E})是连通网， TE是N上最小生成树中边的集合 \n         1. 初始令U={u0},(u0V), TE=φ\n         2. 在所有uU,vV-U的边(u,v)E中，找一条代价最小\n            的边(u0,v0), 并保证不形成回路 \n         3. 将(u0,v0)并入集合TE，同时v0并入U \n         4. 重复上述操作直至U=V为止，则T=(V,{TE})为N的\n            最小生成树  \n      2. 总结：每次迭代加入所有连通边中权值最小的。\n\n### 三角计数\n\n1. 定义：寻找无向图中的所有三角形\n2. 步骤\n   1. 建立邻接表：\n      1. 如果A-B & A < B，则将B加入A的邻接表 如果A-B & B < A，则将A加入B的邻接表  A<B比较的是id\n   2. 遍历每个节点，对于结点A，遍历A邻接表中的结点，如果邻接结点B,C两两之间存在边，则A、B、C三者之间存在三角形\n\n### 社区发现\n\n1. 社区定义：同一社区内的节点与节点之间的连接很紧密，而社区与社区之间的连接比较稀疏。社区是一个子图\n\n2. 数学描述：![](https://img-blog.csdn.net/20130710080910046)\n\n3. 衡量标准：模块度\n\n   1. 计算公式\n\n   ![](https://img-blog.csdn.net/20130710081032203)\n\n4. 常见算法\n\n   1. GN算法\n      1. 思想：在一个网络之中，通过社区内部的边的最短路径相对较少，而通过社区之间的边的最短路径的数目则相对较多。从社区内部走大概率会走很多条边。\n      2. 步骤\n         1. 计算每一条边的边介数。边介数（betweenness）：网络中任意两个节点通过此边的最短路径的数目。\n         2. 删除边介数最大的边\n         3. 重复（1）（2），直到网络中的任一顶点作为一个社区为止。\n      3. 缺陷\n         1. 不知道最后会有多少个社区\n         2. 在计算边介数的时候可能会有很对重复计算最短路径的情况，时间复杂度太高\n         3. GN算法不能判断算法终止位置\n   2. LPA算法（标签传播算法）\n      1. 思路\n         1. 自己是什么标签，由邻居决定。邻居中什么标签最多，则此结点是什么标签\n      2. 步骤\n         1. 为所有结点指定一个唯一的标签\n         2. 逐轮刷新所有结点的标签，直到达到收敛要求位置。刷新规则： 对于某一个节点，考察其所有邻居节点的标签，并进行统计，将出现个数最多的那个标签赋给当前节点。当个数最多的标签不唯一时，随机选一个。\n\n### 拓扑排序\n\n1. 定义 ：**拓扑排序（Topological Sorting）**是一个**有向无环图（DAG, Directed Acyclic Graph）**的所有顶点的线性序列。且该序列必须满足下面两个条件：\n   1. 每个顶点出现且只出现一次\n   2. 若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面\n2. 步骤\n   1. 从 DAG 图中选择一个 没有前驱（即入度为0）的顶点并输出\n   2. 从图中删除该顶点和所有以它为起点的有向边\n   3. 重复 1 和 2 直到当前的 DAG 图为空或**当前图中不存在无前驱的顶点为止**。后一种情况说明有向图中必然存在环\n      ![img](http://img.blog.csdn.net/20150507001759702)\n\n","source":"_posts/图计算常用算法.md","raw":"---\ntitle: 图计算常用算法\ndate: 2018-04-24 11:20:17\ncategories: algorithm\ntags:\n- graph \ncopyright: true\n---\n\n# 图算法的典型操作\n\n关于一些常见图算法的调研与学习。\n\n<!--more-->\n\n## 常用图算法\n\n### PageRank\n\n1. 背景\t\n\n   1. 既考虑入链数量，又考虑了网页质量因素，二者相结合 数量与权重的结合\n   2. 算法与主题无关，因为PR值是根据图计算出来的\n\n2. 算法原理\n\n   1. 基本思想\n\n      A有链接指向B，表明A认为B比A重要。A将自身权重分配一部分给B。\n\n      $W(B)=W(A)/N$   W(A) 是A的PR值，W(B)是A 分配的权重，N是A的出链数\n\n   2. PageRank公式修正\n\n      存在出链为0的孤立网页，增加阻力系数q ，一般取q=0.85，其意义是用户有1-q的概率不点击此页面上面的所有链接。同时还有随机直接跳转的概率，如直接输入网址，点击书签等。完整公式如下：\n\n      ![](E:\\data\\ict\\docs\\page rank.png)\n\n### Connected component\n\n1. 定义\n   1. 连通分支：图中，某个子图的任意两点有边连接，而子图之间无边连接\n   2. 问题：cc是寻找连通分支的算法？？\n2. 通过BFS、DFS算法的便利就可以找到连通分支，每个白色节点开始的就是一个连通分支。\n3. 常见算法\n   1. DFS\n      1. 原理：访问某个顶点后只有当某个节点是叶结点后才会访问其余相邻节点。\n      2. 步骤：\n         1. 选择一个结点作为起始结点，标记为灰色\n         2. 从该节点的邻居结点中选择一个结点，标记为灰色，继续这个操作\n         3. 当选中的结点时叶子结点时，将其涂黑并返回到上一个父节点。\n         4. 重复2,3直到所有结点都被访问。\n   2. BFS   （DFS，BFS不是图的遍历算法吗）。\n      1. 原理：在进一步遍历中顶点之前，先访问当前结点的所有邻接结点。\n      2. 步骤：\n         1. 选择一个顶点作为起始节点，放入队列，标记为灰色，其余标记为白色\n         2. 寻找队列首部结点的所有邻居节点，将其放入队列中并标记为灰色，将队列首部结点出队，并标记为黑色  \n         3. 重复2步骤，直到队列中的节点全部为空。\n\n### SSSP (single-source shortest paths)\n\n1. 单独的起点与目标点之间最短路径的计算。起点固定，寻找与其他所有结点之间的最短路径。包括单源单汇，单源多汇\n2. 常见算法\n   1. Dijkstra\n      1. 步骤\n         1. 将所有顶点分成两个集合A、B，其中集合A表示已经求得从V0出发的最短路径的顶点集合，集合B为为待求解的顶点集合。初始时有A={V0}\n         2. 将集合A与集合B相连的边（A中的所有结点与B中所有的结点形成的边）按照从V0出发的最短权重和递增次序排序，取最短的边，将该条边在集合B中所对应的顶点加入到集合A中\n         3. 重复第二步，直至B为空集。\n      2. 总结：\n         1. 最短中的最短：每次迭代时比较的是当前状态下以V0为起点，A中顶点为中间点的到各顶点之间的最短路径权重，最后再选择在当前所有最短路径中路径最短的一个顶点加入A。也就是说每次加入A集合的点是最短路径中的最短。\n         2. 给定目标点，在每次迭代时，并不知道能否到达最后的目标点，所以把到所有结点的最短距离都算出来了。\n\n### Betweenness Centrality（中介中心性）\n\n1. 定义 ：中心性用来衡量节结点的重要性。Betweenness Centrality ：考虑的是该节点出现在其他两节点之间的最短路径上的比率。\n\n2. 思想：如果一个成员位于其他成员的多条最短路上，那么该成员就是核心成员，就具有较大的中介中心性。\n\n3. 步骤\n\n   其中![\\sigma_{st}](https://i2.wp.com/upload.wikimedia.org/math/b/b/7/bb79bd91213d03edf0c8fc04fbd51085.png)表示的是节点s和t之间的最短路径的数量，而![\\sigma_{st}(v)](https://i2.wp.com/upload.wikimedia.org/math/4/2/c/42c33f5f78864175f0d9c9af1c492f5d.png)是最短路径中经过节点v的数量。\n\n   1. 计算各个点对之间最短路径的长度和条数，用于计算pair-dependencies: δst(v) =σst(v)/σst\n\n      ![clip_image004](http://static.oschina.net/uploads/img/201305/11121047_IQnh.jpg)\n\n   2. 对于每个节点，累积属于自己的pair-dependencies\n\n   ![](https://i2.wp.com/upload.wikimedia.org/math/4/c/c/4cc6eaa2dce9d504feeed5bd88b96d73.png)\n\n### LBP算法(Local Binary Pattern, 局部二值模式)\n\n1. 定义：LBP是一种用来描述图像局部纹理特征的算子。\n\n   1. 原始的LBP算子定义为在3*3的窗口内，以窗口中心像素为阈值，将相邻的8个像素的灰度值与其进行比较，若周围像素值大于中心像素值，则该像素点的位置被标记为1，否则为0\n\n   ![img](http://hi.csdn.net/attachment/201104/13/0_1302700245WllL.gif)\n\n2. 作用是进行特征提取，而且，提取的特征是图像的纹理特征，并且，是局部的纹理特征.\n\n3. 改进版本\n\n   1. 原型LBP算子 \n   2. LBP等价模式\n\n### 最小生成树\n\n1. 定义：无环连通图，图中所有结点均参与，所有边的权重加起来最小。\n2. 算法\n   1. Prim算法  \n      1. 步骤：设N=(V,{E})是连通网， TE是N上最小生成树中边的集合 \n         1. 初始令U={u0},(u0V), TE=φ\n         2. 在所有uU,vV-U的边(u,v)E中，找一条代价最小\n            的边(u0,v0), 并保证不形成回路 \n         3. 将(u0,v0)并入集合TE，同时v0并入U \n         4. 重复上述操作直至U=V为止，则T=(V,{TE})为N的\n            最小生成树  \n      2. 总结：每次迭代加入所有连通边中权值最小的。\n\n### 三角计数\n\n1. 定义：寻找无向图中的所有三角形\n2. 步骤\n   1. 建立邻接表：\n      1. 如果A-B & A < B，则将B加入A的邻接表 如果A-B & B < A，则将A加入B的邻接表  A<B比较的是id\n   2. 遍历每个节点，对于结点A，遍历A邻接表中的结点，如果邻接结点B,C两两之间存在边，则A、B、C三者之间存在三角形\n\n### 社区发现\n\n1. 社区定义：同一社区内的节点与节点之间的连接很紧密，而社区与社区之间的连接比较稀疏。社区是一个子图\n\n2. 数学描述：![](https://img-blog.csdn.net/20130710080910046)\n\n3. 衡量标准：模块度\n\n   1. 计算公式\n\n   ![](https://img-blog.csdn.net/20130710081032203)\n\n4. 常见算法\n\n   1. GN算法\n      1. 思想：在一个网络之中，通过社区内部的边的最短路径相对较少，而通过社区之间的边的最短路径的数目则相对较多。从社区内部走大概率会走很多条边。\n      2. 步骤\n         1. 计算每一条边的边介数。边介数（betweenness）：网络中任意两个节点通过此边的最短路径的数目。\n         2. 删除边介数最大的边\n         3. 重复（1）（2），直到网络中的任一顶点作为一个社区为止。\n      3. 缺陷\n         1. 不知道最后会有多少个社区\n         2. 在计算边介数的时候可能会有很对重复计算最短路径的情况，时间复杂度太高\n         3. GN算法不能判断算法终止位置\n   2. LPA算法（标签传播算法）\n      1. 思路\n         1. 自己是什么标签，由邻居决定。邻居中什么标签最多，则此结点是什么标签\n      2. 步骤\n         1. 为所有结点指定一个唯一的标签\n         2. 逐轮刷新所有结点的标签，直到达到收敛要求位置。刷新规则： 对于某一个节点，考察其所有邻居节点的标签，并进行统计，将出现个数最多的那个标签赋给当前节点。当个数最多的标签不唯一时，随机选一个。\n\n### 拓扑排序\n\n1. 定义 ：**拓扑排序（Topological Sorting）**是一个**有向无环图（DAG, Directed Acyclic Graph）**的所有顶点的线性序列。且该序列必须满足下面两个条件：\n   1. 每个顶点出现且只出现一次\n   2. 若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面\n2. 步骤\n   1. 从 DAG 图中选择一个 没有前驱（即入度为0）的顶点并输出\n   2. 从图中删除该顶点和所有以它为起点的有向边\n   3. 重复 1 和 2 直到当前的 DAG 图为空或**当前图中不存在无前驱的顶点为止**。后一种情况说明有向图中必然存在环\n      ![img](http://img.blog.csdn.net/20150507001759702)\n\n","slug":"图计算常用算法","published":1,"updated":"2019-11-08T13:15:48.042Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6he1401003xdstz7btpg812","content":"<h1 id=\"图算法的典型操作\"><a href=\"#图算法的典型操作\" class=\"headerlink\" title=\"图算法的典型操作\"></a>图算法的典型操作</h1><p>关于一些常见图算法的调研与学习。</p>\n<a id=\"more\"></a>\n<h2 id=\"常用图算法\"><a href=\"#常用图算法\" class=\"headerlink\" title=\"常用图算法\"></a>常用图算法</h2><h3 id=\"PageRank\"><a href=\"#PageRank\" class=\"headerlink\" title=\"PageRank\"></a>PageRank</h3><ol>\n<li><p>背景    </p>\n<ol>\n<li>既考虑入链数量，又考虑了网页质量因素，二者相结合 数量与权重的结合</li>\n<li>算法与主题无关，因为PR值是根据图计算出来的</li>\n</ol>\n</li>\n<li><p>算法原理</p>\n<ol>\n<li><p>基本思想</p>\n<p>A有链接指向B，表明A认为B比A重要。A将自身权重分配一部分给B。</p>\n<p>$W(B)=W(A)/N$   W(A) 是A的PR值，W(B)是A 分配的权重，N是A的出链数</p>\n</li>\n<li><p>PageRank公式修正</p>\n<p>存在出链为0的孤立网页，增加阻力系数q ，一般取q=0.85，其意义是用户有1-q的概率不点击此页面上面的所有链接。同时还有随机直接跳转的概率，如直接输入网址，点击书签等。完整公式如下：</p>\n<p><img src=\"E:\\data\\ict\\docs\\page rank.png\" alt=\"\"></p>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"Connected-component\"><a href=\"#Connected-component\" class=\"headerlink\" title=\"Connected component\"></a>Connected component</h3><ol>\n<li>定义<ol>\n<li>连通分支：图中，某个子图的任意两点有边连接，而子图之间无边连接</li>\n<li>问题：cc是寻找连通分支的算法？？</li>\n</ol>\n</li>\n<li>通过BFS、DFS算法的便利就可以找到连通分支，每个白色节点开始的就是一个连通分支。</li>\n<li>常见算法<ol>\n<li>DFS<ol>\n<li>原理：访问某个顶点后只有当某个节点是叶结点后才会访问其余相邻节点。</li>\n<li>步骤：<ol>\n<li>选择一个结点作为起始结点，标记为灰色</li>\n<li>从该节点的邻居结点中选择一个结点，标记为灰色，继续这个操作</li>\n<li>当选中的结点时叶子结点时，将其涂黑并返回到上一个父节点。</li>\n<li>重复2,3直到所有结点都被访问。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>BFS   （DFS，BFS不是图的遍历算法吗）。<ol>\n<li>原理：在进一步遍历中顶点之前，先访问当前结点的所有邻接结点。</li>\n<li>步骤：<ol>\n<li>选择一个顶点作为起始节点，放入队列，标记为灰色，其余标记为白色</li>\n<li>寻找队列首部结点的所有邻居节点，将其放入队列中并标记为灰色，将队列首部结点出队，并标记为黑色  </li>\n<li>重复2步骤，直到队列中的节点全部为空。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"SSSP-single-source-shortest-paths\"><a href=\"#SSSP-single-source-shortest-paths\" class=\"headerlink\" title=\"SSSP (single-source shortest paths)\"></a>SSSP (single-source shortest paths)</h3><ol>\n<li>单独的起点与目标点之间最短路径的计算。起点固定，寻找与其他所有结点之间的最短路径。包括单源单汇，单源多汇</li>\n<li>常见算法<ol>\n<li>Dijkstra<ol>\n<li>步骤<ol>\n<li>将所有顶点分成两个集合A、B，其中集合A表示已经求得从V0出发的最短路径的顶点集合，集合B为为待求解的顶点集合。初始时有A={V0}</li>\n<li>将集合A与集合B相连的边（A中的所有结点与B中所有的结点形成的边）按照从V0出发的最短权重和递增次序排序，取最短的边，将该条边在集合B中所对应的顶点加入到集合A中</li>\n<li>重复第二步，直至B为空集。</li>\n</ol>\n</li>\n<li>总结：<ol>\n<li>最短中的最短：每次迭代时比较的是当前状态下以V0为起点，A中顶点为中间点的到各顶点之间的最短路径权重，最后再选择在当前所有最短路径中路径最短的一个顶点加入A。也就是说每次加入A集合的点是最短路径中的最短。</li>\n<li>给定目标点，在每次迭代时，并不知道能否到达最后的目标点，所以把到所有结点的最短距离都算出来了。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"Betweenness-Centrality（中介中心性）\"><a href=\"#Betweenness-Centrality（中介中心性）\" class=\"headerlink\" title=\"Betweenness Centrality（中介中心性）\"></a>Betweenness Centrality（中介中心性）</h3><ol>\n<li><p>定义 ：中心性用来衡量节结点的重要性。Betweenness Centrality ：考虑的是该节点出现在其他两节点之间的最短路径上的比率。</p>\n</li>\n<li><p>思想：如果一个成员位于其他成员的多条最短路上，那么该成员就是核心成员，就具有较大的中介中心性。</p>\n</li>\n<li><p>步骤</p>\n<p>其中<img src=\"https://i2.wp.com/upload.wikimedia.org/math/b/b/7/bb79bd91213d03edf0c8fc04fbd51085.png\" alt=\"\\sigma_{st}\">表示的是节点s和t之间的最短路径的数量，而<img src=\"https://i2.wp.com/upload.wikimedia.org/math/4/2/c/42c33f5f78864175f0d9c9af1c492f5d.png\" alt=\"\\sigma_{st}(v)\">是最短路径中经过节点v的数量。</p>\n<ol>\n<li><p>计算各个点对之间最短路径的长度和条数，用于计算pair-dependencies: δst(v) =σst(v)/σst</p>\n<p><img src=\"http://static.oschina.net/uploads/img/201305/11121047_IQnh.jpg\" alt=\"clip_image004\"></p>\n</li>\n<li><p>对于每个节点，累积属于自己的pair-dependencies</p>\n</li>\n</ol>\n<p><img src=\"https://i2.wp.com/upload.wikimedia.org/math/4/c/c/4cc6eaa2dce9d504feeed5bd88b96d73.png\" alt=\"\"></p>\n</li>\n</ol>\n<h3 id=\"LBP算法-Local-Binary-Pattern-局部二值模式\"><a href=\"#LBP算法-Local-Binary-Pattern-局部二值模式\" class=\"headerlink\" title=\"LBP算法(Local Binary Pattern, 局部二值模式)\"></a>LBP算法(Local Binary Pattern, 局部二值模式)</h3><ol>\n<li><p>定义：LBP是一种用来描述图像局部纹理特征的算子。</p>\n<ol>\n<li>原始的LBP算子定义为在3*3的窗口内，以窗口中心像素为阈值，将相邻的8个像素的灰度值与其进行比较，若周围像素值大于中心像素值，则该像素点的位置被标记为1，否则为0</li>\n</ol>\n<p><img src=\"http://hi.csdn.net/attachment/201104/13/0_1302700245WllL.gif\" alt=\"img\"></p>\n</li>\n<li><p>作用是进行特征提取，而且，提取的特征是图像的纹理特征，并且，是局部的纹理特征.</p>\n</li>\n<li><p>改进版本</p>\n<ol>\n<li>原型LBP算子 </li>\n<li>LBP等价模式</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"最小生成树\"><a href=\"#最小生成树\" class=\"headerlink\" title=\"最小生成树\"></a>最小生成树</h3><ol>\n<li>定义：无环连通图，图中所有结点均参与，所有边的权重加起来最小。</li>\n<li>算法<ol>\n<li>Prim算法  <ol>\n<li>步骤：设N=(V,{E})是连通网， TE是N上最小生成树中边的集合 <ol>\n<li>初始令U={u0},(u0V), TE=φ</li>\n<li>在所有uU,vV-U的边(u,v)E中，找一条代价最小<br>的边(u0,v0), 并保证不形成回路 </li>\n<li>将(u0,v0)并入集合TE，同时v0并入U </li>\n<li>重复上述操作直至U=V为止，则T=(V,{TE})为N的<br>最小生成树  </li>\n</ol>\n</li>\n<li>总结：每次迭代加入所有连通边中权值最小的。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"三角计数\"><a href=\"#三角计数\" class=\"headerlink\" title=\"三角计数\"></a>三角计数</h3><ol>\n<li>定义：寻找无向图中的所有三角形</li>\n<li>步骤<ol>\n<li>建立邻接表：<ol>\n<li>如果A-B &amp; A &lt; B，则将B加入A的邻接表 如果A-B &amp; B &lt; A，则将A加入B的邻接表  A&lt;B比较的是id</li>\n</ol>\n</li>\n<li>遍历每个节点，对于结点A，遍历A邻接表中的结点，如果邻接结点B,C两两之间存在边，则A、B、C三者之间存在三角形</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"社区发现\"><a href=\"#社区发现\" class=\"headerlink\" title=\"社区发现\"></a>社区发现</h3><ol>\n<li><p>社区定义：同一社区内的节点与节点之间的连接很紧密，而社区与社区之间的连接比较稀疏。社区是一个子图</p>\n</li>\n<li><p>数学描述：<img src=\"https://img-blog.csdn.net/20130710080910046\" alt=\"\"></p>\n</li>\n<li><p>衡量标准：模块度</p>\n<ol>\n<li>计算公式</li>\n</ol>\n<p><img src=\"https://img-blog.csdn.net/20130710081032203\" alt=\"\"></p>\n</li>\n<li><p>常见算法</p>\n<ol>\n<li>GN算法<ol>\n<li>思想：在一个网络之中，通过社区内部的边的最短路径相对较少，而通过社区之间的边的最短路径的数目则相对较多。从社区内部走大概率会走很多条边。</li>\n<li>步骤<ol>\n<li>计算每一条边的边介数。边介数（betweenness）：网络中任意两个节点通过此边的最短路径的数目。</li>\n<li>删除边介数最大的边</li>\n<li>重复（1）（2），直到网络中的任一顶点作为一个社区为止。</li>\n</ol>\n</li>\n<li>缺陷<ol>\n<li>不知道最后会有多少个社区</li>\n<li>在计算边介数的时候可能会有很对重复计算最短路径的情况，时间复杂度太高</li>\n<li>GN算法不能判断算法终止位置</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>LPA算法（标签传播算法）<ol>\n<li>思路<ol>\n<li>自己是什么标签，由邻居决定。邻居中什么标签最多，则此结点是什么标签</li>\n</ol>\n</li>\n<li>步骤<ol>\n<li>为所有结点指定一个唯一的标签</li>\n<li>逐轮刷新所有结点的标签，直到达到收敛要求位置。刷新规则： 对于某一个节点，考察其所有邻居节点的标签，并进行统计，将出现个数最多的那个标签赋给当前节点。当个数最多的标签不唯一时，随机选一个。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"拓扑排序\"><a href=\"#拓扑排序\" class=\"headerlink\" title=\"拓扑排序\"></a>拓扑排序</h3><ol>\n<li>定义 ：<strong>拓扑排序（Topological Sorting）</strong>是一个<strong>有向无环图（DAG, Directed Acyclic Graph）</strong>的所有顶点的线性序列。且该序列必须满足下面两个条件：<ol>\n<li>每个顶点出现且只出现一次</li>\n<li>若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面</li>\n</ol>\n</li>\n<li>步骤<ol>\n<li>从 DAG 图中选择一个 没有前驱（即入度为0）的顶点并输出</li>\n<li>从图中删除该顶点和所有以它为起点的有向边</li>\n<li>重复 1 和 2 直到当前的 DAG 图为空或<strong>当前图中不存在无前驱的顶点为止</strong>。后一种情况说明有向图中必然存在环<br><img src=\"http://img.blog.csdn.net/20150507001759702\" alt=\"img\"></li>\n</ol>\n</li>\n</ol>\n","site":{"data":{}},"length":2613,"excerpt":"<h1 id=\"图算法的典型操作\"><a href=\"#图算法的典型操作\" class=\"headerlink\" title=\"图算法的典型操作\"></a>图算法的典型操作</h1><p>关于一些常见图算法的调研与学习。</p>","more":"<h2 id=\"常用图算法\"><a href=\"#常用图算法\" class=\"headerlink\" title=\"常用图算法\"></a>常用图算法</h2><h3 id=\"PageRank\"><a href=\"#PageRank\" class=\"headerlink\" title=\"PageRank\"></a>PageRank</h3><ol>\n<li><p>背景    </p>\n<ol>\n<li>既考虑入链数量，又考虑了网页质量因素，二者相结合 数量与权重的结合</li>\n<li>算法与主题无关，因为PR值是根据图计算出来的</li>\n</ol>\n</li>\n<li><p>算法原理</p>\n<ol>\n<li><p>基本思想</p>\n<p>A有链接指向B，表明A认为B比A重要。A将自身权重分配一部分给B。</p>\n<p>$W(B)=W(A)/N$   W(A) 是A的PR值，W(B)是A 分配的权重，N是A的出链数</p>\n</li>\n<li><p>PageRank公式修正</p>\n<p>存在出链为0的孤立网页，增加阻力系数q ，一般取q=0.85，其意义是用户有1-q的概率不点击此页面上面的所有链接。同时还有随机直接跳转的概率，如直接输入网址，点击书签等。完整公式如下：</p>\n<p><img src=\"E:\\data\\ict\\docs\\page rank.png\" alt=\"\"></p>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"Connected-component\"><a href=\"#Connected-component\" class=\"headerlink\" title=\"Connected component\"></a>Connected component</h3><ol>\n<li>定义<ol>\n<li>连通分支：图中，某个子图的任意两点有边连接，而子图之间无边连接</li>\n<li>问题：cc是寻找连通分支的算法？？</li>\n</ol>\n</li>\n<li>通过BFS、DFS算法的便利就可以找到连通分支，每个白色节点开始的就是一个连通分支。</li>\n<li>常见算法<ol>\n<li>DFS<ol>\n<li>原理：访问某个顶点后只有当某个节点是叶结点后才会访问其余相邻节点。</li>\n<li>步骤：<ol>\n<li>选择一个结点作为起始结点，标记为灰色</li>\n<li>从该节点的邻居结点中选择一个结点，标记为灰色，继续这个操作</li>\n<li>当选中的结点时叶子结点时，将其涂黑并返回到上一个父节点。</li>\n<li>重复2,3直到所有结点都被访问。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>BFS   （DFS，BFS不是图的遍历算法吗）。<ol>\n<li>原理：在进一步遍历中顶点之前，先访问当前结点的所有邻接结点。</li>\n<li>步骤：<ol>\n<li>选择一个顶点作为起始节点，放入队列，标记为灰色，其余标记为白色</li>\n<li>寻找队列首部结点的所有邻居节点，将其放入队列中并标记为灰色，将队列首部结点出队，并标记为黑色  </li>\n<li>重复2步骤，直到队列中的节点全部为空。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"SSSP-single-source-shortest-paths\"><a href=\"#SSSP-single-source-shortest-paths\" class=\"headerlink\" title=\"SSSP (single-source shortest paths)\"></a>SSSP (single-source shortest paths)</h3><ol>\n<li>单独的起点与目标点之间最短路径的计算。起点固定，寻找与其他所有结点之间的最短路径。包括单源单汇，单源多汇</li>\n<li>常见算法<ol>\n<li>Dijkstra<ol>\n<li>步骤<ol>\n<li>将所有顶点分成两个集合A、B，其中集合A表示已经求得从V0出发的最短路径的顶点集合，集合B为为待求解的顶点集合。初始时有A={V0}</li>\n<li>将集合A与集合B相连的边（A中的所有结点与B中所有的结点形成的边）按照从V0出发的最短权重和递增次序排序，取最短的边，将该条边在集合B中所对应的顶点加入到集合A中</li>\n<li>重复第二步，直至B为空集。</li>\n</ol>\n</li>\n<li>总结：<ol>\n<li>最短中的最短：每次迭代时比较的是当前状态下以V0为起点，A中顶点为中间点的到各顶点之间的最短路径权重，最后再选择在当前所有最短路径中路径最短的一个顶点加入A。也就是说每次加入A集合的点是最短路径中的最短。</li>\n<li>给定目标点，在每次迭代时，并不知道能否到达最后的目标点，所以把到所有结点的最短距离都算出来了。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"Betweenness-Centrality（中介中心性）\"><a href=\"#Betweenness-Centrality（中介中心性）\" class=\"headerlink\" title=\"Betweenness Centrality（中介中心性）\"></a>Betweenness Centrality（中介中心性）</h3><ol>\n<li><p>定义 ：中心性用来衡量节结点的重要性。Betweenness Centrality ：考虑的是该节点出现在其他两节点之间的最短路径上的比率。</p>\n</li>\n<li><p>思想：如果一个成员位于其他成员的多条最短路上，那么该成员就是核心成员，就具有较大的中介中心性。</p>\n</li>\n<li><p>步骤</p>\n<p>其中<img src=\"https://i2.wp.com/upload.wikimedia.org/math/b/b/7/bb79bd91213d03edf0c8fc04fbd51085.png\" alt=\"\\sigma_{st}\">表示的是节点s和t之间的最短路径的数量，而<img src=\"https://i2.wp.com/upload.wikimedia.org/math/4/2/c/42c33f5f78864175f0d9c9af1c492f5d.png\" alt=\"\\sigma_{st}(v)\">是最短路径中经过节点v的数量。</p>\n<ol>\n<li><p>计算各个点对之间最短路径的长度和条数，用于计算pair-dependencies: δst(v) =σst(v)/σst</p>\n<p><img src=\"http://static.oschina.net/uploads/img/201305/11121047_IQnh.jpg\" alt=\"clip_image004\"></p>\n</li>\n<li><p>对于每个节点，累积属于自己的pair-dependencies</p>\n</li>\n</ol>\n<p><img src=\"https://i2.wp.com/upload.wikimedia.org/math/4/c/c/4cc6eaa2dce9d504feeed5bd88b96d73.png\" alt=\"\"></p>\n</li>\n</ol>\n<h3 id=\"LBP算法-Local-Binary-Pattern-局部二值模式\"><a href=\"#LBP算法-Local-Binary-Pattern-局部二值模式\" class=\"headerlink\" title=\"LBP算法(Local Binary Pattern, 局部二值模式)\"></a>LBP算法(Local Binary Pattern, 局部二值模式)</h3><ol>\n<li><p>定义：LBP是一种用来描述图像局部纹理特征的算子。</p>\n<ol>\n<li>原始的LBP算子定义为在3*3的窗口内，以窗口中心像素为阈值，将相邻的8个像素的灰度值与其进行比较，若周围像素值大于中心像素值，则该像素点的位置被标记为1，否则为0</li>\n</ol>\n<p><img src=\"http://hi.csdn.net/attachment/201104/13/0_1302700245WllL.gif\" alt=\"img\"></p>\n</li>\n<li><p>作用是进行特征提取，而且，提取的特征是图像的纹理特征，并且，是局部的纹理特征.</p>\n</li>\n<li><p>改进版本</p>\n<ol>\n<li>原型LBP算子 </li>\n<li>LBP等价模式</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"最小生成树\"><a href=\"#最小生成树\" class=\"headerlink\" title=\"最小生成树\"></a>最小生成树</h3><ol>\n<li>定义：无环连通图，图中所有结点均参与，所有边的权重加起来最小。</li>\n<li>算法<ol>\n<li>Prim算法  <ol>\n<li>步骤：设N=(V,{E})是连通网， TE是N上最小生成树中边的集合 <ol>\n<li>初始令U={u0},(u0V), TE=φ</li>\n<li>在所有uU,vV-U的边(u,v)E中，找一条代价最小<br>的边(u0,v0), 并保证不形成回路 </li>\n<li>将(u0,v0)并入集合TE，同时v0并入U </li>\n<li>重复上述操作直至U=V为止，则T=(V,{TE})为N的<br>最小生成树  </li>\n</ol>\n</li>\n<li>总结：每次迭代加入所有连通边中权值最小的。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"三角计数\"><a href=\"#三角计数\" class=\"headerlink\" title=\"三角计数\"></a>三角计数</h3><ol>\n<li>定义：寻找无向图中的所有三角形</li>\n<li>步骤<ol>\n<li>建立邻接表：<ol>\n<li>如果A-B &amp; A &lt; B，则将B加入A的邻接表 如果A-B &amp; B &lt; A，则将A加入B的邻接表  A&lt;B比较的是id</li>\n</ol>\n</li>\n<li>遍历每个节点，对于结点A，遍历A邻接表中的结点，如果邻接结点B,C两两之间存在边，则A、B、C三者之间存在三角形</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"社区发现\"><a href=\"#社区发现\" class=\"headerlink\" title=\"社区发现\"></a>社区发现</h3><ol>\n<li><p>社区定义：同一社区内的节点与节点之间的连接很紧密，而社区与社区之间的连接比较稀疏。社区是一个子图</p>\n</li>\n<li><p>数学描述：<img src=\"https://img-blog.csdn.net/20130710080910046\" alt=\"\"></p>\n</li>\n<li><p>衡量标准：模块度</p>\n<ol>\n<li>计算公式</li>\n</ol>\n<p><img src=\"https://img-blog.csdn.net/20130710081032203\" alt=\"\"></p>\n</li>\n<li><p>常见算法</p>\n<ol>\n<li>GN算法<ol>\n<li>思想：在一个网络之中，通过社区内部的边的最短路径相对较少，而通过社区之间的边的最短路径的数目则相对较多。从社区内部走大概率会走很多条边。</li>\n<li>步骤<ol>\n<li>计算每一条边的边介数。边介数（betweenness）：网络中任意两个节点通过此边的最短路径的数目。</li>\n<li>删除边介数最大的边</li>\n<li>重复（1）（2），直到网络中的任一顶点作为一个社区为止。</li>\n</ol>\n</li>\n<li>缺陷<ol>\n<li>不知道最后会有多少个社区</li>\n<li>在计算边介数的时候可能会有很对重复计算最短路径的情况，时间复杂度太高</li>\n<li>GN算法不能判断算法终止位置</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>LPA算法（标签传播算法）<ol>\n<li>思路<ol>\n<li>自己是什么标签，由邻居决定。邻居中什么标签最多，则此结点是什么标签</li>\n</ol>\n</li>\n<li>步骤<ol>\n<li>为所有结点指定一个唯一的标签</li>\n<li>逐轮刷新所有结点的标签，直到达到收敛要求位置。刷新规则： 对于某一个节点，考察其所有邻居节点的标签，并进行统计，将出现个数最多的那个标签赋给当前节点。当个数最多的标签不唯一时，随机选一个。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"拓扑排序\"><a href=\"#拓扑排序\" class=\"headerlink\" title=\"拓扑排序\"></a>拓扑排序</h3><ol>\n<li>定义 ：<strong>拓扑排序（Topological Sorting）</strong>是一个<strong>有向无环图（DAG, Directed Acyclic Graph）</strong>的所有顶点的线性序列。且该序列必须满足下面两个条件：<ol>\n<li>每个顶点出现且只出现一次</li>\n<li>若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面</li>\n</ol>\n</li>\n<li>步骤<ol>\n<li>从 DAG 图中选择一个 没有前驱（即入度为0）的顶点并输出</li>\n<li>从图中删除该顶点和所有以它为起点的有向边</li>\n<li>重复 1 和 2 直到当前的 DAG 图为空或<strong>当前图中不存在无前驱的顶点为止</strong>。后一种情况说明有向图中必然存在环<br><img src=\"http://img.blog.csdn.net/20150507001759702\" alt=\"img\"></li>\n</ol>\n</li>\n</ol>"},{"title":"shell 脚本遍历redis数据库","date":"2019-03-14T12:00:46.000Z","copyright":true,"_content":"\n## 使用shell脚本遍历redis数据库中的所有kv对\n\n记录下如何使用shell通过redis-cli 命令来操作redis数据库，因为直接在命令行中输入\n\n`redis-cli command` 的话command必须是单个单词，不能像是`KEYS *` 这种.\n\n<!--more-->\n\n````\n#!/bin/bash\nfilename='redis'`date +%Y-%m-%d_%H:%M`\nwork_path=$(dirname \"$0\") \necho \"实例化redis数据文件为:$work_path/$filename\"\necho \"keys *\" | redis-cli > key_db.txt\necho \"将所有key保存到:$work_path/key_db.txt\"\nfor line in `cat key_db.txt`\ndo\n        echo \"key:$line \" >>$work_path/$filename.txt\n        echo \"key-value:\" >>$work_path/$filename.txt\n        echo \"hgetall $line\" | redis-cli >>$work_path/$filename.txt\ndone\n````\n\n使用echo 来把命令输出到管道然后再传递给redis-cli。在循环里面也是使用echo来把字符串输入到文件中。","source":"_posts/使用shell脚本遍历redis数据库中的所有kv对.md","raw":"---\ntitle: shell 脚本遍历redis数据库\ndate: 2019-03-14 20:00:46\ncategories: Linux\ntags:\n- shell\n- redis\ncopyright: true\n---\n\n## 使用shell脚本遍历redis数据库中的所有kv对\n\n记录下如何使用shell通过redis-cli 命令来操作redis数据库，因为直接在命令行中输入\n\n`redis-cli command` 的话command必须是单个单词，不能像是`KEYS *` 这种.\n\n<!--more-->\n\n````\n#!/bin/bash\nfilename='redis'`date +%Y-%m-%d_%H:%M`\nwork_path=$(dirname \"$0\") \necho \"实例化redis数据文件为:$work_path/$filename\"\necho \"keys *\" | redis-cli > key_db.txt\necho \"将所有key保存到:$work_path/key_db.txt\"\nfor line in `cat key_db.txt`\ndo\n        echo \"key:$line \" >>$work_path/$filename.txt\n        echo \"key-value:\" >>$work_path/$filename.txt\n        echo \"hgetall $line\" | redis-cli >>$work_path/$filename.txt\ndone\n````\n\n使用echo 来把命令输出到管道然后再传递给redis-cli。在循环里面也是使用echo来把字符串输入到文件中。","slug":"使用shell脚本遍历redis数据库中的所有kv对","published":1,"updated":"2019-11-08T13:15:39.540Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6he14030040dstz4zurlplx","content":"<h2 id=\"使用shell脚本遍历redis数据库中的所有kv对\"><a href=\"#使用shell脚本遍历redis数据库中的所有kv对\" class=\"headerlink\" title=\"使用shell脚本遍历redis数据库中的所有kv对\"></a>使用shell脚本遍历redis数据库中的所有kv对</h2><p>记录下如何使用shell通过redis-cli 命令来操作redis数据库，因为直接在命令行中输入</p>\n<p><code>redis-cli command</code> 的话command必须是单个单词，不能像是<code>KEYS *</code> 这种.</p>\n<a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">filename=&apos;redis&apos;`date +%Y-%m-%d_%H:%M`</span><br><span class=\"line\">work_path=$(dirname &quot;$0&quot;) </span><br><span class=\"line\">echo &quot;实例化redis数据文件为:$work_path/$filename&quot;</span><br><span class=\"line\">echo &quot;keys *&quot; | redis-cli &gt; key_db.txt</span><br><span class=\"line\">echo &quot;将所有key保存到:$work_path/key_db.txt&quot;</span><br><span class=\"line\">for line in `cat key_db.txt`</span><br><span class=\"line\">do</span><br><span class=\"line\">        echo &quot;key:$line &quot; &gt;&gt;$work_path/$filename.txt</span><br><span class=\"line\">        echo &quot;key-value:&quot; &gt;&gt;$work_path/$filename.txt</span><br><span class=\"line\">        echo &quot;hgetall $line&quot; | redis-cli &gt;&gt;$work_path/$filename.txt</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n<p>使用echo 来把命令输出到管道然后再传递给redis-cli。在循环里面也是使用echo来把字符串输入到文件中。</p>\n","site":{"data":{}},"length":639,"excerpt":"<h2 id=\"使用shell脚本遍历redis数据库中的所有kv对\"><a href=\"#使用shell脚本遍历redis数据库中的所有kv对\" class=\"headerlink\" title=\"使用shell脚本遍历redis数据库中的所有kv对\"></a>使用shell脚本遍历redis数据库中的所有kv对</h2><p>记录下如何使用shell通过redis-cli 命令来操作redis数据库，因为直接在命令行中输入</p>\n<p><code>redis-cli command</code> 的话command必须是单个单词，不能像是<code>KEYS *</code> 这种.</p>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">filename=&apos;redis&apos;`date +%Y-%m-%d_%H:%M`</span><br><span class=\"line\">work_path=$(dirname &quot;$0&quot;) </span><br><span class=\"line\">echo &quot;实例化redis数据文件为:$work_path/$filename&quot;</span><br><span class=\"line\">echo &quot;keys *&quot; | redis-cli &gt; key_db.txt</span><br><span class=\"line\">echo &quot;将所有key保存到:$work_path/key_db.txt&quot;</span><br><span class=\"line\">for line in `cat key_db.txt`</span><br><span class=\"line\">do</span><br><span class=\"line\">        echo &quot;key:$line &quot; &gt;&gt;$work_path/$filename.txt</span><br><span class=\"line\">        echo &quot;key-value:&quot; &gt;&gt;$work_path/$filename.txt</span><br><span class=\"line\">        echo &quot;hgetall $line&quot; | redis-cli &gt;&gt;$work_path/$filename.txt</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n<p>使用echo 来把命令输出到管道然后再传递给redis-cli。在循环里面也是使用echo来把字符串输入到文件中。</p>"},{"title":"Redis源码阅读——SDS","date":"2019-03-22T07:58:45.000Z","copyright":true,"_content":"\n# Redis源码阅读——SDS\n\n参考Redis设计与实现 以及网上博客阅读Redis源码。\n\n<!--more-->\n\nSDS相关知识点见读书笔记。\n\n## 创建和销毁\n\n为了能够对sds进行相关API的测试，因此把sds模块单独提出来。阅读Redis的Makefile发现，编译sds模块需要的源文件包括`sds.c`, `sds.h` `zmalloc.c` \n\n```Make\ntest-sds: sds.c sds.h\n        $(REDIS_CC) sds.c zmalloc.c -DSDS_TEST_MAIN $(FINAL_LIBS) -o /tmp/sds_test\n        /tmp/sds_test\n```\n\n但是实际编译后会发现会报很多函数未定义的错。原因是redis源码里面sds的内存分配、释放、重分配这些函数是封装成zmalloc,zfee这些函数的，只单纯的把zmalloc.c提取出来是远远不够的。后面发现redis的作者已经把sds给单独提出来了。包括三个源文件`sds.c`,`sds.h`,`sdsalloc.h` 因此执行如下操作即可单独把redis的sds模块提取出来。\n\n### 提取sds模块\n\n1. 新建redis_sds测试目录\n\n   选择合适的目录下新建\n\n   `mkdir redis_sds`\n\n2. 复制源文件至redis_sds目录下\n\n   在redis源码的src目录下执行：\n\n   `cp sds.c ~/redis_sds/`\n\n   `cp sds.h ~/redis_sds/`\n\n   `cp sdsalloc.h ~/redis_sds/`\n\n3. 修改sdsalloc.h \n\n   复制过来的sdsalloc.h 将sds模块的内存函数封装为使用zmalloc函数。为了简化处理直接使用libc的malloc函数来进行内存管理，同时将zmalloc.h给注释掉。\n\n   ```c\n   //#include \"zmalloc.h\"\n   #define s_malloc malloc\n   #define s_realloc realloc\n   #define s_free free\n   ```\n\n4. 新建主函数\n\n   新建主函数sds_test.c\n\n   ```c\n   #include <stdio.h>\n   #include <stdlib.h>\n   #include \"sds.c\"\n   //#include \"sds.h\"\n   int main(int argc, char *argv[]) {\n       sds s = sdsnew(\"Hello World!\");\n       printf(\"Length:%d, Type:%d\\n\", sdslen(s), sdsReqType(sdslen(s)));\n   \n       s = sdscat(s, \"The length of this sentence is greater than 32 bytes\");\n       printf(\"Length:%d, Type:%d\\n\", sdslen(s), sdsReqType(sdslen(s)));\n   \n       sdsfree(s);\n       return 0;\n   }\n   ```\n\n   直接include sds.c 即可，因为如果#include “sds.h” 的话，sdsReqType这个函数并没有在sds.h里面声明，而且因为sdsReqType的申明是：\n\n   `static inline char sdsReqType(size_t string_size) {`  有static限制所以不能在sds.h中先声明，所以为了简单就直接#include 了sds.c了\n\n5. 编译  \n\n   为了方便重复编译，所以写了个简单的Makefile。\n\n   ```\n   test : sds_test.c sds.h sds.c sdsalloc.h\n           gcc -o sdstest sds_test.c\n   ```\n\n   只需要编译sds_test.c 即可。因为sds_test.c 里面是直接#include sds.c 了所以再\n\n   `gcc -o sdstest sds_test.c sds.c` 会将sds.c 里面的函数重复编译两次，造成Multiple definition 问题。\n\n   之后只需要执行make命令就可以生成可执行文件sdstest。\n\n   执行后输出为：\n\n   ```\n   ./sdstest \n   Length:12, Type:0\n   Length:64, Type:1\n   ```\n\n   ### sds的创建\n\n   通过`sdsnew` 来创建了一个sds。sdsnew源码为：\n\n   ```c\n   /* Create a new sds string starting from a null terminated C string. */\n   sds sdsnew(const char *init) {\n       //使用？条件判断符来简化if语句对NULL的判断，直接使用strlen来返回字符指针的长度。\n       size_t initlen = (init == NULL) ? 0 : strlen(init); \n       return sdsnewlen(init, initlen);\n   }\n   ```\n\n   需要注意的是字符数组和字符指针是有区别的：字符指针的数据是存放在进程的虚拟地址空间的程序代码和数据段，是只读的不能修改。字符数组存放的字符串数据是存放在用户栈的，是可以更改的。且字符指针的数据没有\"\\0\"这个结束符。\n\n   参考博客讲的很好：<https://blog.csdn.net/on_1y/article/details/13030439>\n\n   `sdsnew` 通过把字符串长度和字符串传递给`sdsnewlen`，来完成创建。\n\n   ```c\n   \n   /* Create a new sds string with the content specified by the 'init' pointer\n    * and 'initlen'.\n    * If NULL is used for 'init' the string is initialized with zero bytes.\n    *\n    * The string is always null-termined (all the sds strings are, always) so\n    * even if you create an sds string with:\n    *\n    * mystring = n(\"abc\",3);\n    *\n    * You can print the string with printf() as there is an implicit \\0 at the\n    * end of the string. However the string is binary safe and can contain\n    * \\0 characters in the middle, as the length is stored in the sds header. */\n   sds sdsnewlen(const void *init, size_t initlen) {\n       void *sh;\n       sds s;\n       char type = sdsReqType(initlen);  //返回字符串对应的type\n       /* Empty strings are usually created in order to append. Use type 8\n        * since type 5 is not good at this. */\n       /*\n       空字符串使用sdshdr8来存储，而不是sdshdr5,（虽然长度小于32），因为sdshdr5不适合扩容。\n       */\n       if (type == SDS_TYPE_5 && initlen == 0) type = SDS_TYPE_8;\n       int hdrlen = sdsHdrSize(type); // 返回对应类型的sdsheader长度。\n       unsigned char *fp; /* flags pointer. */\n   \n       sh = s_malloc(hdrlen+initlen+1); // 申请头部+字符串+NULL的大小。(单位为byte)\n       if (!init)\n           memset(sh, 0, hdrlen+initlen+1); // 将sh后面对应大小的字节全部置为0；\n       if (sh == NULL) return NULL;\n       s = (char*)sh+hdrlen; //s指针指向字符串的首字节。\n       fp = ((unsigned char*)s)-1; // fp指针指向flag\n       switch(type) {  // 初始化sdshdr\n           case SDS_TYPE_5: {\n               *fp = type | (initlen << SDS_TYPE_BITS);// 设置flag这个字节的具体值\n               break;\n           }\n           case SDS_TYPE_8: {\n               SDS_HDR_VAR(8,s); // 获取header指针sh\n               sh->len = initlen; //header中len的初始\n               sh->alloc = initlen; //header 中alloc的初试\n               *fp = type;  //flag 的初始。\n               break;\n           }\n           case SDS_TYPE_16: {\n               SDS_HDR_VAR(16,s);\n               sh->len = initlen;\n               sh->alloc = initlen;\n               *fp = type; \n               break;\n           }\n           case SDS_TYPE_32: {\n               SDS_HDR_VAR(32,s);\n               sh->len = initlen;\n               sh->alloc = initlen;\n               *fp = type;\n               break;\n           }\n           case SDS_TYPE_64: {\n               SDS_HDR_VAR(64,s);\n               sh->len = initlen;\n               sh->alloc = initlen;\n               *fp = type;\n               break;\n           }\n       }\n       if (initlen && init)\n           memcpy(s, init, initlen); // 将字符串拷贝到s(也就是buf数组)\n       s[initlen] = '\\0'; //在字符串后面添加终止符\n       return s;\n   }\n   ```\n\n   `    char type = sdsReqType(initlen);` 获取sds类型，源码分析在读书笔记里面有记录。源码为\n\n   ```c\n   static inline char sdsReqType(size_t string_size) {\n       if (string_size < 1<<5) // string_size < 2^5\n           return SDS_TYPE_5;\n       if (string_size < 1<<8)  //string_size < 2^8\n           return SDS_TYPE_8;\n       if (string_size < 1<<16)\t//string_size < 2^16\n           return SDS_TYPE_16;\n   #if (LONG_MAX == LLONG_MAX)\n       if (string_size < 1ll<<32)  //string_size < 2^32\n           return SDS_TYPE_32;\n   #endif\n       return SDS_TYPE_64; \n   }\n   ```\n\n   采用左移来计算对应多少位的范围，而不是用2^5 这样的乘法。**直接移位比使用幂来计算快很多**。\n\n   `1<<5`   计算出来就是2^5 次方。1是int型，4byte32位。最低8bit位的二进制为：00000001 左移5位后变成了：00100000 对应的十进制既是32。\n\n   计算n个bit位的最大值：(1<<n) -1\n\n   但是需要注意位数不够的情况。因为1是int型，只有32个bit。所以在左移32个bit时，需要使用long long int型。用1ll来表示，此时1ll为64个bit。\n\n   还得考虑机器是否为64位机器，在32位机器上LONG_MAX = 2147483647L，64位机器上LONG_MAX = 9223372036854775807L 。不论32位机器还是64位机器上 LLONG_MAX 都是9223372036854775807L 。所以当LONG_MAX == LLONG_MAX 说明字长为64bit。加上条件编译，说明在32位机器上不使用sdshdr32而直接跳到了sdshdr64，仅仅在64位机器上使用sdshdr32。原因是什么？还没想通\n\n   ```c\n   static inline int sdsHdrSize(char type) {\n       switch(type&SDS_TYPE_MASK) {\n           case SDS_TYPE_5:\n               return sizeof(struct sdshdr5);\n           case SDS_TYPE_8:\n               return sizeof(struct sdshdr8);\n           case SDS_TYPE_16:\n               return sizeof(struct sdshdr16);\n           case SDS_TYPE_32:\n               return sizeof(struct sdshdr32);\n           case SDS_TYPE_64:\n               return sizeof(struct sdshdr64);\n       }\n       return 0;\n   }\n   ```\n\n   因为struct里面的buf数组是柔性数组，计算结构体的大小的时候不会计算在内。\n\n   `memset(sh, 0, hdrlen+initlen+1);`  memset函数会将sh中当前位置后面的`hdrlen+initlen+1`个字节全部置于0。 注意sh指向的是`hdrlen+initlen+1` 个字节的首个字节。（sh指针存储的地址就是首个字节的地址。） \n\n   memset源码为：<https://github.com/gcc-mirror/gcc/blob/master/libgcc/memset.c>\n\n   ```c\n   /* Public domain.  */\n   #include <stddef.h>\n   \n   void *\n   memset (void *dest, int val, size_t len)\n   {\n     unsigned char *ptr = dest; // 用char来限定每次指针+1只移动一个字节。\n     while (len-- > 0)\n       *ptr++ = val;\n     return dest;\n   }\n   ```\n\n   假设`hdrlen+initlen+1` 为8 ，经过memset后，从sh首字节开始共有8个字节都被置为0。\n\n   ![](https://res.cloudinary.com/bravey/image/upload/v1553525055/blog/memset.png)\n\n   指针的类型时用来确定指针需要从首地址寻址（偏移）多少个字节。比如int * 指针说明指针存储的地址朝后面偏移3个字节才是这个int类型的所有数据。即指针存储的地址时起点，而终点是由类型来确定的。此外，类型也是指针加减的步长，比如char类型的步长就是1byte，而uint_16类型的指针步长就是2byte。\n\n   随后用switch语句对不同类型的sdshdr设置初始值。\n\n   首先是sdshdr5\n\n    `*fp = type | (initlen << SDS_TYPE_BITS)` 使用移位和或操作的方式来对8个bit位赋值。(不得不感慨这些操作真的是太巧妙了)\n\n   假设initlen为3。则initlen的二进制为0000 0011（应该是8byte（64位机器）或者4byte（32位机器），为了简单用1byte的二进制表示）而SDS_TYPE_BITS 为3。所以先将initlen 左移3个bit 变成0000 0001 1000(共有8byte或者4byte)。再与type进行或运算。type为0000 0000 进行或运算后，得到的内容是8bit的，因为type是char类型，即0001 1000 。\n\n   其他sdshdr类型的设置都差不多，详解下sdshdr8.\n\n   `SDS_HDR_VAR(8,s)`  `SDS_HDR_VAR` 是个宏定义的函数\n\n   `#define SDS_HDR_VAR(T,s) struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T)));`\n\n   采用宏定义函数的好处是\n\n   1. 能够减少额外的开销 因为如果写成普通函数的话，函数的调用会在用户栈开辟空间，形参压栈，返回时还需要释放栈，可想而知的开销。使用宏定义函数则在代码规模和速度方面都比函数更胜一筹。宏定义的本质就是替换，所以在使用宏定义函数的地方，执行的时候相当于是在直接执行`struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T)))` 这句代码\n   2. 函数的参数必须被声明为一种特定的类型，所以它只能在类型合适的表达式上使用。而宏定义则可以用于整形、长整形、单浮点型、双浮点型以及其他任何可以用“>”操作符比较值大小的类型，也就是说，宏是与类型无关的。（有点C++模版类的感觉）\n\n   宏定义函数中的## 是（token-pasting）**符号连接操作符** 直接将形参T链接到sdshdr上面。也就是sdshdrT。\n\n   所以这句代码也就很简单了，将字符串指针s向后移动header的大小，也就得到了header的指针。（不过有个疑问是为什么还要重新获取headr的地址，最开始不就是指向了header吗？，难道memset是直接对sh进行操作的？测试过了，memset不会修改sh的地址，所以应该是为了再次确保sh一定指向header）\n\n   解释一下：SDS_HDR_VAR 的作用是将sh的类型修改为结构体指针，因为之前sh 一直都是空指针，(虽然指针的指向地址是headr，但是没有限定它类型)不然后面没法用sh->len, sh->alloc 来访问对应的结构体成员。\n\n   最开始创建的时候alloc 和len是一样大的，没有分配多余空间）\n\n   `memcpy(s, init, initlen);` 函数将init的前initlen个字符拷贝给s。\n\n   memcpy源码为：\n\n   ```\n   /* Public domain.  */\n   #include <stddef.h>\n   \n   void *\n   memcpy (void *dest, const void *src, size_t len)\n   {\n     char *d = dest;\n     const char *s = src;\n     while (len--)\n       *d++ = *s++;\n     return dest;\n   }\n   ```\n\n   整个过程中的三个指针sh,s,fp对应关系如下图\n\n   ![](https://res.cloudinary.com/bravey/image/upload/v1553525055/blog/sds.png)\n\n\n\n## 销毁\n\n销毁使用sdsfree来实现\n\n源码为：\n\n```c\n/* Free an sds string. No operation is performed if 's' is NULL. */\nvoid sdsfree(sds s) {\n    if (s == NULL) return;\n    s_free((char*)s-sdsHdrSize(s[-1]));\n}\n```\n\ns[-1],就是指针s向后移动移位，也就是flag的位置。将s移动到sh的位置，释放sh指针也就释放了整个sds内存。\n\n疑惑：sh指针在sdsnewlen函数中是个局部变量，在sdsnewlen函数中是自动释放的，这里并没有传递sh指针为什么也可以释放对应的空间？\n\n自己想了下：malloc 函数传递的参数是需要分配的内存大小(len)，返回的是指针也就是地址。free()函数只用将malloc函数返回的指针(地址)作为参数传入，就可以释放之前该地址分配到的内存空间。而地址只是首地址，总共的偏移量（大小），应该是由操作系统在内存分配的时候就记录了的。\n\n博客中记录：申请的时候实际上占用的内存要比申请的大。因为超出的空间是用来记录对这块内存的管理信息。额外的空间用来记录管理信息——分配块的长度，指向下一个分配块的指针等等。果然malloc的时候用来一个struct来记录分配的信息。\n\n```c\n  struct mem_control_block { \n    int is_available;    //一般来说应该是一个可用空间的首地址，但这里英文单词却显示出空间是否可用的一个标记\n    int size;            //这是实际空间的大小 \n    };\n```\n\n<http://www.cnblogs.com/hanyonglu/archive/2011/04/28/2031271.html>\n\nfree()就是根据这个结构体的信息来释放malloc()申请的空间\n\n另外的疑惑：释放完空间后，s 指针不用把它指向null吗？  \n\n\n\n暂时就只是创建和销毁的源码把，看了两天，阅读源码真的是酣畅淋漓，收获良多。学到了很多奇妙的C技巧，还对操作系统的知识有了更具象的理解。\n\n## 其他\n\n阅读sdsfromlonglong部分的源码：\n\nsdsfromlonglong 函数用于将一个long long 类型的整形数字转换为字符数组。\n\n```c\n/* Create an sds string from a long long value. It is much faster than:\n *\n * sdscatprintf(sdsempty(),\"%lld\\n\", value);\n */\nsds sdsfromlonglong(long long value) {\n    char buf[SDS_LLSTR_SIZE];  // 给buf数组分配最小的空间，21的长度\n    int len = sdsll2str(buf,value); //将long long 转为字符数组存储在buf中，并返回字符串的长度\n\n    return sdsnewlen(buf,len);\n}\n```\n\n可以看到主要的转换操作在sdsll2str这个函数中：\n\n```c\n/* Helper for sdscatlonglong() doing the actual number -> string\n * conversion. 's' must point to a string with room for at least\n * SDS_LLSTR_SIZE bytes.\n *\n * The function returns the length of the null-terminated string\n * representation stored at 's'. */\n#define SDS_LLSTR_SIZE 21\nint sdsll2str(char *s, long long value) {\n    char *p, aux;\n    unsigned long long v; \n    size_t l;\n\n    /* Generate the string representation, this method produces\n     * an reversed string. */\n    v = (value < 0) ? -value : value;  //判断是否为负数\n    p = s;\n    do {\n        *p++ = '0'+(v%10); // 除以10取余数\n        v /= 10;     //去除个位\n    } while(v);\n    if (value < 0) *p++ = '-';\n\n    /* Compute length and add null term. */\n    l = p-s;   // 计算出字符串的长度 不含终止符\n    *p = '\\0'; // 首地址填终止符。\n\n    /* Reverse the string. */\n    p--;\n    while(s < p) {\n        aux = *s;\n        *s = *p;\n        *p = aux;\n        s++;\n        p--;\n    }\n    return l;\n}\n```\n\n```c\n    do {\n        *p++ = '0'+(v%10); // 除以10取余数\n        v /= 10;     //去除个位\n    } while(v);\n```\n\n假设v是352，变成字符串是将每一个对应的10进制上面的3,5,2这三个个位、十位、百位的数字给单独变成字符。\n\n`*p++ = '0'+(v%10); ` p 指针是字符数组buf的首地址，而将整型变成字符型的操作就是与字符'0' 相加，这样就可以对应的数字变成字符类型。同时p相应的加1来指向下一个byte用来存储下一个被转换的char。\n\nchar类型存储的是对应字符的ascii值，ASCII表为：<https://baike.baidu.com/item/ASCII/309296> ，所以字符的运算实际上是对应的ASCII的值的运算。\nv%10是除以10取余数，352%10 =2； 35%10=5，所以也就是取得v值的10进制上面的个位数。\n所以在while循环里面每次对v除以10并取余，就可以得到对应long long 型的字符串。\n但是因为每次得到的字符都是最后面的个位数，所以352，所输出的字符串数组为：‘2’， ‘3’， ‘5’ 是一个倒序的，因此还需要再反转一次。\n\n```c\n/* Reverse the string. */ \np--;\nwhile(s < p) {\n    aux = *s;\n    *s = *p;\n    *p = aux;\n    s++;\n    p--;\n}\n```\n字符串反转，首尾各有一个指针，当首指针小于尾指针的时候，交换数字，并同时向中间移动\n\n## 参考资料\n\n<https://blog.csdn.net/yangbodong22011/article/details/78419966>","source":"_posts/Redis源码阅读——SDS/2019-03-22-Redis源码阅读——SDS.md","raw":"---\ntitle: Redis源码阅读——SDS\ndate: 2019-03-22 15:58:45\ncategories: 源码阅读\ntags:\n- redis\n- 源码阅读\ncopyright: true\n---\n\n# Redis源码阅读——SDS\n\n参考Redis设计与实现 以及网上博客阅读Redis源码。\n\n<!--more-->\n\nSDS相关知识点见读书笔记。\n\n## 创建和销毁\n\n为了能够对sds进行相关API的测试，因此把sds模块单独提出来。阅读Redis的Makefile发现，编译sds模块需要的源文件包括`sds.c`, `sds.h` `zmalloc.c` \n\n```Make\ntest-sds: sds.c sds.h\n        $(REDIS_CC) sds.c zmalloc.c -DSDS_TEST_MAIN $(FINAL_LIBS) -o /tmp/sds_test\n        /tmp/sds_test\n```\n\n但是实际编译后会发现会报很多函数未定义的错。原因是redis源码里面sds的内存分配、释放、重分配这些函数是封装成zmalloc,zfee这些函数的，只单纯的把zmalloc.c提取出来是远远不够的。后面发现redis的作者已经把sds给单独提出来了。包括三个源文件`sds.c`,`sds.h`,`sdsalloc.h` 因此执行如下操作即可单独把redis的sds模块提取出来。\n\n### 提取sds模块\n\n1. 新建redis_sds测试目录\n\n   选择合适的目录下新建\n\n   `mkdir redis_sds`\n\n2. 复制源文件至redis_sds目录下\n\n   在redis源码的src目录下执行：\n\n   `cp sds.c ~/redis_sds/`\n\n   `cp sds.h ~/redis_sds/`\n\n   `cp sdsalloc.h ~/redis_sds/`\n\n3. 修改sdsalloc.h \n\n   复制过来的sdsalloc.h 将sds模块的内存函数封装为使用zmalloc函数。为了简化处理直接使用libc的malloc函数来进行内存管理，同时将zmalloc.h给注释掉。\n\n   ```c\n   //#include \"zmalloc.h\"\n   #define s_malloc malloc\n   #define s_realloc realloc\n   #define s_free free\n   ```\n\n4. 新建主函数\n\n   新建主函数sds_test.c\n\n   ```c\n   #include <stdio.h>\n   #include <stdlib.h>\n   #include \"sds.c\"\n   //#include \"sds.h\"\n   int main(int argc, char *argv[]) {\n       sds s = sdsnew(\"Hello World!\");\n       printf(\"Length:%d, Type:%d\\n\", sdslen(s), sdsReqType(sdslen(s)));\n   \n       s = sdscat(s, \"The length of this sentence is greater than 32 bytes\");\n       printf(\"Length:%d, Type:%d\\n\", sdslen(s), sdsReqType(sdslen(s)));\n   \n       sdsfree(s);\n       return 0;\n   }\n   ```\n\n   直接include sds.c 即可，因为如果#include “sds.h” 的话，sdsReqType这个函数并没有在sds.h里面声明，而且因为sdsReqType的申明是：\n\n   `static inline char sdsReqType(size_t string_size) {`  有static限制所以不能在sds.h中先声明，所以为了简单就直接#include 了sds.c了\n\n5. 编译  \n\n   为了方便重复编译，所以写了个简单的Makefile。\n\n   ```\n   test : sds_test.c sds.h sds.c sdsalloc.h\n           gcc -o sdstest sds_test.c\n   ```\n\n   只需要编译sds_test.c 即可。因为sds_test.c 里面是直接#include sds.c 了所以再\n\n   `gcc -o sdstest sds_test.c sds.c` 会将sds.c 里面的函数重复编译两次，造成Multiple definition 问题。\n\n   之后只需要执行make命令就可以生成可执行文件sdstest。\n\n   执行后输出为：\n\n   ```\n   ./sdstest \n   Length:12, Type:0\n   Length:64, Type:1\n   ```\n\n   ### sds的创建\n\n   通过`sdsnew` 来创建了一个sds。sdsnew源码为：\n\n   ```c\n   /* Create a new sds string starting from a null terminated C string. */\n   sds sdsnew(const char *init) {\n       //使用？条件判断符来简化if语句对NULL的判断，直接使用strlen来返回字符指针的长度。\n       size_t initlen = (init == NULL) ? 0 : strlen(init); \n       return sdsnewlen(init, initlen);\n   }\n   ```\n\n   需要注意的是字符数组和字符指针是有区别的：字符指针的数据是存放在进程的虚拟地址空间的程序代码和数据段，是只读的不能修改。字符数组存放的字符串数据是存放在用户栈的，是可以更改的。且字符指针的数据没有\"\\0\"这个结束符。\n\n   参考博客讲的很好：<https://blog.csdn.net/on_1y/article/details/13030439>\n\n   `sdsnew` 通过把字符串长度和字符串传递给`sdsnewlen`，来完成创建。\n\n   ```c\n   \n   /* Create a new sds string with the content specified by the 'init' pointer\n    * and 'initlen'.\n    * If NULL is used for 'init' the string is initialized with zero bytes.\n    *\n    * The string is always null-termined (all the sds strings are, always) so\n    * even if you create an sds string with:\n    *\n    * mystring = n(\"abc\",3);\n    *\n    * You can print the string with printf() as there is an implicit \\0 at the\n    * end of the string. However the string is binary safe and can contain\n    * \\0 characters in the middle, as the length is stored in the sds header. */\n   sds sdsnewlen(const void *init, size_t initlen) {\n       void *sh;\n       sds s;\n       char type = sdsReqType(initlen);  //返回字符串对应的type\n       /* Empty strings are usually created in order to append. Use type 8\n        * since type 5 is not good at this. */\n       /*\n       空字符串使用sdshdr8来存储，而不是sdshdr5,（虽然长度小于32），因为sdshdr5不适合扩容。\n       */\n       if (type == SDS_TYPE_5 && initlen == 0) type = SDS_TYPE_8;\n       int hdrlen = sdsHdrSize(type); // 返回对应类型的sdsheader长度。\n       unsigned char *fp; /* flags pointer. */\n   \n       sh = s_malloc(hdrlen+initlen+1); // 申请头部+字符串+NULL的大小。(单位为byte)\n       if (!init)\n           memset(sh, 0, hdrlen+initlen+1); // 将sh后面对应大小的字节全部置为0；\n       if (sh == NULL) return NULL;\n       s = (char*)sh+hdrlen; //s指针指向字符串的首字节。\n       fp = ((unsigned char*)s)-1; // fp指针指向flag\n       switch(type) {  // 初始化sdshdr\n           case SDS_TYPE_5: {\n               *fp = type | (initlen << SDS_TYPE_BITS);// 设置flag这个字节的具体值\n               break;\n           }\n           case SDS_TYPE_8: {\n               SDS_HDR_VAR(8,s); // 获取header指针sh\n               sh->len = initlen; //header中len的初始\n               sh->alloc = initlen; //header 中alloc的初试\n               *fp = type;  //flag 的初始。\n               break;\n           }\n           case SDS_TYPE_16: {\n               SDS_HDR_VAR(16,s);\n               sh->len = initlen;\n               sh->alloc = initlen;\n               *fp = type; \n               break;\n           }\n           case SDS_TYPE_32: {\n               SDS_HDR_VAR(32,s);\n               sh->len = initlen;\n               sh->alloc = initlen;\n               *fp = type;\n               break;\n           }\n           case SDS_TYPE_64: {\n               SDS_HDR_VAR(64,s);\n               sh->len = initlen;\n               sh->alloc = initlen;\n               *fp = type;\n               break;\n           }\n       }\n       if (initlen && init)\n           memcpy(s, init, initlen); // 将字符串拷贝到s(也就是buf数组)\n       s[initlen] = '\\0'; //在字符串后面添加终止符\n       return s;\n   }\n   ```\n\n   `    char type = sdsReqType(initlen);` 获取sds类型，源码分析在读书笔记里面有记录。源码为\n\n   ```c\n   static inline char sdsReqType(size_t string_size) {\n       if (string_size < 1<<5) // string_size < 2^5\n           return SDS_TYPE_5;\n       if (string_size < 1<<8)  //string_size < 2^8\n           return SDS_TYPE_8;\n       if (string_size < 1<<16)\t//string_size < 2^16\n           return SDS_TYPE_16;\n   #if (LONG_MAX == LLONG_MAX)\n       if (string_size < 1ll<<32)  //string_size < 2^32\n           return SDS_TYPE_32;\n   #endif\n       return SDS_TYPE_64; \n   }\n   ```\n\n   采用左移来计算对应多少位的范围，而不是用2^5 这样的乘法。**直接移位比使用幂来计算快很多**。\n\n   `1<<5`   计算出来就是2^5 次方。1是int型，4byte32位。最低8bit位的二进制为：00000001 左移5位后变成了：00100000 对应的十进制既是32。\n\n   计算n个bit位的最大值：(1<<n) -1\n\n   但是需要注意位数不够的情况。因为1是int型，只有32个bit。所以在左移32个bit时，需要使用long long int型。用1ll来表示，此时1ll为64个bit。\n\n   还得考虑机器是否为64位机器，在32位机器上LONG_MAX = 2147483647L，64位机器上LONG_MAX = 9223372036854775807L 。不论32位机器还是64位机器上 LLONG_MAX 都是9223372036854775807L 。所以当LONG_MAX == LLONG_MAX 说明字长为64bit。加上条件编译，说明在32位机器上不使用sdshdr32而直接跳到了sdshdr64，仅仅在64位机器上使用sdshdr32。原因是什么？还没想通\n\n   ```c\n   static inline int sdsHdrSize(char type) {\n       switch(type&SDS_TYPE_MASK) {\n           case SDS_TYPE_5:\n               return sizeof(struct sdshdr5);\n           case SDS_TYPE_8:\n               return sizeof(struct sdshdr8);\n           case SDS_TYPE_16:\n               return sizeof(struct sdshdr16);\n           case SDS_TYPE_32:\n               return sizeof(struct sdshdr32);\n           case SDS_TYPE_64:\n               return sizeof(struct sdshdr64);\n       }\n       return 0;\n   }\n   ```\n\n   因为struct里面的buf数组是柔性数组，计算结构体的大小的时候不会计算在内。\n\n   `memset(sh, 0, hdrlen+initlen+1);`  memset函数会将sh中当前位置后面的`hdrlen+initlen+1`个字节全部置于0。 注意sh指向的是`hdrlen+initlen+1` 个字节的首个字节。（sh指针存储的地址就是首个字节的地址。） \n\n   memset源码为：<https://github.com/gcc-mirror/gcc/blob/master/libgcc/memset.c>\n\n   ```c\n   /* Public domain.  */\n   #include <stddef.h>\n   \n   void *\n   memset (void *dest, int val, size_t len)\n   {\n     unsigned char *ptr = dest; // 用char来限定每次指针+1只移动一个字节。\n     while (len-- > 0)\n       *ptr++ = val;\n     return dest;\n   }\n   ```\n\n   假设`hdrlen+initlen+1` 为8 ，经过memset后，从sh首字节开始共有8个字节都被置为0。\n\n   ![](https://res.cloudinary.com/bravey/image/upload/v1553525055/blog/memset.png)\n\n   指针的类型时用来确定指针需要从首地址寻址（偏移）多少个字节。比如int * 指针说明指针存储的地址朝后面偏移3个字节才是这个int类型的所有数据。即指针存储的地址时起点，而终点是由类型来确定的。此外，类型也是指针加减的步长，比如char类型的步长就是1byte，而uint_16类型的指针步长就是2byte。\n\n   随后用switch语句对不同类型的sdshdr设置初始值。\n\n   首先是sdshdr5\n\n    `*fp = type | (initlen << SDS_TYPE_BITS)` 使用移位和或操作的方式来对8个bit位赋值。(不得不感慨这些操作真的是太巧妙了)\n\n   假设initlen为3。则initlen的二进制为0000 0011（应该是8byte（64位机器）或者4byte（32位机器），为了简单用1byte的二进制表示）而SDS_TYPE_BITS 为3。所以先将initlen 左移3个bit 变成0000 0001 1000(共有8byte或者4byte)。再与type进行或运算。type为0000 0000 进行或运算后，得到的内容是8bit的，因为type是char类型，即0001 1000 。\n\n   其他sdshdr类型的设置都差不多，详解下sdshdr8.\n\n   `SDS_HDR_VAR(8,s)`  `SDS_HDR_VAR` 是个宏定义的函数\n\n   `#define SDS_HDR_VAR(T,s) struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T)));`\n\n   采用宏定义函数的好处是\n\n   1. 能够减少额外的开销 因为如果写成普通函数的话，函数的调用会在用户栈开辟空间，形参压栈，返回时还需要释放栈，可想而知的开销。使用宏定义函数则在代码规模和速度方面都比函数更胜一筹。宏定义的本质就是替换，所以在使用宏定义函数的地方，执行的时候相当于是在直接执行`struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T)))` 这句代码\n   2. 函数的参数必须被声明为一种特定的类型，所以它只能在类型合适的表达式上使用。而宏定义则可以用于整形、长整形、单浮点型、双浮点型以及其他任何可以用“>”操作符比较值大小的类型，也就是说，宏是与类型无关的。（有点C++模版类的感觉）\n\n   宏定义函数中的## 是（token-pasting）**符号连接操作符** 直接将形参T链接到sdshdr上面。也就是sdshdrT。\n\n   所以这句代码也就很简单了，将字符串指针s向后移动header的大小，也就得到了header的指针。（不过有个疑问是为什么还要重新获取headr的地址，最开始不就是指向了header吗？，难道memset是直接对sh进行操作的？测试过了，memset不会修改sh的地址，所以应该是为了再次确保sh一定指向header）\n\n   解释一下：SDS_HDR_VAR 的作用是将sh的类型修改为结构体指针，因为之前sh 一直都是空指针，(虽然指针的指向地址是headr，但是没有限定它类型)不然后面没法用sh->len, sh->alloc 来访问对应的结构体成员。\n\n   最开始创建的时候alloc 和len是一样大的，没有分配多余空间）\n\n   `memcpy(s, init, initlen);` 函数将init的前initlen个字符拷贝给s。\n\n   memcpy源码为：\n\n   ```\n   /* Public domain.  */\n   #include <stddef.h>\n   \n   void *\n   memcpy (void *dest, const void *src, size_t len)\n   {\n     char *d = dest;\n     const char *s = src;\n     while (len--)\n       *d++ = *s++;\n     return dest;\n   }\n   ```\n\n   整个过程中的三个指针sh,s,fp对应关系如下图\n\n   ![](https://res.cloudinary.com/bravey/image/upload/v1553525055/blog/sds.png)\n\n\n\n## 销毁\n\n销毁使用sdsfree来实现\n\n源码为：\n\n```c\n/* Free an sds string. No operation is performed if 's' is NULL. */\nvoid sdsfree(sds s) {\n    if (s == NULL) return;\n    s_free((char*)s-sdsHdrSize(s[-1]));\n}\n```\n\ns[-1],就是指针s向后移动移位，也就是flag的位置。将s移动到sh的位置，释放sh指针也就释放了整个sds内存。\n\n疑惑：sh指针在sdsnewlen函数中是个局部变量，在sdsnewlen函数中是自动释放的，这里并没有传递sh指针为什么也可以释放对应的空间？\n\n自己想了下：malloc 函数传递的参数是需要分配的内存大小(len)，返回的是指针也就是地址。free()函数只用将malloc函数返回的指针(地址)作为参数传入，就可以释放之前该地址分配到的内存空间。而地址只是首地址，总共的偏移量（大小），应该是由操作系统在内存分配的时候就记录了的。\n\n博客中记录：申请的时候实际上占用的内存要比申请的大。因为超出的空间是用来记录对这块内存的管理信息。额外的空间用来记录管理信息——分配块的长度，指向下一个分配块的指针等等。果然malloc的时候用来一个struct来记录分配的信息。\n\n```c\n  struct mem_control_block { \n    int is_available;    //一般来说应该是一个可用空间的首地址，但这里英文单词却显示出空间是否可用的一个标记\n    int size;            //这是实际空间的大小 \n    };\n```\n\n<http://www.cnblogs.com/hanyonglu/archive/2011/04/28/2031271.html>\n\nfree()就是根据这个结构体的信息来释放malloc()申请的空间\n\n另外的疑惑：释放完空间后，s 指针不用把它指向null吗？  \n\n\n\n暂时就只是创建和销毁的源码把，看了两天，阅读源码真的是酣畅淋漓，收获良多。学到了很多奇妙的C技巧，还对操作系统的知识有了更具象的理解。\n\n## 其他\n\n阅读sdsfromlonglong部分的源码：\n\nsdsfromlonglong 函数用于将一个long long 类型的整形数字转换为字符数组。\n\n```c\n/* Create an sds string from a long long value. It is much faster than:\n *\n * sdscatprintf(sdsempty(),\"%lld\\n\", value);\n */\nsds sdsfromlonglong(long long value) {\n    char buf[SDS_LLSTR_SIZE];  // 给buf数组分配最小的空间，21的长度\n    int len = sdsll2str(buf,value); //将long long 转为字符数组存储在buf中，并返回字符串的长度\n\n    return sdsnewlen(buf,len);\n}\n```\n\n可以看到主要的转换操作在sdsll2str这个函数中：\n\n```c\n/* Helper for sdscatlonglong() doing the actual number -> string\n * conversion. 's' must point to a string with room for at least\n * SDS_LLSTR_SIZE bytes.\n *\n * The function returns the length of the null-terminated string\n * representation stored at 's'. */\n#define SDS_LLSTR_SIZE 21\nint sdsll2str(char *s, long long value) {\n    char *p, aux;\n    unsigned long long v; \n    size_t l;\n\n    /* Generate the string representation, this method produces\n     * an reversed string. */\n    v = (value < 0) ? -value : value;  //判断是否为负数\n    p = s;\n    do {\n        *p++ = '0'+(v%10); // 除以10取余数\n        v /= 10;     //去除个位\n    } while(v);\n    if (value < 0) *p++ = '-';\n\n    /* Compute length and add null term. */\n    l = p-s;   // 计算出字符串的长度 不含终止符\n    *p = '\\0'; // 首地址填终止符。\n\n    /* Reverse the string. */\n    p--;\n    while(s < p) {\n        aux = *s;\n        *s = *p;\n        *p = aux;\n        s++;\n        p--;\n    }\n    return l;\n}\n```\n\n```c\n    do {\n        *p++ = '0'+(v%10); // 除以10取余数\n        v /= 10;     //去除个位\n    } while(v);\n```\n\n假设v是352，变成字符串是将每一个对应的10进制上面的3,5,2这三个个位、十位、百位的数字给单独变成字符。\n\n`*p++ = '0'+(v%10); ` p 指针是字符数组buf的首地址，而将整型变成字符型的操作就是与字符'0' 相加，这样就可以对应的数字变成字符类型。同时p相应的加1来指向下一个byte用来存储下一个被转换的char。\n\nchar类型存储的是对应字符的ascii值，ASCII表为：<https://baike.baidu.com/item/ASCII/309296> ，所以字符的运算实际上是对应的ASCII的值的运算。\nv%10是除以10取余数，352%10 =2； 35%10=5，所以也就是取得v值的10进制上面的个位数。\n所以在while循环里面每次对v除以10并取余，就可以得到对应long long 型的字符串。\n但是因为每次得到的字符都是最后面的个位数，所以352，所输出的字符串数组为：‘2’， ‘3’， ‘5’ 是一个倒序的，因此还需要再反转一次。\n\n```c\n/* Reverse the string. */ \np--;\nwhile(s < p) {\n    aux = *s;\n    *s = *p;\n    *p = aux;\n    s++;\n    p--;\n}\n```\n字符串反转，首尾各有一个指针，当首指针小于尾指针的时候，交换数字，并同时向中间移动\n\n## 参考资料\n\n<https://blog.csdn.net/yangbodong22011/article/details/78419966>","slug":"Redis源码阅读——SDS/2019-03-22-Redis源码阅读——SDS","published":1,"updated":"2019-11-08T13:17:24.974Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6he142d009cdstzbd3o6yyf","content":"<h1 id=\"Redis源码阅读——SDS\"><a href=\"#Redis源码阅读——SDS\" class=\"headerlink\" title=\"Redis源码阅读——SDS\"></a>Redis源码阅读——SDS</h1><p>参考Redis设计与实现 以及网上博客阅读Redis源码。</p>\n<a id=\"more\"></a>\n<p>SDS相关知识点见读书笔记。</p>\n<h2 id=\"创建和销毁\"><a href=\"#创建和销毁\" class=\"headerlink\" title=\"创建和销毁\"></a>创建和销毁</h2><p>为了能够对sds进行相关API的测试，因此把sds模块单独提出来。阅读Redis的Makefile发现，编译sds模块需要的源文件包括<code>sds.c</code>, <code>sds.h</code> <code>zmalloc.c</code> </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test-sds: sds.c sds.h</span><br><span class=\"line\">        $(REDIS_CC) sds.c zmalloc.c -DSDS_TEST_MAIN $(FINAL_LIBS) -o /tmp/sds_test</span><br><span class=\"line\">        /tmp/sds_test</span><br></pre></td></tr></table></figure>\n<p>但是实际编译后会发现会报很多函数未定义的错。原因是redis源码里面sds的内存分配、释放、重分配这些函数是封装成zmalloc,zfee这些函数的，只单纯的把zmalloc.c提取出来是远远不够的。后面发现redis的作者已经把sds给单独提出来了。包括三个源文件<code>sds.c</code>,<code>sds.h</code>,<code>sdsalloc.h</code> 因此执行如下操作即可单独把redis的sds模块提取出来。</p>\n<h3 id=\"提取sds模块\"><a href=\"#提取sds模块\" class=\"headerlink\" title=\"提取sds模块\"></a>提取sds模块</h3><ol>\n<li><p>新建redis_sds测试目录</p>\n<p>选择合适的目录下新建</p>\n<p><code>mkdir redis_sds</code></p>\n</li>\n<li><p>复制源文件至redis_sds目录下</p>\n<p>在redis源码的src目录下执行：</p>\n<p><code>cp sds.c ~/redis_sds/</code></p>\n<p><code>cp sds.h ~/redis_sds/</code></p>\n<p><code>cp sdsalloc.h ~/redis_sds/</code></p>\n</li>\n<li><p>修改sdsalloc.h </p>\n<p>复制过来的sdsalloc.h 将sds模块的内存函数封装为使用zmalloc函数。为了简化处理直接使用libc的malloc函数来进行内存管理，同时将zmalloc.h给注释掉。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//#include \"zmalloc.h\"</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> s_malloc malloc</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> s_realloc realloc</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> s_free free</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>新建主函数</p>\n<p>新建主函数sds_test.c</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"sds.c\"</span></span></span><br><span class=\"line\"><span class=\"comment\">//#include \"sds.h\"</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span> </span>&#123;</span><br><span class=\"line\">    sds s = sdsnew(<span class=\"string\">\"Hello World!\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Length:%d, Type:%d\\n\"</span>, sdslen(s), sdsReqType(sdslen(s)));</span><br><span class=\"line\"></span><br><span class=\"line\">    s = sdscat(s, <span class=\"string\">\"The length of this sentence is greater than 32 bytes\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Length:%d, Type:%d\\n\"</span>, sdslen(s), sdsReqType(sdslen(s)));</span><br><span class=\"line\"></span><br><span class=\"line\">    sdsfree(s);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>直接include sds.c 即可，因为如果#include “sds.h” 的话，sdsReqType这个函数并没有在sds.h里面声明，而且因为sdsReqType的申明是：</p>\n<p><code>static inline char sdsReqType(size_t string_size) {</code>  有static限制所以不能在sds.h中先声明，所以为了简单就直接#include 了sds.c了</p>\n</li>\n<li><p>编译  </p>\n<p>为了方便重复编译，所以写了个简单的Makefile。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test : sds_test.c sds.h sds.c sdsalloc.h</span><br><span class=\"line\">        gcc -o sdstest sds_test.c</span><br></pre></td></tr></table></figure>\n<p>只需要编译sds_test.c 即可。因为sds_test.c 里面是直接#include sds.c 了所以再</p>\n<p><code>gcc -o sdstest sds_test.c sds.c</code> 会将sds.c 里面的函数重复编译两次，造成Multiple definition 问题。</p>\n<p>之后只需要执行make命令就可以生成可执行文件sdstest。</p>\n<p>执行后输出为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./sdstest </span><br><span class=\"line\">Length:12, Type:0</span><br><span class=\"line\">Length:64, Type:1</span><br></pre></td></tr></table></figure>\n<h3 id=\"sds的创建\"><a href=\"#sds的创建\" class=\"headerlink\" title=\"sds的创建\"></a>sds的创建</h3><p>通过<code>sdsnew</code> 来创建了一个sds。sdsnew源码为：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Create a new sds string starting from a null terminated C string. */</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdsnew</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *init)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//使用？条件判断符来简化if语句对NULL的判断，直接使用strlen来返回字符指针的长度。</span></span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> initlen = (init == <span class=\"literal\">NULL</span>) ? <span class=\"number\">0</span> : <span class=\"built_in\">strlen</span>(init); </span><br><span class=\"line\">    <span class=\"keyword\">return</span> sdsnewlen(init, initlen);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要注意的是字符数组和字符指针是有区别的：字符指针的数据是存放在进程的虚拟地址空间的程序代码和数据段，是只读的不能修改。字符数组存放的字符串数据是存放在用户栈的，是可以更改的。且字符指针的数据没有”\\0”这个结束符。</p>\n<p>参考博客讲的很好：<a href=\"https://blog.csdn.net/on_1y/article/details/13030439\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/on_1y/article/details/13030439</a></p>\n<p><code>sdsnew</code> 通过把字符串长度和字符串传递给<code>sdsnewlen</code>，来完成创建。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Create a new sds string with the content specified by the 'init' pointer</span></span><br><span class=\"line\"><span class=\"comment\"> * and 'initlen'.</span></span><br><span class=\"line\"><span class=\"comment\"> * If NULL is used for 'init' the string is initialized with zero bytes.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * The string is always null-termined (all the sds strings are, always) so</span></span><br><span class=\"line\"><span class=\"comment\"> * even if you create an sds string with:</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * mystring = n(\"abc\",3);</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * You can print the string with printf() as there is an implicit \\0 at the</span></span><br><span class=\"line\"><span class=\"comment\"> * end of the string. However the string is binary safe and can contain</span></span><br><span class=\"line\"><span class=\"comment\"> * \\0 characters in the middle, as the length is stored in the sds header. */</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdsnewlen</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *init, <span class=\"keyword\">size_t</span> initlen)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *sh;</span><br><span class=\"line\">    sds s;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> type = sdsReqType(initlen);  <span class=\"comment\">//返回字符串对应的type</span></span><br><span class=\"line\">    <span class=\"comment\">/* Empty strings are usually created in order to append. Use type 8</span></span><br><span class=\"line\"><span class=\"comment\">     * since type 5 is not good at this. */</span></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    空字符串使用sdshdr8来存储，而不是sdshdr5,（虽然长度小于32），因为sdshdr5不适合扩容。</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type == SDS_TYPE_5 &amp;&amp; initlen == <span class=\"number\">0</span>) type = SDS_TYPE_8;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> hdrlen = sdsHdrSize(type); <span class=\"comment\">// 返回对应类型的sdsheader长度。</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *fp; <span class=\"comment\">/* flags pointer. */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    sh = s_malloc(hdrlen+initlen+<span class=\"number\">1</span>); <span class=\"comment\">// 申请头部+字符串+NULL的大小。(单位为byte)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!init)</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(sh, <span class=\"number\">0</span>, hdrlen+initlen+<span class=\"number\">1</span>); <span class=\"comment\">// 将sh后面对应大小的字节全部置为0；</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sh == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    s = (<span class=\"keyword\">char</span>*)sh+hdrlen; <span class=\"comment\">//s指针指向字符串的首字节。</span></span><br><span class=\"line\">    fp = ((<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span>*)s)<span class=\"number\">-1</span>; <span class=\"comment\">// fp指针指向flag</span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span>(type) &#123;  <span class=\"comment\">// 初始化sdshdr</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> SDS_TYPE_5: &#123;</span><br><span class=\"line\">            *fp = type | (initlen &lt;&lt; SDS_TYPE_BITS);<span class=\"comment\">// 设置flag这个字节的具体值</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SDS_TYPE_8: &#123;</span><br><span class=\"line\">            SDS_HDR_VAR(<span class=\"number\">8</span>,s); <span class=\"comment\">// 获取header指针sh</span></span><br><span class=\"line\">            sh-&gt;len = initlen; <span class=\"comment\">//header中len的初始</span></span><br><span class=\"line\">            sh-&gt;alloc = initlen; <span class=\"comment\">//header 中alloc的初试</span></span><br><span class=\"line\">            *fp = type;  <span class=\"comment\">//flag 的初始。</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SDS_TYPE_16: &#123;</span><br><span class=\"line\">            SDS_HDR_VAR(<span class=\"number\">16</span>,s);</span><br><span class=\"line\">            sh-&gt;len = initlen;</span><br><span class=\"line\">            sh-&gt;alloc = initlen;</span><br><span class=\"line\">            *fp = type; </span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SDS_TYPE_32: &#123;</span><br><span class=\"line\">            SDS_HDR_VAR(<span class=\"number\">32</span>,s);</span><br><span class=\"line\">            sh-&gt;len = initlen;</span><br><span class=\"line\">            sh-&gt;alloc = initlen;</span><br><span class=\"line\">            *fp = type;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SDS_TYPE_64: &#123;</span><br><span class=\"line\">            SDS_HDR_VAR(<span class=\"number\">64</span>,s);</span><br><span class=\"line\">            sh-&gt;len = initlen;</span><br><span class=\"line\">            sh-&gt;alloc = initlen;</span><br><span class=\"line\">            *fp = type;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initlen &amp;&amp; init)</span><br><span class=\"line\">        <span class=\"built_in\">memcpy</span>(s, init, initlen); <span class=\"comment\">// 将字符串拷贝到s(也就是buf数组)</span></span><br><span class=\"line\">    s[initlen] = <span class=\"string\">'\\0'</span>; <span class=\"comment\">//在字符串后面添加终止符</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>char type = sdsReqType(initlen);</code> 获取sds类型，源码分析在读书笔记里面有记录。源码为</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">char</span> <span class=\"title\">sdsReqType</span><span class=\"params\">(<span class=\"keyword\">size_t</span> string_size)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (string_size &lt; <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">5</span>) <span class=\"comment\">// string_size &lt; 2^5</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> SDS_TYPE_5;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (string_size &lt; <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">8</span>)  <span class=\"comment\">//string_size &lt; 2^8</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> SDS_TYPE_8;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (string_size &lt; <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">16</span>)\t<span class=\"comment\">//string_size &lt; 2^16</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> SDS_TYPE_16;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> (LONG_MAX == LLONG_MAX)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (string_size &lt; <span class=\"number\">1l</span>l&lt;&lt;<span class=\"number\">32</span>)  <span class=\"comment\">//string_size &lt; 2^32</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> SDS_TYPE_32;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> SDS_TYPE_64; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>采用左移来计算对应多少位的范围，而不是用2^5 这样的乘法。<strong>直接移位比使用幂来计算快很多</strong>。</p>\n<p><code>1&lt;&lt;5</code>   计算出来就是2^5 次方。1是int型，4byte32位。最低8bit位的二进制为：00000001 左移5位后变成了：00100000 对应的十进制既是32。</p>\n<p>计算n个bit位的最大值：(1&lt;&lt;n) -1</p>\n<p>但是需要注意位数不够的情况。因为1是int型，只有32个bit。所以在左移32个bit时，需要使用long long int型。用1ll来表示，此时1ll为64个bit。</p>\n<p>还得考虑机器是否为64位机器，在32位机器上LONG_MAX = 2147483647L，64位机器上LONG_MAX = 9223372036854775807L 。不论32位机器还是64位机器上 LLONG_MAX 都是9223372036854775807L 。所以当LONG_MAX == LLONG_MAX 说明字长为64bit。加上条件编译，说明在32位机器上不使用sdshdr32而直接跳到了sdshdr64，仅仅在64位机器上使用sdshdr32。原因是什么？还没想通</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">sdsHdrSize</span><span class=\"params\">(<span class=\"keyword\">char</span> type)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span>(type&amp;SDS_TYPE_MASK) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SDS_TYPE_5:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">sizeof</span>(struct sdshdr5);</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SDS_TYPE_8:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">sizeof</span>(struct sdshdr8);</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SDS_TYPE_16:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">sizeof</span>(struct sdshdr16);</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SDS_TYPE_32:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">sizeof</span>(struct sdshdr32);</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SDS_TYPE_64:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">sizeof</span>(struct sdshdr64);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为struct里面的buf数组是柔性数组，计算结构体的大小的时候不会计算在内。</p>\n<p><code>memset(sh, 0, hdrlen+initlen+1);</code>  memset函数会将sh中当前位置后面的<code>hdrlen+initlen+1</code>个字节全部置于0。 注意sh指向的是<code>hdrlen+initlen+1</code> 个字节的首个字节。（sh指针存储的地址就是首个字节的地址。） </p>\n<p>memset源码为：<a href=\"https://github.com/gcc-mirror/gcc/blob/master/libgcc/memset.c\" target=\"_blank\" rel=\"noopener\">https://github.com/gcc-mirror/gcc/blob/master/libgcc/memset.c</a></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Public domain.  */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stddef.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> *</span><br><span class=\"line\"><span class=\"built_in\">memset</span> (<span class=\"keyword\">void</span> *dest, <span class=\"keyword\">int</span> val, <span class=\"keyword\">size_t</span> len)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *ptr = dest; <span class=\"comment\">// 用char来限定每次指针+1只移动一个字节。</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (len-- &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    *ptr++ = val;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dest;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>假设<code>hdrlen+initlen+1</code> 为8 ，经过memset后，从sh首字节开始共有8个字节都被置为0。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1553525055/blog/memset.png\" alt=\"\"></p>\n<p>指针的类型时用来确定指针需要从首地址寻址（偏移）多少个字节。比如int * 指针说明指针存储的地址朝后面偏移3个字节才是这个int类型的所有数据。即指针存储的地址时起点，而终点是由类型来确定的。此外，类型也是指针加减的步长，比如char类型的步长就是1byte，而uint_16类型的指针步长就是2byte。</p>\n<p>随后用switch语句对不同类型的sdshdr设置初始值。</p>\n<p>首先是sdshdr5</p>\n<p> <code>*fp = type | (initlen &lt;&lt; SDS_TYPE_BITS)</code> 使用移位和或操作的方式来对8个bit位赋值。(不得不感慨这些操作真的是太巧妙了)</p>\n<p>假设initlen为3。则initlen的二进制为0000 0011（应该是8byte（64位机器）或者4byte（32位机器），为了简单用1byte的二进制表示）而SDS_TYPE_BITS 为3。所以先将initlen 左移3个bit 变成0000 0001 1000(共有8byte或者4byte)。再与type进行或运算。type为0000 0000 进行或运算后，得到的内容是8bit的，因为type是char类型，即0001 1000 。</p>\n<p>其他sdshdr类型的设置都差不多，详解下sdshdr8.</p>\n<p><code>SDS_HDR_VAR(8,s)</code>  <code>SDS_HDR_VAR</code> 是个宏定义的函数</p>\n<p><code>#define SDS_HDR_VAR(T,s) struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T)));</code></p>\n<p>采用宏定义函数的好处是</p>\n<ol>\n<li>能够减少额外的开销 因为如果写成普通函数的话，函数的调用会在用户栈开辟空间，形参压栈，返回时还需要释放栈，可想而知的开销。使用宏定义函数则在代码规模和速度方面都比函数更胜一筹。宏定义的本质就是替换，所以在使用宏定义函数的地方，执行的时候相当于是在直接执行<code>struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T)))</code> 这句代码</li>\n<li>函数的参数必须被声明为一种特定的类型，所以它只能在类型合适的表达式上使用。而宏定义则可以用于整形、长整形、单浮点型、双浮点型以及其他任何可以用“&gt;”操作符比较值大小的类型，也就是说，宏是与类型无关的。（有点C++模版类的感觉）</li>\n</ol>\n<p>宏定义函数中的## 是（token-pasting）<strong>符号连接操作符</strong> 直接将形参T链接到sdshdr上面。也就是sdshdrT。</p>\n<p>所以这句代码也就很简单了，将字符串指针s向后移动header的大小，也就得到了header的指针。（不过有个疑问是为什么还要重新获取headr的地址，最开始不就是指向了header吗？，难道memset是直接对sh进行操作的？测试过了，memset不会修改sh的地址，所以应该是为了再次确保sh一定指向header）</p>\n<p>解释一下：SDS_HDR_VAR 的作用是将sh的类型修改为结构体指针，因为之前sh 一直都是空指针，(虽然指针的指向地址是headr，但是没有限定它类型)不然后面没法用sh-&gt;len, sh-&gt;alloc 来访问对应的结构体成员。</p>\n<p>最开始创建的时候alloc 和len是一样大的，没有分配多余空间）</p>\n<p><code>memcpy(s, init, initlen);</code> 函数将init的前initlen个字符拷贝给s。</p>\n<p>memcpy源码为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* Public domain.  */</span><br><span class=\"line\">#include &lt;stddef.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">void *</span><br><span class=\"line\">memcpy (void *dest, const void *src, size_t len)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  char *d = dest;</span><br><span class=\"line\">  const char *s = src;</span><br><span class=\"line\">  while (len--)</span><br><span class=\"line\">    *d++ = *s++;</span><br><span class=\"line\">  return dest;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>整个过程中的三个指针sh,s,fp对应关系如下图</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1553525055/blog/sds.png\" alt=\"\"></p>\n</li>\n</ol>\n<h2 id=\"销毁\"><a href=\"#销毁\" class=\"headerlink\" title=\"销毁\"></a>销毁</h2><p>销毁使用sdsfree来实现</p>\n<p>源码为：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Free an sds string. No operation is performed if 's' is NULL. */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sdsfree</span><span class=\"params\">(sds s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    s_free((<span class=\"keyword\">char</span>*)s-sdsHdrSize(s[<span class=\"number\">-1</span>]));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>s[-1],就是指针s向后移动移位，也就是flag的位置。将s移动到sh的位置，释放sh指针也就释放了整个sds内存。</p>\n<p>疑惑：sh指针在sdsnewlen函数中是个局部变量，在sdsnewlen函数中是自动释放的，这里并没有传递sh指针为什么也可以释放对应的空间？</p>\n<p>自己想了下：malloc 函数传递的参数是需要分配的内存大小(len)，返回的是指针也就是地址。free()函数只用将malloc函数返回的指针(地址)作为参数传入，就可以释放之前该地址分配到的内存空间。而地址只是首地址，总共的偏移量（大小），应该是由操作系统在内存分配的时候就记录了的。</p>\n<p>博客中记录：申请的时候实际上占用的内存要比申请的大。因为超出的空间是用来记录对这块内存的管理信息。额外的空间用来记录管理信息——分配块的长度，指向下一个分配块的指针等等。果然malloc的时候用来一个struct来记录分配的信息。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mem_control_block</span> &#123;</span> </span><br><span class=\"line\">  <span class=\"keyword\">int</span> is_available;    <span class=\"comment\">//一般来说应该是一个可用空间的首地址，但这里英文单词却显示出空间是否可用的一个标记</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> size;            <span class=\"comment\">//这是实际空间的大小 </span></span><br><span class=\"line\">  &#125;;</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://www.cnblogs.com/hanyonglu/archive/2011/04/28/2031271.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/hanyonglu/archive/2011/04/28/2031271.html</a></p>\n<p>free()就是根据这个结构体的信息来释放malloc()申请的空间</p>\n<p>另外的疑惑：释放完空间后，s 指针不用把它指向null吗？  </p>\n<p>暂时就只是创建和销毁的源码把，看了两天，阅读源码真的是酣畅淋漓，收获良多。学到了很多奇妙的C技巧，还对操作系统的知识有了更具象的理解。</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>阅读sdsfromlonglong部分的源码：</p>\n<p>sdsfromlonglong 函数用于将一个long long 类型的整形数字转换为字符数组。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Create an sds string from a long long value. It is much faster than:</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * sdscatprintf(sdsempty(),\"%lld\\n\", value);</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdsfromlonglong</span><span class=\"params\">(<span class=\"keyword\">long</span> <span class=\"keyword\">long</span> value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[SDS_LLSTR_SIZE];  <span class=\"comment\">// 给buf数组分配最小的空间，21的长度</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = sdsll2str(buf,value); <span class=\"comment\">//将long long 转为字符数组存储在buf中，并返回字符串的长度</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sdsnewlen(buf,len);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到主要的转换操作在sdsll2str这个函数中：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Helper for sdscatlonglong() doing the actual number -&gt; string</span></span><br><span class=\"line\"><span class=\"comment\"> * conversion. 's' must point to a string with room for at least</span></span><br><span class=\"line\"><span class=\"comment\"> * SDS_LLSTR_SIZE bytes.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * The function returns the length of the null-terminated string</span></span><br><span class=\"line\"><span class=\"comment\"> * representation stored at 's'. */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SDS_LLSTR_SIZE 21</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sdsll2str</span><span class=\"params\">(<span class=\"keyword\">char</span> *s, <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *p, aux;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> v; </span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> l;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Generate the string representation, this method produces</span></span><br><span class=\"line\"><span class=\"comment\">     * an reversed string. */</span></span><br><span class=\"line\">    v = (value &lt; <span class=\"number\">0</span>) ? -value : value;  <span class=\"comment\">//判断是否为负数</span></span><br><span class=\"line\">    p = s;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        *p++ = <span class=\"string\">'0'</span>+(v%<span class=\"number\">10</span>); <span class=\"comment\">// 除以10取余数</span></span><br><span class=\"line\">        v /= <span class=\"number\">10</span>;     <span class=\"comment\">//去除个位</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span>(v);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value &lt; <span class=\"number\">0</span>) *p++ = <span class=\"string\">'-'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Compute length and add null term. */</span></span><br><span class=\"line\">    l = p-s;   <span class=\"comment\">// 计算出字符串的长度 不含终止符</span></span><br><span class=\"line\">    *p = <span class=\"string\">'\\0'</span>; <span class=\"comment\">// 首地址填终止符。</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Reverse the string. */</span></span><br><span class=\"line\">    p--;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(s &lt; p) &#123;</span><br><span class=\"line\">        aux = *s;</span><br><span class=\"line\">        *s = *p;</span><br><span class=\"line\">        *p = aux;</span><br><span class=\"line\">        s++;</span><br><span class=\"line\">        p--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> l;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    *p++ = <span class=\"string\">'0'</span>+(v%<span class=\"number\">10</span>); <span class=\"comment\">// 除以10取余数</span></span><br><span class=\"line\">    v /= <span class=\"number\">10</span>;     <span class=\"comment\">//去除个位</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span>(v);</span><br></pre></td></tr></table></figure>\n<p>假设v是352，变成字符串是将每一个对应的10进制上面的3,5,2这三个个位、十位、百位的数字给单独变成字符。</p>\n<p><code>*p++ = &#39;0&#39;+(v%10);</code> p 指针是字符数组buf的首地址，而将整型变成字符型的操作就是与字符’0’ 相加，这样就可以对应的数字变成字符类型。同时p相应的加1来指向下一个byte用来存储下一个被转换的char。</p>\n<p>char类型存储的是对应字符的ascii值，ASCII表为：<a href=\"https://baike.baidu.com/item/ASCII/309296\" target=\"_blank\" rel=\"noopener\">https://baike.baidu.com/item/ASCII/309296</a> ，所以字符的运算实际上是对应的ASCII的值的运算。<br>v%10是除以10取余数，352%10 =2； 35%10=5，所以也就是取得v值的10进制上面的个位数。<br>所以在while循环里面每次对v除以10并取余，就可以得到对应long long 型的字符串。<br>但是因为每次得到的字符都是最后面的个位数，所以352，所输出的字符串数组为：‘2’， ‘3’， ‘5’ 是一个倒序的，因此还需要再反转一次。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Reverse the string. */</span> </span><br><span class=\"line\">p--;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(s &lt; p) &#123;</span><br><span class=\"line\">    aux = *s;</span><br><span class=\"line\">    *s = *p;</span><br><span class=\"line\">    *p = aux;</span><br><span class=\"line\">    s++;</span><br><span class=\"line\">    p--;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>字符串反转，首尾各有一个指针，当首指针小于尾指针的时候，交换数字，并同时向中间移动</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://blog.csdn.net/yangbodong22011/article/details/78419966\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/yangbodong22011/article/details/78419966</a></p>\n","site":{"data":{}},"length":9911,"excerpt":"<h1 id=\"Redis源码阅读——SDS\"><a href=\"#Redis源码阅读——SDS\" class=\"headerlink\" title=\"Redis源码阅读——SDS\"></a>Redis源码阅读——SDS</h1><p>参考Redis设计与实现 以及网上博客阅读Redis源码。</p>","more":"<p>SDS相关知识点见读书笔记。</p>\n<h2 id=\"创建和销毁\"><a href=\"#创建和销毁\" class=\"headerlink\" title=\"创建和销毁\"></a>创建和销毁</h2><p>为了能够对sds进行相关API的测试，因此把sds模块单独提出来。阅读Redis的Makefile发现，编译sds模块需要的源文件包括<code>sds.c</code>, <code>sds.h</code> <code>zmalloc.c</code> </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test-sds: sds.c sds.h</span><br><span class=\"line\">        $(REDIS_CC) sds.c zmalloc.c -DSDS_TEST_MAIN $(FINAL_LIBS) -o /tmp/sds_test</span><br><span class=\"line\">        /tmp/sds_test</span><br></pre></td></tr></table></figure>\n<p>但是实际编译后会发现会报很多函数未定义的错。原因是redis源码里面sds的内存分配、释放、重分配这些函数是封装成zmalloc,zfee这些函数的，只单纯的把zmalloc.c提取出来是远远不够的。后面发现redis的作者已经把sds给单独提出来了。包括三个源文件<code>sds.c</code>,<code>sds.h</code>,<code>sdsalloc.h</code> 因此执行如下操作即可单独把redis的sds模块提取出来。</p>\n<h3 id=\"提取sds模块\"><a href=\"#提取sds模块\" class=\"headerlink\" title=\"提取sds模块\"></a>提取sds模块</h3><ol>\n<li><p>新建redis_sds测试目录</p>\n<p>选择合适的目录下新建</p>\n<p><code>mkdir redis_sds</code></p>\n</li>\n<li><p>复制源文件至redis_sds目录下</p>\n<p>在redis源码的src目录下执行：</p>\n<p><code>cp sds.c ~/redis_sds/</code></p>\n<p><code>cp sds.h ~/redis_sds/</code></p>\n<p><code>cp sdsalloc.h ~/redis_sds/</code></p>\n</li>\n<li><p>修改sdsalloc.h </p>\n<p>复制过来的sdsalloc.h 将sds模块的内存函数封装为使用zmalloc函数。为了简化处理直接使用libc的malloc函数来进行内存管理，同时将zmalloc.h给注释掉。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//#include \"zmalloc.h\"</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> s_malloc malloc</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> s_realloc realloc</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> s_free free</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>新建主函数</p>\n<p>新建主函数sds_test.c</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"sds.c\"</span></span></span><br><span class=\"line\"><span class=\"comment\">//#include \"sds.h\"</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span> </span>&#123;</span><br><span class=\"line\">    sds s = sdsnew(<span class=\"string\">\"Hello World!\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Length:%d, Type:%d\\n\"</span>, sdslen(s), sdsReqType(sdslen(s)));</span><br><span class=\"line\"></span><br><span class=\"line\">    s = sdscat(s, <span class=\"string\">\"The length of this sentence is greater than 32 bytes\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Length:%d, Type:%d\\n\"</span>, sdslen(s), sdsReqType(sdslen(s)));</span><br><span class=\"line\"></span><br><span class=\"line\">    sdsfree(s);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>直接include sds.c 即可，因为如果#include “sds.h” 的话，sdsReqType这个函数并没有在sds.h里面声明，而且因为sdsReqType的申明是：</p>\n<p><code>static inline char sdsReqType(size_t string_size) {</code>  有static限制所以不能在sds.h中先声明，所以为了简单就直接#include 了sds.c了</p>\n</li>\n<li><p>编译  </p>\n<p>为了方便重复编译，所以写了个简单的Makefile。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test : sds_test.c sds.h sds.c sdsalloc.h</span><br><span class=\"line\">        gcc -o sdstest sds_test.c</span><br></pre></td></tr></table></figure>\n<p>只需要编译sds_test.c 即可。因为sds_test.c 里面是直接#include sds.c 了所以再</p>\n<p><code>gcc -o sdstest sds_test.c sds.c</code> 会将sds.c 里面的函数重复编译两次，造成Multiple definition 问题。</p>\n<p>之后只需要执行make命令就可以生成可执行文件sdstest。</p>\n<p>执行后输出为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./sdstest </span><br><span class=\"line\">Length:12, Type:0</span><br><span class=\"line\">Length:64, Type:1</span><br></pre></td></tr></table></figure>\n<h3 id=\"sds的创建\"><a href=\"#sds的创建\" class=\"headerlink\" title=\"sds的创建\"></a>sds的创建</h3><p>通过<code>sdsnew</code> 来创建了一个sds。sdsnew源码为：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Create a new sds string starting from a null terminated C string. */</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdsnew</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *init)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//使用？条件判断符来简化if语句对NULL的判断，直接使用strlen来返回字符指针的长度。</span></span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> initlen = (init == <span class=\"literal\">NULL</span>) ? <span class=\"number\">0</span> : <span class=\"built_in\">strlen</span>(init); </span><br><span class=\"line\">    <span class=\"keyword\">return</span> sdsnewlen(init, initlen);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要注意的是字符数组和字符指针是有区别的：字符指针的数据是存放在进程的虚拟地址空间的程序代码和数据段，是只读的不能修改。字符数组存放的字符串数据是存放在用户栈的，是可以更改的。且字符指针的数据没有”\\0”这个结束符。</p>\n<p>参考博客讲的很好：<a href=\"https://blog.csdn.net/on_1y/article/details/13030439\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/on_1y/article/details/13030439</a></p>\n<p><code>sdsnew</code> 通过把字符串长度和字符串传递给<code>sdsnewlen</code>，来完成创建。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Create a new sds string with the content specified by the 'init' pointer</span></span><br><span class=\"line\"><span class=\"comment\"> * and 'initlen'.</span></span><br><span class=\"line\"><span class=\"comment\"> * If NULL is used for 'init' the string is initialized with zero bytes.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * The string is always null-termined (all the sds strings are, always) so</span></span><br><span class=\"line\"><span class=\"comment\"> * even if you create an sds string with:</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * mystring = n(\"abc\",3);</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * You can print the string with printf() as there is an implicit \\0 at the</span></span><br><span class=\"line\"><span class=\"comment\"> * end of the string. However the string is binary safe and can contain</span></span><br><span class=\"line\"><span class=\"comment\"> * \\0 characters in the middle, as the length is stored in the sds header. */</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdsnewlen</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *init, <span class=\"keyword\">size_t</span> initlen)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *sh;</span><br><span class=\"line\">    sds s;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> type = sdsReqType(initlen);  <span class=\"comment\">//返回字符串对应的type</span></span><br><span class=\"line\">    <span class=\"comment\">/* Empty strings are usually created in order to append. Use type 8</span></span><br><span class=\"line\"><span class=\"comment\">     * since type 5 is not good at this. */</span></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    空字符串使用sdshdr8来存储，而不是sdshdr5,（虽然长度小于32），因为sdshdr5不适合扩容。</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type == SDS_TYPE_5 &amp;&amp; initlen == <span class=\"number\">0</span>) type = SDS_TYPE_8;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> hdrlen = sdsHdrSize(type); <span class=\"comment\">// 返回对应类型的sdsheader长度。</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *fp; <span class=\"comment\">/* flags pointer. */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    sh = s_malloc(hdrlen+initlen+<span class=\"number\">1</span>); <span class=\"comment\">// 申请头部+字符串+NULL的大小。(单位为byte)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!init)</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(sh, <span class=\"number\">0</span>, hdrlen+initlen+<span class=\"number\">1</span>); <span class=\"comment\">// 将sh后面对应大小的字节全部置为0；</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sh == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    s = (<span class=\"keyword\">char</span>*)sh+hdrlen; <span class=\"comment\">//s指针指向字符串的首字节。</span></span><br><span class=\"line\">    fp = ((<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span>*)s)<span class=\"number\">-1</span>; <span class=\"comment\">// fp指针指向flag</span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span>(type) &#123;  <span class=\"comment\">// 初始化sdshdr</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> SDS_TYPE_5: &#123;</span><br><span class=\"line\">            *fp = type | (initlen &lt;&lt; SDS_TYPE_BITS);<span class=\"comment\">// 设置flag这个字节的具体值</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SDS_TYPE_8: &#123;</span><br><span class=\"line\">            SDS_HDR_VAR(<span class=\"number\">8</span>,s); <span class=\"comment\">// 获取header指针sh</span></span><br><span class=\"line\">            sh-&gt;len = initlen; <span class=\"comment\">//header中len的初始</span></span><br><span class=\"line\">            sh-&gt;alloc = initlen; <span class=\"comment\">//header 中alloc的初试</span></span><br><span class=\"line\">            *fp = type;  <span class=\"comment\">//flag 的初始。</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SDS_TYPE_16: &#123;</span><br><span class=\"line\">            SDS_HDR_VAR(<span class=\"number\">16</span>,s);</span><br><span class=\"line\">            sh-&gt;len = initlen;</span><br><span class=\"line\">            sh-&gt;alloc = initlen;</span><br><span class=\"line\">            *fp = type; </span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SDS_TYPE_32: &#123;</span><br><span class=\"line\">            SDS_HDR_VAR(<span class=\"number\">32</span>,s);</span><br><span class=\"line\">            sh-&gt;len = initlen;</span><br><span class=\"line\">            sh-&gt;alloc = initlen;</span><br><span class=\"line\">            *fp = type;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SDS_TYPE_64: &#123;</span><br><span class=\"line\">            SDS_HDR_VAR(<span class=\"number\">64</span>,s);</span><br><span class=\"line\">            sh-&gt;len = initlen;</span><br><span class=\"line\">            sh-&gt;alloc = initlen;</span><br><span class=\"line\">            *fp = type;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initlen &amp;&amp; init)</span><br><span class=\"line\">        <span class=\"built_in\">memcpy</span>(s, init, initlen); <span class=\"comment\">// 将字符串拷贝到s(也就是buf数组)</span></span><br><span class=\"line\">    s[initlen] = <span class=\"string\">'\\0'</span>; <span class=\"comment\">//在字符串后面添加终止符</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>char type = sdsReqType(initlen);</code> 获取sds类型，源码分析在读书笔记里面有记录。源码为</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">char</span> <span class=\"title\">sdsReqType</span><span class=\"params\">(<span class=\"keyword\">size_t</span> string_size)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (string_size &lt; <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">5</span>) <span class=\"comment\">// string_size &lt; 2^5</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> SDS_TYPE_5;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (string_size &lt; <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">8</span>)  <span class=\"comment\">//string_size &lt; 2^8</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> SDS_TYPE_8;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (string_size &lt; <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">16</span>)\t<span class=\"comment\">//string_size &lt; 2^16</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> SDS_TYPE_16;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> (LONG_MAX == LLONG_MAX)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (string_size &lt; <span class=\"number\">1l</span>l&lt;&lt;<span class=\"number\">32</span>)  <span class=\"comment\">//string_size &lt; 2^32</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> SDS_TYPE_32;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> SDS_TYPE_64; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>采用左移来计算对应多少位的范围，而不是用2^5 这样的乘法。<strong>直接移位比使用幂来计算快很多</strong>。</p>\n<p><code>1&lt;&lt;5</code>   计算出来就是2^5 次方。1是int型，4byte32位。最低8bit位的二进制为：00000001 左移5位后变成了：00100000 对应的十进制既是32。</p>\n<p>计算n个bit位的最大值：(1&lt;&lt;n) -1</p>\n<p>但是需要注意位数不够的情况。因为1是int型，只有32个bit。所以在左移32个bit时，需要使用long long int型。用1ll来表示，此时1ll为64个bit。</p>\n<p>还得考虑机器是否为64位机器，在32位机器上LONG_MAX = 2147483647L，64位机器上LONG_MAX = 9223372036854775807L 。不论32位机器还是64位机器上 LLONG_MAX 都是9223372036854775807L 。所以当LONG_MAX == LLONG_MAX 说明字长为64bit。加上条件编译，说明在32位机器上不使用sdshdr32而直接跳到了sdshdr64，仅仅在64位机器上使用sdshdr32。原因是什么？还没想通</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">sdsHdrSize</span><span class=\"params\">(<span class=\"keyword\">char</span> type)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span>(type&amp;SDS_TYPE_MASK) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SDS_TYPE_5:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">sizeof</span>(struct sdshdr5);</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SDS_TYPE_8:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">sizeof</span>(struct sdshdr8);</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SDS_TYPE_16:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">sizeof</span>(struct sdshdr16);</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SDS_TYPE_32:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">sizeof</span>(struct sdshdr32);</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SDS_TYPE_64:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">sizeof</span>(struct sdshdr64);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为struct里面的buf数组是柔性数组，计算结构体的大小的时候不会计算在内。</p>\n<p><code>memset(sh, 0, hdrlen+initlen+1);</code>  memset函数会将sh中当前位置后面的<code>hdrlen+initlen+1</code>个字节全部置于0。 注意sh指向的是<code>hdrlen+initlen+1</code> 个字节的首个字节。（sh指针存储的地址就是首个字节的地址。） </p>\n<p>memset源码为：<a href=\"https://github.com/gcc-mirror/gcc/blob/master/libgcc/memset.c\" target=\"_blank\" rel=\"noopener\">https://github.com/gcc-mirror/gcc/blob/master/libgcc/memset.c</a></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Public domain.  */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stddef.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> *</span><br><span class=\"line\"><span class=\"built_in\">memset</span> (<span class=\"keyword\">void</span> *dest, <span class=\"keyword\">int</span> val, <span class=\"keyword\">size_t</span> len)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *ptr = dest; <span class=\"comment\">// 用char来限定每次指针+1只移动一个字节。</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (len-- &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    *ptr++ = val;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dest;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>假设<code>hdrlen+initlen+1</code> 为8 ，经过memset后，从sh首字节开始共有8个字节都被置为0。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1553525055/blog/memset.png\" alt=\"\"></p>\n<p>指针的类型时用来确定指针需要从首地址寻址（偏移）多少个字节。比如int * 指针说明指针存储的地址朝后面偏移3个字节才是这个int类型的所有数据。即指针存储的地址时起点，而终点是由类型来确定的。此外，类型也是指针加减的步长，比如char类型的步长就是1byte，而uint_16类型的指针步长就是2byte。</p>\n<p>随后用switch语句对不同类型的sdshdr设置初始值。</p>\n<p>首先是sdshdr5</p>\n<p> <code>*fp = type | (initlen &lt;&lt; SDS_TYPE_BITS)</code> 使用移位和或操作的方式来对8个bit位赋值。(不得不感慨这些操作真的是太巧妙了)</p>\n<p>假设initlen为3。则initlen的二进制为0000 0011（应该是8byte（64位机器）或者4byte（32位机器），为了简单用1byte的二进制表示）而SDS_TYPE_BITS 为3。所以先将initlen 左移3个bit 变成0000 0001 1000(共有8byte或者4byte)。再与type进行或运算。type为0000 0000 进行或运算后，得到的内容是8bit的，因为type是char类型，即0001 1000 。</p>\n<p>其他sdshdr类型的设置都差不多，详解下sdshdr8.</p>\n<p><code>SDS_HDR_VAR(8,s)</code>  <code>SDS_HDR_VAR</code> 是个宏定义的函数</p>\n<p><code>#define SDS_HDR_VAR(T,s) struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T)));</code></p>\n<p>采用宏定义函数的好处是</p>\n<ol>\n<li>能够减少额外的开销 因为如果写成普通函数的话，函数的调用会在用户栈开辟空间，形参压栈，返回时还需要释放栈，可想而知的开销。使用宏定义函数则在代码规模和速度方面都比函数更胜一筹。宏定义的本质就是替换，所以在使用宏定义函数的地方，执行的时候相当于是在直接执行<code>struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T)))</code> 这句代码</li>\n<li>函数的参数必须被声明为一种特定的类型，所以它只能在类型合适的表达式上使用。而宏定义则可以用于整形、长整形、单浮点型、双浮点型以及其他任何可以用“&gt;”操作符比较值大小的类型，也就是说，宏是与类型无关的。（有点C++模版类的感觉）</li>\n</ol>\n<p>宏定义函数中的## 是（token-pasting）<strong>符号连接操作符</strong> 直接将形参T链接到sdshdr上面。也就是sdshdrT。</p>\n<p>所以这句代码也就很简单了，将字符串指针s向后移动header的大小，也就得到了header的指针。（不过有个疑问是为什么还要重新获取headr的地址，最开始不就是指向了header吗？，难道memset是直接对sh进行操作的？测试过了，memset不会修改sh的地址，所以应该是为了再次确保sh一定指向header）</p>\n<p>解释一下：SDS_HDR_VAR 的作用是将sh的类型修改为结构体指针，因为之前sh 一直都是空指针，(虽然指针的指向地址是headr，但是没有限定它类型)不然后面没法用sh-&gt;len, sh-&gt;alloc 来访问对应的结构体成员。</p>\n<p>最开始创建的时候alloc 和len是一样大的，没有分配多余空间）</p>\n<p><code>memcpy(s, init, initlen);</code> 函数将init的前initlen个字符拷贝给s。</p>\n<p>memcpy源码为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* Public domain.  */</span><br><span class=\"line\">#include &lt;stddef.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">void *</span><br><span class=\"line\">memcpy (void *dest, const void *src, size_t len)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  char *d = dest;</span><br><span class=\"line\">  const char *s = src;</span><br><span class=\"line\">  while (len--)</span><br><span class=\"line\">    *d++ = *s++;</span><br><span class=\"line\">  return dest;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>整个过程中的三个指针sh,s,fp对应关系如下图</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1553525055/blog/sds.png\" alt=\"\"></p>\n</li>\n</ol>\n<h2 id=\"销毁\"><a href=\"#销毁\" class=\"headerlink\" title=\"销毁\"></a>销毁</h2><p>销毁使用sdsfree来实现</p>\n<p>源码为：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Free an sds string. No operation is performed if 's' is NULL. */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sdsfree</span><span class=\"params\">(sds s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    s_free((<span class=\"keyword\">char</span>*)s-sdsHdrSize(s[<span class=\"number\">-1</span>]));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>s[-1],就是指针s向后移动移位，也就是flag的位置。将s移动到sh的位置，释放sh指针也就释放了整个sds内存。</p>\n<p>疑惑：sh指针在sdsnewlen函数中是个局部变量，在sdsnewlen函数中是自动释放的，这里并没有传递sh指针为什么也可以释放对应的空间？</p>\n<p>自己想了下：malloc 函数传递的参数是需要分配的内存大小(len)，返回的是指针也就是地址。free()函数只用将malloc函数返回的指针(地址)作为参数传入，就可以释放之前该地址分配到的内存空间。而地址只是首地址，总共的偏移量（大小），应该是由操作系统在内存分配的时候就记录了的。</p>\n<p>博客中记录：申请的时候实际上占用的内存要比申请的大。因为超出的空间是用来记录对这块内存的管理信息。额外的空间用来记录管理信息——分配块的长度，指向下一个分配块的指针等等。果然malloc的时候用来一个struct来记录分配的信息。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mem_control_block</span> &#123;</span> </span><br><span class=\"line\">  <span class=\"keyword\">int</span> is_available;    <span class=\"comment\">//一般来说应该是一个可用空间的首地址，但这里英文单词却显示出空间是否可用的一个标记</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> size;            <span class=\"comment\">//这是实际空间的大小 </span></span><br><span class=\"line\">  &#125;;</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://www.cnblogs.com/hanyonglu/archive/2011/04/28/2031271.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/hanyonglu/archive/2011/04/28/2031271.html</a></p>\n<p>free()就是根据这个结构体的信息来释放malloc()申请的空间</p>\n<p>另外的疑惑：释放完空间后，s 指针不用把它指向null吗？  </p>\n<p>暂时就只是创建和销毁的源码把，看了两天，阅读源码真的是酣畅淋漓，收获良多。学到了很多奇妙的C技巧，还对操作系统的知识有了更具象的理解。</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>阅读sdsfromlonglong部分的源码：</p>\n<p>sdsfromlonglong 函数用于将一个long long 类型的整形数字转换为字符数组。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Create an sds string from a long long value. It is much faster than:</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * sdscatprintf(sdsempty(),\"%lld\\n\", value);</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdsfromlonglong</span><span class=\"params\">(<span class=\"keyword\">long</span> <span class=\"keyword\">long</span> value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[SDS_LLSTR_SIZE];  <span class=\"comment\">// 给buf数组分配最小的空间，21的长度</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = sdsll2str(buf,value); <span class=\"comment\">//将long long 转为字符数组存储在buf中，并返回字符串的长度</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sdsnewlen(buf,len);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到主要的转换操作在sdsll2str这个函数中：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Helper for sdscatlonglong() doing the actual number -&gt; string</span></span><br><span class=\"line\"><span class=\"comment\"> * conversion. 's' must point to a string with room for at least</span></span><br><span class=\"line\"><span class=\"comment\"> * SDS_LLSTR_SIZE bytes.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * The function returns the length of the null-terminated string</span></span><br><span class=\"line\"><span class=\"comment\"> * representation stored at 's'. */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SDS_LLSTR_SIZE 21</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sdsll2str</span><span class=\"params\">(<span class=\"keyword\">char</span> *s, <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *p, aux;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> v; </span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> l;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Generate the string representation, this method produces</span></span><br><span class=\"line\"><span class=\"comment\">     * an reversed string. */</span></span><br><span class=\"line\">    v = (value &lt; <span class=\"number\">0</span>) ? -value : value;  <span class=\"comment\">//判断是否为负数</span></span><br><span class=\"line\">    p = s;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        *p++ = <span class=\"string\">'0'</span>+(v%<span class=\"number\">10</span>); <span class=\"comment\">// 除以10取余数</span></span><br><span class=\"line\">        v /= <span class=\"number\">10</span>;     <span class=\"comment\">//去除个位</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span>(v);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value &lt; <span class=\"number\">0</span>) *p++ = <span class=\"string\">'-'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Compute length and add null term. */</span></span><br><span class=\"line\">    l = p-s;   <span class=\"comment\">// 计算出字符串的长度 不含终止符</span></span><br><span class=\"line\">    *p = <span class=\"string\">'\\0'</span>; <span class=\"comment\">// 首地址填终止符。</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Reverse the string. */</span></span><br><span class=\"line\">    p--;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(s &lt; p) &#123;</span><br><span class=\"line\">        aux = *s;</span><br><span class=\"line\">        *s = *p;</span><br><span class=\"line\">        *p = aux;</span><br><span class=\"line\">        s++;</span><br><span class=\"line\">        p--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> l;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    *p++ = <span class=\"string\">'0'</span>+(v%<span class=\"number\">10</span>); <span class=\"comment\">// 除以10取余数</span></span><br><span class=\"line\">    v /= <span class=\"number\">10</span>;     <span class=\"comment\">//去除个位</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span>(v);</span><br></pre></td></tr></table></figure>\n<p>假设v是352，变成字符串是将每一个对应的10进制上面的3,5,2这三个个位、十位、百位的数字给单独变成字符。</p>\n<p><code>*p++ = &#39;0&#39;+(v%10);</code> p 指针是字符数组buf的首地址，而将整型变成字符型的操作就是与字符’0’ 相加，这样就可以对应的数字变成字符类型。同时p相应的加1来指向下一个byte用来存储下一个被转换的char。</p>\n<p>char类型存储的是对应字符的ascii值，ASCII表为：<a href=\"https://baike.baidu.com/item/ASCII/309296\" target=\"_blank\" rel=\"noopener\">https://baike.baidu.com/item/ASCII/309296</a> ，所以字符的运算实际上是对应的ASCII的值的运算。<br>v%10是除以10取余数，352%10 =2； 35%10=5，所以也就是取得v值的10进制上面的个位数。<br>所以在while循环里面每次对v除以10并取余，就可以得到对应long long 型的字符串。<br>但是因为每次得到的字符都是最后面的个位数，所以352，所输出的字符串数组为：‘2’， ‘3’， ‘5’ 是一个倒序的，因此还需要再反转一次。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Reverse the string. */</span> </span><br><span class=\"line\">p--;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(s &lt; p) &#123;</span><br><span class=\"line\">    aux = *s;</span><br><span class=\"line\">    *s = *p;</span><br><span class=\"line\">    *p = aux;</span><br><span class=\"line\">    s++;</span><br><span class=\"line\">    p--;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>字符串反转，首尾各有一个指针，当首指针小于尾指针的时候，交换数字，并同时向中间移动</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://blog.csdn.net/yangbodong22011/article/details/78419966\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/yangbodong22011/article/details/78419966</a></p>"}],"PostAsset":[{"_id":"source/_posts/BigdataBench-deploy/runcc.png","post":"ck6he13zp0039dstz50e3vlb8","slug":"runcc.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"ck6he13y40008dstzzvo6ibha","category_id":"ck6he13y10005dstz9roogsys","_id":"ck6he13ya000edstz2r0d8nfa"},{"post_id":"ck6he13xt0002dstz97wnh59g","category_id":"ck6he13y10005dstz9roogsys","_id":"ck6he13yc000idstzor9finuz"},{"post_id":"ck6he13y7000cdstzd4cuv3bb","category_id":"ck6he13y10005dstz9roogsys","_id":"ck6he13ye000ldstz5ok3g3md"},{"post_id":"ck6he13xy0004dstzz05m0d43","category_id":"ck6he13y6000adstz1eqld0v6","_id":"ck6he13yh000qdstzz97u9bfh"},{"post_id":"ck6he13yb000hdstz6ep5ds97","category_id":"ck6he13y10005dstz9roogsys","_id":"ck6he13yi000sdstzkkpk3sqp"},{"post_id":"ck6he13y30007dstz9fcphdrz","category_id":"ck6he13ya000fdstz0f6c8qa6","_id":"ck6he13yk000wdstzs4xlzl25"},{"post_id":"ck6he13yg000pdstzz831w9xd","category_id":"ck6he13ya000fdstz0f6c8qa6","_id":"ck6he13ym000zdstz8ibc6gmm"},{"post_id":"ck6he13y50009dstzxyum8dbx","category_id":"ck6he13ya000fdstz0f6c8qa6","_id":"ck6he13yn0013dstz6xnh105t"},{"post_id":"ck6he13y9000ddstzi0wx2pu2","category_id":"ck6he13ya000fdstz0f6c8qa6","_id":"ck6he13yp0016dstzfgzil3b6"},{"post_id":"ck6he13yl000ydstz8zz1phca","category_id":"ck6he13ya000fdstz0f6c8qa6","_id":"ck6he13yr001adstzso5d4nb1"},{"post_id":"ck6he13yd000kdstzitbkvm3z","category_id":"ck6he13ym0010dstze7totaot","_id":"ck6he13yt001edstz38x81g29"},{"post_id":"ck6he13yo0015dstzsf46b7b5","category_id":"ck6he13ym0010dstze7totaot","_id":"ck6he13yv001idstz8m98stm1"},{"post_id":"ck6he13yq0018dstzeupnptsd","category_id":"ck6he13ym0010dstze7totaot","_id":"ck6he13yw001ldstz2eqapaaf"},{"post_id":"ck6he13yi000rdstz754cjleh","category_id":"ck6he13ym0010dstze7totaot","_id":"ck6he13yy001pdstz8i4i1qjj"},{"post_id":"ck6he13ys001bdstzyc6asrzb","category_id":"ck6he13ym0010dstze7totaot","_id":"ck6he13yz001sdstzn2yqaf24"},{"post_id":"ck6he13yj000vdstz44zardas","category_id":"ck6he13yt001ddstz6dddezpl","_id":"ck6he13z1001vdstzo6kmj6y3"},{"post_id":"ck6he13yn0012dstzq9dcgwxi","category_id":"ck6he13yx001ndstzxg13iafz","_id":"ck6he13z40020dstznykzx1pq"},{"post_id":"ck6he13yt001fdstzvonxo8p4","category_id":"ck6he13z1001udstzna2omqt0","_id":"ck6he13z70027dstzqtvoq2g1"},{"post_id":"ck6he13z50023dstzv0sdd58j","category_id":"ck6he13z40021dstzror3d68c","_id":"ck6he13z9002ddstzhnqs8b63"},{"post_id":"ck6he13yv001jdstzm0rhgu3b","category_id":"ck6he13z40021dstzror3d68c","_id":"ck6he13zb002gdstzdgw9lvnc"},{"post_id":"ck6he13z60025dstz240gyadr","category_id":"ck6he13ym0010dstze7totaot","_id":"ck6he13zc002jdstzrs0tb5vz"},{"post_id":"ck6he13z70029dstz3nmffhms","category_id":"ck6he13ym0010dstze7totaot","_id":"ck6he13ze002ndstz5usqpesi"},{"post_id":"ck6he13yx001mdstz2cc9f0j7","category_id":"ck6he13z40021dstzror3d68c","_id":"ck6he13zg002qdstzhd2ksvvx"},{"post_id":"ck6he13z9002cdstzripjnm22","category_id":"ck6he13z40021dstzror3d68c","_id":"ck6he13zh002tdstzjdfbe8rb"},{"post_id":"ck6he13yy001rdstzkm1sz5re","category_id":"ck6he13z40021dstzror3d68c","_id":"ck6he13zj002wdstze9yai6zj"},{"post_id":"ck6he13z0001tdstz6js1m9i1","category_id":"ck6he13zd002ldstzdhvm8qwl","_id":"ck6he13zl0030dstzdx45tm59"},{"post_id":"ck6he13zg002sdstzulne5rnb","category_id":"ck6he13ym0010dstze7totaot","_id":"ck6he13zn0033dstzt2occba2"},{"post_id":"ck6he13zi002vdstz1xdevs99","category_id":"ck6he13zd002ldstzdhvm8qwl","_id":"ck6he13zp0038dstzl48h7gpn"},{"post_id":"ck6he13z1001wdstz0j3e2vfx","category_id":"ck6he13z40021dstzror3d68c","_id":"ck6he13zq003adstzm49uzdrl"},{"post_id":"ck6he13zj002ydstzzqptt46d","category_id":"ck6he13ym0010dstze7totaot","_id":"ck6he13zr003ddstzgo3qstsi"},{"post_id":"ck6he13zl0032dstzji057qo2","category_id":"ck6he13ya000fdstz0f6c8qa6","_id":"ck6he13zt003gdstzm3d2xfrh"},{"post_id":"ck6he13z3001zdstz900nq0mt","category_id":"ck6he13z40021dstzror3d68c","_id":"ck6he13zu003idstz6lsp5kfv"},{"post_id":"ck6he13zo0036dstzfa8q11kl","category_id":"ck6he13yx001ndstzxg13iafz","_id":"ck6he13zw003ndstzj24g2eoi"},{"post_id":"ck6he13zp0039dstz50e3vlb8","category_id":"ck6he13yx001ndstzxg13iafz","_id":"ck6he13zy003qdstzi70eyq27"},{"post_id":"ck6he13za002fdstzcai2hfje","category_id":"ck6he13zo0037dstz3jkrhtk3","_id":"ck6he1401003vdstzcjsnos6z"},{"post_id":"ck6he13zq003cdstzesg9dot6","category_id":"ck6he13ya000fdstz0f6c8qa6","_id":"ck6he1402003ydstzwyovze07"},{"post_id":"ck6he13zs003fdstzn82lndii","category_id":"ck6he13ym0010dstze7totaot","_id":"ck6he14040041dstzut7xasi8"},{"post_id":"ck6he13zc002idstz2xdtd06n","category_id":"ck6he13zs003edstzbe7f7k6r","_id":"ck6he14040043dstzonjmr7nk"},{"post_id":"ck6he13zv003mdstzwg1ewf24","category_id":"ck6he13zd002ldstzdhvm8qwl","_id":"ck6he14050046dstz58iyxi39"},{"post_id":"ck6he13zd002mdstz8a7hzh9j","category_id":"ck6he13zv003kdstzsl5hxz3g","_id":"ck6he14060048dstzdew2yh3f"},{"post_id":"ck6he13zw003pdstzbknx8w77","category_id":"ck6he13ya000fdstz0f6c8qa6","_id":"ck6he1407004bdstzb0ssflkk"},{"post_id":"ck6he1400003udstzj1uuzlwf","category_id":"ck6he13ya000fdstz0f6c8qa6","_id":"ck6he1407004ddstztccuevh4"},{"post_id":"ck6he13zf002pdstzyalchkf0","category_id":"ck6he13zv003kdstzsl5hxz3g","_id":"ck6he1407004fdstzssmkcfp6"},{"post_id":"ck6he14030040dstz4zurlplx","category_id":"ck6he13ya000fdstz0f6c8qa6","_id":"ck6he1408004idstzkp05hauh"},{"post_id":"ck6he1401003xdstz7btpg812","category_id":"ck6he14040042dstzjdsv2jop","_id":"ck6he1408004jdstzk3n8u39w"},{"post_id":"ck6he142d009cdstzbd3o6yyf","category_id":"ck6he13yt001ddstz6dddezpl","_id":"ck6he142g009fdstza8r3v0pz"}],"PostTag":[{"post_id":"ck6he13xt0002dstz97wnh59g","tag_id":"ck6he13y30006dstzqaw05047","_id":"ck6he13yd000jdstzmob0lyk8"},{"post_id":"ck6he13xt0002dstz97wnh59g","tag_id":"ck6he13y7000bdstz1j0t8ynv","_id":"ck6he13ye000mdstz3riq7ae2"},{"post_id":"ck6he13xy0004dstzz05m0d43","tag_id":"ck6he13yb000gdstzy6gwmake","_id":"ck6he13yl000xdstz7av13oxk"},{"post_id":"ck6he13xy0004dstzz05m0d43","tag_id":"ck6he13yf000odstz2tf4no0r","_id":"ck6he13ym0011dstznqffylv1"},{"post_id":"ck6he13y30007dstz9fcphdrz","tag_id":"ck6he13yj000udstz3by02jya","_id":"ck6he13ys001cdstzmucgui23"},{"post_id":"ck6he13y30007dstz9fcphdrz","tag_id":"ck6he13yn0014dstz2kl84ac3","_id":"ck6he13yu001gdstzys2ai686"},{"post_id":"ck6he13y40008dstzzvo6ibha","tag_id":"ck6he13y30006dstzqaw05047","_id":"ck6he13yw001kdstzu52uzdv6"},{"post_id":"ck6he13y40008dstzzvo6ibha","tag_id":"ck6he13yr0019dstzqjg65ewc","_id":"ck6he13yy001odstz10y8rkny"},{"post_id":"ck6he13y50009dstzxyum8dbx","tag_id":"ck6he13yv001hdstzwpueqpwy","_id":"ck6he13z3001ydstz3ttmcwbd"},{"post_id":"ck6he13y50009dstzxyum8dbx","tag_id":"ck6he13yy001qdstzltwjkwii","_id":"ck6he13z40022dstzafk1g9a5"},{"post_id":"ck6he13y7000cdstzd4cuv3bb","tag_id":"ck6he13y30006dstzqaw05047","_id":"ck6he13z70026dstz84y70uqa"},{"post_id":"ck6he13y7000cdstzd4cuv3bb","tag_id":"ck6he13z2001xdstz9abdfgzw","_id":"ck6he13z8002adstzlb8fhtfn"},{"post_id":"ck6he13y9000ddstzi0wx2pu2","tag_id":"ck6he13z60024dstzwze8lvib","_id":"ck6he13zd002kdstz5z0gwryj"},{"post_id":"ck6he13y9000ddstzi0wx2pu2","tag_id":"ck6he13z8002bdstzcih0lc9s","_id":"ck6he13zf002odstz6x697zql"},{"post_id":"ck6he13yb000hdstz6ep5ds97","tag_id":"ck6he13zb002hdstzdzpnm92e","_id":"ck6he13zl0031dstzunif6ebc"},{"post_id":"ck6he13yb000hdstz6ep5ds97","tag_id":"ck6he13zg002rdstzn1j683ic","_id":"ck6he13zn0034dstz1dvrqjvk"},{"post_id":"ck6he13yd000kdstzitbkvm3z","tag_id":"ck6he13zj002xdstzd9u67lyo","_id":"ck6he13zv003ldstzr7y46f4j"},{"post_id":"ck6he13yd000kdstzitbkvm3z","tag_id":"ck6he13zn0035dstzf5ve6m2z","_id":"ck6he13zw003odstzlbc74s6j"},{"post_id":"ck6he13yd000kdstzitbkvm3z","tag_id":"ck6he13zq003bdstzeasm62vc","_id":"ck6he1400003tdstznw553kyu"},{"post_id":"ck6he13yg000pdstzz831w9xd","tag_id":"ck6he13z8002bdstzcih0lc9s","_id":"ck6he1401003wdstzkryzc12u"},{"post_id":"ck6he14030040dstz4zurlplx","tag_id":"ck6he13z8002bdstzcih0lc9s","_id":"ck6he14050045dstzxa8fk1o8"},{"post_id":"ck6he14030040dstz4zurlplx","tag_id":"ck6he13y30006dstzqaw05047","_id":"ck6he14060047dstzngb1zgf0"},{"post_id":"ck6he13yi000rdstz754cjleh","tag_id":"ck6he13zy003rdstzgfb6kahu","_id":"ck6he14060049dstz4lzua3fr"},{"post_id":"ck6he13yi000rdstz754cjleh","tag_id":"ck6he1402003zdstz3roa3wzk","_id":"ck6he1407004cdstzdu4fab9s"},{"post_id":"ck6he13yj000vdstz44zardas","tag_id":"ck6he13y30006dstzqaw05047","_id":"ck6he1407004edstzv0x63nny"},{"post_id":"ck6he13yj000vdstz44zardas","tag_id":"ck6he14050044dstzbs6uc1pm","_id":"ck6he1408004hdstz2kg21kp6"},{"post_id":"ck6he13yl000ydstz8zz1phca","tag_id":"ck6he1406004adstzbdco5hue","_id":"ck6he1408004ldstzhf8sjosx"},{"post_id":"ck6he13yl000ydstz8zz1phca","tag_id":"ck6he1407004gdstzpbarog3x","_id":"ck6he1409004mdstzjfi6shyt"},{"post_id":"ck6he13yn0012dstzq9dcgwxi","tag_id":"ck6he1408004kdstzpiu0fpyn","_id":"ck6he1409004qdstzz2tl6g2m"},{"post_id":"ck6he13yn0012dstzq9dcgwxi","tag_id":"ck6he1409004ndstzb3i5r7bl","_id":"ck6he140a004rdstzb4ypdcos"},{"post_id":"ck6he13yn0012dstzq9dcgwxi","tag_id":"ck6he1409004odstzka9eqc08","_id":"ck6he140a004tdstz2ndkogtr"},{"post_id":"ck6he13yo0015dstzsf46b7b5","tag_id":"ck6he1409004pdstzdttol4pp","_id":"ck6he140b004xdstzmv8gywyz"},{"post_id":"ck6he13yo0015dstzsf46b7b5","tag_id":"ck6he140a004sdstzclpbbhuz","_id":"ck6he140b004ydstzw9t6k916"},{"post_id":"ck6he13yo0015dstzsf46b7b5","tag_id":"ck6he140a004udstza3oyr6y3","_id":"ck6he140c0050dstzgx08rc6s"},{"post_id":"ck6he13yo0015dstzsf46b7b5","tag_id":"ck6he1402003zdstz3roa3wzk","_id":"ck6he140c0051dstz6e69t6md"},{"post_id":"ck6he13yq0018dstzeupnptsd","tag_id":"ck6he140b004wdstzsjfo59ww","_id":"ck6he140c0053dstzsu67q345"},{"post_id":"ck6he13yq0018dstzeupnptsd","tag_id":"ck6he140b004zdstz1ey4w721","_id":"ck6he140d0054dstzqdvnx607"},{"post_id":"ck6he13ys001bdstzyc6asrzb","tag_id":"ck6he1402003zdstz3roa3wzk","_id":"ck6he140e0058dstzeftxa6zn"},{"post_id":"ck6he13ys001bdstzyc6asrzb","tag_id":"ck6he140d0055dstzea0quqza","_id":"ck6he140e0059dstz09tzy7o0"},{"post_id":"ck6he13ys001bdstzyc6asrzb","tag_id":"ck6he1409004pdstzdttol4pp","_id":"ck6he140e005bdstzhowwiuvi"},{"post_id":"ck6he13yt001fdstzvonxo8p4","tag_id":"ck6he140d0057dstz7nc4mb1l","_id":"ck6he140f005edstzqo1n9wjc"},{"post_id":"ck6he13yt001fdstzvonxo8p4","tag_id":"ck6he140e005adstzuq7ot8uf","_id":"ck6he140f005fdstzyeygs9to"},{"post_id":"ck6he13yt001fdstzvonxo8p4","tag_id":"ck6he140e005cdstz95v3e413","_id":"ck6he140f005hdstz6uqsce5w"},{"post_id":"ck6he13yv001jdstzm0rhgu3b","tag_id":"ck6he140f005ddstz3b1qlbhk","_id":"ck6he140g005idstzylg939up"},{"post_id":"ck6he13yx001mdstz2cc9f0j7","tag_id":"ck6he140f005gdstzqaqf8cld","_id":"ck6he140h005ndstz2qvcqed9"},{"post_id":"ck6he13yx001mdstz2cc9f0j7","tag_id":"ck6he140g005jdstzw7x90apl","_id":"ck6he140h005odstzqk2ph6sw"},{"post_id":"ck6he13yx001mdstz2cc9f0j7","tag_id":"ck6he140g005kdstzue7m9l8a","_id":"ck6he140h005qdstzo9qf5r9m"},{"post_id":"ck6he13yx001mdstz2cc9f0j7","tag_id":"ck6he140g005ldstzupjldswn","_id":"ck6he140i005rdstzd67acnpu"},{"post_id":"ck6he13yy001rdstzkm1sz5re","tag_id":"ck6he140h005mdstzxkyuxb8h","_id":"ck6he140k005xdstzl2k0vx6h"},{"post_id":"ck6he13yy001rdstzkm1sz5re","tag_id":"ck6he140g005kdstzue7m9l8a","_id":"ck6he140k005ydstz3x3b9mgf"},{"post_id":"ck6he13yy001rdstzkm1sz5re","tag_id":"ck6he140g005ldstzupjldswn","_id":"ck6he140k0060dstztibw402x"},{"post_id":"ck6he13yy001rdstzkm1sz5re","tag_id":"ck6he140j005tdstz1xpb16cf","_id":"ck6he140k0061dstzp3lorpj4"},{"post_id":"ck6he13yy001rdstzkm1sz5re","tag_id":"ck6he140j005udstzlvsgi71u","_id":"ck6he140l0063dstzwzyokp19"},{"post_id":"ck6he13yy001rdstzkm1sz5re","tag_id":"ck6he140j005vdstzz8v19mtl","_id":"ck6he140l0064dstzvyv2uuzm"},{"post_id":"ck6he13z0001tdstz6js1m9i1","tag_id":"ck6he140j005wdstz2aec7ugv","_id":"ck6he140m0066dstzb0bg4cqb"},{"post_id":"ck6he13z0001tdstz6js1m9i1","tag_id":"ck6he140k005zdstzw256tzpk","_id":"ck6he140m0067dstzrzuto8ot"},{"post_id":"ck6he13z1001wdstz0j3e2vfx","tag_id":"ck6he140g005kdstzue7m9l8a","_id":"ck6he140n006bdstzho4los8a"},{"post_id":"ck6he13z1001wdstz0j3e2vfx","tag_id":"ck6he140g005ldstzupjldswn","_id":"ck6he140n006cdstzy8fdbmpz"},{"post_id":"ck6he13z1001wdstz0j3e2vfx","tag_id":"ck6he140m0068dstzh6x6afmg","_id":"ck6he140o006edstznmhc6sav"},{"post_id":"ck6he13z1001wdstz0j3e2vfx","tag_id":"ck6he140m0069dstzzaatuyny","_id":"ck6he140o006fdstzu9c7len8"},{"post_id":"ck6he13z3001zdstz900nq0mt","tag_id":"ck6he140n006adstzq29cpoqf","_id":"ck6he140p006jdstzcloinrp0"},{"post_id":"ck6he13z3001zdstz900nq0mt","tag_id":"ck6he140n006ddstzv2iscghl","_id":"ck6he140p006kdstzrb8pjsch"},{"post_id":"ck6he13z3001zdstz900nq0mt","tag_id":"ck6he140g005ldstzupjldswn","_id":"ck6he140q006mdstzuqig8m4t"},{"post_id":"ck6he13z3001zdstz900nq0mt","tag_id":"ck6he140g005kdstzue7m9l8a","_id":"ck6he140q006ndstz3rdh21yn"},{"post_id":"ck6he13z50023dstzv0sdd58j","tag_id":"ck6he140g005ldstzupjldswn","_id":"ck6he140r006rdstzu7r46qp5"},{"post_id":"ck6he13z50023dstzv0sdd58j","tag_id":"ck6he140g005kdstzue7m9l8a","_id":"ck6he140r006sdstzm091gke7"},{"post_id":"ck6he13z50023dstzv0sdd58j","tag_id":"ck6he140q006odstz8kbsqf5g","_id":"ck6he140s006udstz2n8zp42h"},{"post_id":"ck6he13z50023dstzv0sdd58j","tag_id":"ck6he140q006pdstz3q22wrj4","_id":"ck6he140s006vdstzd72wcoam"},{"post_id":"ck6he13z60025dstz240gyadr","tag_id":"ck6he1402003zdstz3roa3wzk","_id":"ck6he140t0070dstz9beb8hfj"},{"post_id":"ck6he13z60025dstz240gyadr","tag_id":"ck6he140r006tdstzp22if4cx","_id":"ck6he140u0071dstz3u3vkl0v"},{"post_id":"ck6he13z60025dstz240gyadr","tag_id":"ck6he140s006wdstz4dvio4ur","_id":"ck6he140u0073dstzdn41m1nw"},{"post_id":"ck6he13z60025dstz240gyadr","tag_id":"ck6he1409004pdstzdttol4pp","_id":"ck6he140u0074dstzrh61gzxn"},{"post_id":"ck6he13z60025dstz240gyadr","tag_id":"ck6he140t006ydstz4313viep","_id":"ck6he140z0076dstzvlowrfw2"},{"post_id":"ck6he13z70029dstz3nmffhms","tag_id":"ck6he140t006zdstzhiro37ij","_id":"ck6he140z0077dstz6ut0gi97"},{"post_id":"ck6he13z70029dstz3nmffhms","tag_id":"ck6he1402003zdstz3roa3wzk","_id":"ck6he140z0079dstz0hgfyrkt"},{"post_id":"ck6he13z9002cdstzripjnm22","tag_id":"ck6he140g005kdstzue7m9l8a","_id":"ck6he1411007edstzgm9lgzfy"},{"post_id":"ck6he13z9002cdstzripjnm22","tag_id":"ck6he140g005ldstzupjldswn","_id":"ck6he1411007fdstzyzgddmrr"},{"post_id":"ck6he13z9002cdstzripjnm22","tag_id":"ck6he1410007adstzzqv1bjvi","_id":"ck6he1411007hdstz1bgca1v5"},{"post_id":"ck6he13z9002cdstzripjnm22","tag_id":"ck6he1410007bdstzp281dgkz","_id":"ck6he1411007idstz9ct23gip"},{"post_id":"ck6he13z9002cdstzripjnm22","tag_id":"ck6he1410007cdstz49bdi5tg","_id":"ck6he1412007kdstz1xg8e6fe"},{"post_id":"ck6he13za002fdstzcai2hfje","tag_id":"ck6he1410007ddstzf02vyfx1","_id":"ck6he1412007ldstzyirofmxi"},{"post_id":"ck6he13za002fdstzcai2hfje","tag_id":"ck6he1411007gdstzdcbqb8c9","_id":"ck6he1412007ndstz6s8g79v6"},{"post_id":"ck6he13zc002idstz2xdtd06n","tag_id":"ck6he1412007jdstzhvahb03l","_id":"ck6he1414007rdstzlmz0gevy"},{"post_id":"ck6he13zc002idstz2xdtd06n","tag_id":"ck6he1412007mdstzmemtixqo","_id":"ck6he1414007sdstzybi93nyu"},{"post_id":"ck6he13zc002idstz2xdtd06n","tag_id":"ck6he1413007odstz2ts1085g","_id":"ck6he1414007udstz6gorz2st"},{"post_id":"ck6he13zc002idstz2xdtd06n","tag_id":"ck6he1413007pdstzgtj00n82","_id":"ck6he1414007vdstzptrrxjcq"},{"post_id":"ck6he13zd002mdstz8a7hzh9j","tag_id":"ck6he140g005kdstzue7m9l8a","_id":"ck6he1415007xdstzawkyh1si"},{"post_id":"ck6he13zd002mdstz8a7hzh9j","tag_id":"ck6he1414007tdstzw4b8x5ls","_id":"ck6he1415007ydstzkax4c9wp"},{"post_id":"ck6he13zf002pdstzyalchkf0","tag_id":"ck6he1415007wdstzw92sjzws","_id":"ck6he14160082dstzruruksv3"},{"post_id":"ck6he13zf002pdstzyalchkf0","tag_id":"ck6he140m0068dstzh6x6afmg","_id":"ck6he14170083dstzwcyx90el"},{"post_id":"ck6he13zf002pdstzyalchkf0","tag_id":"ck6he14160080dstzmnahhzgx","_id":"ck6he14170085dstz0sovrkvl"},{"post_id":"ck6he13zg002sdstzulne5rnb","tag_id":"ck6he1409004pdstzdttol4pp","_id":"ck6he14180088dstzya951v9p"},{"post_id":"ck6he13zg002sdstzulne5rnb","tag_id":"ck6he14170084dstzrimmx09k","_id":"ck6he14180089dstzp1jpy9ve"},{"post_id":"ck6he13zg002sdstzulne5rnb","tag_id":"ck6he1402003zdstz3roa3wzk","_id":"ck6he1419008bdstz8ub50oex"},{"post_id":"ck6he13zi002vdstz1xdevs99","tag_id":"ck6he13zg002rdstzn1j683ic","_id":"ck6he1419008cdstzcyepvn02"},{"post_id":"ck6he13zi002vdstz1xdevs99","tag_id":"ck6he14180087dstzyj9km3ry","_id":"ck6he1419008edstzc71e5963"},{"post_id":"ck6he13zj002ydstzzqptt46d","tag_id":"ck6he1402003zdstz3roa3wzk","_id":"ck6he141a008hdstz2pa8ssh7"},{"post_id":"ck6he13zj002ydstzzqptt46d","tag_id":"ck6he1419008ddstzwlkiwnm0","_id":"ck6he141b008idstz0273vlgb"},{"post_id":"ck6he13zj002ydstzzqptt46d","tag_id":"ck6he1409004pdstzdttol4pp","_id":"ck6he141b008kdstzxnghfyci"},{"post_id":"ck6he13zl0032dstzji057qo2","tag_id":"ck6he13z60024dstzwze8lvib","_id":"ck6he141b008ldstze5ez5y7h"},{"post_id":"ck6he13zl0032dstzji057qo2","tag_id":"ck6he141a008gdstzhtlshig1","_id":"ck6he141c008ndstz0m90blhk"},{"post_id":"ck6he13zo0036dstzfa8q11kl","tag_id":"ck6he141b008jdstzenihr829","_id":"ck6he141c008odstzj99qa0rl"},{"post_id":"ck6he13zp0039dstz50e3vlb8","tag_id":"ck6he141b008mdstzbwixe5m5","_id":"ck6he141c008qdstzq57xiqf1"},{"post_id":"ck6he13zq003cdstzesg9dot6","tag_id":"ck6he13z60024dstzwze8lvib","_id":"ck6he141d008sdstzfq85l5l8"},{"post_id":"ck6he13zq003cdstzesg9dot6","tag_id":"ck6he141c008pdstzt0k945qv","_id":"ck6he141d008tdstzsrb68r8j"},{"post_id":"ck6he13zs003fdstzn82lndii","tag_id":"ck6he1419008ddstzwlkiwnm0","_id":"ck6he141e008wdstzkymw676l"},{"post_id":"ck6he13zs003fdstzn82lndii","tag_id":"ck6he140t006ydstz4313viep","_id":"ck6he141e008xdstzkrikmfnf"},{"post_id":"ck6he13zt003hdstzedfidjpe","tag_id":"ck6he13y30006dstzqaw05047","_id":"ck6he141f008zdstzh2uoudi1"},{"post_id":"ck6he13zt003hdstzedfidjpe","tag_id":"ck6he141e008vdstzptkw93ab","_id":"ck6he141f0090dstzhi7si373"},{"post_id":"ck6he13zv003mdstzwg1ewf24","tag_id":"ck6he1407004gdstzpbarog3x","_id":"ck6he141g0092dstzqxvy829i"},{"post_id":"ck6he13zw003pdstzbknx8w77","tag_id":"ck6he13z60024dstzwze8lvib","_id":"ck6he141h0095dstze2kj4rid"},{"post_id":"ck6he13zw003pdstzbknx8w77","tag_id":"ck6he141c008pdstzt0k945qv","_id":"ck6he141h0096dstz1sg3xxug"},{"post_id":"ck6he13zw003pdstzbknx8w77","tag_id":"ck6he141g0093dstzsk43je2y","_id":"ck6he141h0098dstz3hsll987"},{"post_id":"ck6he1400003udstzj1uuzlwf","tag_id":"ck6he13z60024dstzwze8lvib","_id":"ck6he141i0099dstzdcexqzhv"},{"post_id":"ck6he1400003udstzj1uuzlwf","tag_id":"ck6he141a008gdstzhtlshig1","_id":"ck6he141i009adstz91m5me7g"},{"post_id":"ck6he1401003xdstz7btpg812","tag_id":"ck6he141h0097dstz7osw7blh","_id":"ck6he141i009bdstz2899k75s"},{"post_id":"ck6he142d009cdstzbd3o6yyf","tag_id":"ck6he13y30006dstzqaw05047","_id":"ck6he142f009ddstzh0jo0jgl"},{"post_id":"ck6he142d009cdstzbd3o6yyf","tag_id":"ck6he13y7000bdstz1j0t8ynv","_id":"ck6he142f009edstzy66yqj5q"}],"Tag":[{"name":"redis","_id":"ck6he13y30006dstzqaw05047"},{"name":"源码阅读","_id":"ck6he13y7000bdstz1j0t8ynv"},{"name":"Hexo","_id":"ck6he13yb000gdstzy6gwmake"},{"name":"Travis-CI","_id":"ck6he13yf000odstz2tf4no0r"},{"name":"docker","_id":"ck6he13yj000udstz3by02jya"},{"name":"容器","_id":"ck6he13yn0014dstz2kl84ac3"},{"name":"dict","_id":"ck6he13yr0019dstzqjg65ewc"},{"name":"gdb","_id":"ck6he13yv001hdstzwpueqpwy"},{"name":"工具","_id":"ck6he13yy001qdstzltwjkwii"},{"name":"object","_id":"ck6he13z2001xdstz9abdfgzw"},{"name":"Linux","_id":"ck6he13z60024dstzwze8lvib"},{"name":"shell","_id":"ck6he13z8002bdstzcih0lc9s"},{"name":"coding","_id":"ck6he13zb002hdstzdzpnm92e"},{"name":"c++","_id":"ck6he13zg002rdstzn1j683ic"},{"name":"牛客","_id":"ck6he13zj002xdstzd9u67lyo"},{"name":"斐波拉契数列","_id":"ck6he13zn0035dstzf5ve6m2z"},{"name":"剑指offer","_id":"ck6he13zq003bdstzeasm62vc"},{"name":"快排","_id":"ck6he13zy003rdstzgfb6kahu"},{"name":"leetcode","_id":"ck6he1402003zdstz3roa3wzk"},{"name":"Makefile","_id":"ck6he14050044dstzbs6uc1pm"},{"name":"gcc","_id":"ck6he1406004adstzbdco5hue"},{"name":"make","_id":"ck6he1407004gdstzpbarog3x"},{"name":"shadowsocks","_id":"ck6he1408004kdstzpiu0fpyn"},{"name":"翻墙","_id":"ck6he1409004ndstzb3i5r7bl"},{"name":"ipv6","_id":"ck6he1409004odstzka9eqc08"},{"name":"分治","_id":"ck6he1409004pdstzdttol4pp"},{"name":"哈希","_id":"ck6he140a004sdstzclpbbhuz"},{"name":"摩尔投票","_id":"ck6he140a004udstza3oyr6y3"},{"name":"OJ","_id":"ck6he140b004wdstzsjfo59ww"},{"name":"编程","_id":"ck6he140b004zdstz1ey4w721"},{"name":"归并排序","_id":"ck6he140d0055dstzea0quqza"},{"name":"内存寻址","_id":"ck6he140d0057dstz7nc4mb1l"},{"name":"寄存器","_id":"ck6he140e005adstzuq7ot8uf"},{"name":"BIOS","_id":"ck6he140e005cdstz95v3e413"},{"name":"Clementine","_id":"ck6he140f005ddstz3b1qlbhk"},{"name":"数据仓库","_id":"ck6he140f005gdstzqaqf8cld"},{"name":"OLAPS","_id":"ck6he140g005jdstzw7x90apl"},{"name":"课程","_id":"ck6he140g005kdstzue7m9l8a"},{"name":"国科大","_id":"ck6he140g005ldstzupjldswn"},{"name":"分类","_id":"ck6he140h005mdstzxkyuxb8h"},{"name":"贝叶斯","_id":"ck6he140j005tdstz1xpb16cf"},{"name":"神经网络","_id":"ck6he140j005udstzlvsgi71u"},{"name":"决策树","_id":"ck6he140j005vdstzz8v19mtl"},{"name":"汇编","_id":"ck6he140j005wdstz2aec7ugv"},{"name":"C语言","_id":"ck6he140k005zdstzw256tzpk"},{"name":"降维","_id":"ck6he140m0068dstzh6x6afmg"},{"name":"相关性分析","_id":"ck6he140m0069dstzzaatuyny"},{"name":"聚类","_id":"ck6he140n006adstzq29cpoqf"},{"name":"K-Means","_id":"ck6he140n006ddstzv2iscghl"},{"name":"余弦相似度","_id":"ck6he140q006odstz8kbsqf5g"},{"name":"推荐","_id":"ck6he140q006pdstz3q22wrj4"},{"name":"数组","_id":"ck6he140r006tdstzp22if4cx"},{"name":"最小值","_id":"ck6he140s006wdstz4dvio4ur"},{"name":"二分查找","_id":"ck6he140t006ydstz4313viep"},{"name":"贪心","_id":"ck6he140t006zdstzhiro37ij"},{"name":"关联规则","_id":"ck6he1410007adstzzqv1bjvi"},{"name":"Apriori","_id":"ck6he1410007bdstzp281dgkz"},{"name":"FP-Growth","_id":"ck6he1410007cdstz49bdi5tg"},{"name":"数学","_id":"ck6he1410007ddstzf02vyfx1"},{"name":"点子","_id":"ck6he1411007gdstzdcbqb8c9"},{"name":"时间序列","_id":"ck6he1412007jdstzhvahb03l"},{"name":"LSTM","_id":"ck6he1412007mdstzmemtixqo"},{"name":"Pytorch","_id":"ck6he1413007odstz2ts1085g"},{"name":"Prophet","_id":"ck6he1413007pdstzgtj00n82"},{"name":"模式识别","_id":"ck6he1414007tdstzw4b8x5ls"},{"name":"特征提取","_id":"ck6he1415007wdstzw92sjzws"},{"name":"距离矩阵","_id":"ck6he14160080dstzmnahhzgx"},{"name":"二叉树","_id":"ck6he14170084dstzrimmx09k"},{"name":"指针","_id":"ck6he14180087dstzyj9km3ry"},{"name":"动态规划","_id":"ck6he1419008ddstzwlkiwnm0"},{"name":"command","_id":"ck6he141a008gdstzhtlshig1"},{"name":"ceph","_id":"ck6he141b008jdstzenihr829"},{"name":"bigdatabench","_id":"ck6he141b008mdstzbwixe5m5"},{"name":"运维","_id":"ck6he141c008pdstzt0k945qv"},{"name":"benchmark","_id":"ck6he141e008vdstzptkw93ab"},{"name":"网络问题","_id":"ck6he141g0093dstzsk43je2y"},{"name":"graph","_id":"ck6he141h0097dstz7osw7blh"}]}}